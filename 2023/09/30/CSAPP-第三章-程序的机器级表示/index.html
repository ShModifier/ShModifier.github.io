

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Modifier">
  <meta name="keywords" content="">
  
    <meta name="description" content="C语言指令对应的机器表示">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP 第三章 程序的机器级表示 总结">
<meta property="og:url" content="https://shmodifier.github.io/2023/09/30/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/index.html">
<meta property="og:site_name" content="Modifier">
<meta property="og:description" content="C语言指令对应的机器表示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shmodifier.github.io/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
<meta property="article:published_time" content="2023-09-30T09:12:38.000Z">
<meta property="article:modified_time" content="2023-10-02T07:19:58.490Z">
<meta property="article:author" content="Modifier">
<meta property="article:tag" content="Knowledge">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shmodifier.github.io/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
  
  
  
  <title>CSAPP 第三章 程序的机器级表示 总结 - Modifier</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shmodifier.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Have a nice day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP 第三章 程序的机器级表示 总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-30 17:12" pubdate>
          2023年9月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          108 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CSAPP 第三章 程序的机器级表示 总结</h1>
            
            
              <div class="markdown-body">
                
                <p>C语言指令对应的机器表示</p>
<span id="more"></span>

<h3 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h3><p>Inter 处理器系列俗称 x86，它经历了一个长期的、不断进化的过程。几十年来，实现了从 16 位到 32 位 i386，最后到现在 64 位的 x86-64 处理器，其中每个后继处理器都是向后兼容的——较早版本的处理器上编译的代码总是可以在较新的处理器上运行。</p>
<h5 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h5><p>1965年，Gordon Mone （Intel 公司的创始人）推断，在未来的十年，芯片上的晶体管数量每年都会翻一番，这个预测就是摩尔定律。事实证明这个预测是正确的。</p>
<blockquote>
<p>还以为是摩尔庄园那个摩尔（x</p>
</blockquote>
<h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><p>假设C程序 Hello.c 文件，我们在 linux 系统中用下面的命令编译代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gcc -g Hello.c -o Hello</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>gcc（GCC）是 Linux 的默认编译器</p>
</blockquote>
<p>用户看来是执行了一条命令，但是实际上机器执行了一系列的程序，才将源代码转换成可执行代码。有以下几个流程，我们也可以用不同的命令控制 GCC 逐步执行：</p>
<ul>
<li><p>预处理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -E Hello.c -o Hello.i</span><br></code></pre></td></tr></table></figure>

<p>C预处理器拓展源代码，插入所有 #include 命令指定的文件，并拓展所有以 #define 声明指定的宏。</p>
</li>
<li><p>编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -S Hello.i -o Hello.s</span><br></code></pre></td></tr></table></figure>

<p>编译器会产生汇编代码文件 <code>Hello.s</code>。</p>
</li>
<li><p>汇编</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -c test.s -o test.o</span><br></code></pre></td></tr></table></figure>

<p>汇编器会将汇编代码转化成二进制目标代码文件 <code>Hello.o</code> 。其中，目标代码是汇编代码的一种形式，它包含所有指令的二进制表示，但是没有填入全局值的地址。</p>
</li>
<li><p>链接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -g test.o -o <span class="hljs-built_in">test</span> [--static]</span><br></code></pre></td></tr></table></figure>

<p>连接器将目标代码文件与实现库函数（例如 printf ）的代码合并，并产生最终的可执行代码文件。其中，我们可以在队后一步编译的时候添加 <code>static</code> 参数进行静态链接，不参加参数就是默认动态链接。</p>
</li>
</ul>
<p>对于机器级编程来说，有两种抽象尤为重要：</p>
<ul>
<li>由指令集体系结构或指令集架构（ISA）定义的机器及程序的格式和行为。</li>
<li>内存地址实际上是虚拟地址</li>
</ul>
<p>在C语言中，我们声明和分配各种数据类型的对象，但是机器代码不区分这些数据，只是将内存看作一个很大的、按字节寻址的数组。不区分各种类型的数据，数组和结构也只使用一组连续的字节来表示。</p>
<p>X86-64 的机器代码和原始的C语言代码差别很大，对于程序员来说是有很多的隐藏状态，例如：</p>
<ul>
<li>程序计数器（通常称为 PC ，在 x86-64 中用 <code>%rip</code> 表示）用于指示程序要执行的下一条指令在内存中的地址</li>
<li>整数寄存器文件，用于存储地址（对应C语言的指针）或整数数据。</li>
<li>条件码寄存器，保存着最近执行的算术逻辑或逻辑指令的状态信息</li>
<li>向量寄存器，存放一个或多个整数或浮点数值</li>
</ul>
<blockquote>
<p>我们经常接触到的汇编语言，其实并不是机器语言。但是汇编代码表示非常接近机器代码，由于汇编代码对于程序员来讲更具有可读性，所以我们经常用汇编代码来学习和解释机器代码行为</p>
</blockquote>
<p>程序内存这些都是由虚拟内存来寻址的，操作系统负责管理虚拟内存空间，把<strong>虚拟地址转换为实际物理地址</strong>。</p>
<p>前面有提到，程序的汇编指令转化为计算机可读的文件二进制目标代码后就变成了一个01的字节序列，机器也只是执行这个字节序列，机器对指令的源代码一无所知。</p>
<p>当然我们可以利用下面的命令反编译可重定向文件或者是可执行 ELF 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename.o</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename</span><br></code></pre></td></tr></table></figure>

<p>我们也可以使用 <code>hexdump -x  filename.o</code> 命令输出二进制文件的十六进制表示形式（虽然没有什么可读性上的帮助 <del>xsbb</del>）</p>
<blockquote>
<p>objdump 、hexdump 命令还有不同参数对应不同功能 </p>
</blockquote>
<p>机器代码的特性：</p>
<ul>
<li><p>指令可以从任意内存地址开始，CPU不会强制进行代码对齐</p>
</li>
<li><p>指令长度从1字节到15字节不等。常用指令的字节数少，越不常用字节数越多</p>
</li>
<li><p>从给定的某一位置开始，每一个机器字节都对应唯一的指令</p>
</li>
<li><p>反汇编器只是根据字节序列确定汇编代码，它不需要访问编译出该程序的源文件</p>
</li>
</ul>
<p>如果我们直接 <code>cat filename.s</code>，输出的汇编代码如下图所示：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6.png" srcset="/img/loading.gif" lazyload></p>
<p>其中以 <code>.</code> 开头的都是知道汇编器和编译器的伪指令，我们可以忽略。我们在表示汇编代码时会省略这些伪指令，同时，汇编代码的格式也有不同，分为 AT&amp;T 和 Inter 两种风格：</p>
<blockquote>
<p>gcc 默认输出的是 AT&amp;T ，微软系列都是 Inter</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Inter</th>
<th>AT&amp;T</th>
</tr>
</thead>
<tbody><tr>
<td>指令后缀</td>
<td>无后缀，例如：mov、push</td>
<td>有指示大小的后缀，例如：pushq、movq</td>
</tr>
<tr>
<td>寄存器</td>
<td>寄存器无 % 符号，例如：rbx</td>
<td>寄存器有 % 符号，例如：%rbx</td>
</tr>
<tr>
<td>立即数</td>
<td>有任何前缀，直接用一个数字表示</td>
<td>用 $ 前缀表示一个立即数</td>
</tr>
<tr>
<td>操作数顺序</td>
<td>操作符 目的操作数 , 源操作数 例如：mov eax,1</td>
<td>操作符 源操作数 , 目的操作数  例如：mov $1,%eax</td>
</tr>
<tr>
<td>内存取址</td>
<td>section:[base + index*scale + disp]</td>
<td>section:disp(base, index, scale)</td>
</tr>
</tbody></table>
<blockquote>
<p>其中base和index必须是寄存器，disp和scale可以是常数</p>
<p>计算方法 :  disp + base + index * scale</p>
<p>最终地址 &#x3D; 地址或偏移 + %基址或偏移量寄存器 + %索引寄存器 * 比例因子</p>
</blockquote>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于 Intel 是从 6 位体系拓展成 64 位的，所以用术语 “字(word)” 表示 16 位的数据类型，因此 32 位数被称为 “双字(double words)”，同理 64 位数被称为 “四字(quad words)”。</p>
<p>指针在不同位数系统中的大小不同，在多少的系统里面就是多少，64位系统中就对应存储为 8 字节的四字。</p>
<p>下面是常见的数据类型的大小：</p>
<table>
<thead>
<tr>
<th align="center">C声明</th>
<th align="center">Intel数据类型</th>
<th align="center">汇编代码后缀</th>
<th align="center">大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">字节</td>
<td align="center">b</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">字</td>
<td align="center">w</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">双字</td>
<td align="center">l</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">char *</td>
<td align="center">四字</td>
<td align="center">q</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">单精度</td>
<td align="center">s</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">双精度</td>
<td align="center">l</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>需要注意的是，虽然4字节的整数和双精度浮点数都是用 l 来表示，但是不会产生歧义，因为两种数据类型使用的是完全不同的两组指令和寄存器。</p>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>寄存器用来存储数据和指针，最初的16位系统中有八个16位的寄存器，分别是 ax , bx , cx , dx , d i, si , sp , bp 。后来发展到 32 位，寄存器也拓展成 32 位，在原本寄存器名字的前面加上 <code>e</code> 来表示，如 eax 。现在的 x86-64 中，寄存器对应拓展为 64 位，把所有的 <code>e</code> 替换成了 <code>r</code>，并且新增了 8 个寄存器 r8~r15。</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%84%E5%AD%98%E5%99%A8.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>大多数的指令都有一个或多个操作数，指示出执行一个操作中要使用的源数据值以及放置结果的目的位置。操作数可以是立即数、寄存器或者内存引用。</p>
<p>其中，内存引用会根据计算出的有效地址去访问内存位置。同时，有许多种寻址模式，允许不同形式的内存引用。书上也给出了很多寻址模式的解析：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" srcset="/img/loading.gif" lazyload></p>
<p>我们最常用的寻址方式是图上的最后一个，是<strong>比例变址寻址</strong>的一种，表示为 <code>Imm(x,y,z)</code>，表示了地址为 <code>x+yz+Imm</code> 的内存空间。</p>
<h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>数据传送指令，就是字面意思，把数据从一个位置复制到另一个位置的指令。</p>
<p>我们把对应执行操作相同，但是执行的操作数大小不同的不同指令称之为同一个<strong>指令类</strong>。</p>
<p>MOV 类指令是最简单的数据传送指令，在实际应用中也最为频繁。这类指令把数据从原位置复制到目的位置，不对数据做任何的处理和改变。</p>
<p>这类指令有两个操作数，源操作数存储在寄存器或内存中的立即数 ，而目的操作数指定一个位置，它是寄存器或者一个内存地址。需要注意的是，<strong>传送指令的两个操作数不能同时指向内存位置</strong>。</p>
<p>MOV 类由 <code>movb</code>、<code>movw</code>、<code>movl</code>、<code>movq</code> 四个指令组成，它们之间的差异是<strong>操作数据大小不同</strong>，分别对应 1 字节、2 字节、4 字节和 8 字节，操作数中的寄存器部分必须和指令最后一个字符对应。这其中传输双字的指令 <strong>movl ，如果目的操作数是一个寄存器，那么它会把寄存器的高位 4 字节全部置零</strong>。</p>
<p>有的时候目的寄存器和源寄存器的字长并不是对应的，可能会出现目的寄存器的字长大于源寄存器的情况，这个时候就会对源操作数进行拓展。这样又对应有两种拓展方式：零拓展（MOVZ 类）和符号拓展（MOVS类）。</p>
<p>指令名称中的后两个字符都是大小指示符，第一个字符指定源的大小（字节b，字w，双字l），第二个就是目的大小（字w，双字l，四字q）。具体如下表：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>movzbw</td>
<td>将做了零拓展的字节传送到字</td>
</tr>
<tr>
<td>movzbl</td>
<td>将做了零拓展的字节传送到双字</td>
</tr>
<tr>
<td>movzwl</td>
<td>将做了零拓展的字传送到双字</td>
</tr>
<tr>
<td>movzbq</td>
<td>将做了零拓展的字节传送到四字</td>
</tr>
<tr>
<td>movzwq</td>
<td>将做了零拓展的字传送到四字</td>
</tr>
<tr>
<td>movsbw</td>
<td>将做了符号拓展的字节传送到字</td>
</tr>
<tr>
<td>movsbl</td>
<td>将做了符号拓展的字节传送到双字</td>
</tr>
<tr>
<td>movswl</td>
<td>将做了符号拓展的字传送到双字</td>
</tr>
<tr>
<td>movsbq</td>
<td>将做了符号拓展的字节传送到四字</td>
</tr>
<tr>
<td>movswq</td>
<td>将做了符号拓展的字传送到四字</td>
</tr>
<tr>
<td>movslq</td>
<td>将做了符号拓展的双字传送到四字</td>
</tr>
<tr>
<td>cltq</td>
<td>把 %eax 符号拓展到 %rax ，等效于 movslq %eax, %rax</td>
</tr>
</tbody></table>
<p>零拓展是用 0 填充目的中的剩余字节，符号拓展就是用最高位符号位填充剩余字节。</p>
<h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>压栈和入栈实际上也是数据传送的操作，只不过操作的对象是栈。<code>pushq(push)</code>的功能是把数据压入栈，<code>popq(pop)</code> 的功能是弹出数据。这两个指令都只有一个操作数——压入的数据源和弹出的数据目的。</p>
<p>push 的作用是将栈指针减 8 也就是抬高栈顶，再将操作数写入开辟出来的栈空间中；pop 正好相反，先将栈顶的8 字节数据传送到操作数当中，再将栈指针加 8。</p>
<p>需要注意的是，因为不能同时交换两个内存地址，所以 <strong>push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器</strong>。</p>
<h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>之前在第二章中学到过计算机的运算，主要分为算数运算和逻辑运算。</p>
<p>这些运算操作又被分成四组：加载有效地址、一元操作、二元操作和移位。一元操作就是只有一个操作数，同样的，二元操作就是有两个操作数。在这之下，每一个运算的指令类都有对应的不同大小操作数的变种。</p>
<p>具体如下表：</p>
<blockquote>
<p>一元操作指令</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INC D</td>
<td>自增（D++）</td>
</tr>
<tr>
<td>DEC D</td>
<td>自减（D–）</td>
</tr>
<tr>
<td>NEG D</td>
<td>取负（-D）</td>
</tr>
<tr>
<td>NOT D</td>
<td>取反（~D）</td>
</tr>
</tbody></table>
<blockquote>
<p>二元操作指令</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ADD S, D</td>
<td>D+ &#x3D; S</td>
</tr>
<tr>
<td>SUB S, D</td>
<td>D- &#x3D; S</td>
</tr>
<tr>
<td>IMUL S, D</td>
<td>D* &#x3D; S（有符号）</td>
</tr>
<tr>
<td>MUL S, D</td>
<td>D* &#x3D; S（无符号）</td>
</tr>
<tr>
<td>IDIV S, D</td>
<td>D&#x2F; &#x3D; S（有符号）</td>
</tr>
<tr>
<td>DIV S, D</td>
<td>D&#x2F; &#x3D; S（无符号）</td>
</tr>
<tr>
<td>XOR S, D</td>
<td>D^ &#x3D; S</td>
</tr>
<tr>
<td>OR S, D</td>
<td>D| &#x3D; S</td>
</tr>
<tr>
<td>AND S, D</td>
<td>D&amp; &#x3D; S</td>
</tr>
<tr>
<td>SAL S, D</td>
<td>D&lt;&lt; &#x3D; S（有符号）</td>
</tr>
<tr>
<td>SAR S, D</td>
<td>算术右移  D&gt;&gt; &#x3D; S（有符号）</td>
</tr>
<tr>
<td>SHL S, D</td>
<td>D&lt;&lt; &#x3D; S（无符号）</td>
</tr>
<tr>
<td>SHR S, D</td>
<td>逻辑右移  D&gt;&gt; &#x3D; S（无符号）</td>
</tr>
</tbody></table>
<h4 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h4><p><code>leaq(lea)</code> 指令是加载有效地址指令，它实际上就是 movq 的变形。</p>
<p><code>lea</code> 指令形式是从内存读取数据到寄存器，但实际上它根本既没有引用内存。它的第一个操作数看上去是个内存引用，但该指令并不是从指定的位置读入数据，而是<strong>将有效地址写入目的操作数</strong>。此外，lea 的目的操作数必须是寄存器。</p>
<p><code>lea</code> 指令有很多灵活的用法，经常用于计算数据，可以实现加法和有限形式的乘法，如下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">example</span><span class="hljs-params">(<span class="hljs-type">long</span> x,<span class="hljs-type">long</span> y)</span><br>&#123;<br>    <span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-type">long</span> t=x+<span class="hljs-number">4</span>*y;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有 <code>lea</code> 指令，这个函数对应的计算部分的汇编代码可以被写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    %rsi, %rax      # 将y（%rsi）移动到%rax寄存器<br>salq    $2, %rax        # 乘以4（左移2位，相当于乘以4）<br>addq    %rdi, %rax      # 将%rdi添加到%rax<br></code></pre></td></tr></table></figure>

<p>但我们引用 lea ，汇编代码就被简化了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leaq (%rdi,4,%rsi),%rax<br></code></pre></td></tr></table></figure>

<blockquote>
<p>没错就这一句🤔</p>
</blockquote>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>程序中不止会有逐步指令执行的直线代码行为，C语言中的某些结构会要求有条件的执行，比如循环语句，在循环中我们会重复执行多次统一部分的指令。对此，机器提供相应的指令来控制修改机器代码的指令顺序。</p>
<p>执行方式分为条件执行和非条件执行</p>
<h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>除了整数寄存器，CPU还维护着一组单位个的条件码寄存器，用来描述最近的算术或逻辑操作的属性，用来判断并执行条件分支指令。常见的条件码如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CF</td>
<td>进位标志</td>
<td>判断是否产生进位</td>
</tr>
<tr>
<td>ZF</td>
<td>零标志</td>
<td>判断最近的结果是否为0</td>
</tr>
<tr>
<td>SF</td>
<td>符号标志</td>
<td>最近操作的结果是否为负数</td>
</tr>
<tr>
<td>OF</td>
<td>溢出标志</td>
<td>最近的操作是否导致补码溢出</td>
</tr>
</tbody></table>
<p>leaq 指令不会改变任何条件码，因为它是用地址进行计算的。除此之外，所有的指令都会设置条件码。同时需要注意，INC 和 DEC 指令不会改变进位标志，CMP 指令和 TEST 指令只改变条件码。</p>
<blockquote>
<p>除了对寄存器的操作，CMP指令和SUB指令的行为相同，TEST指令和ADD指令的行为相同</p>
</blockquote>
<h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>机器并不是直接去读取条件吗，常用的方法有以下三种：</p>
<ul>
<li>根据条件码的某种组合，将一个字节设置为0或1。我们将这类指令称为 SET 指令</li>
<li>条件跳转到程序的某个其他的部分</li>
<li>有条件地传送数据</li>
</ul>
<p>每一条 SET 指令的后缀都指明了它们所考虑的条件码的组合，需要注意的是后缀表示的是不同的条件而不是不同的操作数。具体的 SET 指令如下表：</p>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">同义后缀</th>
<th align="center">条件码</th>
<th align="center">设置条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sete</td>
<td align="center">z</td>
<td align="center">ZF&#x3D;&#x3D;1</td>
<td align="center">相等（零）</td>
</tr>
<tr>
<td align="center">setne</td>
<td align="center">nz</td>
<td align="center">ZF&#x3D;&#x3D;0</td>
<td align="center">不相等（不为零）</td>
</tr>
<tr>
<td align="center">sets</td>
<td align="center">&#x2F;</td>
<td align="center">SF&#x3D;&#x3D;1</td>
<td align="center">负数</td>
</tr>
<tr>
<td align="center">setns</td>
<td align="center">&#x2F;</td>
<td align="center">SF&#x3D;&#x3D;0</td>
<td align="center">非负数</td>
</tr>
<tr>
<td align="center">setg</td>
<td align="center">nle</td>
<td align="center">(SF^OF)&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td>
<td align="center">（有符号）大于</td>
</tr>
<tr>
<td align="center">setge</td>
<td align="center">nl</td>
<td align="center">(SF^OF)&#x3D;&#x3D;0</td>
<td align="center">（有符号）大于等于</td>
</tr>
<tr>
<td align="center">setl</td>
<td align="center">nge</td>
<td align="center">(SF^OF)&#x3D;&#x3D;1</td>
<td align="center">（有符号）小于</td>
</tr>
<tr>
<td align="center">setle</td>
<td align="center">ng</td>
<td align="center">(SF^OF)&#x3D;&#x3D;1|ZF</td>
<td align="center">（有符号）小于等于</td>
</tr>
<tr>
<td align="center">seta</td>
<td align="center">nbe</td>
<td align="center">CF&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td>
<td align="center">（无符号）大于</td>
</tr>
<tr>
<td align="center">setae</td>
<td align="center">nb</td>
<td align="center">CF&#x3D;&#x3D;0</td>
<td align="center">（无符号）大于等于</td>
</tr>
<tr>
<td align="center">setb</td>
<td align="center">nae</td>
<td align="center">CF&#x3D;&#x3D;1</td>
<td align="center">（无符号）小于</td>
</tr>
<tr>
<td align="center">setbe</td>
<td align="center">na</td>
<td align="center">CF|ZF&#x3D;&#x3D;1</td>
<td align="center">（无符号）小于等于</td>
</tr>
</tbody></table>
<h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>前面提到机器需要指令来实现指令执行的切换，跳转（jump）指令就会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。</p>
<p><code>jmp</code> 指令是无条件跳转，它可以直接跳转，即跳转目标是作为指令的一部分编码，比如 <code>jmp *%rax</code> ；也可以间接跳转，即跳转目标需要从寄存器或内存位置读出，比如 <code>jmp *(%rax)</code> 。</p>
<p><code>jmp</code> 指令的条件指令就是 <code>j+后缀</code> ，具体后缀和上面 <code>set</code> 后缀部分相同，对应条件也相同。</p>
<p>跳转指令的目标值是一个地址，它主要有两种编码方式：</p>
<ul>
<li>绝对地址：给出绝对地址，用四字节直接指定要跳转到的内存地址。</li>
<li>相对地址：用偏移量编码，将目标指令的地址与紧跟在跳转指令后面的指令地址之间的差值作为编码，编译器或汇编器会完成这些工作。</li>
</ul>
<h4 id="条件分支的实现"><a href="#条件分支的实现" class="headerlink" title="条件分支的实现"></a>条件分支的实现</h4><p>条件分支是编程中常用的一种控制结构，它允许根据条件的成立与否来执行不同的代码路径。条件分支通常可以通过两种主要方法来实现：条件控制和条件传送语句。</p>
<h5 id="条件控制来实现条件分支"><a href="#条件控制来实现条件分支" class="headerlink" title="条件控制来实现条件分支"></a>条件控制来实现条件分支</h5><p>在条件控制中，程序使用条件语句（如 <code>if</code>、<code>else if</code> 、<code>else</code> ）来检查一个或多个条件表达式，并基于这些条件的真假来选择执行不同的代码块。</p>
<p>条件控制通常使用分支指令（如条件跳转指令）来实现，例如，在汇编语言中，<code>jz</code>（跳转如果零）、<code>jnz</code>（跳转如果不为零）等指令可用于根据条件跳转到不同的代码段。</p>
<p>条件控制的一个典型示例是使用 <code>if </code>语句来根据条件执行不同的代码块。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>在汇编代码中我们就可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    cmp rdi, rsi     ; 比较 x 和 y<br>    jg L1      ; 如果 x &gt; y，则跳转到 greater<br>    mov rax, 0      ; 否则，将 0 存储在 %rax 中<br>    jmp done<br>L1:<br>    mov rax, 1      ; 如果 x &gt; y，则将 1 存储在 %rax 中<br>done:<br>    ; 返回结果并退出<br>    ret<br></code></pre></td></tr></table></figure>

<h5 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h5><p>条件传送语句是一种通过条件来选择是否将一个值传送到目标寄存器或内存位置的机制，使用数据实现条件转移。它通常用于执行非常简单的条件分支，其中只有两个可能的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    result=x-y;<br>&#125; <br><span class="hljs-keyword">else</span><br>&#123;<br>    result=y-x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在汇编代码中我们就可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   movq %rdi,%rax<br>   subq %rsi,%rax          ;let %rax=x-y<br>   movq %rsi,%rbx<br>   subq %rdi,%rbx          ;let %rbx=y-x<br>cmp %rsi,%rdi<br>cmovle %rbx,%rax        ;if x&lt;=y movq %rbx,%rax<br>ret<br></code></pre></td></tr></table></figure>

<p>注意观察上面的汇编代码，它会先把两种结果都算出来，最后再根据判断结果赋值。虽然这种方法看上去执行的步骤更多，但是实际上它的运行速度更快。</p>
<h5 id="条件控制和条件传送的比较"><a href="#条件控制和条件传送的比较" class="headerlink" title="条件控制和条件传送的比较"></a>条件控制和条件传送的比较</h5><p>处理器通过流水线来获得高性能，在流水线中，机器会重叠连续指令，比如在执行某一条指令的同时会同时执行它前面一条的算术运算。</p>
<p>像前面的条件传送语句中，他的计算步骤是同时进行的；但是由于条件控制语句在执行完毕之前，不能确定程序是否要跳转，也就无法知道它接下来要执行的指令，所以我们只能等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>C语言中的很多循环例如 do-while 、while 和 for 。汇编中并没有相应的代码来直接实现这些操作，但是可以用条件测试和跳转组合来实现循环的效果。</p>
<h5 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">do</span>&#123;<br>	<span class="hljs-comment">//bodyment</span><br>	i--;<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>它对应的汇编代码就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq $10,%rcx     <br>do:<br>    ;do bodyment<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    jns do<br></code></pre></td></tr></table></figure>

<p>同样，其他的循环也有对应的实现方法</p>
<h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>       i--;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">do:<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    js end<br>    ;do bodyment<br>    jmp do<br>end:<br>    ret<br></code></pre></td></tr></table></figure>

<h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rcx,0<br>do:<br>    ;something<br>    addq %rcx,$1<br>    cmpq $10,%rcx<br>    jl do<br></code></pre></td></tr></table></figure>

<p>综上，上方的三个循环都可以用条件分支代码的思路去实现，由控制来构成机器代码。</p>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 语句可以根据一个整数索引值进行多重分支，当开关的情况数量比较多，并且值的跨度范围比较小时，会通过使用<strong>跳转表</strong>来实现程序的高效性。</p>
<p>跳转表是一个数组或类似数据结构，其中每个 <code>case</code> 标签对应一个表项。每个表项包含两部分信息：条件值和跳转目标。在跳转的判断部分，程序会在跳转表中直接查找 <code>switch </code> 表达式的值对应的条件值，<strong>只进行一次判断</strong>就跳转到指定位置运行。</p>
<p>比如下面这段C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">switch_eg</span><span class="hljs-params">(n)</span><br>&#123;<br>    <span class="hljs-type">int</span> val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            val+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            val*=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            val/=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            val--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L1:<br>    .quad .L2<br>    .quad .L3<br>    .quad .L4<br>    .quad .L5<br>    .quad .L6<br><br>switch_eg:<br>    movq $1,%rax<br>    subq $1,%rdi    ;rdi 也就是 n ，其值要匹配跳转表的索引<br>    cmpq $3,%rdi<br>    ja L6<br>    jmp *.L1(,%rdi,8)    ;跳转表<br>L2:<br>    addq $2,%rax<br>    jmp end<br>L3: <br>    subq $2,%rax<br>    jmp end<br>L4:<br>    mul $2,%rax<br>    jmp end<br>L5:<br>    div $2,%rax<br>    jmp end<br>L6:<br>    addq $1,%rax<br>end:<br>    ret<br></code></pre></td></tr></table></figure>



<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是软件中很重要的抽象，它提供了一种封装代码的方式，用一组参数和可选的返回值实现了某种功能。我们可以在程序中不同的地方调用这个函数。</p>
<p>我们假设过程 P 调用过程 Q ，Q 执行后返回到 P。</p>
<h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>C语言过程调用机制的一个关键特性就是使用了栈数据结构提供的后进先出的内存管理原则。</p>
<p>当某个函数运行时所需要的局部变量超过了寄存器的数量，就会在栈上开辟空间，这个在栈上分配的空间就称为这个函数的栈帧。</p>
<p>当 P 调用 Q 时，会把 P 的状态保存起来，并存储 Q 调用结束后的返回地址，调用完以后再恢复到调用前的状态。需要注意这个<strong>返回地址属于 P 的帧的一部分</strong>。</p>
<h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>当控制从函数 P 转移到函数 Q 只需要把程序计数器（PC）设置为 Q 的起始地址，但当 Q 调用结束返回 P时，处理器必须记住 P 应该继续执行的代码位置，这个信息就是由 <code>call</code> 指令来记录的。</p>
<p><code>call Q</code> 指令用来调用 Q ，同时它会将 P 当前的地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。地址 A 就是函数 Q 的返回地址，也是 <code>ret</code> 指令的地址。ret 指令紧跟在 call 指令之后，会从栈中弹出返回地址 A，并把 PC 重新设置为 A ，继续函数 P 的执行。</p>
<p>call 指令和 ret 指令的一般形式如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>call  <em>Label</em></td>
<td>过程调用</td>
<td>控制程序跳转到被调用过程的指令地址</td>
</tr>
<tr>
<td>call  *<em>Operand</em></td>
<td>过程调用</td>
<td>控制程序跳转到被调用过程的指令地址</td>
</tr>
<tr>
<td>ret</td>
<td>从过程调用中返回</td>
<td>控制程序返回到调用它的地方</td>
</tr>
</tbody></table>
<p>这两个指令对应的寄存器层面的变化如下：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%80.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%802.png" srcset="/img/loading.gif" lazyload></p>
<p>call 指令执行前</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%89%8D.png" srcset="/img/loading.gif" lazyload></p>
<p>call 指令执行完毕后，<em>rip</em> 寄存器指向调用的函数 <code>foo()</code> 的地址 <code>0x4004e7</code>，此时 <em>rsp</em> 指向返回地址 <code>0x400514</code></p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%90%8E.png" srcset="/img/loading.gif" lazyload></p>
<p>ret 执行后 <em>rip</em> 寄存器指向原本 <code>foo()</code> 函数对应的返回地址 <code>0x400514</code></p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6ret%E5%90%8E.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>在函数调用的过程中，不仅要把控制在过程中传递，还需要传递数据参数。</p>
<p>在 x86-64 中，大部分的过程间的数据传递是通过寄存器实现的。寄存器最多传递六个整数，顺序是： %rdi，%rsi，%rdx，%rcx，%r8，%r9 ，其余参数自右向左依次入栈。</p>
<h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>有一些局部数据必须放在内存中，具体情况如下：</p>
<ul>
<li>寄存器不足以存放所有的本地数据</li>
<li>对局部变量使用地址运算符 <code>&amp;</code> 进行取地址操作</li>
<li>变量是数组或结构，必须通过引用来访问</li>
</ul>
<h4 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h4><p>我们知道，寄存器是在整个过程中共享的资源，我们需要保证 在一个过程调用另一个过程时，被调用者不会覆盖调用者将要使用的寄存器的值，以保证调用结束后程序可以正常运行。对此 x86-64 有一组统一的寄存器使用惯例。</p>
<p> 惯例中：%rbx,%rbp,%r12~%r15 被划分为<strong>被调用者保存寄存器</strong>，就是被调用函数不回去待变这些寄存器的值。而其它的寄存器，除了 %rsp 都分类为<strong>调用者保存寄存器</strong>，也就是任何函数都可以改变它们。</p>
<p>我们可以这样理解“调用者保存”这个名字，Q 被调用时可以随意改变这些寄存器，那么保存好这些数据就是调用者 P 的责任。</p>
<h3 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h3><p>C语言中的数组是一种将标量数据据继承更大数据类型的方式。</p>
<h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>对于数据类型 T 和整型常数 N，数组声明为 <code>T A[N];</code> ，它的起始位置我们表示为 <em>xA</em> ，数组占用的字节数是 <em>sizeof(T)* N</em> ，我们访问 A[i] ,实际上就是访问 <em>xA + sizeof(T)* i</em>  。</p>
<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许且对指针进行运算，计算出来的值会根据引用该指针的数据类型的大小进行伸缩。也就是说表达式 p+i  相当于 *xp+sizeof(type)<em>i</em> 的地址（xp 表示数组 p 的基地址）。</p>
<h4 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h4><p>我们使用的二维数组，例如 <code>int A[5][3];</code>，等价于 <code>typedef int row3_t[3]; row3_t A[5]</code>，这种就是嵌套声明。</p>
<p>我们要访问多维数组 <code>T D[R][C]</code> 的元素 <em>D[i][j]</em>  ，对应的内存地址是 <em>xD+sizeof(T) *i+sizeof(T) *j</em>  。</p>
<h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>C语言提供了两种将不同类型对象结合到一起创建数据类型的机制：结构和联合</p>
<h4 id="结构（struct"><a href="#结构（struct" class="headerlink" title="结构（struct)"></a>结构（struct)</h4><p><code>struct</code> 也叫结构体，将可能不同类型的基本数据聚和到一个对象当中，用名字来引用结构的各个部分。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，作为内存引用指令中的位移，用来实现各个元素的引用。</p>
<p>也就是说，我们想要访问结构体中的某个对象，只需要将结构体的地址再加上这个字段的偏移即可。</p>
<h4 id="联合（union"><a href="#联合（union" class="headerlink" title="联合（union)"></a>联合（union)</h4><p>联合的声明方式和结构体相同，但不同的是联合内的<strong>所有成员变量共享同一块内存</strong>，只能同时访问一个数据成员，而结构体中的数据成员各自独立的占用内存，所以可以被同时访问。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 U的指针 <code>p</code> ，<code>p-&gt;c</code> 和<code>p-&gt;i[0]</code>都是指向 U 的起始位置。</p>
<h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>许多计算系统都对数据类型的合法地址做出了一些限制，要求某些数据对象的地址必须是某个值的倍数。例如处理器总是从内存中取 8 字节，那么有效地址就必须是 8 字节的倍数，这样我们可以保证用一个内存操作来读、写值了。</p>
<p>例如下面的结构体，如果没有对齐要求，我们认为他们的内存占用情况如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//5+=4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但实际上是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//8+=4</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>画出图就是下面的样子，灰色部分是为了对内对齐导致的两个数据成员之间的空的间隙</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png" srcset="/img/loading.gif" lazyload></p>
<p>因为不同的数据类型都必须对其相应的值K，具体如下表：</p>
<table>
<thead>
<tr>
<th>K</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>char</td>
</tr>
<tr>
<td>2</td>
<td>short</td>
</tr>
<tr>
<td>4</td>
<td>int , float</td>
</tr>
<tr>
<td>8</td>
<td>long , double , char*</td>
</tr>
</tbody></table>
<h3 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><del>指针我一生之敌！</del></p>
<p>指针是C语言的特色，它们允许程序直接访问计算机内存中的数据。每个指针都对应一个类型，表示了它指向的内存为什么数据类型。</p>
<p>以下是指针的特点：</p>
<ul>
<li><code>*</code> 操作符是间接引用指针，结果数据是该指针的类型</li>
<li>每个指针都有一个值，这个值就是某个指定类型对象的地址，NULL(0) 也是一个值，表示指针并没有指向任何地方</li>
<li>对指针进行强制类型转换值，改变它的类型，不改变它的值</li>
<li>指针可以指向函数</li>
</ul>
<p>我们这样来声明一个指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">type *name ;   <br>type (*name) (arglist) ;  <span class="hljs-comment">//指向函数，括号必须将*和函数名括在一起</span><br></code></pre></td></tr></table></figure>

<h4 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h4><p>GNU 调试器 GDB 提供了许多有用的特性，支持机器级程序运行时的分析。我们可以用下面的指令启动GDB并调试程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gdb filename</span><br></code></pre></td></tr></table></figure>

<p>输入 help(h) 就可以查看具体的命令，常用的命令如下：</p>
<table>
<thead>
<tr>
<th>调试命令 (缩写)</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>break (b)  xxx</td>
<td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点位置</td>
</tr>
<tr>
<td>run (r）</td>
<td>执行被调试的程序，其会自动在第一个断点处暂停执行</td>
</tr>
<tr>
<td>continue (c）</td>
<td>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</td>
</tr>
<tr>
<td>next (n)</td>
<td>令程序一行代码一行代码的执行</td>
</tr>
<tr>
<td>step（s）</td>
<td>如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样</td>
</tr>
<tr>
<td>until (u)</td>
<td>当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体</td>
</tr>
<tr>
<td>until n</td>
<td>命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止</td>
</tr>
<tr>
<td>print (p）xxx</td>
<td>打印指定变量的值，其中 xxx 指的就是某一变量名</td>
</tr>
<tr>
<td>list (l)</td>
<td>显示源程序代码的内容，包括各行代码所在的行号</td>
</tr>
<tr>
<td>finish（fi）</td>
<td>结束当前正在执行的函数，并在跳出函数后暂停程序的执行</td>
</tr>
<tr>
<td>return（return）</td>
<td>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行</td>
</tr>
<tr>
<td>jump（j)</td>
<td>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码</td>
</tr>
<tr>
<td>quit (q)</td>
<td>终止调试，退出 GDB shell</td>
</tr>
<tr>
<td>kill (k)</td>
<td>杀死程序，强制终止正在被调试的异常程序</td>
</tr>
</tbody></table>
<h4 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h4><p>C在数组引用的时不会进行任何边界检查，而且局部变量和状态信息都存放在栈中，两者结合起来就会导致严重的程序错误，破坏栈中存储的信息，如果保持这个被破坏的信息并试图重新加载寄存器或者尝试执行 ret ，就会导致程序发生错误。</p>
<p>一种常见的状态破坏被称为<strong>缓冲区溢出</strong>，通常发生子啊在我们在栈中分配字符数组的时候，输入的字符串的长度超出了为它分配的空间大小。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">echo</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>    gets(buf);    <span class="hljs-comment">//gets不会对输入数据的长度进行判断，只有遇到&quot;\n&quot;才会停止读取</span><br>    <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对应的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushq    %rbp<br>movq    %rsp, %rbp<br>subq    $16, %rsp<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>movl    $0, %eax<br>call    gets@PLT<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>call    puts@PLT<br>nop<br>leave<br>ret<br></code></pre></td></tr></table></figure>

<p>其中有指令 <code>leaq -8(%rbp), %rax</code> 的意思就是将相对于基指针 <code>rbp</code> 的地址偏移 <code>-8</code>加载到寄存器 <code>rax</code> 中，也就是说一旦输入超过了 8 字节，就会覆盖 <code>rbp</code> 所在的位置，再长 8 字节就会覆盖住返回地址。</p>
<p>缓冲区溢出的致命使用就是让程序执行本来不该执行的函数，这也是一种最常见的网络攻击的方法。我们称编写的攻击代码为 exploit code ，直接输入的字节被称为 payload。一般情况下，攻击代码可能会尝试启动一个 shell 程序，这样攻击者就可以获取对受害计算机直接操控的权限。</p>
<h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p>GCC 提供了一些机制来防止攻击者利用缓冲区溢出来获取系统控制权限，如下：</p>
<ul>
<li><p>栈随机化</p>
<p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样我们就可以直接将想要执行的函数地址覆盖在返回地址上。</p>
<p>栈随机的思想使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization，ASLR）</strong>。原理是每次运行程序时，程序的不同部分包括程序代码、库代码和全局变量等数据都会被加载到内存的不同区域。</p>
<p>当然攻击者也有对抗保护的方法，就是在实际的的攻击代码前面插入很多 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列常用的术语 “nop sled” 就是”滑“过序列的意思。</p>
</li>
<li><p>栈破坏检测</p>
<p>栈破坏检测是在栈已经被破坏后进行的防御措施，GCC 中对应的机制叫做栈保护者（stack-protector）。其思想是在缓冲区和返回地址之前插入一段随机数，在函数返回之前检查这个随机数是否被更改，如果被更改就终止程序。这个随机数叫做金丝雀（canary）值。</p>
</li>
<li><p>栈不可执行</p>
<p>这个保护措施直接限制了攻击者像系统中插入可执行代码的行为，也就是 NX（No-Execute），通过这个特性我们可以将栈设置为不可执行，也就是向栈上插入的代码是不会运行的。</p>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><del>书上还有一小节浮点数的部分</del></p>
<p>当前使用的 AVX 指令集中，浮点数的机器代码风格和整数数据的各种操作类似，不同就在于寄存器和指令的表示，浮点数通常有专用的浮点寄存器和浮点指令。</p>
<blockquote>
<p>AVX 指令集是英特尔（Intel）和AMD（Advanced Micro Devices）处理器架构中的一种 SIMD（Single Instruction, Multiple Data，单指令多数据）扩展指令集</p>
</blockquote>
<hr>
<p>我要开始快乐国庆节噜！！</p>
<p>身上颓废的上学味已经消散，现在我浑身都散发着浓郁的爱国气息🥳</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="category-chain-item">读书笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Knowledge/">#Knowledge</a>
      
        <a href="/tags/CSAPP/">#CSAPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP 第三章 程序的机器级表示 总结</div>
      <div>https://shmodifier.github.io/2023/09/30/CSAPP-第三章-程序的机器级表示/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Modifier</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/03/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/" title="CSAPP 第三章 bomblab attacklab">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSAPP 第三章 bomblab attacklab</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/19/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/" title="CSAPP 第二章 datalab">
                        <span class="hidden-mobile">CSAPP 第二章 datalab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    
    <div class="footer-content">
       <p> Copyright &copy; 2022&nbsp;-&nbsp;2024 <a href="/">Modifier</a> </p> <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></p> <!--  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> -->

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
