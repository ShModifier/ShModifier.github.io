

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Modifier">
  <meta name="keywords" content="">
  
    <meta name="description" content="libc2.23 的 malloc 和 free 函数源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc和free源码分析">
<meta property="og:url" content="https://shmodifier.github.io/2023/12/17/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Modifier">
<meta property="og:description" content="libc2.23 的 malloc 和 free 函数源码分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shmodifier.github.io/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
<meta property="article:published_time" content="2023-12-17T12:43:55.000Z">
<meta property="article:modified_time" content="2023-12-17T13:09:06.156Z">
<meta property="article:author" content="Modifier">
<meta property="article:tag" content="Knowledge">
<meta property="article:tag" content="libc">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shmodifier.github.io/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
  
  
  
  <title>malloc和free源码分析 - Modifier</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shmodifier.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Have a nice day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="malloc和free源码分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-17 20:43" pubdate>
          2023年12月17日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          272 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">malloc和free源码分析</h1>
            
            
              <div class="markdown-body">
                
                <p>libc2.23 的 malloc 和 free 函数源码分析</p>
<span id="more"></span>

<p>我们知道程序它有动态分配内存的操作，Linux 就是靠 malloc 和 free 来实现分配和回收的。</p>
<blockquote>
<p>不刻意去说明都是用 64 位系统举例解释的</p>
</blockquote>
<h1 id="ptmalloc2-的分配策略"><a href="#ptmalloc2-的分配策略" class="headerlink" title="ptmalloc2 的分配策略"></a>ptmalloc2 的分配策略</h1><blockquote>
<p>之前写堆概述的时候写过一次了这次粗略概括一下顺便复习了</p>
</blockquote>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>Linux系统中使用 ptmalloc2 ，在这个分配规则下，<strong>不是每一次 malloc 程序都会向系统申请内存。</strong></p>
<p>在第一次 <code>malloc()</code>的时候，它会向操作系统申请 <code>0x21000B(132KB)</code> 的内存（固定值不会变），后续分配都从已经申请的这一大块内存中分割，用完了才会再次向系统申请内存。</p>
<p>那么如何去分割块呢？我们实践时会发现，并不是我们希望获得多少内存程序就分割给我们多少的。每一个被分割的堆块都需要标注它们的信息，例如是否被使用、堆块大小等数据特征，这就导致分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。</p>
<p>同时由于需要保证指针对齐，系统要求每一个堆块都是 <code>SIZE_SZ*2</code> 的整倍数，也就是说 <strong>32 位操作系统下的堆块大小必须是 8 的整数倍，64 位必须是 16 的整数倍。</strong></p>
<p>以32位操作系统为例，size 的值必定为 8 的整数倍，二进制角度下看来，低三位永远是0，如果不利用起来的话就有点浪费。</p>
<p>如下图，在 malloc.c 中定义了下面的部分：</p>
<p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%87%E5%BF%97%E4%BD%8D%E4%B8%8Esize.png" srcset="/img/loading.gif" lazyload></p>
<p>规定 <code>size</code> 的低三位不作为实际的 <code>chunk</code> 大小，而是标志位。三个标志位从高位到低位分别是：</p>
<ol>
<li><strong>NON_MAIN_ARENA</strong>：是否为主分配，0表示是主分配，权值为4</li>
<li><strong>IS_MMAPPED</strong>：表示内存是否为 <code>mmap</code> 获得，0表示不是，权值为2</li>
<li><strong>PREV_INUSE</strong>：表示前面一个内存块是否被使用，0表示不被使用，权值为1</li>
</ol>
<p>在 64 位操作系统中就是低 4 位，多出一个标志位，但是这个标志位当前无任何意义，但是它同样不作为 <code>chunk</code>的大小。</p>
<p>如果是单单满足 <code>SIZE_SZ*2</code> 的整倍数，那么理论上我们应该是可以分配 0x10 大小的堆块的，但是我们实际运行<code>malloc (0x10)</code> 发现堆块大小是 0x20，这是为什么呢？</p>
<p>接下来我们了解一下chunk结构就能知道，chunk 的结构体有 <code>0x10</code> 个默认被包含在堆块里的必须分配的字节。</p>
<h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>目前来看，分配堆块的时候实际上操作很简单，就是从大堆块里面分割一块合适的大小就好了。但是释放以后不能像捏橡皮泥一样再把它放回去。如果我们每一次 free 都不做处理的操作直接丢弃，例如我们一次性申请了很多小的堆块并释放，只有再下次申请同样堆块才会被利用，如果我们不再分配同样的小堆块，这块区域就会被浪费。</p>
<p>这时我们要了解一下 ptmalloc 的又一个策略：<strong>尽量合并物理相邻的空闲堆块</strong>。就是回收时，可以把相邻的小堆块合并成大堆块。在合并的时候我可能前面会有 <code>free</code> 的内存块，后面也会有 <code>free</code> 的内存块。</p>
<p>那么我怎么在只知道我自身信息的情况下准确找到前后的 <code>chunk</code> 具体在哪呢？</p>
<p>这时需要把 malloc_chunk 结构体拎上来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过 <code>prev_size</code> 位我们不仅可以得知前一个 <code>chunk</code> 有没有被 <code>free</code> ，还可以得知 <code>chunk</code> 的大小。所以在一个 <code>chunk</code> 的结构体内，在 size 之前还会有一个 <code>prev_size</code> 。</p>
<p>在程序使用时，<code>fd</code>、<code>bk</code> 等指针可以给用户写数据，只有被释放的时候才会存储指针数据。</p>
<p>所以 <code>prev_size</code> 和 <code>size</code> 两个数据就占了 0x10 的空间，这也就是最小堆块是 0x20 的原因。</p>
<h3 id="详细的回收处理"><a href="#详细的回收处理" class="headerlink" title="详细的回收处理"></a>详细的回收处理</h3><p>bin 就是空闲 chunk 的别名，我们使用链表结构来管理空闲堆块，我们说的 bin 也指代不同的链表表头。</p>
<h5 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h5><p>0x20~0x80 大小的 chunk，我们会把它扔进 <code>fast bin</code> 。</p>
<p><code>fast bin</code> 管理 free_chunk 采用<strong>单链表</strong>方式，并且符合<strong>先进后出（FILO）</strong>的原则，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>p2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-built_in">free</span>(p2);<br>p3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>p4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br></code></pre></td></tr></table></figure>

<p>最后 <code>p3</code> 的指针是原本指向 <code>p2</code> 的指针，<code>p4</code> 的指针是原本指向 <code>p1</code>的指针。</p>
<p>并且所有 <code>fast bin</code> 之后的 chunk 的 <code>prev_inuse</code> 位永远为 1 ，也就是说它永远被视为在使用中。由于这个位用于合并相邻堆块，所以 <code>fast bin</code> 不会被合并，free 掉的时候是多大就是多大。比如我们当前 <code>fast bin</code> 中只有 0x20 和 0x30 的堆块，我们新申请一个 0x50 的堆块，检查 <code>fastbin</code> 中没有就是没有，不会去合并 0x20 和 0x30 的两个堆块来拼 0x50 ，也不会切割某个堆块。</p>
<blockquote>
<p>其他的都会参与切割与合并</p>
</blockquote>
<h5 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h5><p>被释放的 free_chunk，经检查不属于 <code>fast bin</code> 之后会被丢进 <code>unsorted bin</code>。</p>
<p><code>unsorted bin</code> 是双向链表结构，也就是说 <code>unsorted bin</code> 中有两个 ”头指针“ ，我们也把头部的两个 bin 看作 chunk。初始状态时，<code>unsorted bin</code> 中没有空闲 chunk，此时两个 bins 的的 <code>fd</code> 和 <code>bk</code> 都指向自身的 <code>prev_size</code> 。</p>
<p><code>unsorted bin</code> 中 chunk 大小不一定相等且无序排列。</p>
<p>当需要检查 <code>unsorted bin</code> 的时候，会遍历整个链表，寻找第一个能满足的 chunk 大小切割。当然这中条件的分割也是基于最小 0x20 大小的基础上的。</p>
<h5 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h5><p><code>small bin</code> 一共有 62 个，它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code>。</p>
<p>按照不同的大小范围区分成不同的链。当中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p>
<table>
<thead>
<tr>
<th>下标</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>x</th>
<th>63</th>
</tr>
</thead>
<tbody><tr>
<td>SIZE_SZ&#x3D;4（32 位）</td>
<td>16</td>
<td>24</td>
<td>32</td>
<td>40</td>
<td>2<em>4</em>x</td>
<td>504</td>
</tr>
<tr>
<td>SIZE_SZ&#x3D;8（64 位）</td>
<td>32</td>
<td>48</td>
<td>64</td>
<td>80</td>
<td>2<em>8</em>x</td>
<td>1008</td>
</tr>
</tbody></table>
<p><code>small bins</code> 采用<strong>双向链表</strong>对 bin 进行管理，每个链表中存储的 chunk 大小都一致。</p>
<p>链表采用 FIFO 的规则，也就是<strong>先进先出</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p>
<p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h5><p><code>large bin</code> 一共有 63 个，从 <code>small bin</code> 最小不能表示的 chunk 开始，大到无穷。</p>
<p> <code>large bin</code> 从 <code>128*SIZE_SZ</code> 开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p>
<p>它同样以二维双向链表进行管理，相同大小的 chunk 用 <code>fd</code> 和 <code>bk</code> 指针相连；不同大小的 chunk，用 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针连接。沿着 <code>fd_nextsize</code> 指针，chunk 大小递增。</p>
<p>大概结构如下图：</p>
<p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin.png" srcset="/img/loading.gif" lazyload></p>
<p>（省略了部分指针）</p>
<h3 id="具体分配细节"><a href="#具体分配细节" class="headerlink" title="具体分配细节"></a>具体分配细节</h3><p><code>malloc()</code> 会对用户请求的size进行处理，来申请同时满足 <code>SIZE_SZ*2</code> 的整数倍，包含 0x10 的固定数据区域且大小最小的堆块。</p>
<p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%88%86%E9%85%8D%E7%BB%86%E8%8A%82size%E5%A4%84%E7%90%86.png" srcset="/img/loading.gif" lazyload></p>
<p>在一些特殊情况下，并不是我们申请多大的堆块，就有多少区域来供我们向上写数据。</p>
<p>一个 <code>size=0x20</code> 的 chunk 中，0x20 字节分别为 <code>prev_size</code>，<code>size</code>，<code>fd</code> 和 <code>bk</code>。</p>
<p><code>prev_size</code> 和 <code>size</code> 都不允许写，但是我们可以写 <code>fd</code> 和 <code>bk</code> ，以及下一个块的 <code>prev_size</code> 。所以<code>size=0x20</code>，我们可以写的数据段为 <code>0x18</code> 。</p>
<p>所以当我请求的内存小于等于 0x18 的时候，系统就会给我们 <code>size=0x20</code> 的 chunk 。一旦多了就会以 <code>0x10( 2*SIZE_SZ)</code>  为单位向上加直到满足条件。</p>
<p>计算好大小之后就进入分配环节，系统搜寻堆块的顺序是： <code>fast bin -&gt; small bin -&gt; large bin -&gt; unsorted bin</code></p>
<p> <code>fast bin</code> 、<code>small bin</code> 和<code>large bin</code> 在搜寻阶段都不进行合并和分割处理。如果在前三个bins中都没有找到合适的堆块，<code>unsorted bin</code> 会找第一个能满足的 chunk 并返回或者切割之后返回。如果切割之后剩余的部分小于 <code>MINSIZE</code> ，那么则不会切割整个返回。</p>
<p><code>unsorted bin</code> 中每遍历一个不满足要求的 free_chunk 就会把这个堆块放进对应的 <code>small bin</code> 或者<code>large bin</code>当中。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下载源码，还挺慢的就是说</p>
<p>我的环境是 ubuntu16.04</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install glibc-source <br>sudo apt-get install libc6-dbg <br>sudo tar xf /usr/src/glibc/glibc-2.23.tar.xz<br></code></pre></td></tr></table></figure>

<blockquote>
<p>之前我还在想为啥网上分析源码的都是一段一段的，没想到这个 malloc 它这么大个文件夹😶‍🌫️</p>
</blockquote>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 内部，<code>malloc()</code> 函数就是 <code>__libc_malloc()</code> 函数，而 <code>__libc_malloc()</code> 函数的主要工作是<code>_int_malloc()</code> 完成的。</p>
<h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>对应的在代码里加注释分析一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br>  <br>  <span class="hljs-comment">//读取malloc_hook，若 malloc_hook 被设置，则直接调用</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>  <span class="hljs-comment">//调用 arena_get 函数，函数获取一个可用的分配区</span><br>  arena_get (ar_ptr, bytes);<br>    <br>  <span class="hljs-comment">//这里！!调用了 _int_malloc()</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>    <br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-comment">//可以理解为一个错误检验？如果 chunk 为空，但分配区指针不为空，再次调用 _int_malloc 获取</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>    <br>  <span class="hljs-comment">//给内存分配区 解锁</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//对分配的chunk 指针进行地址检查</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>assert 命令如果失败，即代表存在错误，会触发对应的异常，通常导致程序终止并打印出错误消息，以帮助定位和修复问题。</p>
</blockquote>
<p>根据函数内容我们可以看出，在 malloc 时，会先检查 <code>malloc_hook</code> 所指向的区域。</p>
<p>我们就有一个利用思路是，<strong>修改 <code>malloc_hook</code> 为我们的 gadget ，修改后再次调用 malloc 就会执行 gadget 从而 getshell 。</strong></p>
<h4 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h4><p><code>__libc_malloc</code> 是通过调用 <code>_int_malloc</code> 来执行分配堆的操作的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>  &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>省略掉一开始定义的一大堆变量，malloc 的第一步就是调用 <code>checked_request2size()</code> 设置 size。</p>
<p> <code>checked_request2size()</code> 函数就是用来查找最小的满足条件的 size 我就不复制了🤪</p>
<p>注意一系列的宏定义：</p>
<ul>
<li><code>__glibc_unlikely(exp)</code> ：表示 exp 很可能为假</li>
<li><code>__glibc_likely(exp)</code> ：表示 exp 很可能为真</li>
<li><code>__builtin_expect(exp,value)</code> ：表示 exp&#x3D;&#x3D;value 大概率成立</li>
</ul>
<p>最后这一小节的意思就是如果没有可以分配的区域，那就调用 <code>sys_malloc</code> 系统调用去用 mmap 分配新的堆区。</p>
<h5 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h5><p>接下来函数就进入 fastbin 部分去查找可以利用的堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查堆块大小是否属于 fastbin</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      <span class="hljs-comment">// 根据 nb 也就是前面返回的 size 获取 fastbins 数组的下标</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">// 得到链表头指针</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp = *fb;<br>      <span class="hljs-comment">// 如果当前链表存在 chunk，则分配该链表的第一个 chunk</span><br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-comment">//如果 victim==NULL 也就是 fastbin 链表中没有 chunk，直接 break 跳出 fastbin 的查找</span><br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-comment">// 如果bin中有 chunk，检查所分配的 chunk 的 size 与所在链表的 size 是否匹配</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">//根据 chunk 得到用户数据指针 p,并返回</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>补充一下这部分用到的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br></code></pre></td></tr></table></figure>

<p>其中末尾有调用到 <code>check_remalloced_chunk</code> 函数，函数具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_remalloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br><br>  <span class="hljs-comment">//检查分配的块是否在内存堆 mmap 区域中</span><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      assert (av == arena_for_chunk (p));<br>      <span class="hljs-keyword">if</span> (chunk_non_main_arena (p))<br>        assert (av != &amp;main_arena);<br>      <span class="hljs-keyword">else</span><br>        assert (av == &amp;main_arena);<br>    &#125;<br>  <span class="hljs-comment">//检查 prev_inuse 那三个标志位</span><br>  do_check_inuse_chunk (av, p);<br><br>  <span class="hljs-comment">/* Legal size ... */</span><br>  <span class="hljs-comment">//检查分配块的大小是否大于最小的有效大小（MINSIZE） </span><br>  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>  <span class="hljs-comment">/* ... and alignment */</span><br>  assert (aligned_OK (chunk2mem (p)));<br>  <span class="hljs-comment">/* chunk is less than MINSIZE more than request */</span><br>  <span class="hljs-comment">//确保分配的块大小是否是满足申请的 size 条件的最小 size </span><br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s) &gt;= <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s + MINSIZE) &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>就是在检查分配的 chunk 的各个标志位双重保险确保分配的 chunk 是正确的。</p>
<h5 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h5><p>如果在 fastbin 中找不到就会进入到 smallbin </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>      <span class="hljs-comment">//查找对应大小的 bin 下标</span><br>      idx = smallbin_index (nb);<br>      <span class="hljs-comment">// 得到 small bin 的链表头地址</span><br>      bin = bin_at (av, idx);<br>      <span class="hljs-comment">//// 这里会获取 small bin 的最后一个 chunk，如果 victim = bin，说明 small bin 是空的</span><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-comment">// 获取 small bin 的倒数第二个 chunk，因为双向链表所以其实就是倒数第一个 chunk</span><br>              bck = victim-&gt;bk;<br>                <span class="hljs-comment">// 检查倒数第二个 chunk 的 fd 指针是否指向最后一个 chunk</span><br>				<span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>              <span class="hljs-comment">// 设置 victim 的下一个 chunk 的 inuse 位</span><br>              set_inuse_bit_at_offset (victim, nb);<br>              <span class="hljs-comment">// 将最后一个 chunk 从 smallbin 中取出，重新设置链中的指针</span><br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>              <span class="hljs-comment">//如果不是主线程则要设置 A 标志位</span><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              <span class="hljs-comment">//检查检查！</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-comment">//根据 chunk 得到用户数据指针 p,并返回</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>宏定义们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS             128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></td></tr></table></figure>

<p>在这一部分中，程序会首先用 <code>last (bin)) != bin</code> 检查符合目标大小的 smallbin 链是否为空。</p>
<p>但是考虑到一种情况是没初始化。当 small bin 没有初始化时，所有指针均为空，也就是紧接着检查的 <code>victim == 0</code> 。那就进行初始化操作调用 <code>malloc_consolidate()</code> 函数。</p>
<p>这个函数超级长，大概实现的功能是先判断堆是否被初始化。</p>
<p>如果已经被初始化了就把所有的 <code>fast bin</code>  取出来，先清除它们的标志位，然后扔到 unsorted bin 中尝试向前合并或者向后合并；如果没有初始化就调用 <code>malloc_init_state</code> 和 <code>check_malloc_state</code> 函数初始化堆。</p>
<blockquote>
<p>其实如果 victim &#x3D;&#x3D; 0 它一定是没有初始化的，所以合并 fastbin 那一部分很少执行到。可以理解为在这里这个函数就是用来初始化 arena 的。</p>
</blockquote>
<h5 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h5><p>如果不在 smallbin 里就会去查找 largebin 辣</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>短短三行，<del>极简</del></p>
<p>先获取 largebin 对应的 index，然后如果 fastbin 不为空，调用 <code>malloc_consolidate</code> 。</p>
<p>因为 largebin 都已经存在了肯定已经初始化，实<strong>际上这里的函数作用是就只是合并 <code>fast bin</code>，但并不再 largebin 中寻找堆块。</strong></p>
<p>之前不是提到说 <code>fast bin</code> 通常不会参与合并与分割嘛，但这就是个例外。举个例子：</p>
<p>我们想要申请一块 0x510 的堆块，同时内存区域中，有一块 0x20 的 <code>fast bin</code> 与一块 0x500 的 <code>large bin</code> 相邻。我们合并这两个堆块就能正好满足把一个 0x520 的 <code>large bin</code> 返回给用户。如果不合并的话就得重新切割 top_chunk 了，造成了空间浪费。</p>
<h5 id="unsortedbin-和-largebin"><a href="#unsortedbin-和-largebin" class="headerlink" title="unsortedbin 和 largebin"></a>unsortedbin 和 largebin</h5><p><del>unsortedbin 部分，也可能是 smallbin，也可能是 largebins</del></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 检查 unsortedbin 是否为空，不为空就继续</span><br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-comment">// 判断当前申请的 size 是否合法</span><br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          <span class="hljs-comment">// 合法则获取 size</span><br>          size = chunksize (victim);<br></code></pre></td></tr></table></figure>

<p>这里的 while 循环就是开始遍历 <code>unsorted chunk</code> 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">//如果申请的大小在 smallbin 的范围中，且 unsortedbin 链表中只有一个 chunk 并指向 last_remainder，且该 chunk 的 size 大小大于用户申请的 size 大小</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>      &#123;<br>        <span class="hljs-comment">/* split and reattach remainder */</span><br>        <span class="hljs-comment">//拆分 chunk，更新last_remainder 的大小和开始地址</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset (victim, nb);<br>        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>        <span class="hljs-comment">//切割出剩下的 chunk 作为新的 av-&gt;last_remainder</span><br>        av-&gt;last_remainder = remainder;<br>        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>        <span class="hljs-comment">// 如果 remainder_size 的大小不属于 smallbin，则需要设置 nextsize 为空，后面会把它丢到 unsortedbin 中</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>          &#123;<br>            remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>            remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br><span class="hljs-comment">//下面就是设置各种标志位了</span><br>        set_head (victim, nb | PREV_INUSE |<br>                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head (remainder, remainder_size | PREV_INUSE);<br>        set_foot (remainder, remainder_size);<br><br>        check_malloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>这段代码最开始的判断详细拆分一下就是：</p>
<ul>
<li><code>in_smallbin_range (nb)</code> ：申请的大小在 small bin 的范围中</li>
<li><code>bck == unsorted_chunks (av)</code> ：unsorted bin 中只有一个 chunk 。</li>
<li><code>victim == av-&gt;last_remainder</code>：这个 chunk 刚好是最近被分割过的剩余部分。</li>
<li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：找到的这个 chunk的 <code>size</code> 大于需要的最小块大小+ <code>MINSIZE</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-comment">//如果上一个条件满足就是 chunk 要被分配出去了所以要把这个 chunk 从 unsortedbin 中解除</span><br><span class="hljs-comment">//因为这个指令在 if 外所以不满足也会拿出最后一个 chunk</span><br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<p>前一个 if 条件不满足就到这里了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><span class="hljs-comment">//如果当前用户申请的size刚好与解链的chunk大小相同，则返回</span><br>      <span class="hljs-keyword">if</span> (size == nb)<br>        &#123;<br>          set_inuse_bit_at_offset (victim, size);<br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>            victim-&gt;size |= NON_MAIN_ARENA;<br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>如果取出的这个 chunk 的  <code>size</code> 刚好等于这个 <code>nb</code> ，那就说明这个块一定是最合适的，就直接返回。如果不合适进入下面的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断取出的这个 chunk 的 size 属不属于 smallbin</span><br><span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>        &#123;<br>          <span class="hljs-comment">//将该chunk插入small bin中</span><br>          victim_index = smallbin_index (size);<br>          bck = bin_at (av, victim_index);<br>          fwd = bck-&gt;fd;<br>        &#125;<br> <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">//不是的话插入 largebin</span><br>          victim_index = largebin_index (size);<br>          bck = bin_at (av, victim_index);<br>          fwd = bck-&gt;fd;<br></code></pre></td></tr></table></figure>

<p>属于 smallbin 就丢进 smallbin，如果不属于就丢进 largebin 了。</p>
<p>这部分代码最开始开始的判断大小然后丢进 largebin、smallbin 的部分，就是我们前面说分配规则的时候提到的把 unsortedbin 中的堆块分类的实现。</p>
<p>我们丢进large bin 之后要设置相应的指针。large bin 中一个 <code>chunk </code> 有四个指针，每对链表头 bin 都管理一个二维双向链表，<code>fd</code>、<code>bk</code> 指针与相同大小的 chunk 连接，<code>fd_nextsize</code> 和 <code>bk_nextsize</code> 与不同大小的 <code>chunk</code> 连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C">   <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>         <span class="hljs-comment">//这里的 bck 指的是表头 bin 所在的 chunk，fwd 指的是最大的 chunk。</span><br><span class="hljs-comment">//检测 largebin 是否非空</span><br>         <span class="hljs-keyword">if</span> (fwd != bck)<br>           &#123;<br>             <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>             <span class="hljs-comment">//去除 P标志位</span><br>             size |= PREV_INUSE;<br>             <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>             <span class="hljs-comment">//检查A标志位</span><br>             assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>             <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>               &#123;<br>                 fwd = bck;<br>                 bck = bck-&gt;bk;<br><br>                 victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>               &#125;<br>             <span class="hljs-keyword">else</span><br>               &#123;<br>                 assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                 <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                   &#123;<br>                     fwd = fwd-&gt;fd_nextsize;<br>                     assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                   &#125;<br><br>                 <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                   <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                   fwd = fwd-&gt;fd;<br>                 <span class="hljs-keyword">else</span><br>                   &#123;<br>                     victim-&gt;fd_nextsize = fwd;<br>                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                     fwd-&gt;bk_nextsize = victim;<br>                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                   &#125;<br>                 bck = fwd-&gt;bk;<br>               &#125;<br>           &#125;<br>         <span class="hljs-comment">//如果 largebin 为空，那么直接加入链表就行</span><br>         <span class="hljs-keyword">else</span><br>           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>我们向一个空的 largebin 中插入 chunk 的流程大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">fwd=bin-&gt;fd;<br>bck=bin-&gt;bk;<br>victim-&gt;bk_nextsize=bck;<br>victim-&gt;fd_nextsize=fwd;<br>fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;<br></code></pre></td></tr></table></figure>

<p>非空也一样，就是把 bin 的指针换成对应的前后 chunk 的指针。</p>
<p>中间没有注释的长长的一部分都是在查找合适的位置插入，然后修改指针。如果在当前的 largebin 中找到了 <code>size</code> 等于我们取出的 chunk 的堆块 <code>size</code> 的堆块，就只需要修改 <code>fd</code> 和 <code>bk </code>指针；其他情况还需要修改 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针。</p>
<p>前面找到了插入的位置，接下来就是插入操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">		  mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>上面对 unsortedbin 的遍历比较长，每一次便利的流程大概流程就是：</p>
<p>查找 unsortedbin 是否为空。不为空，且只有一个 chunk 且为 last_remainder 时，进行 last_remainder 切分后直接返回；如果有多个 chunk ，则需要将 chunk 从 unsortedbin 中解链，如果大小满足则返回，</p>
<p>如果chunk大小不满足，进行判断对应丢进 smallbin 或 largebin 。</p>
<p>注意，<strong>当取得 unsorted bin chunk 与我们申请的 chunk 大小相同时</strong>，程序进行了如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-comment">//将当前的chunk从unsortedbin 链表里解除</span><br>unsorted_chunks(av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks(av);<br></code></pre></td></tr></table></figure>

<p>据此我们可以发现另外一种利用方法，<strong>控制 av 的 bk 指针，那么就能向 bk 的 fd 指针写入 av 的值，发生 unsortedbin attack。</strong></p>
<p>我们之前不是遍历 unsortedbin 又整理了一下 largebin 和 smallbin 嘛，如果在 unsortebin 里面没找到合适的就会再去查找一遍请求 size 对应的 bin 中的 chunk 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//确认用户申请的 chunk 大小不属于 smallbin</span><br><span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>     &#123;<br>       bin = bin_at (av, idx);<br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-comment">//如果 largebin 不为空，用户请求的 size 小于 large bin 中最大的 chunk size</span><br>       <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>           (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>         &#123;<br>           <span class="hljs-comment">//while 循环获取刚好小于用户请求的 size 的 large bin</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                   (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>             victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">              list does not have to be rerouted.  */</span><br>           <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>             victim = victim-&gt;fd;<br><br>           <span class="hljs-comment">//拆分符合要求的 large chunk</span><br>           remainder_size = size - nb;<br>           <span class="hljs-comment">//将large chunk从 largebin 中解链</span><br>           unlink (av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-comment">//处理切分下来的剩余部分，如果切割下来的部分小于 MINSIZE 那就不切割了</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>             &#123;<br>               <span class="hljs-comment">//把它物理相邻的下一个快prev_inuse位设1</span><br>               set_inuse_bit_at_offset (victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                 victim-&gt;size |= NON_MAIN_ARENA;<br>             &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>             &#123;<br>               <span class="hljs-comment">//将切割的剩余部分插入 unsortedbin 中</span><br>               remainder = chunk_at_offset (victim, nb);<br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks (av);<br>               fwd = bck-&gt;fd;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                 &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>                 &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br>               <span class="hljs-comment">// remainder 不满足 small bin</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                 &#123;<br>                   <span class="hljs-comment">//清空它的fd_nextsize和bk_nextsize</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>               <span class="hljs-comment">// 设置分配的 chunk 堆头</span><br>               set_head (victim, nb | PREV_INUSE |<br>                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head (remainder, remainder_size | PREV_INUSE);<br>               set_foot (remainder, remainder_size);<br>             &#125;<br>           check_malloced_chunk (av, victim, nb);<br>           <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>           alloc_perturb (p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>在寻找时不是有说要找最小能满足的大小的块嘛，代码中 <code>nb</code> 是指用户需要的最小能满足的块的 <code>size</code> ，实际上并不是所有情况下都满足 <code>size=nb</code> 。例如：我们申请 0x1 大小的堆块，那就只能给它一个 0x20 的 chunk。或者 我们现在甚至没有 0x20 的块，但是有一个 0x30 的，那么这个 0x30 的 chunk 就是我们要寻找的堆块。</p>
<p>在处理切割下来的堆块时，它只检测了了 <code>unsorted bin-&gt;fd-&gt;bk</code> 是否等于那个 <code>unsorted bin</code> ，对于堆块来说就是只检测了 <code>bk</code> 指针。这是一个利用小技巧，也就是说这时<strong>我们可以修改 <code>fd</code> 指针为期望的值，不会在这里被检测到，就是 <code>unsorted bin attack</code> 了。</strong></p>
<p>被切割的剩下 chunk 会被放在 <code>unsortedbin</code> ，但是程序仍然会检测它是不是在 <code>small bin</code> 的范围里。如果不在 <code>small bin</code> 范围内，就会清空它的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 。因为它要回到 <code>unsorted bin</code> ，这两个字段就没什么用了，就会被清空。</p>
<p>如果当前的 large bin 中没有符合要求的 chunk，则在其它 size 的 large bin 中进行查找。首先需要看一下这个  <code>binmap</code> 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">++idx;<br>   bin = bin_at (av, idx);<br>   block = idx2block (idx);<br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>   bit = idx2bit (idx);<br></code></pre></td></tr></table></figure>

<p>这个结构用于快速检索一个 <code>bin</code> 是否为空，每一个 <code>bit</code> 表示对应的 <code>bin</code> 中是否存在空闲 chunk 。这一段就是说，如果 <code>large bin</code> 搜索完了都没有找到合适的 <code>chunk</code> ，那么就去下一个 <code>idx</code> 里面寻找。然后一共有4个 <code>int</code> ，每个 <code>int</code> 32位表示一块 <code>map</code> ，一共表示 <code>128</code> 位。</p>
<p>这段代码的执行流程就是：利用 idx 索引值来获取指向对应 bin 的指针。然后根据这个 bin 指针来获取 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>     &#123;<br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>         &#123;<br>           <span class="hljs-keyword">do</span><br>             &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                 <span class="hljs-keyword">goto</span> use_top;<br>             &#125;<br>           <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>           bit = <span class="hljs-number">1</span>;<br>         &#125;<br></code></pre></td></tr></table></figure>

<p>两个判断条件：</p>
<ul>
<li><code>bit&gt;map</code>：如果这个位的权值都比它整个的 <code>map</code> 都大了，说明 <code>map</code> 上那个 <code>bit</code> 的权值必定为0</li>
<li><code>bit==0</code>：如果这个 <code>bit</code> 都是 0 说明这个 <code>index</code> 也不对。</li>
</ul>
<p>两个条件只要满足其一就是没有空闲堆块，接着去查看下一个 index。</p>
<p>接下来的判断如果 <code>map==0</code> ，说明这整个 <code>block</code> 都没有空闲块，就直接跳过，不为 0 则退出去执行下面的操作，如果超过了 <code>block</code> 的总数，那就说明 <code>unsorted bin</code> 和 <code>large bin</code> 中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个 <code>goto use_top;</code> 跳转，在后面会分析到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>      <span class="hljs-comment">// 在 block 中找到存在符合要求的 large bin 链表头指针</span><br>      <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>          bin = next_bin (bin);<br>          bit &lt;&lt;= <span class="hljs-number">1</span>;<br>          assert (bit != <span class="hljs-number">0</span>);<br>        &#125;<br><br>      <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>      victim = last (bin);<br><br>      <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br><span class="hljs-comment">// 如果链表非空</span><br>      <span class="hljs-keyword">if</span> (victim == bin)<br>        &#123;<br>          av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>          bin = next_bin (bin);<br>          bit &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>经过上面的流程，我们已经找到了合适的 block ，接下来就是寻找 block 的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到 bk 为 <code>large bin</code> 的最小块，所以先从它开始，也就是先执行 <code>bin = next_bin (bin);</code> 。</p>
<p>当然不能说 <code>map</code> 里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有就要及时把标志位清除然后 <code>bit&lt;&lt;1</code> 去寻找下一个 <code>index</code> 。</p>
<p>找到合适的 <code>large bin</code> 的索引，我们就可以从中找合适的堆块，流程和上面一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">// 找到第一个大于申请 size 的 chunk 进行堆块划分</span><br>       <span class="hljs-keyword">else</span><br>         &#123;<br>           size = chunksize (victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink (av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>             &#123;<br>               set_inuse_bit_at_offset (victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                 victim-&gt;size |= NON_MAIN_ARENA;<br>             &#125;<br><br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>             &#123;<br>               remainder = chunk_at_offset (victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks (av);<br>               fwd = bck-&gt;fd;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                 &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>                 &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                 av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                 &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>               set_head (victim, nb | PREV_INUSE |<br>                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head (remainder, remainder_size | PREV_INUSE);<br>               set_foot (remainder, remainder_size);<br>             &#125;<br>           check_malloced_chunk (av, victim, nb);<br>           <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>           alloc_perturb (p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<h5 id="Topchunk"><a href="#Topchunk" class="headerlink" title="Topchunk"></a>Topchunk</h5><p>如果在 large bin 中没有找到响应的 chunk，则需要在 top chunk 中查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br><br>	  <span class="hljs-comment">//从 av-&gt;top 拿到 top_chunk 的地址</span><br>      victim = av-&gt;top;<br>	  <span class="hljs-comment">//判断大小</span><br>      size = chunksize (victim);<br>	  <span class="hljs-comment">//如果大小符合切割要求，就按照之前的流程切割并把 chunk 返回用户</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>        &#123;<br>          remainder_size = size - nb;<br>          remainder = chunk_at_offset (victim, nb);<br>          av-&gt;top = remainder;<br>          set_head (victim, nb | PREV_INUSE |<br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head (remainder, remainder_size | PREV_INUSE);<br><br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br><br>      <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>	  <span class="hljs-comment">//如果大小不满足需要，就先合并所有的 fastbin，接着执行之前的循环</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        &#123;<br>          malloc_consolidate (av);<br>          <span class="hljs-comment">/* restore original bin index */</span><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          <span class="hljs-keyword">else</span><br>            idx = largebin_index (nb);<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>	  <span class="hljs-comment">//调用 sysmalloc 去分配新一页内存</span><br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>          <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意程序会反复查找当前内存区域是否有合适的内存，如果实在没有才会去调用 <code>sysmalloc</code>。一次还是分配<code>0x21000</code> 的 chunk 作为新的 <code>top_chunk</code> ，原来的 <code>top_chunk</code> 将会被 <code>free</code> 。</p>
<p>如果我们没有改过 <code>top_chunk</code> 的 <code>size </code>，那么新的和旧的 <code>top_chunk </code>将会是物理相邻，如果 <code>free</code> 的<code>top_chunk </code>不在 <code>fast bin</code> 范围内，那就会和新的 <code>top_chunk</code> 发生合并。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>malloc()</code>  函数被调用时主要流程如下：</p>
<ol>
<li>检查是否设置了 <code>malloc_hook</code> ，若设置了则跳转进入 <code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc()</code> 。</li>
<li>如果当前的分配区为空，则调用 <code>sysmalloc</code> 分配空间，返回指向新 <code>chunk</code> 的指针，否则进入下一步。</li>
<li>若用户申请的大小在 <code>fast bin</code> 的范围内，则考虑寻找对应 <code>size</code> 的 fastbin chunk ，如果这个对应 <code>size</code> 的 fastbin 中有满足的堆块就返回给用户，如果没有就进入下一步。</li>
<li>如果用户申请的 <code>size</code> 符合 <code>small bin</code> 的范围，则在相应大小的链表中寻找 <code>chunk</code> 。若 <code>small bin</code> 未初始化，则调用 <code>malloc_consolidate</code> 初始化分配器，然后继续下面的步骤；如果已经初始化了，就寻找对应的 <code>small bin</code> 的链表，如果该 <code>size</code>  的 <code>small bin</code> 又满足的堆块就取出返回，否则继续下面的步骤。如果申请的不在 <code>small bin</code> 的范围，那么调用 <code>malloc_consolidate</code> 函数去合并所有 fastbin 并进入下一步。</li>
<li>如果在上面的流程中都没有找到对应的块，会遍历 fast bins 中的 chunk，将相邻的 chunk 进行合并， 并链接到 unsorted bin 中。</li>
<li>如果用户申请的大小符合 <code>large bin</code> 或 <code>small bin</code> 链表为空，完成了上一步之后，就会开始遍历处理 <code>unsorted bin</code> 链表中的 chunk 。如果 <code>unsorted bin</code> 只 有一个 chunk，这个 chunk 在上次分配时被使用过，且所需分配的 chunk 大 小属于 <code>small bin</code>，同时这个 chunk 的 <code>size</code> 大于等于需要分配的大小。这种情况下就直接将该 chunk 进行切割；否则将根据 chunk 的空间大小将其放入 small  bins 或是 large bins 中，遍历完成后，转入下一步。</li>
<li>上面的步骤执行结束还没有找到堆块，就说明需要分配的是一块大的内存，或者 <code>small bin</code> 和 <code>unsorted bin</code> 中都找不到合适的 chunk，并且 <code>fast bin</code> 和 <code>unsorted bin</code> 中所有的 chunk 都清除干净了。程序就来时从 <code>large bins</code> 中按照 “smallest-first，best-fit” 的原则，找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链接回到 bins 中。若操作成功，则分配结束，否则转到下一步。</li>
<li>根据 <code>binmap</code> 找到表示更大 <code>size</code> 的 <code>large bin</code> 链表，若其中存在空闲的 chunk ，则将 chunk 拆分之后返回符合要求的部分，并更新 <code>last_remainder</code>。如果没有合适的堆块就进入下一步去 <code>top chunk</code> 中寻找。</li>
<li>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code> 。否则将再一次检查 <code>fast bin</code>，如果 <code>fast bin</code> 不为空，就调用 <code>malloc_consolidate()</code> 合并堆块后再次从第 4 步开始重新查找。</li>
<li>如果前面的步骤中都没有找到合适的 chunk ，才会调用 <code>sysmalloc()</code> 重新分配空间并处理原本的 <code>top chunk</code> 。</li>
</ol>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h4><p><del>一开始还以为 free 没有 malloc这么长了呢</del></p>
<p><code>free </code>函数也是由 <code>__libc_free</code> 函数完成 chunk 的释放的操作的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br>  <span class="hljs-comment">// 判断是否设置了 free_hook</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      <span class="hljs-comment">// 如果设置了就调用 free_hook</span><br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-comment">//free(NULL) 无任何意义，直接返回</span><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br>    <br>  <span class="hljs-comment">// 将用户提供的 mem 指针转换为堆块头指针</span><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-comment">// 判断 chunk 是否由 mmap 分配</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-comment">// 如果是 mmap 分配的，则首先更新 mmap 分配和收缩阈值</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      <span class="hljs-comment">// 释放空间</span><br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 如果不是 mmap 创建，则调用 _int_free 函数</span><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>跟 <code>malloc</code> 一样，函数会先读取 <code>__free_hook</code> 看看是否为空，如果不为空则直接由 <code>free_hook</code> 指向的函数代为执行 <code>free</code> ，这里也是我们经常劫持的钩子函数。</p>
<p> <code>free_hook</code> 劫持起来比 <code>malloc_hook</code> 困难，但是一旦劫持成功也会很方便。 <code>malloc_hook</code> 函数我们只能写 <code>one_gadget</code> ，而一旦条件苛刻那么就还得调栈啊之类的一些操作。如果劫持到了 <code>free_hook</code> 我们就可以直接写 <code>system()</code> 函数，然后 <code>free</code> 一个内容为 <code>&#39;/bin/sh&#39;</code> 的堆块就能 <code>get shell</code>。</p>
<h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>首先是各种各样的参数定义和错误检查。我把注释删掉了，注释的意思大概就是要检查用户是不是设置了恶意参数。</p>
<ul>
<li><code>__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</code>：指针和size进行比较，<del>不理解但尊重</del>。也就是大概 <code>p&gt;0xfff....</code> ，主要是应该要检测被 <code>free</code> 的 <code>chunk</code> 的 <code>size</code> 不要过大。<code>size</code> 取负之后会变得很大，比如 <code>0xfff...</code> 这样的大数值通常指针不会指向这样的地址，<code>f</code> 开头的一般都是内核地址。</li>
<li><code>__builtin_expect (misaligned_chunk (p), 0)</code>：计算 chunk 的指针与上掩码（ <code>0x10-1</code>也就是 <code>0xf</code> ），取出后四位观察是否为 0 。如果不为 0 则说明指针错误了，就会报错。这里主要是检查对齐，指针需要指到 <code>0x10</code> 的整倍数才能被正常 <code>free</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><br>check_inuse_chunk(av, p);<br></code></pre></td></tr></table></figure>

<p>接下来又是在检查：</p>
<ul>
<li><code>size &lt; MINSIZE</code>：如果 <code>size</code> 还比 <code>MINSIZE</code> 要小，那肯定 <code>size</code> 错了。</li>
<li><code>!aligned_OK (size)</code>：<code>chunk size</code> 也要对齐，但是这个 <code>check</code> 一般不会被触发，因为再取出 <code>chunk size</code> 的时候就会把最低位与掉。</li>
</ul>
<p> 然后就是和 <code>malloc</code> 里相同的 check 来检查 <code>inuse</code> 位。</p>
<h5 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h5><p>接下来就是判断这个被 free 的 chunk 是不是在 fastbin 范围内了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断这个 chunk 的大小是不是属于 fastbin ，且其后一个 chunk 不是 topchunk</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">	bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-comment">//判断 size 是否小于 MINSIZE 或者是 size&gt;=system_mem</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>	|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>			     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br>	<span class="hljs-keyword">if</span> (have_lock<br>	    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>		  mutex_lock(&amp;av-&gt;mutex);<br>		  locked = <span class="hljs-number">1</span>;<br>		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>	      &#125;))<br>	  &#123;<br>	    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>	    <span class="hljs-keyword">goto</span> errout;<br>	  &#125;<br>	<span class="hljs-keyword">if</span> (! have_lock)<br>	  &#123;<br>	    (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>	    locked = <span class="hljs-number">0</span>;<br>	  &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码检查 <code>size</code> 大小，如果大小有问题就用分配器的 lock 再次做一个判断，如果判断条件还是成立的话那就说明 <code>size</code> 真的被改成了非法数值，那就报错退出。如果进来了但是没有执行报错，说明可能多线程有点问题，就释放这个 <code>arena</code> 的锁。</p>
<p>检查完毕就开始释放这个 chunk：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//清理 fastbin 中的数据</span><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>   <br><span class="hljs-comment">//初始化 fastbin</span><br>   set_fastchunks(av);<br><span class="hljs-comment">// 获取 size 对应的 fastbin 下标</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>   fb = &amp;fastbin (av, idx);<br>   <br>   <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>   mchunkptr old = *fb, old2;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>   <span class="hljs-keyword">do</span><br>     &#123;<br>   <br>   <span class="hljs-comment">// 判断当前 fastbin 头 chunk 与要被释放的 chunk 是否相同（防止 double free）</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>     &#123;<br>       errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>       <span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>       <br>   <span class="hljs-comment">// 将要被释放的 chunk 放入 fastbin 头部，修改其 fd 指针指向 old</span><br>   <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>     old_idx = fastbin_index(chunksize(old));<br>   p-&gt;fd = old2 = old;<br>     &#125;<br>   <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>   <br>   <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>     &#123;<br>   errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>   <span class="hljs-keyword">goto</span> errout;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>它首先调用了 一个 <code>free_perturb()</code> 函数，函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">free_perturb</span> <span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (perturb_byte))<br>    <span class="hljs-built_in">memset</span> (p, perturb_byte, n);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实跟前面 <code>malloc</code> 那个函数差不多，就是看你有没有设置那个值，如果设置了就在 <code>free</code> 之前把堆块进行 <code>memset</code> 清空，但是不一样的是，<code>perturb</code> 中 <code>memset</code> 第二个参数是要根据你设置的值再异或一个 <code>0xff</code> 的。</p>
<p>其中有一个检查时针对 double free 的，那么如果真的 double free 了是什么样的呢？</p>
<p>我们 <code>free(A)</code> ，第一次 <code>free</code>  A，对应的 bin 为空，这个 chunk 链入其中，现在 <code>fast bin</code> 中多了一个 A 。接下来我们第二次 <code>free(A)</code> ，A 会再次被加入 <code>fast bin</code> 中，然后会导致产生一个自己指向自己的指针。这时 <code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我们再申请一个和 A 一样大的 <code>chunk</code> ，A 被申请走，但是<code>fast bin</code> 链中还剩下一个 A，但是此时我们手里有一个 A ，<code>fast bin</code> 中也有一个 A 。</p>
<p>这样我们就可以直接编辑 A 的指针域了。比如我让它指向了 got 表中的 <code>free()</code> 函数。那么此时 <code>fast bin</code> 中的情况就是 <code>A-&gt;free@got</code> 。然后我再次申请和 A 一样大小的 <code>chunk</code> ，A 被取出来， <code>fast bin</code> 中剩下<code>free@got</code> 。那么我第三次申请就得到了在 <code>free@got</code> 那边的 <code>chunk</code> ，然后假如我偷偷修改一下 <code>free@got</code> 为 <code>system()</code> ，那就能 get shell 了。同时我们可以看到，<code>free@got</code> 这个指针是能任意编辑的，也就是说我想申请到哪都不是问题，这样就能任意地址写了。</p>
<p>我们也有方法来绕过 double free 检查。因为对于 double free 的检查只有这里一处，我们就可以先 <code>free(A)</code> 再 <code>free(B)</code>，再 <code>free(A)</code> ，这样就造成 double free 啦！</p>
<p>如果过了检测，就将这个 chunk 链在 <code>fast bin</code> 的顶部，就是一个普通的单链表的插入。因为后进先出，所以只在 <code>fast bin</code> 的一端插入删除。</p>
<h5 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h5><p>它一共就三个大的 <code>if-else</code> 分支条件，是不是属于 <code>large bin</code> 、是不是属于 <code>mmap</code> 分配，和其他情况，也就是 <code>unsorted bin</code> 。</p>
<p>如果chunk是 <code>mmap</code> 分配的话那就调用 <code>munmap_chunk()</code> 函数去 <code>free</code> 这个 chunk。这部分代码就在 <code>_int_free</code> 函数的最后，我们不去讨论这部分具体的代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们就来分析 <code>unsorted bin</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>   <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>     <span class="hljs-comment">//用一个分配器的时候先加锁，用完了释放</span><br>     (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>     locked = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// 获取 next_chunk</span><br>   nextchunk = chunk_at_offset(p, size);<br><br>   <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">      top block.  */</span><br>   <span class="hljs-comment">// 检查当前 chunk 是否是 top chunk 头（防止 double free）</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>   <span class="hljs-comment">// 判断 next chunk 是否超过分配区</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>		  &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>		  &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>   <span class="hljs-comment">// 检查 next chunk 的 inuse 位，判断被释放的 chunk 是否在使用 </span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   <span class="hljs-comment">// 判断 next chunk 的 size 是否合法</span><br>   nextsize = chunksize(nextchunk);<br>   <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   <span class="hljs-comment">// 清除要被释放的 chunk 的内容</span><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br></code></pre></td></tr></table></figure>

<p>上面的部分就是对堆块的各种检查，保证 free 这个堆块不会发生错误。其中 <code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>的检查，也就是如果下一个 chunk 的 <code>size</code> 小于 <code>MINSIZE</code> 也会报错， 因为会涉及到 chunk 的向前合并或者向后合并，因此需要对前后堆块都进行检查。</p>
<p>下面就是向前和向后合并堆块大小的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/* consolidate backward */</span><br>   <span class="hljs-comment">// 如果前一个 prev chunk 也处于释放状态，则用 unlink 合并两个 chunk</span><br>   <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>     prevsize = p-&gt;prev_size;<br>     size += prevsize;<br>     p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>     unlink(av, p, bck, fwd);<br>   &#125;<br><br>   <span class="hljs-comment">// 如果 next chunk 不是 top chunk</span><br>   <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>     <span class="hljs-comment">/* get and clear inuse bit */</span><br>     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>     <span class="hljs-comment">/* consolidate forward */</span><br>     <span class="hljs-comment">// 如果 next chunk 也处于释放中，则继续向下合并 next chunk</span><br>     <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink(av, nextchunk, bck, fwd);<br>size += nextsize;<br>     &#125; <span class="hljs-keyword">else</span><br>   <span class="hljs-comment">// 清除 inuse 位</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>     <span class="hljs-comment">// 获取当前 unsortedbin 的末尾 chunk 和链表头 chunk</span><br>     bck = unsorted_chunks(av);<br>     fwd = bck-&gt;fd;<br>     <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>&#123;<br>  errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>  <span class="hljs-keyword">goto</span> errout;<br>&#125;<br>     <span class="hljs-comment">// 将当前 chunk 插入 unsortedbin 中</span><br>     p-&gt;fd = fwd;<br>     p-&gt;bk = bck;<br>     <span class="hljs-comment">// 如果 size 不属于 small bin，需要设置 large bin</span><br>     <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>&#123;<br>  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>&#125;<br>     <span class="hljs-comment">// 更新链表头尾指针</span><br>     bck-&gt;fd = p;<br>     fwd-&gt;bk = p;<br><br>     <span class="hljs-comment">// 设置 chunk 的头部和尾部 prev_size</span><br>     set_head(p, size | PREV_INUSE);<br>     set_foot(p, size);<br><br>     check_free_chunk(av, p);<br>   &#125;<br><br>   <span class="hljs-comment">// 如果当前 chunk 临近 top chunk，则直接合并到 top chunk</span><br>   <span class="hljs-keyword">else</span> &#123;<br>     size += nextsize;<br>     set_head(p, size | PREV_INUSE);<br>     av-&gt;top = p;<br>     check_chunk(av, p);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>下面就是一个比较特殊的情况，就是我们如果一下子回收一个 <code>0x10000B</code> 这么大的空间，会回收给系统，这样可以减少资源占用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// 如果前面释放的 chunk 大小较大，将 fast bin 合并到 unsortedbin 中</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>	malloc_consolidate(av);<br><br>      <span class="hljs-comment">// 如果进程的分配区是主分配区，调用 systrim 收缩内存，否则获取非主分配区的 heap_info，用 heap_trim 收缩 heap</span><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br>	<span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>	    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>	  systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">	   large, because the corresponding heap might go away.  */</span><br>	heap_info *heap = heap_for_ptr(top(av));<br><br>	assert(heap-&gt;ar_ptr == av);<br>	heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>先调用 <code>malloc_consolidate</code> 合并所有 <code>fast bin</code> 。如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用 <code>systrim</code> 收缩内存，否则就获得非主分配区的 <code>heap_info</code> 指针，调用 <code>heap_trim</code> 收缩 <code>heap</code> 。</p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>free</code>不像 <code>malloc</code> 那么复杂，大致上就是属于 <code>fast bin</code> 的直接加入对应链表，不属于 <code>fast bin</code> 的向前合并或者向后合并然后加入 <code>unsorted bin </code> 。如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p>
<hr>
<p>这里有对 ptmalloc2 的相关代码的分析：<a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">Glibc内存管理 (seebug.org)</a></p>
<p>这个前半部分的理论讲的比较细，源码分析部分就比较粗略了</p>
<p>碎碎念：</p>
<p>计算机发明者和计算机各种语言各种库的发明者好牛，他们的脑子和我的好像是不太一样的🥹</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/pwn/" class="category-chain-item">pwn</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Knowledge/">#Knowledge</a>
      
        <a href="/tags/libc/">#libc</a>
      
        <a href="/tags/heap/">#heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>malloc和free源码分析</div>
      <div>https://shmodifier.github.io/2023/12/17/malloc和free源码分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Modifier</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/08/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" title="CSAPP 第十章 系统级IO">
                        <span class="hidden-mobile">CSAPP 第十章 系统级IO</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    
    <div class="footer-content">
       <p> Copyright &copy; 2022&nbsp;-&nbsp;2023 <a href="/">Modifier</a> </p> <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></p> <!--  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> -->

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
