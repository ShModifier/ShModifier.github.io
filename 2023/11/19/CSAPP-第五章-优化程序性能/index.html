

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Modifier">
  <meta name="keywords" content="">
  
    <meta name="description" content="程序猿也适用的优化性能小技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP 第五章 优化程序性能">
<meta property="og:url" content="https://shmodifier.github.io/2023/11/19/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/index.html">
<meta property="og:site_name" content="Modifier">
<meta property="og:description" content="程序猿也适用的优化性能小技巧">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shmodifier.github.io/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
<meta property="article:published_time" content="2023-11-19T05:46:47.000Z">
<meta property="article:modified_time" content="2023-11-19T11:20:13.407Z">
<meta property="article:author" content="Modifier">
<meta property="article:tag" content="Knowledge">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://shmodifier.github.io/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg">
  
  
  
  <title>CSAPP 第五章 优化程序性能 - Modifier</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shmodifier.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":false,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Have a nice day!</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/%E9%A1%B5%E9%A6%96%E5%9B%BE.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSAPP 第五章 优化程序性能"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-19 13:46" pubdate>
          2023年11月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          89 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CSAPP 第五章 优化程序性能</h1>
            
            
              <div class="markdown-body">
                
                <p>程序猿也适用的优化性能小技巧</p>
<span id="more"></span>

<h1 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h1><p>大多数的编译器都向用户提供了一些对他们所使用的优化的控制，最简单的控制就是<strong>优化级别</strong>。</p>
<p>例如命令行选项 <code>&quot;-Og&quot;</code> 调用 GCC 会让它使用一组基本的优化，以选项 <code>&quot;-01&quot;</code> 或更高调用 GCC 会让它使用更大量的优化。这样做可以提高程序的性能，但是也可能会增加程序的规模。</p>
<p>除此之外我们需要注意<strong>优化的安全性</strong>，也就是说优化前后成功内需不能有任何编译者目的之外的功能。</p>
<p>我们来看下面的两个过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">twiddle1</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp,<span class="hljs-type">long</span> *yp)</span><br>&#123;<br>    *xp += *yp;<br>    *xp += *yp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">twiddle2</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp,<span class="hljs-type">long</span> *yp)</span><br>&#123;<br>    *xp += <span class="hljs-number">2</span>* *yp;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面两个函数的功能都是将存储在指针 yp 位置的值两次加到 xp 知识的位置的值。但是函数 <code>twiddle2()</code> 的效率更高，它只要求有三次引用 （读 *xp，读 *yp，写 *xp），而 <code>twiddle1()</code> 需要有六次引用（两次读 *xp，两次读 *yp，两次写 *xp）。</p>
<p>那我们自然就会认为这两个函数的功能相同且 <code>twiddle2()</code> 更高效，默认编译器会按照 <code>twiddle2()</code> 的方式来编译  <code>twiddle1()</code> ，但实际上并非如此。</p>
<p>我们必须要考虑到 <code>*xp =*yp</code> ，即两个指针指向同一处的情况来讲，此时两个函数会分别进行下面的计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//twiddle1，结果是*xp的值增加4倍</span><br>	*xp += *xp<br>	*xp += *xp<br><span class="hljs-comment">//twiddle2结果是*xp的值增加3倍</span><br>    *xp += <span class="hljs-number">2</span>* *xp<br></code></pre></td></tr></table></figure>

<blockquote>
<p>两个指针可能指向同一个内存位置的情况成为内存别名使用</p>
</blockquote>
<p>可以看出运算结果是不相同的，而编译器也不知道这个函数如何被调用，所以必须要考虑到两个指针指向同一处内存地址的情况，这就是一个限制优化的因素。</p>
<p>再看另一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> f()+f()+f()+f();<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>*f();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和上面的第一个例子一样，我们第一眼会觉得这两个函数计算的是相同的结果，并且 <code>func2()</code> 比 <code>func1()</code> 更高效，自然会认为编译器会将 <code>func1()</code> 按照 <code>func2()</code> 的风格编译。</p>
<p>但我们要考虑下面的 f 函数代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> counter=<span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> counter++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们排除它会改变全局程序状态这一行为，特别地，如果全局变量 counter 设置为 0，那么 <code>func1()</code> 会返回0+1+2+3&#x3D;6，而 <code>func2()</code> 返回 4*0&#x3D;0。</p>
<p>自上可以看出，函数调用也是妨碍优化的因素之一。</p>
<h1 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h1><p>我们首先需要引入度量标准——<strong>每元素的周期数 (Cycles Per Element，CPE)</strong> ，作为一种表示程序性能并指导我们改进代码的方法。</p>
<p>我们知道处理器活动的顺序是由时钟控制的，度量标准指的就是每个指令执行需要多少个时钟周期。</p>
<p>例如下面的函数 <code>psum1()</code> 和 <code>psum2()</code> 都是计算长度为 n 的向量 <code>a = ⟨ a0, a1, a2, ···, an-1 ⟩</code>的前置和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Compute prefix sum of vector a */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">psum1</span><span class="hljs-params">(<span class="hljs-type">float</span> a[], <span class="hljs-type">float</span> p[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i; <br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>]; <br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;n; i++)<br>        p[i] = p[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">psum2</span><span class="hljs-params">(<span class="hljs-type">float</span> a[], <span class="hljs-type">float</span> p[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i; <br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>]; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n<span class="hljs-number">-1</span>; i+=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">float</span> mid_val = p[i<span class="hljs-number">-1</span>] + a[i]; <br>        p[i]= mid_val; <br>        p[i+<span class="hljs-number">1</span>] =mid_val + a[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/* For even n, finish remaining element */</span><br>    <span class="hljs-keyword">if</span> (i&lt;n)<br>        p[i] = p[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数 <code>psum1()</code> 每次迭代计算结果数列的一个元素。函数 <code>psum2()</code> 使用<strong>循环展开</strong>的技术，每次迭代计算两个元素。它们的运行时间可以用一个常数加上一个被处理元素个数成正比的因子描述。下图对两个函数把 n 和周期数进行最小二乘拟合：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%89%8D%E7%BD%AE%E5%92%8C.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>最小二乘拟合：</p>
<p>对于数据点的集合，我们利用最小二乘拟合，我们尝试画一条形如 y&#x3D;mx+b 的线，使下面的这个误差度最小<br>$$<br>\sum_{n&#x3D;1}^n (m_ix+b-y_i)^2<br>$$<br>将 E(m,b) 分别对 m 和 b 求导，把两个导数函数设置为0，进行推导就能得出计算 m 和 b 的算法。</p>
</blockquote>
<p>我们发现，循环展开的方式可以加快程序效率，减少访存的次数，而访存往往是计算机执行指令时最耗时间的一个指令。</p>
<p>在 <code>psum1()</code> 中，每次循环要进行读 <code>p[i-1]</code> ，读 <code>a[i]</code>，写 <code>p[i]</code> 三次访存。而在 <code>psum2()</code> 中，我们每次循环有读 <code>p[i-1]</code> ，读 <code>a[i]</code>，读 <code>a[i+1]</code>，写 <code>p[i]</code> ，写 <code>p[i+1]</code>五次访存，但是 <code>psum2()</code> 一次循环的操作数是 <code>psum1()</code> 的两倍，且减少了循环的次数。</p>
<p>又由于 <code>psum1()</code> 循环次数多，需要更多的条件跳转语句，这样它被 <code>n</code> 影响的就更多了，相比于此， <code>psum2()</code> 就优化了许多。</p>
<h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><p>我们声明一个向量的数据结构：头部和数据数组</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<p>我们在四个数据类型下面做测试：<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>。分别对他们进行求和和求积的操作来测试程序的 CPE。</p>
<p>最后我们得到了这样的结果：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%9C.png" srcset="/img/loading.gif" lazyload></p>
<p>我们可以发现，未经优化的代码效率较低；使用命令行选项 “-O1”，就会进行一些基本的优化。程序员不需要做什么，就会显著地提高程序性。</p>
<h1 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h1><p>一个很常见的例子，我们想要逐个处理字符串 s 的数据，我们经常会用到 <code>for (int i=0;i&lt;strlen(s);i++)</code> 这样的语句，看上去没有任何的问题，但是我们每次循环中都要去计算一次 <code>strlen(s)</code> 的值。而在运行过程中我们的s是不会变的，<code>strlen(s)</code> 也是一个常数。在循环次数很大的程序中就会由于这个无用的调用增加程序的运行时间。</p>
<p>优化方法也很简单，就是把 <code>strlen(s)</code> 这条命令移出循环，就会为每次循环过程减少一次计算流程，变成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br></code></pre></td></tr></table></figure>

<p>这样的优化称为<strong>代码移动</strong>，不会对程序造成明显的 CPE 下降的影响，但是会有一定程度上的效率的提升。</p>
<p>我们利用这个方法把书中5.3节的combine1函数进行优化，接下来的示例也会用这个函数进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">conbine2</span><span class="hljs-params">(vec_ptr v,<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length=vec_length(v);<br>    *dest=IDENT;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v,i,&amp;val);<br>        *dest=*dest OP val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（类的功能实现代码就不抄了我太懒了）</p>
<p>我们需要注意<strong>代码移动是不能由编译器来完成的</strong>，因为编译器会想到最差的情况比如字符发生改变或者从非零变成了零，这个问题以编译器的能力是无法处理的，必须由程序员来进行对应的优化。</p>
<p>由于我们测试时使用的是小数据集，而实际应用中的数据数量是我们所不能估计的，此时就会产生明显的差别。这也反映了编程时的常见问题——一个看上去无足轻重的代码片断有隐藏的渐近低效率（asymptotic inefficiency）。</p>
<h1 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h1><p>像我们看到过的那样，过程调用会带来开销，而且妨碍大多数形式的程序优化。</p>
<p>在 <code>combine()</code> 函数中，每一次循环迭代都会调用一次 <code>get_vec_element()</code> 来获取下一个向量元素。对每个向量引用，这个函数要把向量索引 <code>i</code> 与循环边界做比较，很明显会造成低效率。在处理其它任意的数组访问时，边界检查是个很有用的特性，但是对 <code>combine()</code>  函数代码，所有的引用都是合法的。</p>
<p>所以我们就可以去掉边界判断来直接访问元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">data_t</span> *<span class="hljs-title function_">get_vec_start</span><span class="hljs-params">(vec_ptr v)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> v-&gt;data;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine3</span><span class="hljs-params">(vec_ptr v，<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>	<span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>	*dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>;i &lt; length; i++) <br>    &#123;<br>        *dest = *dest OP data[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试后令我们意外的是效率并没有明显的提升。但是我们先保留这个优化，将它视作一个优化方式的其中一步，有许多步骤组合将使程序的性能有明显的提升。</p>
<h1 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h1><p>在 <code>combine3()</code> 中，我们每次循环都会调用指针来访问内存。例如 <code>*dest = *dest OP data[i];</code>，这部分的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L17<br>	vmovsd (%rbx), %xmm0<br>	vmulsd (%rbx), %xmm0,%xmm0<br>	vmovsd %xmm0, (%rbx)<br>	addq $8,%rdx<br>	cmp %rax, %rdx<br>	jne .L17<br></code></pre></td></tr></table></figure>

<p>我们可以看到，指针 dest 被存储在 rdx 中，我们每次都要先从内存读出再写入内存。但实际上这个数据是不变的，每次迭代开始的 dest 指向的数值就是最后写入的值。</p>
<p>我们就可以优化这部分内容，消除不必要的内存读写。我们构造一个临时变量来存储累计计算出来的值，循环开始时读取内存，循环结束时再执行内存的写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">combine4</span><span class="hljs-params">(vec_ptr v，<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>	<span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>	<span class="hljs-type">data_t</span> acc = IDENT;<br>    <span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>;i &lt; length; i++) <br>    &#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest=acc;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%B6%88%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8.png" srcset="/img/loading.gif" lazyload></p>
<p>测试结果乐意看出这个优化让我们的效率有了很大的提升。同过程调用一样，这个优化部分也需要程序员来进行。</p>
<p>当我们用命令行选项 “-O2” 来编译 <code>combine3()</code> ，我们发现性能远远优于使用 “-O1” 。此时得到的性能与我们刚才优化后的 <code>combine4()</code> 相当，但是整数的计算仍低于  <code>combine4()</code> 。我们对比一下O1、O2的汇编代码来探索一下原因：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-O2%E6%B1%87%E7%BC%96.png" srcset="/img/loading.gif" lazyload></p>
<p>我们发现O2的优化中将 <code>vmovsd (%rbx), %xmm0</code> 这句内存读取的指令优化掉了，也就相当于设定了一个临时变量。编译器为了防止和源程序有差异，还是会每次循环更新 dest 的值的，所以说这里的优化接近 <code>combine4()</code>，但是和 <code>combine4()</code> 有差距。</p>
<h1 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h1><p>除了编译上的优化，我们还需要考虑利用处理器微体系结构的优化，也就是处理器用来执行指令的底层系统设计。</p>
<p>在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。多条指令并行地执行，同时又呈现出一种简单的顺序执行指令的表象。</p>
<p>以下两种因素限制程序的最大性能：</p>
<ul>
<li>延迟界限：当一系列操作必须按照严格顺序执行时，某一条指令开始前，上一条指令必须结束。代码中的数据相关性会限制指令级并行，程序受限于延时界限。</li>
<li>吞吐量界限：处理器功能单元的原始计算能力，是程序性能的终极限制。</li>
</ul>
<h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>我们假象的处理器并不严格地基于近期的 Inter 处理器的结构。这些处理器被称作超标量初期里，可以在每个时钟周期执行多个操作，并且是乱序的，也就是指令的顺序不一定要与它们的机器及程序中的顺序一致</p>
<p>处理器的设计有两个部分：</p>
<ul>
<li>指令控制单元 (ICU, instruction controll unit) ：负责从内存中读取指令序列，生成一组基本操作，发送给 EU。</li>
<li>执行单元 (EU, execution unit) ：每个时钟周期接收多个操作，执行操作。</li>
</ul>
<p>下图是现代处理器的一个非常简化的示意图：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>ICU 从指令高速缓存中读取指令</strong>，指令高速缓存是个特殊的高速存储器，它包含着最近访问的指令。通常 ICU 会在当前正在执行的指令很早前就取指，这样才会有足够的时间编译指令，并把操作发送到 EU。</p>
<p>程序遇到分支时，有选择分支和不选择分支两种可能。在”取指控制“模块，现代处理器采用<strong>分支预测</strong>的技术，处理器不仅会猜测是否会选择分支，还会预测分支的目标地址。</p>
<p>在这基础上，程序使用<strong>投机执行</strong>的技术，处理器取出预测的分支会跳到的指令，进行指令译码，在确定分支之前就开始执行。如果之后确定分支预测错误，会将状态重置到分支点，取出并执行另一个方向上的指令，这个步骤会造成性能损耗。</p>
<p><strong>指令译码</strong>接收程序指令，将他们转换成一组基本操作（微操作），例如两个数相加，从内存读数据，向内存写数据。通常,一条只对寄存器操作的指令会被转换成一个操作，例如 <code>addq %rax, %rdx</code> 将会转换成加法操作；而包括内存引用的指令将转换成多个操作，将内存引用和算术运算分来，例如 <code>addq %rax, 8(%rdx)</code>，将会转换成 3 个步骤：加载，加法，存回。执行单元可以并行执行这类多条指令的不同部分。</p>
<p>除此之外，ICU中有两个重要的单元：</p>
<ul>
<li><strong>功能单元</strong>：EU每个时钟周期可以接收多个来自取指单元的操作，每个功能单元可以执行多种不同的操作。</li>
<li><strong>退役单元retirement unit</strong>：在队列中记录正在执行的指令的信息，确保乱序执行的结果遵守机器级程序的顺序语义。退役单元控制寄存器的更新，一旦一条指令执行完成，并且<strong>分支预测</strong>的结果被确认为预测正确，那么这条指令可以退役(retire)，对寄存器的更新可以被执行，否则这条指令被清空(flushed)，并且丢弃计算的结果。</li>
</ul>
<p>控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名</strong>。对寄存器的更新只有在指令退役时才会执行，在执行单元间传送指令（退役之前）需要用到寄存器重命名机制。</p>
<blockquote>
<p>书上的解释看不明白我问了 chatGPT：指令被解码时，处理器会分配一个空闲的物理寄存器，并将该指令中涉及到的逻辑寄存器重定向到这个物理寄存器。这样就可以确保指令之间不会互相干扰，从而提高了指令级并行性（Instruction-Level Parallelism）。</p>
<p>eg:</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>处理器性能由以下几个数值刻画：</p>
<ul>
<li>延迟：它表示完成运算所需要的总时间</li>
<li>发射时间：表示两个连续的同类型的运算之间所需要的总时间</li>
<li>容量：表示是能够执行该运算的功能单位的数量</li>
</ul>
<p>其中，表示发射时间的另一个常见的方法是指明这个功能单位的最大吞吐量，定义为发射时间的倒数。</p>
<p>算术运算的延迟、发射时间和容量会影响合并函数的性能，我们用 CPE 的值的两个基本界限来描述这种影响：</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%BB%B6%E8%BF%9F%E7%95%8C%E9%99%90.png" srcset="/img/loading.gif" lazyload></p>
<p>延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小 CPE 值。吞吐量界限给出了 CPE 的最小界限。</p>
<h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><p>我们用数据流表示在现在处理器上执行的机器及程序性能，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了需要优化的关键路径，这是执行一组机器指令所需时钟周期数的一个下界。</p>
<p>例如：下图为之前章节中 combine4 函数的图形化表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L25:<br>	vmulsd (%rdx), %xmm0, %xmm0<br>	addq $8, %rdx<br>	cmpq %rax, %rdx<br>	jne .L25<br></code></pre></td></tr></table></figure>

<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%95%B0%E6%8D%AE%E6%B5%81.png" srcset="/img/loading.gif" lazyload></p>
<p>对于形成循环的代码片段，我们可以将访问到的寄存器分为四类：</p>
<ul>
<li>只读：这些寄存器只用作源值，可以作为数据，也可以用来计算内存地址，但是在循环中它们是不会被修改的。</li>
<li>循环：combine4 的只读寄存器是 %rax。</li>
<li>只写：这些寄存器作为数据传送操作的目的。在本循环中没有这样的寄存器。</li>
<li>局部：这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。在这个循环中，条件码寄存器就是例子，cmp 操作会修改它们， jne 操作又会使用它们，不过这种相关是在<strong>单次迭代</strong>之内的。</li>
<li>循环：对于循环来说，这些寄存器既作为源值，又作为目的，一次迭代中产生的值会在另一次选代中用到。可以看到，%rdx 和 %xmm0是 comine4 的循环寄存器，对应于程序值 data+i 和 acc。</li>
</ul>
<h1 id="优化代码完整示例"><a href="#优化代码完整示例" class="headerlink" title="优化代码完整示例"></a>优化代码完整示例</h1><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// OP为+时IDENT为0</span><br><span class="hljs-comment">// OP为*时IDENT为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine1</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vec_length(v); i++)<br>    &#123;  <br>        <span class="hljs-comment">// 这里vec_length(v)重复求值了</span><br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v, i, &amp;val);<br>        *dest = *dest OP val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="消除循环的低效率-1"><a href="#消除循环的低效率-1" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><p>优化方法称为<strong>代码移动(code motion)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine2</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);  <span class="hljs-comment">// 将不变的长度放到循环外</span><br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v, i, &amp;val);<br>        *dest = *dest OP val;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="减少过程调用-1"><a href="#减少过程调用-1" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">data_t</span>* <span class="hljs-title function_">get_vec_start</span><span class="hljs-params">(vec_ptr v)</span>&#123;<span class="hljs-keyword">return</span> v-&gt;data;&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine3</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);  <span class="hljs-comment">// 获取数组起始地址</span><br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        *dest = *dest OP data[i];  <span class="hljs-comment">// 将函数调用get_vec_element(v, i, &amp;val)改为内存偏移量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="消除不必要的内存引用-1"><a href="#消除不必要的内存引用-1" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine4</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;  <span class="hljs-comment">// 计算结果保存在局部变量，减少内存寻址次数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p>
<p>循环展开能够从两个方面改进程序的性能：</p>
<ul>
<li>它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</li>
<li>它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine5</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);C<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;<br><br>    <span class="hljs-comment">// 2x1 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)<br>    &#123;<br>        acc = (acc OP data[i]) OP data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)<br>    &#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine6</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc0 = IDENT;  <span class="hljs-comment">// 多个累积变量</span><br>    <span class="hljs-type">data_t</span> acc1 = IDENT;<br><br>    <span class="hljs-comment">// 2x2 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)&#123;<br>        acc0 = acc0 OP data[i];<br>        acc1 = acc1 OP data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)&#123;<br>        acc0 = acc0 OP data[i];<br>    &#125;<br>    *dest = acc0 OP acc1;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到这里程序已经突破了延迟界限。</p>
<h3 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">C<br><span class="hljs-type">void</span> <span class="hljs-title function_">combine7</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;<br><br>    <span class="hljs-comment">// 2x1a 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)&#123;<br>        acc = acc OP (data[i] OP data[i+<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 重新结合</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)&#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h1><h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><p>循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度户超过了可用的奇存器数量，那么编译器会诉诸**溢出(spilling)**，将某些临时值存放到内存中，通常是在运行时堆栈上分配空间，造成性能下降。解决办法是控制循环展开的数量。</p>
<h3 id="分支预测错误处罚"><a href="#分支预测错误处罚" class="headerlink" title="分支预测错误处罚"></a>分支预测错误处罚</h3><p>当分支预测逻辑不能正确预测一个分支是否要跳转的时候，条件分支可能会招致很大的预测错误处罚。</p>
<p>解决方案如下：</p>
<ul>
<li><p>不要过分关心可预测的分支</p>
<p>比如 combine4 中的边界检查，我们可以直接使用不用边界检查的函数。处理器能够预测这些分支的结果，所以这些求值都不会对形成程序执行中关键路径的指令的取指和处理产生太大的影响。</p>
</li>
<li><p>书写适用条件传送的代码</p>
<p>使用“功能性”代码代替”命令式“代码，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 优化前命令式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minmax1</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> b[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; b[i])<br>        &#123;  <span class="hljs-comment">// 分支预测错误时损耗很大</span><br>            <span class="hljs-type">long</span> t = a[i];  <span class="hljs-comment">// 交换a[i]和b[i]</span><br>            a[i] = b[i];<br>            b[i] = t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优化后功能性的</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minmax1</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> b[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;n; i++)<br>    &#123;<br>        <span class="hljs-type">long</span> min = a[i] &lt; b[i] ? a[i] : b[i];  <span class="hljs-comment">// 编译为条件传送汇编代码，避免分支预测</span><br>        <span class="hljs-type">long</span> max = a[i] &lt; b[i] ? b[i] : a[i];<br>        a[i] = min;<br>        b[i] = max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="理解内存的性能"><a href="#理解内存的性能" class="headerlink" title="理解内存的性能"></a>理解内存的性能</h1><p>我们所做的测试都只是访问比较少的内存，内存的性能还没有影响到程序的性能。接下来我们会进一步考虑设计加载和存储操作的程序的性能。</p>
<h3 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h3><p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。</p>
<p>例如，在下面的函数中，由一系列加载操作组成的一个计算，一条加载操作的结果决定下一条操作的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELF</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELF</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">long</span> data;<br>&#125;list_ele,*list_ptr;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">list_len</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-type">long</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ls)<br>    &#123;<br>        len++;<br>        ls=ls-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个函数的循环中，变量 <code>ls</code> 的每个后续值依赖于指针引用 <code>s-&gt;next</code> 读出的值。</p>
<p>测试表明函数 list_len 的 CPE 为 4.00，我们认为这直接表明了加载操作的延迟。我们考虑一下循环的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L3                                 ;loop:<br>    addq $1, %rax                   ;    Increment len<br>    movq (%rdi), %rdi               ;    ls=ls-&gt;next<br>    testq %rdi, %rdi                ;    test ls<br>    jne .L3<br></code></pre></td></tr></table></figure>

<p>第 3 行上的 movq 指令是这个循环中关键的瓶颈。后面存器 rdi 的每个值都依赖于加载操作的结果，而加载操作又以 rdi 中的值作为它的地址。因此，直到前一次选代的加载操作完成，下一次迭代的加载操作才能开始。这个函数的 CPE 等于 4.00，是由加载操作的延迟决定的。</p>
<h3 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h3><blockquote>
<p>这一节就是在讲减少存储操作优化性能，例子就不敲了感觉这一节还好懂的   <del>我是懒惰虫</del></p>
</blockquote>
<p>存储操作即将寄存器的值写到内存。</p>
<p>内存操作的实现包括许多细微之处。对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。另一方面，对于内存操作，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些。</p>
<h1 id="应用：性能提高技术"><a href="#应用：性能提高技术" class="headerlink" title="应用：性能提高技术"></a>应用：性能提高技术</h1><p>我们已经描述了许多优化程序性能的基本策略：</p>
<h4 id="高级设计"><a href="#高级设计" class="headerlink" title="高级设计"></a>高级设计</h4><ul>
<li>选择适当的算法和数据结构</li>
</ul>
<h4 id="基本编码原则"><a href="#基本编码原则" class="headerlink" title="基本编码原则"></a>基本编码原则</h4><ul>
<li>消除连续函数调用，将计算移到循环外</li>
<li>消除不必要的内存引用，引入临时变量来存储中间结果</li>
</ul>
<h4 id="低级优化"><a href="#低级优化" class="headerlink" title="低级优化"></a>低级优化</h4><ul>
<li>循环展开</li>
<li>使用多个累积变量、重新结合技术提高指令级并行</li>
<li>用功能性风格重写条件操作，使编译采用条件传送</li>
</ul>
<hr>
<p>开辟了 .md 文件内联公式块新技能！🥳</p>
<p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="category-chain-item">读书笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Knowledge/">#Knowledge</a>
      
        <a href="/tags/CSAPP/">#CSAPP</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSAPP 第五章 优化程序性能</div>
      <div>https://shmodifier.github.io/2023/11/19/CSAPP-第五章-优化程序性能/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Modifier</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/25/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="CSAPP 第六章 存储器体系结构">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSAPP 第六章 存储器体系结构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/22/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="CSAPP 第四章 处理器体系结构">
                        <span class="hidden-mobile">CSAPP 第四章 处理器体系结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    
    <div class="footer-content">
       <p> Copyright &copy; 2022&nbsp;-&nbsp;2023 <a href="/">Modifier</a> </p> <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></p> <!--  <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> -->

    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  

<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
