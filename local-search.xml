<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>物理地址，虚拟地址和逻辑地址</title>
    <link href="/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>关于物理地址，虚拟地址和逻辑地址的定义和之间的关系</p><span id="more"></span><p>虽然写了这么多知识点但脑袋还是乱乱的，希望哪天突然开窍叭🥱</p><h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>我们平时使用的各种数据都是存储在硬盘等存储器上，但硬盘的运行速度很慢。所以需要运行程序或者使用数据时，这些数据必须从硬盘上转到另一种容量小但速度快很多的存储器，之后才送进CPU进行处理。这中间的存储器就是内存。</p><p>无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。</p><p>其中：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p><strong>物理地址就是常说的内存地址，是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。</strong></p><p>计算机将内存划分为一个个小的内存单元，同时对其编号，这样就能有效管理内存。在空间划分实践中，一个<strong>内存单元</strong>的大小为1<strong>字节</strong>。一个字节是八个比特，相当于八个二进制位，两个十六进制位。</p><blockquote><p>可以理解为一栋叫内存的楼，每一套商品房都有自己的门牌号叫内存单元，每一个家庭是一个数据，每一位家庭成员所居住的小房间则不会进行编号。</p></blockquote><p>每个内存单元都有编号（内存编号），内存编号可以称为<strong>地址</strong>，在<code>C</code>语言中也称为<strong>指针</strong>。</p><h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>在内存中存储”修饰符“或”MOD“，可以示意为：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-28_20-14-36.png"></p><p>![]&#x2F;img&#x2F;物理地址，虚拟地址和逻辑地址&#x2F;Snipaste_2023-03-28_20-23-49.png)</p><blockquote><p>数字后面加H表示十六进制</p></blockquote><p>在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；第二行中每一格内数字就是对应的内存的地址。</p><p>汉字在一个地址空间里储存不下，会放进两个连续的地址空间里。而字母或者阿拉伯数字就可以放进一个内存地址里。在上图中，”修“的内存地址为1000H，或者M的内存地址为”1000H”。</p><h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟存储器不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p><strong>虚拟地址用于指示虚拟存储器的地址，它是用逻辑地址指示的</strong></p><p>在程序运行时，我们需要将进程与物理地址映射起来，才能区分这些内存中存储的数据属于哪个进程。但内存大小有限，进程却可以很多，甚至可能同时进行多个进程。为了实现让很多进程共用一个存储资源有限的内存，我们引出虚拟地址的概念，我们先将进程与虚拟地址映射起来，再将虚拟地址与物理地址映射起来。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-0204ff048148735a260fa5f94f475f14_r.png"></p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址，就是指机器语言指令中用来指定一个操作数或一条指令的地址，<strong>由一个段(segment)和偏移量(offset)组成</strong>，说地直白点就是CPU拿到的地址。</p><p>段号：用来查找段的起始地址，它被存储在段寄存器当中</p><p>偏移地址：是存储单元的物理地址与所在起始段的差值</p><h1 id="各种内存的关系"><a href="#各种内存的关系" class="headerlink" title="各种内存的关系"></a>各种内存的关系</h1><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/bba9443a9c0249ffa501df86649ce5d8.png"></p><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子保存在寄存器里。段选择子最重要的是段号，用作段表的索引。段表里保存的是这个段的基地址、段的界限和特权等级等。</p><p>段选择子是十六位的，其中十四位表示地址信息</p><h4 id="段偏移量"><a href="#段偏移量" class="headerlink" title="段偏移量"></a>段偏移量</h4><p>偏移量定义为：把存储单元的<strong>实际地址</strong>与其所在段的<strong>段地址</strong>之间的距离称为段内偏移，也称为“有效地址”或“偏移量”。</p><p>虚拟地址中的段偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将其段及地址加到段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>内存碎片</li></ul><p>举例来说。假设我们现在占有 1G 的物理内存，用户执行了多个程序，游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。</p><p>这个时候，我们关闭浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。但如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><p>这里的内存碎片的问题共有两处地方：</p><p>外部内存碎片，也就是产生了多个<strong>不连续</strong>的小物理内存，导致新的程序无法被装载；</p><p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致<strong>内存的浪费</strong></p><ul><li>内存交换效率低</li></ul><p>对于外部内存碎片的问题，我们采用内存交换的解决措施。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新重新规划内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）</p><p>虚拟地址与物理地址之间通过页表来映射：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-e63c20d1bace757600fccb051a29eaf6_720w.webp"></p><p>页存储在内存里，由CPU的内存管理单元即MMU负责映射转换的工作吗，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.webp"></p><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</p><h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p><hr><p>冲浪冲到的，我觉得比起枯燥的文字，这个更好理解</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-29_21-54-52.png"></p><hr><p>之前觉得自己很牛直接开始做题，靠一些老本还是能做几道题，但最近发现偏移量和内存地址啥的根本不会看也不会算，还是老老实实打基础叭😳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编基础</title>
    <link href="/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>32bit的x86汇编基础，包括一些常规指令，内存和寻址模式</p><span id="more"></span><p>总觉得学了又好像没学······</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/img/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86-registers.png"></p><p>现代 x86 处理器有 8 个 32 bit 寄存器，如上图所示。</p><p>寄存器名字是早期计算机历史上流传下来的。</p><ul><li>EAX：一般用作累加器(Accumulator)</li><li>EBX：一般用作基址寄存器(Base)</li><li>ECX：一般用来计数(Count)</li><li>EDX：一般用来存放数据(Data)</li><li>ESI：一般用作源变址(Source Index)</li><li>EDI：一般用作目标变址(Destinatin Index)</li><li>ESP：一般用作堆栈指针(Stack Pointer)</li><li>EBP：一般用作基址指针(Base Pointer)</li></ul><p>现在大部分寄存器的名字已经失去了原来的意义，但有两个是例外：<strong>栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP</strong>。</p><p>对于 <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。例如 <code>EAX</code> 的高 16bit 叫 <code>AX</code>（去掉 E, 据说E表示 Extended）,低 8bit 叫 <code>AL</code> (Low）, 8-16bit 叫 <code>AH</code> （High）。</p><p>在汇编语言中，这些寄存器的名字是<strong>大小写无关</strong>的，既可以用 <code>EAX</code>，也可以写 <code>eax</code>。</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><ul><li>存放程序的为代码段，存放数据的为数据段</li><li>真实的内存单元地址称为物理地址，而程序中的地址为逻辑地址</li></ul><p>由于程序并不知道自己会被加载到哪，因此访存如果用绝对地址将会出错，在执行程序时就需要<strong>程序重定位</strong>这个操作。</p><p>该操作在汇编中通过<code>org</code>指令实现，如<code>org 0A100h</code>代表该程序中的所有标号都以<code>0A100h</code>做偏移。</p><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>将内存分段后，程序只需要识别偏移地址就可以确定数据位置。程序重定位通过设置代码段CS寄存器和数据段DS寄存器实现。</p><p>在8086中，地址总线是20位的，需要将段寄存器左移4位（<code>0x10h</code>，相当于16进制左移1位）变为20位，然后再同偏移地址相加。</p><p>两种典型情况</p><ul><li>因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，每个段16B，偏移地址从<code>0000H</code>到<code>000FH</code></li><li>同样在不允许段之间重叠的情况下，因为偏移地址也是16位，1MB的内存最多只能划分成16个段，每段长64KB，段地址由<code>0000H</code>到<code>F000H</code></li></ul><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p><code>.DATA</code>：声明静态存储区</p><p>数据类型修饰语：</p><p><code>DB/db</code>：Byte,1Byte</p><p><code>DW/dw</code>：Word,2Byte</p><p><code>DD/dd</code>：Double Word,4Bytes</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.DATA<br>var     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.<br>var2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.<br>        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.<br>X       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.<br>Y       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.<br></code></pre></td></tr></table></figure><p><strong>在汇编中只有一维数组</strong>，没有二维和多维数组。一维数组其实就是内存中的一块连续区域。<code>DUP</code> 和字符串常量也是声明数组的两种方法。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Z       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.<br>bytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.<br>arr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0<br>str     DB &#x27;hello&#x27;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.<br></code></pre></td></tr></table></figure><h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>有多个指令可以用于内存寻址。如果要访问某一大小的内存，则通过添加修饰词<code>byte</code>、<code>word</code>、<code>dword</code>实现。</p><p>🌰：</p><p>其中<code>MOV</code> 将在内存和寄存器之间移动数据，接受两个参数：第一个参数是目的地，第二个是源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte[ebx], 2<br></code></pre></td></tr></table></figure><h3 id="函数调用-call-堆栈组织"><a href="#函数调用-call-堆栈组织" class="headerlink" title="函数调用(call)堆栈组织"></a>函数调用(call)堆栈组织</h3><h4 id="Caller规则"><a href="#Caller规则" class="headerlink" title="Caller规则"></a>Caller规则</h4><ol><li>在调用函数&#x2F;子程序(subroutine)之前，先保存特定寄存器的状态(caller-saved)（包括<code>eax</code>、<code>ecx</code>、<code>edx</code>）</li><li>将要传的参数堆栈（注意要逆序，<strong>最后一个参数最先入</strong>）。因为栈往下生长，因此第一个参数会被存在最低的地址</li><li>调用函数，<code>call</code>会将返回地址<code>eip</code>压入栈中</li><li>返回时先把参数移出栈，然后将原来保存的寄存器再pop出来</li></ol><h4 id="Callee规则"><a href="#Callee规则" class="headerlink" title="Callee规则"></a>Callee规则</h4><ol><li><p>将<code>ebp</code>推入栈，将<code>esp</code>的值拷贝入<code>ebp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp, esp<br></code></pre></td></tr></table></figure></li><li><p>分配局部变量，栈由上向下增长，如分配3个4B，则<code>sub esp, 12</code></p></li><li><p>保存寄存器状态</p></li></ol><h1 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h1><p>机器指令通常分为三类：数据移动、算术&#x2F;逻辑和控制流。</p><p>接下来的符号解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">&lt;reg32&gt; ; 任何32位寄存器 （EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP）<br>&lt;reg16&gt;; 任何16位寄存器 （AX, BX, CX, or DX）<br>&lt;reg8&gt;; 任何8位寄存器 （AH, BH, CH, DH, AL, BL, CL, or DL）<br>&lt;reg&gt;; 任何寄存器<br>&lt;mem&gt;; 一个内存地址 （e.g., [eax], [var + 4], or dword ptr [eax+ebx]）<br>&lt;con32&gt;; 任何32位常量<br>&lt;con16&gt;; 任何16位常量<br>&lt;con8&gt;; 任何8位常量<br>&lt;con&gt;; 任何8、16、32位常量<br></code></pre></td></tr></table></figure><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov指令将第二操作对象（寄存器、内存内容或是常量值）所引用的数据项复制到其第一操作对象（寄存器或是内存）所引用的位置。</p><p>寄存器到寄存器的移动是合法的，但是直接内存到内存的移动是不合法的。在需要内存传输的情况下，必须首先将源内存中的内容加载到寄存器中，然后才能将其存储到目标内存地址。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov &lt;reg&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;mem&gt;<br>mov &lt;mem&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;const&gt;<br>mov &lt;mem&gt;,&lt;const&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, ebx ; 将EBX中的值复制到EAX<br>mov byte ptr [var], 5 ; 将5存储到地址var的一个字节中<br></code></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>ESP（堆栈指针）通过push递减。</p><p>push指令将其操作对象放在内存中硬件支持堆栈的顶部。具体地说，PUSH首先将ESP递减4，然后将其操作对象放入内存地址[ESP]处的32位大小的区域中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push &lt;reg32&gt;<br>push &lt;mem&gt;<br>push &lt;con32&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax ; 将eax入栈<br>push [var] ; 将地址var处开始的4个字节入栈<br></code></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop指令将4字节数据元素从硬件支持的堆栈顶部移至指定的操作对象（即寄存器或内存位置）。它首先将位于内存位置[SP]的4个字节移动到指定的寄存器或内存位置，然后将SP递增4。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop &lt;reg32&gt;<br>pop &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop edi ; 将堆栈的顶部元素弹出到EDI中<br>pop [ebx] ; 将堆栈的顶部元素弹出到内存从EBX位置开始的四个字节中<br></code></pre></td></tr></table></figure><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea指令将其第二个操作对象指定的地址放入其<strong>第一个操作对象指定的寄存器中</strong>。需要注意的是，内存位置的内容不会被加载，并且只有有效地址会被计算并放入寄存器中。这对于获取指向内存区域的指针非常有用。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea &lt;reg32&gt;,&lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea edi, [ebx+4*esi] ; 将地址EBX+4*ESI放入EDI<br>lea eax, [var] ; 将var中的值放在EAX中<br></code></pre></td></tr></table></figure><h2 id="算数和逻辑运算符"><a href="#算数和逻辑运算符" class="headerlink" title="算数和逻辑运算符"></a>算数和逻辑运算符</h2><h4 id="add-整数加法"><a href="#add-整数加法" class="headerlink" title="add-整数加法"></a>add-整数加法</h4><p>add指令将其两个操作对象相加，将结果存储在第一个操作对象中。需要注意的是，虽然两个操作对象都可以是寄存器，<strong>但最多只有一个操作对象可以是内存位置</strong>。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax, 10 ; EAX ← EAX + 10<br>add BYTE PTR [var], 10 ; 将存储在内存地址var的单字节值加上10<br></code></pre></td></tr></table></figure><h4 id="sub-整数减法"><a href="#sub-整数减法" class="headerlink" title="sub-整数减法"></a>sub-整数减法</h4><p>sub指令将其第一个操作对象的值减去第二个对象的值，并将结果存储在第一个对象的内存位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub &lt;reg&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;mem&gt;<br>sub &lt;mem&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;con&gt;<br>sub &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="inc-dec-递增，递减"><a href="#inc-dec-递增，递减" class="headerlink" title="inc,dec-递增，递减"></a>inc,dec-递增，递减</h4><p>inc指令将其操作对象的内容+1；DEC指令将其操作对象的内容-1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc &lt;reg&gt;<br>inc &lt;mem&gt;<br>dec &lt;reg&gt;<br>dec &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax ; 从EAX的内容中减去1<br>inc DWORD PTR [var] ; 将存储在位置var的32位整数加1<br></code></pre></td></tr></table></figure><h4 id="imul-整数乘法"><a href="#imul-整数乘法" class="headerlink" title="imul-整数乘法"></a>imul-整数乘法</h4><p>imul指令有两种基本格式：两个操作对象和三个操作对象。</p><p>有两个操作对象时将其两个操作对象相乘，并将结果储存在第一个操作对象当中，其中，第一个对象必须是寄存器。</p><p>有三个操作对象时，将第二个操作对象与第三个操作对象相乘，并将其结果储存在第一个操作对象当中，其中第一个对象必须是寄存器，第三个对象必须是常量值。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br></code></pre></td></tr></table></figure><h4 id="idiv-整数除法"><a href="#idiv-整数除法" class="headerlink" title="idiv-整数除法"></a>idiv-整数除法</h4><p>idiv指令将64位整数<code>EDX:EAX</code>的内容除以指定的操作对象值。结果存储在EAX中，其余数的存储在EDX中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br></code></pre></td></tr></table></figure><h4 id="and-or-xor-按位与、或和异或"><a href="#and-or-xor-按位与、或和异或" class="headerlink" title="and,or xor-按位与、或和异或"></a>and,or xor-按位与、或和异或</h4><p>这些指令对其操作对象执行指定的位运算（分别为按位与、或和异或），并将结果放在第一个操作对象位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>or &lt;reg&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;mem&gt;<br>or &lt;mem&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;con&gt;<br>or &lt;mem&gt;,&lt;con&gt;<br><br>xor &lt;reg&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;mem&gt;<br>xor &lt;mem&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;con&gt;<br>xor &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br></code></pre></td></tr></table></figure><h4 id="not-按位取反"><a href="#not-按位取反" class="headerlink" title="not-按位取反"></a>not-按位取反</h4><p>not指令触发反转操作对象中的所有位，其结果称为反码。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not &lt;reg&gt;<br>not &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br></code></pre></td></tr></table></figure><h4 id="neg-求补"><a href="#neg-求补" class="headerlink" title="neg-求补"></a>neg-求补</h4><p>neg是汇编指令中的求补指令，对操作对象执行求补运算：用0减去操作对象，然后结果返回操作对象；或是直接将操作对象按位取反后+1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg &lt;reg&gt;<br>neg &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax ; EAX → - EAX<br></code></pre></td></tr></table></figure><h4 id="shl-shr-左移，右移"><a href="#shl-shr-左移，右移" class="headerlink" title="shl, shr-左移，右移"></a>shl, shr-左移，右移</h4><p>这些指令将其第一个操作对象内容中的位左右移位，用零填充产生的空位位置。移位后的操作对象最多可以移位31位。要移位的位数由第二个操作对象指定，该操作对象可以是8位常量，也可以是寄存器CL。</p><p>在任一情况下，以32为模执行大于31的移位计数。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shr &lt;reg&gt;,&lt;con8&gt;<br>shr &lt;mem&gt;,&lt;con8&gt;<br>shr &lt;reg&gt;,&lt;cl&gt;<br>shr &lt;mem&gt;,&lt;cl&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><p>x86处理器维护一个指令指针（IP）寄存器，它是一个32位值，指示当前指令在内存中的起始位置。通常，在执行一条指令后，它会递增以指向内存中的下一条指令的起始位置。IP寄存器不能直接操作，而是由提供的控制流指令隐式更新。</p><blockquote><p>我们使用符号&lt;LABEL&gt;来表示代码中已标记的位置。通过输入标签名称后跟冒号，可以在x86汇编代码中的任意位置插入标签。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">       mov esi, [ebp+8]<br>begin: xor ecx, ecx<br>       mov eax, [esi]<br></code></pre></td></tr></table></figure><p>此代码段中的第二条指令被标记为begin。在代码的其他地方，我们可以使用更方便的符号名称begin来引用此指令所在的内存中的位置。这个标签只是表示位置的一种方便方式，而不是它的32位值。</p><h4 id="jmp-跳转"><a href="#jmp-跳转" class="headerlink" title="jmp-跳转"></a>jmp-跳转</h4><p>将程序控制流转移到操作对象指示的内存位置上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp &lt;label&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp begin ; 跳到标记为begin的指令位置<br></code></pre></td></tr></table></figure><h4 id="jcondition-条件跳转"><a href="#jcondition-条件跳转" class="headerlink" title="jcondition-条件跳转"></a>jcondition-条件跳转</h4><p>这些指令是基于一组条件码状态判断是否进行跳转，该条件码被存储在称为机器状态字的特殊寄存器中。</p><p>机器状态字的内容包括有关上次执行的算术运算的信息。例如，此字的某一比特位表示最后结果是否为零，某另一个比特位指示上次结果是否为负数。</p><p>基于这些条件码，可以执行多个条件跳转。例如，如果上次算术运算的结果为零，则JZ指令执行到指定操作对象标签的跳转。否则，控制按顺序前进到下一条指令。</p><p>许多条件分支的名字都是根据上一次执行的特殊比较指令cmp命名的。例如，条件分支（如JLE和JNE）基于首先对所需操作对象执行cmp操作。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">je &lt;label&gt;  ; 相等时跳转<br>jne &lt;label&gt; ; 不相等时跳转<br>jz &lt;label&gt;  ; 最后结果为零时跳转<br>jg &lt;label&gt;  ; 大于时跳转<br>jge &lt;label&gt; ; 大于等于时跳转<br>jl &lt;label&gt;  ; 小于时跳转<br>jle &lt;label&gt; ; 小于等于时跳转<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax, ebx<br>jle done ; 如果EAX的中的值小于或等于EBX中的值，跳至标签done。否则，继续执行下一条指令<br></code></pre></td></tr></table></figure><h4 id="cmp-比较"><a href="#cmp-比较" class="headerlink" title="cmp-比较"></a>cmp-比较</h4><p>比较两个指定操作对象的值，适当设置机器状态字中的条件代码。此指令等同于sub指令，不同之处在于将丢弃减法结果，而不是替换第一个操作对象。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp &lt;reg&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;mem&gt;<br>cmp &lt;mem&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp DWORD PTR [var], 10<br>jeq loop ; 如果存储在var中的4个字节的值等于4字节整数常量10，则跳转到标记为loop的位置<br></code></pre></td></tr></table></figure><h4 id="call-ret-子程序调用和返回"><a href="#call-ret-子程序调用和返回" class="headerlink" title="call, ret-子程序调用和返回"></a>call, ret-子程序调用和返回</h4><p>这些指令实现一个子程序调用和返回。</p><p>call指令首先将当前代码位置压入到内存中硬件支持的堆栈中，然后无条件跳转到标签操作对象指示的代码位置。与简单的跳转指令不同，call指令保存当前位置，并在子程序完成时返回到此处。</p><p>ret指令实现子程序返回机制。此指令首先从硬件支持的内存堆栈中弹出代码位置，然后无条件跳转至该代码位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call &lt;label&gt;<br>ret<br></code></pre></td></tr></table></figure><hr><p>最近一直被问x86学完了没，这算学完叭（小声bb)🤨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PWN的边缘疯狂试探</title>
    <link href="/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/"/>
    <url>/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>一点点 pwn 基础——栈和堆、汇编基础和Linux常用保护机制</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PWN是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音–砰的一声，被”黑”的电脑或手机就被你操纵了 。</p><p>（上文来自百度）</p><p>个人认为解决PWN题就是利用简单的逆向得到代码，从代码中发现漏洞，再通过二进制或系统调用等方式利用这些漏洞获得目标主机的shell 。</p><p>很酷！！！！！😎</p><h1 id="前知知识"><a href="#前知知识" class="headerlink" title="前知知识"></a>前知知识</h1><p>就是我只知道这么多就来学pwn了</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/271639137915732.jpg"></p><p>在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。</p><p>编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用.</p><p>例如<code>mov $5, %eax</code>或<code>mov eax, 5</code>表示将5赋值给寄存器<strong>eax</strong>。</p><p> 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母<strong>“e”</strong>作名称前缀，指示寄存器大小为32位；x86_64架构用字母<strong>“r”</strong>作名称前缀，指示各寄存器大小为64位。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈溢出就是数据会占用一个存储空间，但是我们写代码的时候默认输入数据就是符合规定的数据，并没有对输入数据进行限制，这时超出这个空间大小的数据就会输入到合法空间以外的地方并造成破坏。</p><p>借此我们就可以控制这个不允许用户操作的空间内的寄存器，改变寄存器的值达到代码执行的效果。</p><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><p>输入：</p><ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul><p>输出：</p><ul><li>sprintf</li></ul><p>字符串：</p><ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul><h3 id="Linux的一些基础命令"><a href="#Linux的一些基础命令" class="headerlink" title="Linux的一些基础命令"></a>Linux的一些基础命令</h3><p><code>sudo</code> ：SuperUserDo 在需要权限的命令前使用</p><p><code>apt-get</code>：可以执行安装、升级、甚至移除软件这类任务</p><p><code>grep</code>：配合正则表达式食用，用于寻找文件或内容</p><p><code>cat</code>：查看文件</p><p><code>rm</code>：移除文件，还可以使用**-r**来进行递归移除，从而移除整个文件夹</p><p><code>cp</code>：拷贝文件</p><p><code>ls</code>：查看目录下的文件</p><p><del>暂时只想起这么多</del></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><blockquote><p>pwn 研究二进制还是要学习底层计算机语言的😢</p></blockquote><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 <code>ADD</code>。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一般情况下，程序都是由bss段，text段和date段三个段组成。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/11.png"></p><p>bss 段：只有定义而没有赋初值的全局变量和静态变量。</p><p>data 段：存放在编译阶段 (而非运行时) 就能确定的数据，可读可写。就是通常所说的<strong>静态存储区</strong>，存储赋了初值的全局变量和赋初值的静态变量以及常量。</p><p>text 段：放<strong>程序代码</strong>，在编译时确定，只读。</p><h5 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h5><p>bss段是用来存放未初始化的全局变量和静态变量的一块内存区域，一般在初始化时bss段部分会清零。</p><h5 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h5><p>存放程序代码的区域，在编译时确定，只读。</p><p>更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器连接各个目标文件并解决各个源文件之间的函数引用。与此同时，还要将所有目标文件中的.text段合在一起，但不是简单的将他们“堆”在一起，还要处理各个段之间函数引用问题。</p><h5 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h5><p>用于存放在编译阶段（而非运行时）就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量，常量和静态变量都存放在这个区域。</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap-堆"></a>Heap-堆</h4><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址(低位），结束地址是较大的那个地址（高位）。</p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分。</p><blockquote><p>实际上，起始地址会有一段静态数据，这里忽略</p></blockquote><p>举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-38-37.png"></p><p>这种因为用户主动请求而划分出来的内存区域，就叫做 Heap（堆）。它由<strong>起始地址</strong>开始，从<strong>低位</strong>向<strong>高位</strong>增长。Heap 的一个重要特点就是<strong>不会自动消失</strong>，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Strack-栈"><a href="#Strack-栈" class="headerlink" title="Strack-栈"></a>Strack-栈</h4><p>Stack 是由于函数运行而临时占用的内存区域。Stack 是由内存区域的<strong>结束地址</strong>开始，从<strong>高位</strong>向<strong>低位</strong>分配。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><p>举个具体的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> add_a_and_b(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如a和b）都保存在这个帧里面。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-50-18.png"></p><p>当调用其他函数时，程序运行到这一行，会新建一个帧。此时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-49-52.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。</p><p>生成新的帧，叫做”压栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”<strong>后进先出</strong>“的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><h4 id="一个🌰"><a href="#一个🌰" class="headerlink" title="一个🌰"></a>一个🌰</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将其转换为汇编语言就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86">.file&quot;test.c&quot;<br>.text<br>.globladd_a_and_b<br>.typeadd_a_and_b, @function<br>add_a_and_b:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl%edi, -4(%rbp)<br>movl%esi, -8(%rbp)<br>movl-4(%rbp), %edx<br>movl-8(%rbp), %eax<br>addl%edx, %eax<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE0:<br>.sizeadd_a_and_b, .-add_a_and_b<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl$3, %esi<br>movl$2, %edi<br>calladd_a_and_b<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><blockquote><p>以我现在的水平还不是很能看明白，我就是把文件全复制下来了</p></blockquote><p>简化以后主要就是这些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure><p>可以看到原程序两个函数<code>add_a_and_b</code>和<code>main</code>对应上面的两个标签<code>_add_a_and_b</code>和<code>_main</code>，每个标签里面是该函数所转成的 CPU 运行流程，每一行就是 CPU 执行的一次操作。</p><p>以其中一行为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86">push   %ebx<br></code></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><table><thead><tr><th>汇编指令</th><th>实际作用</th><th>等价代码</th></tr></thead><tbody><tr><td>mov rax,rbx</td><td>用于赋值</td><td>rax&#x3D;rbx</td></tr><tr><td>add&#x2F;sub rax,rbx</td><td>用于加&#x2F;减法</td><td>rax+&#x3D;rbx&#x2F;rax-&#x3D;rbx</td></tr><tr><td>and&#x2F;xor&#x2F;or rax,rbx</td><td>用于与&#x2F;异或&#x2F;或</td><td>rax&amp;&#x3D;rbx&#x2F;rax^&#x3D;rbx&#x2F;rax</td></tr><tr><td>push rax</td><td>压栈</td><td>rsp-&#x3D;8;*rsp&#x3D;rax</td></tr><tr><td>pop rax</td><td>出栈</td><td>rax&#x3D;*rsp;rsp+&#x3D;8</td></tr><tr><td>call rax</td><td>调用函数</td><td>push rip;jmp rax;</td></tr><tr><td>ret</td><td>从函数返回</td><td>pop rip;</td></tr><tr><td>cmp rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax-rbx</td></tr><tr><td>test rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax&amp;rbx</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table><thead><tr><th>汇编指令示例</th><th>英文全称</th><th>实际作用</th></tr></thead><tbody><tr><td>jmp</td><td>jump</td><td>跳转</td></tr><tr><td>jz</td><td>jump if zero</td><td>为0时跳转</td></tr><tr><td>jnz</td><td>jump if not zero</td><td>不为零时跳转</td></tr><tr><td>jg</td><td>jump if greater</td><td>有符号数大于跳转</td></tr><tr><td>jl</td><td>jump if lsee</td><td>有符号数小于跳转</td></tr></tbody></table><p>跳转指令不同于 mov 指令，他可以用于修改段寄存器 cs、ip 的值，从而修改 CPU 在内存中所读取的内容的地址。</p><p><del>表格是从小卓的博客copy来的</del></p><h1 id="Linux常用保护机制"><a href="#Linux常用保护机制" class="headerlink" title="Linux常用保护机制"></a>Linux常用保护机制</h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了 保护机制</p><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>这不是个保护机制是个脚本软件。</p><p>checksec用来检查可执行文件的属性，查看文件开启了哪些保护机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">checksec [filename]<br></code></pre></td></tr></table></figure><p>以之前一道 Pwn 题题目为例：<br><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_21-08-51.png"></p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>RELRO即为read only relocation，可以理解为我们熟悉的windows系统里的只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o hello test.c // 默认情况下，是Partial RELRO<br>gcc -z norelro -o hello test.c // 关闭，即No RELRO<br>gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO<br>gcc -z now -o hello test.c // 全部开启，即Full RELRO<br></code></pre></td></tr></table></figure><h3 id="CANNARY（栈保护）"><a href="#CANNARY（栈保护）" class="headerlink" title="CANNARY（栈保护）"></a>CANNARY（栈保护）</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。</p><p>在 Linux 中我们将 cookie 信息称为 canary。</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>gcc -fstack-protector-all 启用保护，为所有函数插入保护<br>gcc -fstack-protector-strong<br>gcc -fstack-protector-explicit 只对有明确stack_protect attribute 的函数开启保护<br>gcc -fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure><h3 id="NX-DEP"><a href="#NX-DEP" class="headerlink" title="NX(DEP)"></a>NX(DEP)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>NX 即 No-eXecute（不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c                    // 默认情况下，开启NX保护<br>gcc -z execstack -o test test.c        // 禁用NX保护<br>gcc -z noexecstack -o test test.c    // 开启NX保护<br></code></pre></td></tr></table></figure><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>PIE即Position-Independent Executable（ 位置无关可执行文件），与ASLR 技术类似。</p><p>ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。</p><p>liunx 下关闭 PIE 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space<br></code></pre></td></tr></table></figure><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c       // 默认情况下，不开启PIE<br>gcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1<br>gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2<br>gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIE<br>gcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE<br></code></pre></td></tr></table></figure><hr><p>杂七杂八忙了一个周，抽时间学了这么点东西。我是菜鸡🥬</p><p>有看几道pwn题，发现大部分题目都是需要一些逆向技巧的，有些还会和web结合 <del>非常疯狂</del></p><p>如果有空web一些基础的东西我还是会继续学的，就熬夜吧熬夜吧🤪</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ubuntu</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>又名：学了就忘只能再看从头重学😣</p><span id="more"></span><h1 id="01-phpstudy中MySQL的简单使用"><a href="#01-phpstudy中MySQL的简单使用" class="headerlink" title="01 phpstudy中MySQL的简单使用"></a>01 phpstudy中MySQL的简单使用</h1><p>在学用MySQL的时候发现自己和学习资料用的不是同一个集成环境，所以打开方式不一样，这种小问题还是难不倒我哒😎</p><p>首先开启MySQL服务    <del>好了接下来就不会了</del></p><p>再去小皮官网看看</p><p>有一个模块是phpMyAdmin的使用。按照官方教程下载好打开我才发现这是在网页上操作，不是命令行。没关系，下载都下载了，学习一下。</p><h4 id="001-图形化界面操作"><a href="#001-图形化界面操作" class="headerlink" title="001 图形化界面操作"></a>001 图形化界面操作</h4><p>在软件管理找到<strong>phpMyAdmin</strong>，点击下载。下载完之后点管理就会自动在浏览器打开，输入用户名和密码就可以使用啦。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-29-51.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong></p><p>在phpMyAdmin也可以用SQL查询语句嗷</p><blockquote><p>输入SELECT id FROM test ;</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-48-13.png"></p><p>使用其他界面操作内容时也可以预览SQL语句</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-51-03.png"></p><p>总之就是很简单易上手辣😇</p><p><del>连我都可以无师自通</del></p><h4 id="002-cmd操作"><a href="#002-cmd操作" class="headerlink" title="002 cmd操作"></a>002 cmd操作</h4><blockquote><p>MySQL在phpstudy_pro文件下的Extensions文件夹里</p></blockquote><p>进入bin目录后在此处打开cmd</p><p>输入<code>mysql -u[用户名] -p[密码] -h [数据库服务器地址]</code>进入</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-28-33.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong>，打开本地数据库可以不加服务器地址</p><p>进入mysql之后就可以快乐使用了</p><h1 id="02-关于MySQL"><a href="#02-关于MySQL" class="headerlink" title="02 关于MySQL"></a>02 关于MySQL</h1><h4 id="001-MySQL常见符号"><a href="#001-MySQL常见符号" class="headerlink" title="001 MySQL常见符号"></a>001 MySQL常见符号</h4><h5 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-29-23.png"></p><p>表示当前命令没有命令执行符或者等待命令执行符<code>;</code>或<code>\g</code>，也可以输入<code>\c</code>取消命令直接输入<code>;</code>回车即可执行命令。</p><h5 id="‘-gt-或”-gt"><a href="#‘-gt-或”-gt" class="headerlink" title="‘&gt;或”&gt;"></a>‘&gt;或”&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-33-39.png"></p><p>表示当前命令缺少<code>&#39;</code>或<code>&quot;</code></p><h4 id="002-MySQL编码规范"><a href="#002-MySQL编码规范" class="headerlink" title="002 MySQL编码规范"></a>002 MySQL编码规范</h4><ul><li><p>关键字与函数名称全部大写；（不大写也可以执行命令）</p></li><li><p>数据库名称、表名、字段名称全部小写；</p></li><li><p>必须以分号结尾</p></li></ul><h4 id="003-结构化查询语言"><a href="#003-结构化查询语言" class="headerlink" title="003 结构化查询语言"></a>003 结构化查询语言</h4><p>主要分为四类</p><p>DDL-数据库定义语言（CREATE DROP ALTER)</p><p>DML-数据库操作语言（INSERT DELETE UPDATE)</p><p>DQL-数据库查询语言（SELECT WHERE)</p><p>DCL-数据库控制语言</p><p><del>说了这么多也没什么用</del>🤪</p><h1 id="03-SQL语法"><a href="#03-SQL语法" class="headerlink" title="03 SQL语法"></a>03 SQL语法</h1><h3 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h3><h5 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE; <br></code></pre></td></tr></table></figure><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [database_name];<br></code></pre></td></tr></table></figure><p>不知道即将创建的库是否存在时，可使用以下命令：如果库不存在就创建，存在则退出命令</p><p><code>CREATE DATABASE IF NOT EXISTS [database_name];</code></p><blockquote><p>但不建议让MySQL来做判断</p></blockquote><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE [database_name];<br></code></pre></td></tr></table></figure><p><strong>数据库不能修改名字</strong></p><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;         //查找当前库的所有表<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-25-02.png"></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT TABLE [table_name](<br>    [column_name] [数据类型] [列的完整性约束]，<br>    ······<br>);<br></code></pre></td></tr></table></figure><blockquote><p>name为创建的表格名，可自行更改</p><p>空格里填表格表头及数据信息</p></blockquote><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(18) NOT NULL,<br>    pwd CHAR(32) NOT NULL,<br>    sex TINYINT NOT NULL DEFAULT 0,<br>    age TINYINT UNSIGNED NOT NULL<br>);<br></code></pre></td></tr></table></figure><blockquote><p>创建新表后，可以使用<code>desc table_name</code>查询表格信息</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-24-19.png"></p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Int</td><td>整数类型</td></tr><tr><td>char(n)</td><td>字符&#x2F;字符串，固定长度</td></tr><tr><td>varchar(n)</td><td>字符&#x2F;字符串，可变长度，最大长度为n</td></tr><tr><td>numeric(a,b)</td><td>精确数值，总位数为a，精确到小数点后第b位</td></tr><tr><td>date</td><td>时间，存储年月日的值</td></tr></tbody></table><p>字段约束</p><table><thead><tr><th>约束类型</th><th>说明</th></tr></thead><tbody><tr><td>UNSIGNED</td><td>只能用于数值整型，设置无符号。最大值不能超过255</td></tr><tr><td>ZEROFILL</td><td>只能用于数值整形，自动用0补全不足位数。eg：001</td></tr><tr><td>AUTO_INCREMENT</td><td>设置字段的自动增量属性，只能用于设置数值类型。</td></tr><tr><td>NULL&#x2F;NOT NULL</td><td>默认为NULL，即没有在此字段插入值。如果设置NOT NULL，则必须在此字段插入相应的值。</td></tr><tr><td>DEFAULT</td><td>通过此属性设置默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键约束，主键自动为NOT NULL。</td></tr></tbody></table><blockquote><p>AUTO_INCREMENT必须和PRIMARY KEY一起用。自动增量必须为主键，但主键不一定要自动增量。</p></blockquote><h5 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [new_table_name] SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] RENAME [new_table_name];<br></code></pre></td></tr></table></figure><h3 id="对字段的操作"><a href="#对字段的操作" class="headerlink" title="对字段的操作"></a>对字段的操作</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] ADD [column_name] [数据类型] [完整性约束] [位置参数];<br></code></pre></td></tr></table></figure><blockquote><p>位置参数可空默认加在表的最后，也可使用FIRST或AFTER[字段名]</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-58-44.png"></p><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] MODIFY [column_name] [改后数据类型] [改后的完整性约束]；<br>SLTER TABLE [table_name] CHANGE [column_name] [new_column_name] [改后数据类型] [改后的完整性约束]；<br></code></pre></td></tr></table></figure><blockquote><p>MODIFY关键字只能改数据类型和完整性约束</p></blockquote><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] DROP [column_name];<br>ALTER TABLE [table_name] DROP [column_name1]，DROP [column_name2]，······；<br></code></pre></td></tr></table></figure><h3 id="对内容的操作"><a href="#对内容的操作" class="headerlink" title="对内容的操作"></a>对内容的操作</h3><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br><br>INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，(&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，······；<br>//一次插入多条数据<br><br>INSERT INTO [table_name] VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法必须严格按照表中顺序一一填写，自增字段可用null占位但不能为空</p></blockquote><p>我的电脑输入字段名不能加引号不然会报错<del>就离谱</del></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-18-09.png"></p><h5 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h5><ul><li>选择某一行或某一列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><ul><li>选择整个表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-19-13.png"></p><h5 id="删除字段-1"><a href="#删除字段-1" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELECT FROM [table_name] [删除条件]; <br></code></pre></td></tr></table></figure><blockquote><p>删除可使用where条件。条件可空，为空时全部值被影响。</p></blockquote><h5 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [table_name] SET [column_name]=[value] [修改条件];<br></code></pre></td></tr></table></figure><blockquote><p>修改条件可空，全部值被影响。</p></blockquote><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除重复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT [column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句用于在表中选择指定符合条件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE 条件（字段名+运算符+数值）;<br></code></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;或DIV</td><td>除</td></tr><tr><td>%或MOD</td><td>取余</td></tr></tbody></table><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或！&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>模糊匹配</td></tr></tbody></table><blockquote><p>可以使用and或or连接多个条件</p></blockquote><p> <strong>like符号举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">like &#x27;[查询内容]%&#x27;      //表示以[查询内容]开头的数据<br>like &#x27;%[查询内容]&#x27;      //表示以[查询内容]结尾的数据<br>like &#x27;%[查询内容]%&#x27;      //表示只要查询内容出现即可<br>like &#x27;_[查询内容]%&#x27;      //表示查询内容前有一位字符，后有任意字符<br>like &#x27;%[查询内容]_&#x27;      //表示查询内容前有任意字符，后有一位字符<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-52-05.png"></p><p> <strong>between用法</strong></p><p> between运算符包括起始值和结束值</p><p> 用于选取两个数值范围之内的值，可以是字符串，数字或者日期</p><p> eg:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] where [colum_name] BETWEEN [value1] and [value2];<br><br>SELECT [colum_name] FROM [table_name] where [colum_name] &gt;= [value1] and [colum_name] &lt;= [value2];<br></code></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in实际上是多个or的合并</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br><br>SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name]=[value1] or [colum_name]=[value2];<br></code></pre></td></tr></table></figure><h5 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h5><p>subquery为子查询，用于嵌套在where子句中的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name],···FROM [table_name] WHERE条件 (子查询)<br></code></pre></td></tr></table></figure><blockquote><p>子查询为一个完整的select语句</p></blockquote><h5 id="as"><a href="#as" class="headerlink" title="as"></a>as</h5><p>用as为查找对象起别名，但我没尝试成功🥲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [字段名] FROM [table_name] [条件语句] as [别名]; <br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_21-10-56.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h5><p>count函数统计符合条件的记录数</p><p>统计表中的记录<strong>总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>不为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *FROM [table_name] WHERE [column_name] IS NULL;<br></code></pre></td></tr></table></figure><h5 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h5><p>max函数返回所选字段最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a>min函数</h5><p>min函数返回所选字段最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="avg函数"><a href="#avg函数" class="headerlink" title="avg函数"></a>avg函数</h5><p>avg函数返回所选字段的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><p>sum函数返回所选按字段的合计值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h3 id="其他一些条件"><a href="#其他一些条件" class="headerlink" title="其他一些条件"></a>其他一些条件</h3><h5 id="having过滤分组"><a href="#having过滤分组" class="headerlink" title="having过滤分组"></a>having过滤分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- having 统计函数 运算符 value；<br></code></pre></td></tr></table></figure><h5 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- GROUP BY [column_name];<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>可分为正序asc和倒序desc两种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- ORDER BY [column_name] [排序方法],[column_name] [排序方法],······;   <br></code></pre></td></tr></table></figure><h5 id="限制查询数量"><a href="#限制查询数量" class="headerlink" title="限制查询数量"></a>限制查询数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- LIMIT [查询数量]<br></code></pre></td></tr></table></figure><h4 id="多表联合"><a href="#多表联合" class="headerlink" title="多表联合"></a>多表联合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [table_name1].[column_name1],[table_name2].[column_name2] FROM [table_name1],[table_name2] + WHERE子句<br></code></pre></td></tr></table></figure><h5 id="jion连接"><a href="#jion连接" class="headerlink" title="jion连接"></a>jion连接</h5><p>jion连接是基于多个表之间的共同字段把他们结合起来进行查询的一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name] AS FROM [table_name1] JION [table_name2] + ON 子句;<br></code></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>列出两个表中都存在的数据<code>jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/jion.png"></p><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p>即使没有匹配也要列出左表的数据<code>left jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/leftjion.png"></p><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p>即使没有匹配也要列出右表的数据<code>right jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/rightjion.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL语句格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SELECT语句] [WHERE条件] [GROUP BY条件] [HAVING条件] [ORDER BY条件] [LIMIT条件]；<br></code></pre></td></tr></table></figure><hr><p>终于把这SQL语句搞完了</p><p>撒花🎉</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>MySQL</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP黑魔法</title>
    <link href="/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <url>/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>古娜拉黑暗之神🪄</p><span id="more"></span><h2 id="PHP基础函数"><a href="#PHP基础函数" class="headerlink" title="PHP基础函数"></a>PHP基础函数</h2><p>接着上一篇小bug，把那些也提溜过来继续写🧐</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>extract() 函数从<strong>数组</strong>中将变量导入到当前的符号表。该函数使用数组<strong>键名</strong>作为变量名，使用数组<strong>键值</strong>作为变量值。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>extract(array,extract_rules,prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>array（数组名）</td><td>规定要使用的数组</td></tr><tr><td>extract_rules（提取规则）</td><td>可省略。<em>extract()</em> 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td></tr><tr><td>prefix（前缀）</td><td>可省略。请注意 <em>prefix</em> 仅在 <em>extract_type</em> 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。</td></tr></tbody></table><p><strong><em>extract_rules</em>可能的值：</strong></p><ul><li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量</li><li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li><li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li><li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li><li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = cat;$b = dog;$c = horse<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>,EXTR_PREFIX_SAME, <span class="hljs-string">&quot;dup&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = Original; $b = Dog; $c = Horse; $dup_a = Cat<br></code></pre></td></tr></table></figure><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>bool isset ( mixed $var [, mixed $... ] )</code></p><blockquote><p>$var为要测试的变量</p></blockquote><p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;变量已设置&quot;</span><br>&#125;<br><span class="hljs-comment">//结果为true，将打印文本</span><br><br><span class="hljs-comment">//使用var_dump输出isset()的返回值。</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">&quot;Mod&quot;</span><br><span class="hljs-variable">$b</span>=<span class="hljs-string">&quot;Modifier&quot;</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$a</span>);<span class="hljs-comment">//删除变量a</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-variable">$c</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$c</span>));<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>变量已设置<br>bool(true)<br>bool(true)<br>bool(false)<br>bool(true)<br>bool(flase)<br></code></pre></td></tr></table></figure><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>file_get_contents() 把整个文件读入一个字符串中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contens</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#输出演示</span><br>This <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">for</span> test<br>(输出文件中的所有文本)<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>strcmp()</code>把两个字符串以二进制方式进行比较，且该函数比较时区分大小写。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>strcmp(string1, string2)</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果返回值小于0，则str1小于str2;</p><p>如果返回值大于0，则str1大于str2;</p><p>如果返回值等于0，则str1等于str2;</p><blockquote><p>有资料说返回值也不仅是-1和1，也可能是其他数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strmp</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//输出0</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//输出1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>还有个函数strcasecmp()，用法与strcmp()类似，只是不区分大小写</p></blockquote><h3 id="ereg-x2F-preg-match"><a href="#ereg-x2F-preg-match" class="headerlink" title="ereg&#x2F;preg_match"></a>ereg&#x2F;preg_match</h3><p><code>ereg()</code>和<code>preg_match()</code>是PHP中常用的正则表达式。</p><p><strong>紧急补课—正则表达式</strong></p><p>在编写处理字符串的程序或者网页的时候，经常会查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的语法。</p><p>作用： 分割， 匹配， 查找， 替换</p><p>例如： 验证邮箱地址格式， 手机号码格式等等</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>preg_match(mode, string subject, array matches);</code></p><p><code>ereg(mode,string,subject,array regs);</code></p><p>mode : 正则表达式</p><p>subject : 需要验证的字符串</p><p>matches&#x2F;regs : 匹配后得到的结果，以数组的方式存储</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回值是<strong>false</strong>或<strong>true</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/php/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式分隔符后的i标记这是一个大小写不敏感的搜索</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串&quot;</span>；<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串&quot;</span>；<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示1：<br>查找到匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2：</span><br><span class="hljs-comment">//查找固定的某个单词</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式中的 \b 标记一个单词边界，所以只有独立的单词会被匹配，而不会匹配单词的部分内容 </span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is harder than others!&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示2：<br>查找到匹配字符串<br>未发现匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#实例演示3：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 从URL中获取主机名称</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;@^(?:http://)?([^/]+)@i&#x27;</span>,<br>    <span class="hljs-string">&quot;http://shmodifier.github.io&quot;</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-variable">$host</span> = <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">// 获取主机名称的后面两部分</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[^.]+\.[^.]+$/&#x27;</span>, <span class="hljs-variable">$host</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;domain name is: <span class="hljs-subst">&#123;$matches[0]&#125;</span>\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示3：<br>domain name is: github.io<br></code></pre></td></tr></table></figure><p><del>乱七八糟一堆符号我一个都看不懂我好得很哇</del></p><h2 id="魔法部分"><a href="#魔法部分" class="headerlink" title="魔法部分"></a>魔法部分</h2><p>警告：麻瓜请自觉退出🚫</p><h3 id="01-strcmp绕过"><a href="#01-strcmp绕过" class="headerlink" title="01 strcmp绕过"></a>01 strcmp绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br>    <br><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], FLAG) == <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我:&quot;</span> . FLAG;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ps：从ws那里copy来的（x</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>strcmp($_GET[&#39;flag&#39;], FLAG) == 0</code>，就是要**$_GET<strong>变量和</strong>FLAG**相等，但是我们除了严刑逼供出题人，根本就不知道FLAG是什么。</p><blockquote><p>$_GET[‘flag’]意思是从url获取一个叫flag的GET参数</p></blockquote><p>不要害怕！</p><p><strong>当 strcmp() 比较出错时会返回 NULL；而返回 NULL 即为返回 0</strong>，我们只需要palyload一个非字符串变量和字符串FLAG比较就会出错并返回0。</p><p>欸，相等辣！</p><p><strong>最终palyload</strong>： <code>?flag[]=0</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-02-28_21-02-17.png"></p><h3 id="02-md5绕过"><a href="#02-md5绕过" class="headerlink" title="02 md5绕过"></a>02 md5绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) != <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>] &amp;&amp; <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>]) &#123;<br>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我 :&quot;</span> . FLAG;<br> &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>($_GET[&#39;s1&#39;])!=$-GET[&#39;s2&#39;] &amp;&amp; md5($GET[s1])==$_get[&#39;s2&#39;]</code>，就是变量s1和s2<strong>不能相等</strong>但是他们的<strong>md5要相等</strong>。</p><p>因为s2和s2不能相等，所以单纯md5加密得出的密文一定也不完全一样，这时就要利用一些歪门邪道<del>（不是）</del>。</p><p><strong>紧急补课—md5</strong></p><p>md5一种密码散列函数。MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p><del>补不了我看不懂</del>🥲</p><h5 id="001-科学计数法绕过"><a href="#001-科学计数法绕过" class="headerlink" title="001 科学计数法绕过"></a>001 科学计数法绕过</h5><p>字符串经过md5加密后，会生成既有数字又有字母的密文，可以利用<strong>科学计数法</strong>的语法规律反推明文。</p><blockquote><p>了解到md5是不可逆的所以应该不能解码，但是可以根据加密规律找满足需要的明文</p></blockquote><p>0无论乘十的几次方都仍然为零，例如<code>&#39;0e123456&#39;==&#39;0e654321&#39;==0</code>。所以只需要找到两个经过md5加密后以<strong>”0e“</strong>开头的字符串充当变量即可。</p><p>copy了一些加密后是0e开头的值：</p><ul><li>QNKCDZO       </li><li>240610708 </li><li>s878926199a      </li><li>s155964671a         </li><li>s214587387a        </li><li>s214587387a        </li><li>0e215962017</li></ul><p><strong>最终playload</strong>：<code>?s1=QNKCDZO&amp;s2=240610708</code> </p><p>没有成功截图😣</p><p>不知道为什么自己运行的时候没成功，页面一片空白什么都没输出。</p><p><strong>紧急补课</strong></p><p>在php中，**’<em>x</em>e<em>y</em>‘** 意为x乘10的y次方。例如：1000 &#x3D;&#x3D; ‘1e3’。</p><h5 id="002-数组绕过"><a href="#002-数组绕过" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h5><p>冲浪冲到的</p><p>php中的md5函数不能用来加密数组，所以会出现结果NULL。例如<code>md5([1,2]) == md5([3,4]) == NULL</code>。</p><p><strong>最终playload</strong>：<code>?s1[]=1&amp;s2[]=2</code></p><p>但是在我的电脑上复现会报错而不是直接null绕过。</p><h3 id="03-extract-变量覆盖绕过"><a href="#03-extract-变量覆盖绕过" class="headerlink" title="03 extract 变量覆盖绕过"></a>03 extract 变量覆盖绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>; <br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$shiyan</span>))<br> &#123; <br>    <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shiyan</span>==<span class="hljs-variable">$content</span>)<br>    &#123; <br>        <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Modifier终将否极泰来&#x27;</span>; <br>    &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123; <br>    <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;<br>   &#125; <br> &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目使用<code>extract($_GET)</code>接受请求，并将其键名和键值转换为变量名和变量值，随后进行if条件的判断。$flag是一个输入的变量，<code>file_get_contents($flag)</code>打开的一定是空文件，所以<code>$content</code>一定为空</p><blockquote><p>解题关键在于令$shiyan&#x3D;&#x3D;$content</p></blockquote><p>使用GET提交参数和值，利用<code>extract($_GET)</code>进行覆盖，使flag和shiyan的值都为空，从而满足if条件，输出flag。</p><p><strong>最终payload</strong>：<code>?flag=&amp;shiyan=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-11-39.png"></p><h3 id="04-绕过过滤的空白字符"><a href="#04-绕过过滤的空白字符" class="headerlink" title="04 绕过过滤的空白字符"></a>04 绕过过滤的空白字符</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;&quot;</span>; <br><span class="hljs-variable">$req</span> = [];<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;<br> <br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_error&quot;</span>, <span class="hljs-literal">false</span>); <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <br> <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;number&#x27;</span>]))&#123;<br>   <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;</span>);<br> <br>   <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;have a fun!!&quot;</span>);<br> <br>&#125;<br> <br><span class="hljs-keyword">foreach</span>([<span class="hljs-variable">$_GET</span>, <span class="hljs-variable">$_POST</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$global_var</span>) &#123;  <br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$global_var</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123; <br>        <span class="hljs-variable">$value</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>); <br>        <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$value</span>) &amp;&amp; <span class="hljs-variable">$req</span>[<span class="hljs-variable">$key</span>] = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$value</span>); <br>    &#125; <br>&#125; <br> <br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_palindrome_number</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>&#123; <br>    <span class="hljs-variable">$number</span> = <span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-variable">$number</span>);<br>    <span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-variable">$j</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$number</span>) - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$j</span>) &#123; <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$number</span>[<span class="hljs-variable">$i</span>] !== <span class="hljs-variable">$number</span>[<span class="hljs-variable">$j</span>]) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>        <span class="hljs-variable">$i</span>++; <br>        <span class="hljs-variable">$j</span>--; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br> <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;number&#x27;</span>])) <br>&#123;<br> <br>   <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;sorry, you cann&#x27;t input a number!&quot;</span>;<br> <br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>]!=<span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>])))<br>&#123;<br> <br>     <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;number must be equal to it&#x27;s integer!! &quot;</span>;  <br> <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br> <br>     <span class="hljs-variable">$value1</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]);<br>     <span class="hljs-variable">$value2</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]));  <br> <br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable">$value1</span>!=<span class="hljs-variable">$value2</span>)&#123;<br>          <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;no, this is not a palindrome number!&quot;</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br> <br>          <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_palindrome_number</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]))&#123;<br>              <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;nice! <span class="hljs-subst">&#123;$value1&#125;</span> is a palindrome number!&quot;</span>; <br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>             <span class="hljs-variable">$info</span>=<span class="hljs-variable">$flag</span>;<br>          &#125;<br>     &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$info</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个代码好长让我来认真看一下🧐</p><p>从最后看<code>echo $info</code>、<code>$info=$flag</code>，我们知道如果满足前面的条件，flag会被赋值给<code>$info</code>并输出。</p><p>再往上找条件</p><p>要不满足条件，即<code>is_palindrome_number($req[&quot;number&quot;])</code>为假。</p><p>前面代码有写<code>is_palindrome_number</code>函数用来判断回文数字。</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-24-52.png"></p><p>要满足<code>$value1=$value2</code>，即<code>intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))</code>，$value反转后不能和原来相等。</p><blockquote><p>strrev()函数反转字符串</p></blockquote><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-31-22.png"></p><p><code>is_numberic($REAUEST[&#39;NUMBER&#39;]</code>需要为假，且<code>$req[&#39;number&#39;]==strval(intval(eq[&#39;number&#39;])</code></p><p>再看看上面</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-52-30.png"></p><p>我们要在url传入一个名为<strong>number</strong>的变量</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-59-58.png"></p><p>这段的意思是把我们所有的输入收集到$global_var列表里，此时列表**$global_var&#x3D;[<em>$number</em>]<strong>。再进入下一步循环，将键名赋值给$key，变量的值赋值给$value，即</strong>$key&#x3D;0，$value&#x3D;$number**。</p><p>进入循环内部后，trim()函数去除变量首尾的空白字符或其他字符后需满足条件<code>is_string($value) &amp;&amp; $req[$key] = addslashes($value)</code>，即$value为字符串并给字符串加反斜线。</p><p>判断条件如下</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_20-29-48.png"></p><p>综上，要传入一个字符串，字符串不能是数字还必须是整数，不是回文数字还要是回文数字😅。</p><p>悖论！<del>烦死了不做了去暴打出题人</del></p><p>没关系我们可以绕过。</p><p><code>intval()</code>和 <code>is_numeric()</code>函数在开始判断前，会先跳过所有空白字符，但是<code>is_palindrome_number()</code>不会，可以利用这个特点，在一个回文数字之前加上一个空白字符，比如<code>\f121</code>就是<code>%0c121</code></p><p>再用%00绕过<code>is_numeric($_REQUEST[&#39;number&#39;])</code></p><p><strong>最终playload</strong>：<code>?number=%00%0c121</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_21-14-18.png"></p><p>这个怎么还显示代码捏</p><h3 id="05-ereg-x2F-preg-match-正则-00-截断"><a href="#05-ereg-x2F-preg-match-正则-00-截断" class="headerlink" title="05 ereg&#x2F;preg_match 正则 %00 截断"></a>05 ereg&#x2F;preg_match 正则 %00 截断</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ereg</span> (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) &lt; <span class="hljs-number">8</span> &amp;&amp; <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] &gt; <span class="hljs-number">99999999</span>)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;*-*&#x27;</span>) !== <span class="hljs-literal">FALSE</span>) <span class="hljs-comment">//strpos — 查找字符串首次出现的位置</span><br>      &#123;<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . <span class="hljs-variable">$flag</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;</span>); <br>       &#125;<br>      &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;</span>; <br>      &#125;<br>   &#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="001-00截断"><a href="#001-00截断" class="headerlink" title="001 %00截断"></a>001 %00截断</h5><p>需要满足条件<code>ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])</code>不为false，即输入的值必须有大小写<strong>字母或者数字</strong>。</p><p>还需满足<code>strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 99999999</code>，即输入值<strong>长度小于8</strong>且<strong>大于99999999</strong>。</p><p>最后要满足<code>strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE</code>，也就是输入中必须有***-***。但是这条和第一条相悖，不慌，姐已经见过大世面了，姐可以绕过它。</p><blockquote><p>当ereg语句遇到%00的时候就会认为是休止符，不再往后看</p></blockquote><p>可以在字符串中添加%00，在它之后加*-*，骗一下第一个判断条件。</p><p>第二个条件可以使用科学计数法，比如1e10。</p><p><strong>最终playload</strong>：<code>?password=1e10%00*-*</code></p><p>本地复现没成功，我好得很哇我好的很哇😅</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-17-52.png"></p><p>本地复现不成功是打不倒我的，我擅长使用百度。</p><p>翻译了一下是“调用了未定义函数”。在php5.3以上的版本将不再支持eregi()和ereg()函数，看了一下的我的版本号是7.3。</p><p>问题也不是不可避免，只需要改一下格式，把<code>ereg()</code>改成<code>erge_match()</code>就行。</p><p><del>但我不会改</del>😣</p><h4 id="002-数组绕过-1"><a href="#002-数组绕过-1" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h4><p>冲浪冲到的另外一种方法</p><p>在true和false之外还有一个返回值是null。可以利用这一特点进行绕过。</p><p>ereg() 只能处理字符串，遇到数组会返回null，而且<code>null !== false</code>。同时，strlen()也不能处理数组，也会返回null，null的长度小于8。</p><p>因为要输入数组，数组大于整数，所以一定会返回true。</p><p><strong>最终playload</strong>：<code>?password=[]=1</code></p><h3 id="06-sha-函数比较绕过"><a href="#06-sha-函数比较绕过" class="headerlink" title="06 sha()函数比较绕过"></a>06 sha()函数比较绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifer终将否极泰来&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>要满足两个条件：<code>($_GET[&#39;name&#39;] ！== $_GET[&#39;password&#39;]</code>和</p><p><code>sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;])</code>。</p><p>就是要让输入的两个变量不相等但是sha1加密后相等。</p><p>不同的字符串经过sha1加密后一定不同，但是sha1不能加密数组，会报错返回null，如果让两个变量同时返回null就会相等辣。</p><p><strong>最终playload</strong>：<code>?name[]=1&amp;password[]=2</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-57-05.png"></p><h3 id="07-session-验证绕过"><a href="#07-session-验证绕过" class="headerlink" title="07 session 验证绕过"></a>07 session 验证绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifier终将否极泰来&quot;</span>;<br><br><span class="hljs-title function_ invoke__">session_start</span>(); <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">die</span> (<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">mt_srand</span>((<span class="hljs-title function_ invoke__">microtime</span>() ^ <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) % <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>) + <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>要满足条件<code>$_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]</code></p><blockquote><p>$_SESSION()存储会话信息</p></blockquote><p>这里session中的password需要我们自己传入，如果不传就是null，同时password也传空，二者就相等啦</p><p><strong>最终playload</strong>：<code>?password=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_21-40-38.png"></p><h3 id="08-urldecode-二次编码绕过"><a href="#08-urldecode-二次编码绕过" class="headerlink" title="08 urldecode 二次编码绕过"></a>08 urldecode 二次编码绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">eregi</span>(<span class="hljs-string">&quot;hackerDJ&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;</span>);<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] == <span class="hljs-string">&quot;hackerDJ&quot;</span>)<br>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>需要满足两个条件：<code>eregi(&quot;hackerDJ&quot;,$_GET[&#39;id&#39;])</code>为false；经过urldecode编码后满足<code>$_GET[&#39;id&#39;] == &quot;hackerDJ&quot;</code></p><p>也就是说传入值不能是hackerDJ，但是传入值<strong>经过urldecode解码后</strong>要和hackerDJ相等。</p><p>所以传入时要将hackerDJ的url编码再编码一次。</p><p><strong>最终playload</strong>：<code>?id=%2568%2561%2563%256b%2544%254a</code></p><hr><p>总觉得少了点什么原来是把这个笔记忘记喽</p><p>发上来防止自己手贱删掉🦭</p><p>把万师傅的原博放这里</p><p><a href="https://drun1baby.github.io/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">PHP 入门基础漏洞 | 芜风 (drun1baby.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器打开本地PHP文件</title>
    <link href="/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>随机掉落废物Mod研究php的笔记😮</p><span id="more"></span><h2 id="01-配置PHP运行环境"><a href="#01-配置PHP运行环境" class="headerlink" title="01 配置PHP运行环境"></a>01 配置PHP运行环境</h2><p>万能的互联网教我下载Apache，PHP和MySQL。好多好麻烦。我选择直接用集成环境。</p><p><a href="https://www.xp.cn/">phpstudy官网</a></p><p>直接去官网下载，会有一个压缩包，解压以后打开第一个exe文件安装就好。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-04-46.png"></p><p>注意：压缩包保存的路径不能有中文和空格</p><p>在安装时的自定义选项中可以修改安装包的位置，我的是默认在D盘根目录，把它改到放压缩包的文件夹里了。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-06-25.png"></p><p>根据本人尝试，在浏览器看PHP文件只需要把Apache打开就行。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-32-00.png"></p><h2 id="02-把文件丢进网站根目录"><a href="#02-把文件丢进网站根目录" class="headerlink" title="02 把文件丢进网站根目录"></a>02 把文件丢进网站根目录</h2><p>在上述安装步骤步骤中，会生成<strong>phpstudy_pro</strong>文件夹，文件夹中又有<strong>WWW</strong>文件夹。</p><p>网站根目录就是www文件下，必须将文件放置此位置才算有效，否则无法运行php文件。</p><h2 id="03-运行PHP文件"><a href="#03-运行PHP文件" class="headerlink" title="03 运行PHP文件"></a>03 运行PHP文件</h2><p>打开浏览器，在导航栏输入<code>localhost/[文件名]</code>就可以啦</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-42-05.png"></p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-41-36.png"></p><h2 id="04-土狗发言"><a href="#04-土狗发言" class="headerlink" title="04 土狗发言"></a>04 土狗发言</h2><p>因为有一个文件写错了，在浏览器打开的时候报错了。</p><p>它居然还可以报错！</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_21-09-18.png"></p><p>太高级了</p><hr><p>集成环境yyds🥳</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用记录</title>
    <link href="/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>遇到的一些奇怪问题和修改主题页面的经验✂️</p><span id="more"></span><h2 id="奇怪问题"><a href="#奇怪问题" class="headerlink" title="奇怪问题"></a>奇怪问题</h2><h4 id="插入图片坑"><a href="#插入图片坑" class="headerlink" title="插入图片坑"></a>插入图片坑</h4><p>在最开始写博客的时候，千挑万选找了张美图准备当封面，复制文件地址插入。<code>hexo g</code> <code>hexo s</code>本地预览一切正常，<code>hexo d</code>一条龙推上去发现图片被和谐掉了（<del>不是</del>）</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-13-07.png"></p><p>前去万能的互联网寻找了一下答案，有的说写文章的时候要建一个同名文件夹放图片，有的说要安装插件。</p><p>我当然是选择建文件夹这个更简单的操作。</p><p>在配置文件_config.yml里找到<strong>post_asset_folder</strong>，把false改为true，再次<code>hexo new</code>就建好.md文件和文件夹了。经过本人一顿Ctrl+C和Ctrl+V的操作把原文件和图片移到新的文件，充满信心地再次<code>hexo g</code> <code>hexo d</code></p><p>还是不显示图片</p><p>好的😢<del>一定是图片它真的违禁了</del></p><p>当我再次在互联网搜索时，我发现了一个华点</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-22-06.png"></p><p>这个markdown语法里的图片插入是<code>/</code>，但是我复制的图片路径用的是<code>\</code>！</p><p>我尝试着修改之后再次<code>hexo d</code></p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-30-47.png"></p><p>就这么成功了🤨</p><h4 id="Spawn-failed坑"><a href="#Spawn-failed坑" class="headerlink" title="Spawn failed坑"></a>Spawn failed坑</h4><p>美滋滋发了一篇笔记上来，发现格式有bug，抓紧时间修改。修改之后再次丝滑一条龙上传······</p><p>没丝滑成功</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-07-25.png"></p><p>报错喽🥳<del>我面容平和根本就没有在生气</del></p><p>翻译了一下是“请确保您有正确的访问权限”，不会搞。把目光投向万能的互联网，网上说是连接的问题。</p><p>看到一条说因为git 进行<code>push</code>或者<code>hexo d</code>的时候改变了一些.deploy_git文件下的内容，只需要重新down一下就行。</p><p>于是删除.deploy_git文件夹，再次<code>hexo c</code> <code>hexo g</code> <code>hexo d</code>。出现了一个新的.deploy_git文件！</p><p>依旧报错🥀</p><p>又继续冲浪找解决方案，又看到一条说要在_config.yml文件里把<strong>repo</strong>地址改成git地址。我早就改过了但是我发现这个人的<strong>deploy</strong>条目比我多一个<strong>branch</strong>。</p><p>秉承着不错过任何一个细节的态度我在自己的文件里也加上了这条并认真填入master。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-11-55.png"></p><p>保存，<code>hexo d</code>，加载成功？？？</p><p>事情怎会如此简单，我解决完问题才想起要记录一下踩坑新鲜事，于是乎再次<code>hexo d</code>想看看效果。</p><p>又报错了😮我才十八眼神还挺好使的难道刚才是眼花了吗？</p><p>换了个搜索引擎继续搜，看到一个csdn上的讨论，都让修改repo地址。我不信邪继续往下拉，看到一条标签</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-17-43.png"></p><p>我脑海中的小灯泡突然就亮了，我回到浏览器看自己的博客，格式已经修改过来了，也就是说那次眼花是真的推上去了。</p><p>Github你不要太荒谬😅</p><h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h4 id="页脚版权声明"><a href="#页脚版权声明" class="headerlink" title="页脚版权声明"></a>页脚版权声明</h4><p>原本的主题页脚，姐不喜欢，这个爱心太不符合姐Bking的人设了。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-35-37.png"></p><p>我想要有个人版权声明的页脚，经过学习掌握版权声明格式后我开始准备大改特改。</p><p>凭借我只有一点知识的脑壳告诉我这种页面要用HTML来写。奈何肚子里墨水太少，只有图纸没有工具没法盖房子<del>（就是不会写代码）</del></p><p>算了，还是求助一下万能互联网吧</p><p>搜到的全是怎么给页脚添加运行时间🥲就是没人教你怎么写版权声明。换个思路，我去抓了一个别人网页的包直接偷现成的。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-52-54.png"></p><p>代码get！</p><p>经过我一番努力，在主题的.yml文件里找到了<strong>footer</strong>部分，非常感谢主题作者的注释写得那么详细，很轻松就找到了HTML代码区。把原来的注释掉，再加上自己copy来的代码。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-59-56.png"></p><p>一条龙以后美美得到自己喜欢的页脚🤪</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-58-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一起来搭博客</title>
    <link href="/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>利用hexo+GitHub搭建一个属于自己的博客</p><span id="more"></span><p>又名：我怎么什么都不会之踩坑记录🥀</p><p>建议在powershell执行命令，cmd有些步骤会提示权限不够</p><p>”踩坑“部分都是遇到的问题和吐槽的碎碎念，如果在过程中没有遇到问题就不用看🥰</p><h2 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h2><p>这里暂时先默认有git，因为当时搭博客的之前就有用到git了。</p><p>等我有空补上😇</p><h2 id="node-js下的Hexo安装和换源"><a href="#node-js下的Hexo安装和换源" class="headerlink" title="node.js下的Hexo安装和换源"></a>node.js下的Hexo安装和换源</h2><h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>首先需要给电脑安装一个node.js</p><p><a href="https://nodejs.org/en/download/">下载链接</a></p><p>我当时还没有记笔记的习惯所以node下载和配置这里没有笔记</p><p>可以看看菜鸟教程讲的很详细了</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程 (runoob.com)</a></p><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>给node.js换一个淘宝镜像，不然接下来下载hexo会timeout。</p><p>直接打开power shell输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>时间会比较长可以下楼跑个两公里</p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>powershell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>换源以后下载速度贼快</p><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>（接下来是不重要的碎碎念可以直接跳过看下一趴）</p><p>最开始看的教程说要修改环境变量，修改了大半天。执行npm install的时候一直报错，一气之下把node所有文件都删了，重新下载。</p><p><del>(别学我，遇到报错要找问题原因而不是逃避)</del></p><blockquote><p>大半夜下载不动寻求卷师傅帮忙，卷发现我的代理地址没更新，狠狠拖后腿。🥲</p></blockquote><p>重新下载之后保持自动配置的环境变量不变，在命令行里直接npm install发现还是报以前一样的错。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-01-33.png"></p><p>复制百度发现是权限不够，要用管理员方式执行命令。</p><blockquote><p>所以我白删了呗！！</p></blockquote><p>win+R打开管理员方式终端，再次输入显示timeout。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_10-59-37.png"></p><p>又百度发现需要换源。</p><p>直接从网上找了个现成的淘宝源，换好以后再install五秒成功。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-02-39.png"></p><h2 id="Hexo的网页配置"><a href="#Hexo的网页配置" class="headerlink" title="Hexo的网页配置"></a>Hexo的网页配置</h2><p>下载后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init blog<br></code></pre></td></tr></table></figure><p>这个命令就是在powershell当前的根目录下新建一个名为blog的文件夹，用于后续配置文件的存放。</p><p>[<em>blog</em>]好像可以填别的文件名，但我没试过所以不建议。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>建好文件夹之后初始化配置</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cd <span class="hljs-keyword">blog </span>  <span class="hljs-comment">#进入blog文件夹</span><br>npm <span class="hljs-keyword">install </span>   <br></code></pre></td></tr></table></figure><p>这个命令结束以后就可以看到blog文件夹里有很多文件喽，类似于下图这样。</p><p>图片里有些文件你没有也没关系，因为这是我建成博客又下载了很多东西之后补截的图。😳</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-01-30.png"></p><p>两条命令生成网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>当然喽hexo善解人意地支持简写，可以直接输入 <code>hexo g</code>和<code>hexo s</code></p><p>用浏览器预览网址<a href="http://localhost:4000/">http://localhost:4000</a></p><p>因为我们还没配置GitHub所以这个时候就是Hexo最基础的丑陋页面。</p><h4 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h4><p>cmd里输入hexo命令后又报错</p><p>说hexo不是可以执行的命令，百度后发现是环境变量的问题，<del>该死的环境变量</del></p><p>发现hexo-cli的bin目录下没有.cmd的文件，但是前一个目录里有，就直接复制过来，又把bin添加到了环境变量里，再hexo init</p><p>运行成功但报错，<del>想死</del></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_12-29-06.png"></p><p>据说是因为目录下没有这个文件夹，<del>为什么应该有hexo的文件夹啊</del></p><p>换个思路，用管理员模式重新下载hexo（我就个遇到困难卸载删除的菜鸡😶‍🌫️</p><p>下载后运行<code>hexo init blog</code></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-24-15.png"></p><p>又一次向万能的互联网求助，修改了一下power shell的权限，再运行</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>成功（？？）</p><blockquote><p>管理员模式yyds</p></blockquote><h3 id="GitHub配置网页"><a href="#GitHub配置网页" class="headerlink" title="GitHub配置网页"></a>GitHub配置网页</h3><p>在GitHub里建一个<strong>用户名.github.io</strong>的仓库，建好以后点击page把这个库变成一个网页。</p><p>我们在命令行输入<code>hexo d</code> 时默认上传<strong>master</strong>分支，但是在GitHub页面默认<strong>main</strong>分支，需要改成master。没有下拉选项，要手动输入</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-16-37.png"></p><p>但是这个时候先别hexo d，会报错，因为还没连接GitHub和hexo。</p><p>这时候你在浏览器搜索<code>https://用户名.github.io</code>，出现仓库的自述文件就是成功啦。</p><h2 id="SSH连接GitHub"><a href="#SSH连接GitHub" class="headerlink" title="SSH连接GitHub"></a>SSH连接GitHub</h2><p>也是默认大家有这玩意的哈</p><p>在git里面输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;[your_email@example.com]&quot;</span><br></code></pre></td></tr></table></figure><p>按回车之后会提示输入内容，可以全部按回车，表示使用默认的<code>~/.ssh</code>文件目录存放密钥，以及不设置密钥的密码。</p><p>在文件夹里找到.ssh文件，找到里面的密钥复制到GitHub。在个人设置页面的SSH and GPG keys 添加</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-20_23-36-59.png"></p><p>再打开git输入连接命令</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-42-49.png"></p><h2 id="Hexo内部操作"><a href="#Hexo内部操作" class="headerlink" title="Hexo内部操作"></a>Hexo内部操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>在blog文件夹里操作</strong></p><p>创建新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-05-20.png"></p><p>还会贴心的告诉你建在哪里了</p><blockquote><p>它真的，我哭死</p></blockquote><p>之后就可以在这个文件夹里看到以“文章标题”命名的md文件，在里面修改之后再运行<code>hexo g</code>和<code>hexo s</code>就能在预览网页看到刚发的文档啦。</p><blockquote><p>这一趴无脑跟教程走没踩雷，我又活了🥳</p></blockquote><h5 id="配置环节"><a href="#配置环节" class="headerlink" title="配置环节"></a>配置环节</h5><p>配置文件[-config.yml]</p><p><code>title</code>修改网页导航栏标签</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-17-41.png"></p><p>让网页和GitHub联姻</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p><code>theme</code>改主题，直接复制主题名字就好</p><h4 id="踩坑-2"><a href="#踩坑-2" class="headerlink" title="踩坑"></a>踩坑</h4><p><code>hexo d</code>把写作部署到GitHub上，又报错啦哈哈哈</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-30-22.png"></p><p>万能的互联网说这个叫映射条目缩进错误，改了好几遍缩进都不对</p><p>还碰到了一个错误</p><blockquote><p>(101.1)错误的意思是第101行与前文重复，把这一行注释掉就行</p></blockquote><p>最后改成这样运行成功</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-49-15.png"></p><p>但是查看<a href="https://shmodifier.github.io还是不成功/">https://ShModifier.github.io还是不成功</a></p><p>后来发现我这聪明的小脑瓜把信息放错了位置🍃</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p>改成这样就好啦</p><hr><p>把搭博客的笔记发上来，给大家看看笑话☃️</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Node</tag>
      
      <tag>Git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ARP欺骗和ARP攻击</title>
    <link href="/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/"/>
    <url>/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>趁着寒假偷偷卷哈哈哈🤪</p><span id="more"></span><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><blockquote><p>每一台主机都有一个arp高速缓存，里面有本局域网中的各主机和路由器的IP地址到硬件地址的映射表</p></blockquote><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>主机A和主机B各自有自己的IP地址和MAC地址，在主机A与主机B通信时，ARP协议可将主机B的IP地址解析为MAC地址。</p><p>第一步：</p><p>主机A首先确定用于访问主机B的IP地址，然后主机A在自己的本地ARP缓存中检查主机B的IP地址匹配的MAC地址</p><p>第二步：</p><p>如果主机A在ARP缓存中没有找到主机B的IP映射，它将询问主机B对应的硬件地址，会将ARP请求帧广播到本地网络上的所有主机，主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接受到ARP请求并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址以自己的IP地址不匹配，他将丢弃ARP请求。</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP1.png"></p><p>第三步：</p><p>主机B确定AARP请求中的IP地址于自己的IP地址匹配，并将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>第四步：</p><p>主机B将包含MAC地址的ARP回复消息直接发送到主机A</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP2.png"></p><p>第五步：</p><p>当主机A收到从主机B发来的ARP回复消息时，会使用主机B的IP地址和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束，将再次重复上面的内容。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h4 id="命令窗口玩转ARP"><a href="#命令窗口玩转ARP" class="headerlink" title="命令窗口玩转ARP"></a>命令窗口玩转ARP</h4><p>输入<code>arp</code>提示使用方法</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-08-45.png"></p><blockquote><p>这里一开始总是说“’ARP’不是可执行的程序”，凭我踩坑经验知道这是环境变量的问题。费尽千辛万苦发现是因为我的环境变量里居然没有system32🥲。但是输入path查看是有它的，不知道哪里出了问题，加上之后重启就好啦</p></blockquote><p>输入<code>arp -a</code>查看ARP缓存表信息</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-09-19.jpg"></p><p><strong>静态</strong>地址即主机自己配置生成的地址。</p><p>当主机新连接入一台设备，并且与主机产生通信后，aqp表会更新一条<strong>动态</strong>地址。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP攻击就是通过伪造IP地址和MAC地址的对应关系，使得网络无法正常通信。即修改靶机的IP地址和MAC地址，使其他设备与靶机的通信无法正常进行，进而截断靶机流量。</p><blockquote><p>可以直接使用arpspoof插件攻击</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo arpspoof -<span class="hljs-selector-tag">i</span> eth0  -t <span class="hljs-selector-attr">[目标IP]</span> -r <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>这里”r”的用法没搞懂😣好像就是直接双向攻击</p><p>Ctrl+C或关闭终端即停止攻击</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p><del>听说ARP欺骗配合DNS欺骗效果更佳</del>🤨</p><h5 id="可以用来干的坏事"><a href="#可以用来干的坏事" class="headerlink" title="可以用来干的坏事"></a>可以用来干的坏事</h5><ul><li>获取浏览图片</li><li>获取靶机各平台输入的账号密码</li><li>获取浏览地址</li></ul><h5 id="行骗方法"><a href="#行骗方法" class="headerlink" title="行骗方法"></a>行骗方法</h5><h6 id="1-伪装成网关"><a href="#1-伪装成网关" class="headerlink" title="1.伪装成网关"></a>1.伪装成网关</h6><p>欺骗源把自己伪装成网关，向局域网内的目标主机发送ARP报文，使得局域网内的主机误以为欺骗源的MAC地址是网关MAC地址，并将原本应该流向网关的数据都发送到欺骗源。</p><blockquote><p>直接对靶机实施ARP欺骗</p></blockquote><h6 id="2-伪装成主机"><a href="#2-伪装成主机" class="headerlink" title="2.伪装成主机"></a>2.伪装成主机</h6><p>用来欺骗局域网内的其他所有主机</p><p>欺骗源将自己伪装成局域网内的另一台主机3，将主机3的IP地址对应的MAC地址替换为欺骗元的IP地址对应的MAC地址使得局域网内靶机发往主机3的报文都流向欺骗源</p><blockquote><p>分别对网关和靶机实施ARP欺骗</p></blockquote><h3 id="操作步骤（行骗步骤）"><a href="#操作步骤（行骗步骤）" class="headerlink" title="操作步骤（行骗步骤）"></a>操作步骤<del>（行骗步骤）</del></h3><blockquote><p>伪装成网关</p></blockquote><p>首先查看欺骗源和靶机的IP地址</p><ul><li><p>直接查看：kali命令窗口输入<code>ifconfig</code>，Windows命令窗口输入<code>ipconfig</code></p></li><li><p>正经方法：</p><p>1.在kali命令窗口输入<code>fping -g xxx.xxx.xxx[网络号码].1/24</code>查询目标网络下的所有主机IP </p><p>2.输入命令<code>nmap -sP xxx.xxx.xxx[网络号码].0/24</code>查询目标网络下的所有主机IP</p></li></ul><p>输入命令<code>route-n</code>查看网关</p><p>使用arpspoof行骗</p><blockquote><p>kali命令窗口输入sudo arpspoof -h查看已经安装的arpspoof版本号，如果未安装，系统会弹出提示，按照提示安装即可 </p></blockquote><p>断网操作</p><p>把靶机发出的请求接受到攻击源主机，因为linux默认ip_forward为0，即不进行流量转发，所以靶机会断网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让靶机认为攻击源为网关：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[目标IP]</span> <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>或者反向欺骗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让网关认为攻击源是靶机：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[网关]</span> <span class="hljs-selector-attr">[目标IP]</span><br></code></pre></td></tr></table></figure><blockquote><p>网卡默认eth0</p></blockquote><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-05_23-10-21.jpg"></p><p><code>cat /proc/sys/net/ipv4/ip_forward </code>查看ip_forward的值。如果ip_forward为0，则被攻击主机不能上网；如果ip_forward为1，则被攻击主机可以上网</p><p>修改数值让他上网</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4/ip_forward<br></code></pre></td></tr></table></figure><blockquote><p>权限不够就<code>sudo -i</code> 使用root权限改</p></blockquote><p>限制网速</p><p>可以使用的工具有tc、iptables、WonderShaper等等，</p><p>以tc为例<del>本菜鸡还没学会后两个</del>😢：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">限制网速200ms延时<br>sudo tc qdisc add dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br> <br>取消限制网速200ms延时<br>sudo tc qdisc <span class="hljs-built_in">del</span> dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br></code></pre></td></tr></table></figure><p>拦截数据—获取浏览网页及账号密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ettercap -Tq -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><p>嗅探图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">driftnet  -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><hr><h3 id="工具说明书"><a href="#工具说明书" class="headerlink" title="工具说明书"></a>工具说明书</h3><p>因为各种工具的使用说明都是英文的，所以直接利用万能的互联网搜了一下中文的使用指南：</p><h5 id="driftnet"><a href="#driftnet" class="headerlink" title="driftnet"></a>driftnet</h5> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">语法： driftnet   <span class="hljs-selector-attr">[options]</span>   <span class="hljs-selector-attr">[filter code]</span><br><br> -<span class="hljs-selector-tag">b</span>  捕获到新的图片时发出嘟嘟声<br> -<span class="hljs-selector-tag">i</span>  interface     选择监听接口<br> -f  file   读取一个指定pcap数据包中的图片<br> -<span class="hljs-selector-tag">p</span>  不让所监听的接口使用混杂模式<br> -<span class="hljs-selector-tag">a</span>  后台模式：将捕获的图片保存到目录中（不会显示在屏幕上）<br> -m  number 指定保存图片数的数目<br> -d  directory  指定保存图片的路径<br> -x  prefix  指定保存图片的前缀名<br></code></pre></td></tr></table></figure><h5 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">名字 <br><span class="hljs-code">       arpspoof - 截获交换局域网中的数据包</span><br><span class="hljs-code"></span><br>用法<br><span class="hljs-code">       arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="hljs-code"></span><br>描述<br><span class="hljs-code">       arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="hljs-code">       内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br><span class="hljs-code"></span><br>参数<br><span class="hljs-code">       -i interface</span><br><span class="hljs-code">              指定要使用的接口（即指定一块网卡）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -c own|host|both</span><br><span class="hljs-code">              指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</span><br><span class="hljs-code">              使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -t target</span><br><span class="hljs-code">              指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       host   host是你想要截获数据包的主机 (通常是网关)。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h5 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>后面跟着连接局域网的网卡<br>T指的是text文本模式<br><span class="hljs-selector-tag">q</span>以安静模式执行这个命令<br>M指定攻击模式<br>&gt;&gt;输出文件<br></code></pre></td></tr></table></figure><hr><p>发个笔记上来不然这个博客真的成碎碎念专栏了😶‍🌫️</p><p>我就是个菜鸡🍃</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>想好怎样告别2022了吗？🥰</p><span id="more"></span><p>我总是喜欢在年末给未来一年的自己留下祝福，今年还是像往年一样的套路：希望2023的自己可以更洒脱、更自由。</p><p>过去的一年，我来到了梦寐以求的十八岁。我从被囚禁在应试教育中的高中生变成了悠闲又忙碌的大学生；我考出了驾照、学会了弹吉他；我第一次离开了父母、远离家乡，开始住宿生活；我了解到不同的世界，看到了新的风景。</p><p>过去的一年，我和很多人相遇，也和很多人告别。</p><p>这几天我想为自己挑选年度九图，于是乎我翻出了网盘里属于高中的文件夹。毕竟就在上半年，我还是一个被豢养的高考金丝雀。我打开看，里面盛满了我高三那年用老古董相机定格的青春热血。文件夹里有学校里盛开的花，阳光下惬意的猫，还有数不清的意气风发的少年。还记得，晦涩而又灿烂的高三，每天晚自习的最后半小时，我都没有向老师家长叮嘱的那般抓紧时间背单词、写大题，我把时间用来在本子上记录我的喜怒哀乐，书写我对这段时光的不舍与留恋。高中毕业，我攒了三本日记加一本随笔。</p><p>我仍记得毕业那场分别，我们背着书包，像平常那样说着再见。我和朋友们没有轰轰烈烈的告别，只有在耳边吹过的炎热又潮湿的晚风，和窗外的喧闹不止的蝉鸣。我将记录随笔的本子带到了大学，却未曾在上面写下一个文字。我只是一次又一次的翻开它，当作大学生活中的乐趣，去重温那段兵荒马乱而又潇洒肆意的时光。就像我在本子里写下的第一段话——“我所记录的每一个文字，都是过去的我对未来的赠礼”。</p><p>四个月的大学好像电影胶卷，被机器拉扯着，在我眼前一闪而过，但是这条路上仍然有精彩的风景。我遇到了新的朋友，和他们分享不同的幸福。全新的生活并不没有让我感到不安，或许是骨子里的积极勇敢，异或许是身边伙伴的鼓励陪伴，让我的这段新的旅程总是平稳畅通的。从学期初的擒敌拳，到学会的投篮捡漏技巧，还有为了交作业尝试的改源码的歪门邪道，再到期末临走前夜获得的羽毛球耍帅技巧······这些奇奇怪怪的技能背后，都有一群我非常感谢相遇相识的人。我还是个喜欢收集物料的人，宿舍书桌上的软木板，钉着我的第一张献血证书，贴着我第一次部门破冰会议的卡片，框架边缘里夹还有临走时收到的新年贺卡······这些物件承载的故事总能在回忆里熠熠生辉。</p><p>在夜深时分，我经常会把这些碎片从记忆深处拎出来，把他们拼凑成完整的拼图。</p><p><del>好吧，我承认自己总是活在回忆里。</del></p><p>最后，感谢2022，让我遇到了意趣相投的人，也让我拥有滚烫而又热烈的记忆。</p><p>新的一年，愿我所爱，平安顺遂。🎆</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐园入场券</title>
    <link href="/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/"/>
    <url>/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<p>这是一张乐园入场券</p><span id="more"></span><p>恭喜你发现了宝藏！</p><p>成功搭建这个博客这是我上大学以来做过最有成就感的事。虽然过程中踩了很多坑，但感谢我没有放弃，才有了现在这个属于我的小小极乐世界。</p><p>这里是一个Modifier的备忘仓库，也有很多未知宝藏。</p><hr><p>最近在不停地修改我的文章，尽可能的把文章写得简洁明了。</p><p>一些很基础的东西也发上来，一是想记录自己的学习历程，二是想着，等到哪天我的文章也有人看了，能让人一下子就能看得明白。</p><hr><p>如果你看到了这里，那就祝你在Modifier的极乐世界里享受自由与快乐吧！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
